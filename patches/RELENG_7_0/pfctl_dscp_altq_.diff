? pf_dscp_altq_.diff
? pf_dscp_altq_pptp(6).diff
Index: contrib/pf/pfctl/parse.y
===================================================================
RCS file: /home/ncvs/src/contrib/pf/pfctl/parse.y,v
retrieving revision 1.8
diff -u -r1.8 parse.y
--- contrib/pf/pfctl/parse.y	3 Jul 2007 12:30:02 -0000	1.8
+++ contrib/pf/pfctl/parse.y	1 Apr 2008 16:10:24 -0000
@@ -184,6 +184,7 @@
 #define FOM_TOS		0x04
 #define FOM_KEEP	0x08
 #define FOM_SRCTRACK	0x10
+#define FOM_DSCP	0x20
 	struct node_uid		*uid;
 	struct node_gid		*gid;
 	struct {
@@ -194,6 +195,7 @@
 	} flags;
 	struct node_icmp	*icmpspec;
 	u_int32_t		 tos;
+	u_int32_t		 dscp;
 	u_int32_t		 prob;
 	struct {
 		int			 action;
@@ -413,7 +415,7 @@
 %token	RETURNRST RETURNICMP RETURNICMP6 PROTO INET INET6 ALL ANY ICMPTYPE
 %token	ICMP6TYPE CODE KEEP MODULATE STATE PORT RDR NAT BINAT ARROW NODF
 %token	MINTTL ERROR ALLOWOPTS FASTROUTE FILENAME ROUTETO DUPTO REPLYTO NO LABEL
-%token	NOROUTE URPFFAILED FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DROP TABLE
+%token	NOROUTE URPFFAILED FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DSCP DROP TABLE
 %token	REASSEMBLE FRAGDROP FRAGCROP ANCHOR NATANCHOR RDRANCHOR BINATANCHOR
 %token	SET OPTIMIZATION TIMEOUT LIMIT LOGINTERFACE BLOCKPOLICY RANDOMID
 %token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC DEBUG SKIP HOSTID
@@ -429,7 +431,7 @@
 %token	<v.i>			PORTBINARY
 %type	<v.interface>		interface if_list if_item_not if_item
 %type	<v.number>		number icmptype icmp6type uid gid
-%type	<v.number>		tos not yesno
+%type	<v.number>		tos dscp not yesno
 %type	<v.i>			no dir af fragcache optimizer
 %type	<v.i>			sourcetrack flush unaryop statelock
 %type	<v.b>			action nataction natpass scrubaction
@@ -1756,7 +1758,14 @@
 #endif
 			}
 
-			r.tos = $9.tos;
+			if ($9.tos) {
+				r.tos = $9.tos;
+				r.rule_flag |= PFRULE_TOS;
+			}
+			if ($9.dscp) {
+				r.tos = $9.dscp;
+				r.rule_flag |= PFRULE_DSCP;
+			}
 			r.keep_state = $9.keep.action;
 
 			/* 'keep state' by default on pass rules. */
@@ -2094,6 +2103,14 @@
 			filter_opts.marker |= FOM_TOS;
 			filter_opts.tos = $1;
 		}
+		| dscp {
+			if (filter_opts.marker & FOM_DSCP) {
+				yyerror("dscp cannot be redefined");
+				YYERROR;
+			}
+			filter_opts.marker |= FOM_DSCP;
+			filter_opts.dscp = $1;
+		}
 		| keep {
 			if (filter_opts.marker & FOM_KEEP) {
 				yyerror("modulate or keep cannot be redefined");
@@ -3085,6 +3102,46 @@
 		}
 		;
 
+dscp		: DSCP STRING			{
+                        if (!strcmp($2, "EF"))
+                                $$ = DSCP_EF;
+                        else if (!strcmp($2, "af11"))
+                                $$ = DSCP_AF11;
+                        else if (!strcmp($2, "af12"))
+                                $$ = DSCP_AF12;
+                        else if (!strcmp($2, "af13"))
+                                $$ = DSCP_AF13;
+                        else if (!strcmp($2, "af21"))
+                                $$ = DSCP_AF21;
+                        else if (!strcmp($2, "af22"))
+                                $$ = DSCP_AF22;
+                        else if (!strcmp($2, "af23"))
+                                $$ = DSCP_AF23;
+                        else if (!strcmp($2, "af31"))
+                                $$ = DSCP_AF31;
+                        else if (!strcmp($2, "af32"))
+                                $$ = DSCP_AF32;
+                        else if (!strcmp($2, "af33"))
+                                $$ = DSCP_AF33;
+                        else if (!strcmp($2, "af41"))
+                                $$ = DSCP_AF41;
+                        else if (!strcmp($2, "af42"))
+                                $$ = DSCP_AF42;
+                        else if (!strcmp($2, "af43"))
+                                $$ = DSCP_AF43;
+                        else if ($2[0] == '0' && $2[1] == 'x')
+                                $$ = strtoul($2, NULL, 16);
+                        else
+                                $$ = strtoul($2, NULL, 10);
+                        if (!$$ || $$ > 64) {
+                                yyerror("illegal dscp value %s", $2);
+                                free($2);
+                                YYERROR;
+                        }
+                        free($2);
+                }
+		;
+
 sourcetrack	: SOURCETRACK		{ $$ = PF_SRCTRACK; }
 		| SOURCETRACK GLOBAL	{ $$ = PF_SRCTRACK_GLOBAL; }
 		| SOURCETRACK RULE	{ $$ = PF_SRCTRACK_RULE; }
@@ -4110,6 +4167,10 @@
 		yyerror("keep state on block rules doesn't make sense");
 		problems++;
 	}
+	if ((r->rule_flag & PFRULE_TOS) && (r->rule_flag & PFRULE_DSCP)) {
+		yyerror("tos and dscp cannot be used together");
+		problems++;
+	}
 	return (-problems);
 }
 
@@ -4902,6 +4963,7 @@
 		{ "debug",		DEBUG},
 		{ "drop",		DROP},
 		{ "drop-ovl",		FRAGDROP},
+		{ "dscp",		DSCP},
 		{ "dup-to",		DUPTO},
 		{ "fastroute",		FASTROUTE},
 		{ "file",		FILENAME},
Index: contrib/pf/pfctl/pfctl_altq.c
===================================================================
RCS file: /home/ncvs/src/contrib/pf/pfctl/pfctl_altq.c,v
retrieving revision 1.9
diff -u -r1.9 pfctl_altq.c
--- contrib/pf/pfctl/pfctl_altq.c	3 Jul 2007 12:30:02 -0000	1.9
+++ contrib/pf/pfctl/pfctl_altq.c	1 Apr 2008 16:10:24 -0000
@@ -690,13 +690,6 @@
 		return (-1);
 	}
 
-	if ((opts->rtsc_m1 < opts->rtsc_m2 && opts->rtsc_m1 != 0) ||
-	    (opts->lssc_m1 < opts->lssc_m2 && opts->lssc_m1 != 0) ||
-	    (opts->ulsc_m1 < opts->ulsc_m2 && opts->ulsc_m1 != 0)) {
-		warnx("m1 must be zero for convex curve: %s", pa->qname);
-		return (-1);
-	}
-
 	/*
 	 * admission control:
 	 * for the real-time service curve, the sum of the service curves
Index: contrib/pf/pfctl/pfctl_parser.c
===================================================================
RCS file: /home/ncvs/src/contrib/pf/pfctl/pfctl_parser.c,v
retrieving revision 1.8
diff -u -r1.8 pfctl_parser.c
--- contrib/pf/pfctl/pfctl_parser.c	3 Jul 2007 12:30:02 -0000	1.8
+++ contrib/pf/pfctl/pfctl_parser.c	1 Apr 2008 16:10:24 -0000
@@ -839,8 +839,10 @@
 				printf(" code %u", r->code-1);
 		}
 	}
-	if (r->tos)
-		printf(" tos 0x%2.2x", r->tos);
+        if (r->tos && (r->rule_flag & PFRULE_TOS))
+                printf(" tos 0x%2.2x", r->tos);
+         if (r->tos && (r->rule_flag & PFRULE_DSCP))
+                  printf(" dscp 0x%2.2x", r->tos & DSCP_MASK);
 	if (!r->keep_state && r->action == PF_PASS && !anchor_call[0])
 		printf(" no state");
 	else if (r->keep_state == PF_STATE_NORMAL)
Index: sys/conf/files
===================================================================
RCS file: /home/ncvs/src/sys/conf/files,v
retrieving revision 1.1243.2.2
diff -u -r1.1243.2.2 files
--- sys/conf/files	6 Dec 2007 10:15:29 -0000	1.1243.2.2
+++ sys/conf/files	1 Apr 2008 16:10:25 -0000
@@ -332,6 +332,8 @@
 	compile-with "${NORMAL_C} -I$S/contrib/pf"
 contrib/pf/net/pf_table.c	optional pf \
 	compile-with "${NORMAL_C} -I$S/contrib/pf"
+contrib/pf/net/pf_pptp.c 	optional pf \
+	compile-with "${NORMAL_C} -I$S/contrib/pf"
 contrib/pf/netinet/in4_cksum.c	optional pf inet
 crypto/blowfish/bf_ecb.c	optional ipsec 
 crypto/blowfish/bf_skey.c	optional crypto | ipsec 
Index: sys/contrib/pf/net/pf.c
===================================================================
RCS file: /home/ncvs/src/sys/contrib/pf/net/pf.c,v
retrieving revision 1.46.2.1
diff -u -r1.46.2.1 pf.c
--- sys/contrib/pf/net/pf.c	25 Nov 2007 19:26:46 -0000	1.46.2.1
+++ sys/contrib/pf/net/pf.c	1 Apr 2008 16:10:26 -0000
@@ -3305,7 +3305,10 @@
 		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
 		    r->dst.port[0], r->dst.port[1], th->th_dport))
 			r = r->skip[PF_SKIP_DST_PORT].ptr;
-		else if (r->tos && !(r->tos == pd->tos))
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 			r = TAILQ_NEXT(r, entries);
 		else if (r->rule_flag & PFRULE_FRAGMENT)
 			r = TAILQ_NEXT(r, entries);
@@ -3727,7 +3730,10 @@
 		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
 		    r->dst.port[0], r->dst.port[1], uh->uh_dport))
 			r = r->skip[PF_SKIP_DST_PORT].ptr;
-		else if (r->tos && !(r->tos == pd->tos))
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 			r = TAILQ_NEXT(r, entries);
 		else if (r->rule_flag & PFRULE_FRAGMENT)
 			r = TAILQ_NEXT(r, entries);
@@ -4082,7 +4088,10 @@
 			r = TAILQ_NEXT(r, entries);
 		else if (r->code && r->code != icmpcode + 1)
 			r = TAILQ_NEXT(r, entries);
-		else if (r->tos && !(r->tos == pd->tos))
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 			r = TAILQ_NEXT(r, entries);
 		else if (r->rule_flag & PFRULE_FRAGMENT)
 			r = TAILQ_NEXT(r, entries);
@@ -4341,7 +4350,10 @@
 		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af,
 		    r->dst.neg, NULL))
 			r = r->skip[PF_SKIP_DST_ADDR].ptr;
-		else if (r->tos && !(r->tos == pd->tos))
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 			r = TAILQ_NEXT(r, entries);
 		else if (r->rule_flag & PFRULE_FRAGMENT)
 			r = TAILQ_NEXT(r, entries);
@@ -4558,7 +4570,10 @@
 		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af,
 		    r->dst.neg, NULL))
 			r = r->skip[PF_SKIP_DST_ADDR].ptr;
-		else if (r->tos && !(r->tos == pd->tos))
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 			r = TAILQ_NEXT(r, entries);
 		else if (r->os_fingerprint != PF_OSFP_ANY)
 			r = TAILQ_NEXT(r, entries);
@@ -6869,6 +6884,15 @@
 			action = pf_test_tcp(&r, &s, dir, kif,
 			    m, off, h, &pd, &a, &ruleset, &ipintrq);
 #endif
+		/* XXX: This are here until a pluggable framework for NAT is finished */
+        	if (s != NULL && s->nat_rule.ptr != NULL) {
+			if (ntohs(pd.hdr.tcp->th_dport) == PPTP_CONTROL_PORT_NUMBER)
+ 				pf_get_pptp_translation(&pd, m, off, s, (void *)&th, dir,
+					pd.hdr.tcp->th_sport);
+              		else if (ntohs(pd.hdr.tcp->th_sport) == PPTP_CONTROL_PORT_NUMBER)
+               			pf_get_pptp_translation(&pd, m, off, s, (void *)&th, dir,
+					pd.hdr.tcp->th_dport);
+		}
 		break;
 	}
 
@@ -6965,6 +6989,8 @@
 			action = pf_test_other(&r, &s, dir, kif, m, off, h,
 			    &pd, &a, &ruleset, &ipintrq);
 #endif
+	        if (s != NULL && s->nat_rule.ptr != NULL && h->ip_p == IPPROTO_GRE)
+               		pf_get_gre_translation(&pd, m, off, (void *)h, dir, 0);
 		break;
 	}
 
@@ -6983,7 +7009,7 @@
 
 #ifdef ALTQ
 	if (action == PF_PASS && r->qid) {
-		if (pqid || (pd.tos & IPTOS_LOWDELAY))
+		if (pqid || ((r->rule_flag & PFRULE_TOS) && pd.tos == IPTOS_LOWDELAY))
 			pd.pf_mtag->qid = r->pqid;
 		else
 			pd.pf_mtag->qid = r->qid;
@@ -7212,7 +7238,7 @@
 	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET6);
 	pd.ip_sum = NULL;
 	pd.af = AF_INET6;
-	pd.tos = 0;
+	pd.tos = (ntohl(h->ip6_flow) >> 20) & DSCP_MASK;
 	pd.tot_len = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);
 	pd.eh = eh;
 
@@ -7444,7 +7470,7 @@
 
 #ifdef ALTQ
 	if (action == PF_PASS && r->qid) {
-		if (pd.tos & IPTOS_LOWDELAY)
+		if ((r->rule_flag & PFRULE_TOS) && pd.tos == IPTOS_LOWDELAY)
 			pd.pf_mtag->qid = r->pqid;
 		else
 			pd.pf_mtag->qid = r->qid;
Index: sys/contrib/pf/net/pf_pptp.c
===================================================================
RCS file: sys/contrib/pf/net/pf_pptp.c
diff -N sys/contrib/pf/net/pf_pptp.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sys/contrib/pf/net/pf_pptp.c	1 Apr 2008 16:10:26 -0000
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) 2000 Whistle Communications, Inc.
+ * Copyright (c) 2008 Ermal Luçi
+ * All rights reserved.
+ *
+ * Subject to the following obligations and disclaimer of warranty, use and
+ * redistribution of this software, in source or object code forms, with or
+ * without modifications are expressly permitted by Whistle Communications;
+ * provided, however, that:
+ * 1. Any and all reproductions of the source or object code must include the
+ *    copyright notice above and the following disclaimer of warranties; and
+ * 2. No rights are granted, in any manner or form, to use Whistle
+ *    Communications, Inc. trademarks, including the mark "WHISTLE
+ *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as
+ *    such appears in the above copyright notice or in the software.
+ *
+ * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,
+ * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
+ * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY
+ * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS
+ * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.
+ * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES
+ * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING
+ * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/mbuf.h>
+#include <sys/filio.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+#include <sys/kernel.h>
+#include <sys/queue.h>
+
+#include <sys/endian.h>
+
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/bpf.h>
+#include <net/route.h>
+
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/tcp.h>
+#include <netinet/tcp_seq.h>
+
+#include <net/pfvar.h>
+
+/*
+ * The data structures here and some of the logic in the code is based
+ * on alias_pptp.c of libalias. 
+ */
+#define PPTP_MAGIC              0x1a2b3c4d
+#define PPTP_CTRL_MSG_TYPE      1
+
+/*
+ * PPTP definitions
+ */
+
+struct grehdr {                 /* Enhanced GRE header. */
+        u_int16_t       gh_flags;       /* Flags. */
+        u_int16_t       gh_protocol;    /* Protocol type. */
+        u_int16_t       gh_length;      /* Payload length. */
+        u_int16_t       gh_call_id;     /* Call ID. */
+        u_int32_t       gh_seq_no;      /* Sequence number (optional). */
+        u_int32_t       gh_ack_no;      /* Acknowledgment number
+                                         * (optional). */
+};
+
+/* The PPTP protocol ID used in the GRE 'proto' field. */
+#define PPTP_GRE_PROTO          0x880b
+
+/* Bits that must be set a certain way in all PPTP/GRE packets. */
+#define PPTP_INIT_VALUE         ((0x2001 << 16) | PPTP_GRE_PROTO)
+#define PPTP_INIT_MASK          0xef7fffff
+
+enum {
+        PPTP_StartCtrlConnRequest = 1,
+        PPTP_StartCtrlConnReply = 2,
+        PPTP_StopCtrlConnRequest = 3,
+        PPTP_StopCtrlConnReply = 4,
+        PPTP_EchoRequest = 5,
+        PPTP_EchoReply = 6,
+        PPTP_OutCallRequest = 7,
+        PPTP_OutCallReply = 8,
+        PPTP_InCallRequest = 9,
+        PPTP_InCallReply = 10,
+        PPTP_InCallConn = 11,
+        PPTP_CallClearRequest = 12,
+        PPTP_CallDiscNotify = 13,
+        PPTP_WanErrorNotify = 14,
+        PPTP_SetLinkInfo = 15
+};
+
+ /* Message structures */
+struct pptpMsgHead {
+        u_int16_t       length; /* total length */
+        u_int16_t       msgType;/* PPTP message type */
+        u_int32_t       magic;  /* magic cookie */
+        u_int16_t       type;   /* control message type */
+        u_int16_t       resv0;  /* reserved */
+};
+
+struct pptpCodes {
+        u_int8_t        resCode;/* Result Code */
+        u_int8_t        errCode;/* Error Code */
+};
+
+struct pptpCallIds {
+        u_int16_t       cid1;   /* Call ID field #1 */
+        u_int16_t       cid2;   /* Call ID field #2 */
+};
+
+void
+pf_get_pptp_translation(struct pf_pdesc *pd, struct mbuf *m, int off, struct pf_state *s,
+	void *p, int dir, u_int16_t nport)
+{
+	struct pptpCallIds *cptr;
+        u_int16_t ctl_type;     
+        struct pptpMsgHead hptr, *tst = NULL;
+	struct pptpCodes *codes = NULL;
+	u_int16_t *pcall_id = NULL;
+	struct tcphdr *th = NULL; 
+
+        /* Verify data length */
+        if (pd->tot_len < (int)(sizeof(struct pptpMsgHead) + sizeof(struct pptpCallIds)))
+                return;
+
+	/* NB: We assume pf(4) has done its checks. */
+	th = (struct tcphdr *)p;
+
+        /* Move up to PPTP message header */
+	if (!pf_pull_hdr(m, off + (th->th_off << 2), &hptr, 
+			sizeof(struct pptpMsgHead), NULL, NULL, AF_INET))
+		return;
+
+        /* Return the control message type */
+        ctl_type = ntohs(hptr.type);
+
+        /* Verify PPTP Control Message */
+        if ((ntohs(hptr.msgType) != PPTP_CTRL_MSG_TYPE) ||
+            (ntohl(hptr.magic) != PPTP_MAGIC))
+                return;
+
+        /* Verify data length. */
+        if ((ctl_type == PPTP_OutCallReply || ctl_type == PPTP_InCallReply) &&
+            (pd->tot_len < (int)(sizeof(struct pptpMsgHead) + sizeof(struct pptpCallIds) +
+                sizeof(struct pptpCodes))))
+                return;
+
+	tst = &hptr;
+        cptr = (struct pptpCallIds *) (tst + 1);
+        /* Verify valid PPTP control message */
+        if (cptr == NULL)
+                return;
+
+        /* Modify certain PPTP messages */
+        switch (ctl_type) {
+        case PPTP_WanErrorNotify:
+        case PPTP_InCallConn:
+        case PPTP_SetLinkInfo:
+        case PPTP_OutCallRequest:
+        case PPTP_InCallRequest:
+                pcall_id = &cptr->cid1;
+                s->lan.pad = cptr->cid1;
+                break; 
+        case PPTP_OutCallReply:
+        case PPTP_InCallReply:
+		if (dir == PF_IN) {
+			pcall_id = &cptr->cid2;
+			ctl_type = cptr->cid2;
+		} else {
+                        pcall_id = &cptr->cid1;
+                        ctl_type = cptr->cid1;
+		}
+		break;
+	case PPTP_CallClearRequest:
+        case PPTP_CallDiscNotify:
+        default:
+                return;
+        }
+
+	codes = (struct pptpCodes *) (cptr + 1);
+	if (codes->resCode == 1) {
+		/* Let pf state table save the translation */
+		if (dir == PF_OUT) {
+			*pcall_id = nport;
+			s->lan.pad = ctl_type;
+		} else
+			*pcall_id = s->lan.pad;
+		th->th_sum = pf_cksum_fixup(th->th_sum, 
+				ctl_type, nport, 0);
+	}
+
+	m_copyback(m, off + (th->th_off << 2) + sizeof(struct pptpMsgHead), 
+		sizeof(struct pptpCallIds), (caddr_t)cptr);	
+
+	return;
+} 
+
+void
+pf_get_gre_translation(struct pf_pdesc *pd, struct mbuf *m, int off, void *p,
+        int dir, u_int16_t nport /* unused */)
+{
+        struct grehdr gr;
+	u_int16_t bcallid;
+	struct ip *iphdr = (struct ip *) p;
+
+	if (!pf_pull_hdr(m, off, &gr, sizeof(struct grehdr),
+			NULL, NULL, AF_INET))
+		return;
+
+        /* Check GRE header bits. */
+        if ((ntohl(*((u_int32_t *) &gr)) & PPTP_INIT_MASK) != PPTP_INIT_VALUE)
+                return;
+
+	bcallid = gr.gh_call_id;
+	if (dir == PF_IN)
+		gr.gh_call_id = 0;
+	iphdr->ip_sum = pf_cksum_fixup(iphdr->ip_sum,
+        			bcallid, 0, 0);
+	
+	m_copyback(m, off, sizeof(struct grehdr), (caddr_t)&gr);
+}
Index: sys/contrib/pf/net/pfvar.h
===================================================================
RCS file: /home/ncvs/src/sys/contrib/pf/net/pfvar.h,v
retrieving revision 1.16
diff -u -r1.16 pfvar.h
--- sys/contrib/pf/net/pfvar.h	3 Jul 2007 12:58:33 -0000	1.16
+++ sys/contrib/pf/net/pfvar.h	1 Apr 2008 16:10:26 -0000
@@ -672,6 +672,27 @@
 	u_int8_t		 allow_opts;
 	u_int8_t		 rt;
 	u_int8_t		 return_ttl;
+#ifndef DSCP_EF
+/* Copied from altq_cdnr.h */
+/* diffserve code points */
+#define DSCP_MASK       0xfc
+#define DSCP_CUMASK     0x03
+#define DSCP_EF         0xb8
+#define DSCP_AF11       0x28
+#define DSCP_AF12       0x30
+#define DSCP_AF13       0x38
+#define DSCP_AF21       0x48
+#define DSCP_AF22       0x50
+#define DSCP_AF23       0x58
+#define DSCP_AF31       0x68
+#define DSCP_AF32       0x70
+#define DSCP_AF33       0x78
+#define DSCP_AF41       0x88
+#define DSCP_AF42       0x90
+#define DSCP_AF43       0x98
+#define AF_CLASSMASK            0xe0
+#define AF_DROPPRECMASK         0x18
+#endif
 	u_int8_t		 tos;
 	u_int8_t		 anchor_relative;
 	u_int8_t		 anchor_wildcard;
@@ -698,6 +719,10 @@
 #define PFRULE_RANDOMID		0x0800
 #define PFRULE_REASSEMBLE_TCP	0x1000
 
+/* rule flags for TOS or DSCP differentiation */
+#define PFRULE_TOS		0x2000
+#define PFRULE_DSCP		0x4000
+
 /* rule flags again */
 #define PFRULE_IFBOUND		0x00010000	/* if-bound */
 
@@ -1707,6 +1732,11 @@
 int	pfr_ina_commit(struct pfr_table *, u_int32_t, int *, int *, int);
 int	pfr_ina_define(struct pfr_table *, struct pfr_addr *, int, int *,
 	    int *, u_int32_t, int);
+
+/* XXX: This are here until a pluggable framework for NAT is finished */
+#define PPTP_CONTROL_PORT_NUMBER 1723
+void	pf_get_pptp_translation(struct pf_pdesc *, struct mbuf *, int, struct pf_state *, void *, int, u_int16_t);
+void	pf_get_gre_translation(struct pf_pdesc *, struct mbuf *, int, void *, int, u_int16_t);
 
 extern struct pfi_statehead	 pfi_statehead;
 extern struct pfi_kif		*pfi_all;
Index: sys/modules/pf/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/modules/pf/Makefile,v
retrieving revision 1.13
diff -u -r1.13 Makefile
--- sys/modules/pf/Makefile	3 Jul 2007 12:46:06 -0000	1.13
+++ sys/modules/pf/Makefile	1 Apr 2008 16:10:27 -0000
@@ -7,7 +7,7 @@
 
 KMOD=	pf
 SRCS = 	pf.c pf_if.c pf_subr.c pf_osfp.c pf_ioctl.c pf_norm.c pf_table.c \
-	pf_ruleset.c \
+	pf_ruleset.c pf_pptp.c \
 	in4_cksum.c \
 	opt_pf.h opt_inet.h opt_inet6.h opt_bpf.h opt_mac.h
 
