diff -rubN /usr/src1/src/etc/mtree/BSD.include.dist /usr/src/etc/mtree/BSD.include.dist
--- /usr/src1/src/etc/mtree/BSD.include.dist	Wed Nov 16 10:50:10 2005
+++ /usr/src/etc/mtree/BSD.include.dist	Thu Jun  8 21:13:09 2006
@@ -32,6 +32,8 @@
     crypto
     ..
     dev
+	usb2
+	..
         acpica
         ..
         an
diff -rubN /usr/src1/src/include/Makefile /usr/src/include/Makefile
--- /usr/src1/src/include/Makefile	Wed Nov 16 10:50:09 2005
+++ /usr/src/include/Makefile	Thu Jun  8 21:13:09 2006
@@ -38,7 +38,7 @@
 LSUBDIRS=	cam/scsi \
 	dev/acpica dev/an dev/bktr dev/firewire dev/hwpmc \
 	dev/ic dev/iicbus ${_dev_ieee488} dev/ofw \
-	dev/pbio dev/ppbus dev/smbus dev/speaker dev/usb dev/wi dev/utopia \
+	dev/pbio dev/ppbus dev/smbus dev/speaker dev/usb dev/usb2 dev/wi dev/utopia \
 	fs/devfs fs/fdescfs fs/fifofs fs/msdosfs fs/ntfs fs/nullfs \
 	fs/nwfs fs/portalfs fs/procfs fs/smbfs fs/udf fs/umapfs \
 	fs/unionfs \
diff -rubN /usr/src1/src/sys/conf/files /usr/src/sys/conf/files
--- /usr/src1/src/sys/conf/files	Wed Apr 12 18:09:27 2006
+++ /usr/src/sys/conf/files	Thu Jun  8 21:13:08 2006
@@ -72,12 +72,12 @@
 	clean		"pccarddevs.h"
 usbdevs.h			optional usb				   \
 	dependency	"$S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" \
-	compile-with	"${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs -h" \
+	compile-with	"${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" \
 	no-obj no-implicit-rule before-depend				   \
 	clean		"usbdevs.h"
 usbdevs_data.h			optional usb				   \
 	dependency	"$S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" \
-	compile-with	"${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs -d" \
+	compile-with	"${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" \
 	no-obj no-implicit-rule before-depend				   \
 	clean		"usbdevs_data.h"
 cam/cam.c			optional scbus
@@ -908,8 +908,6 @@
 dev/ubsec/ubsec.c		optional ubsec
 #
 # USB support
-dev/usb/ehci.c			optional ehci
-dev/usb/ehci_pci.c		optional ehci pci
 dev/usb/hid.c			optional usb
 dev/usb/if_aue.c		optional aue
 dev/usb/if_axe.c		optional axe
@@ -919,8 +917,6 @@
 dev/usb/if_ural.c		optional ural
 dev/usb/if_rue.c		optional rue
 dev/usb/if_udav.c		optional udav
-dev/usb/ohci.c			optional ohci
-dev/usb/ohci_pci.c		optional ohci pci
 dev/usb/ubsa.c			optional ubsa ucom
 dev/usb/ubser.c			optional ubser
 dev/usb/ucom.c			optional ucom
@@ -928,11 +924,7 @@
 dev/usb/udbp.c			optional udbp
 dev/usb/ufm.c			optional ufm
 dev/usb/uftdi.c			optional uftdi ucom
-dev/usb/ugen.c			optional ugen
-dev/usb/uhci.c			optional uhci
-dev/usb/uhci_pci.c		optional uhci pci
 dev/usb/uhid.c			optional uhid
-dev/usb/uhub.c			optional usb
 dev/usb/ukbd.c			optional ukbd
 dev/usb/ulpt.c			optional ulpt
 dev/usb/umass.c			optional umass
@@ -941,14 +933,9 @@
 dev/usb/ums.c			optional ums
 dev/usb/uplcom.c		optional uplcom ucom
 dev/usb/urio.c			optional urio
-dev/usb/usb.c			optional usb
 dev/usb/usb_ethersubr.c		optional usb
 dev/usb/usb_if.m		optional usb
-dev/usb/usb_mem.c		optional usb
 dev/usb/usb_quirks.c		optional usb
-dev/usb/usb_subr.c		optional usb
-dev/usb/usbdi.c			optional usb
-dev/usb/usbdi_util.c		optional usb
 dev/usb/uscanner.c		optional uscanner
 dev/usb/uvisor.c		optional uvisor ucom
 dev/usb/uvscom.c		optional uvscom ucom
@@ -1856,3 +1843,23 @@
 vm/vm_unix.c			standard
 vm/vm_zeroidle.c		standard
 vm/vnode_pager.c		standard
+ 
+#  
+# USB support  
+dev/usb2/_uhci.c            optional usb  
+dev/usb2/_uhci_pci.c        optional usb  
+dev/usb2/_uhci.c            optional uhci  
+dev/usb2/_uhci_pci.c        optional uhci  
+dev/usb2/_ohci.c            optional usb  
+dev/usb2/_ohci_pci.c        optional usb  
+dev/usb2/_ohci.c            optional ohci  
+dev/usb2/_ohci_pci.c        optional ohci  
+dev/usb2/_ehci.c            optional ehci  
+dev/usb2/_ehci_pci.c        optional ehci  
+dev/usb2/_uhub.c            optional usb  
+dev/usb2/_usb.c             optional usb  
+dev/usb2/_usb_requests.c    optional usb  
+dev/usb2/_usb_subr.c        optional usb  
+dev/usb2/_usb_transfer.c    optional usb  
+dev/usb2/_ugen.c            optional ugen  
+usbdevs.h                   optional usb dependency "$S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" compile-with "${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" no-obj no-implicit-rule before-depend clean "usbdevs.h"  
diff -rubN /usr/src1/src/sys/conf/kmod.mk /usr/src/sys/conf/kmod.mk
--- /usr/src1/src/sys/conf/kmod.mk	Thu Feb 23 02:13:31 2006
+++ /usr/src/sys/conf/kmod.mk	Thu Jun  8 21:13:09 2006
@@ -402,7 +402,7 @@
 .else
 usbdevs.h: @/tools/usbdevs2h.awk @/dev/usb/usbdevs
 .endif
-	${AWK} -f @/tools/usbdevs2h.awk @/dev/usb/usbdevs -h
+	${AWK} -f @/tools/usbdevs2h.awk @/dev/usb/usbdevs
 .endif
 
 .if ${SRCS:Musbdevs_data.h} != ""
@@ -412,7 +412,7 @@
 .else
 usbdevs_data.h: @/tools/usbdevs2h.awk @/dev/usb/usbdevs
 .endif
-	${AWK} -f @/tools/usbdevs2h.awk @/dev/usb/usbdevs -d
+	${AWK} -f @/tools/usbdevs2h.awk @/dev/usb/usbdevs
 .endif
 
 .if ${SRCS:Macpi_quirks.h} != ""
diff -rubN /usr/src1/src/sys/dev/CVS/Entries /usr/src/sys/dev/CVS/Entries
--- /usr/src1/src/sys/dev/CVS/Entries	Thu Jun  8 21:23:24 2006
+++ /usr/src/sys/dev/CVS/Entries	Thu Jun  8 21:16:16 2006
@@ -167,3 +167,4 @@
 D/wl////
 D/xe////
 D/zs////
+D/usb2////
diff -rubN /usr/src1/src/sys/dev/sound/usb/uaudio.c /usr/src/sys/dev/sound/usb/uaudio.c
--- /usr/src1/src/sys/dev/sound/usb/uaudio.c	Tue Apr  4 17:34:10 2006
+++ /usr/src/sys/dev/sound/usb/uaudio.c	Thu Jun  8 21:14:14 2006
@@ -3742,9 +3742,6 @@
 	int i, j, enc;
 	int samples_per_frame, sample_size;
 
-	if ((sc->sc_playchan.pipe != NULL) || (sc->sc_recchan.pipe != NULL))
-		return (-1);
-
 	switch(ch->format & 0x000FFFFF) {
 	case AFMT_U8:
 		enc = AUDIO_ENCODING_ULINEAR_LE;
diff -rubN /usr/src1/src/sys/dev/sound/usb/uaudio.c.orig /usr/src/sys/dev/sound/usb/uaudio.c.orig
--- /usr/src1/src/sys/dev/sound/usb/uaudio.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/sound/usb/uaudio.c.orig	Tue Apr  4 17:34:10 2006
@@ -0,0 +1,4547 @@
+/*	$NetBSD: uaudio.c,v 1.91 2004/11/05 17:46:14 kent Exp $	*/
+/*	$FreeBSD: src/sys/dev/sound/usb/uaudio.c,v 1.14.2.2 2006/04/04 17:34:10 ariff Exp $ */
+
+/*-
+ * Copyright (c) 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * USB audio specs: http://www.usb.org/developers/devclass_docs/audio10.pdf
+ *                  http://www.usb.org/developers/devclass_docs/frmts10.pdf
+ *                  http://www.usb.org/developers/devclass_docs/termt10.pdf
+ */
+
+#include <sys/cdefs.h>
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+__KERNEL_RCSID(0, "$NetBSD: uaudio.c,v 1.91 2004/11/05 17:46:14 kent Exp $");
+#endif
+
+/*
+ * Also merged:
+ *  $NetBSD: uaudio.c,v 1.94 2005/01/15 15:19:53 kent Exp $
+ *  $NetBSD: uaudio.c,v 1.95 2005/01/16 06:02:19 dsainty Exp $
+ *  $NetBSD: uaudio.c,v 1.96 2005/01/16 12:46:00 kent Exp $
+ *  $NetBSD: uaudio.c,v 1.97 2005/02/24 08:19:38 martin Exp $
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/device.h>
+#include <sys/ioctl.h>
+#endif
+#include <sys/tty.h>
+#include <sys/file.h>
+#include <sys/reboot.h>		/* for bootverbose */
+#include <sys/select.h>
+#include <sys/proc.h>
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/device.h>
+#elif defined(__FreeBSD__)
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/conf.h>
+#endif
+#include <sys/poll.h>
+#if defined(__FreeBSD__)
+#include <sys/sysctl.h>
+#include <sys/sbuf.h>
+#endif
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/audioio.h>
+#include <dev/audio_if.h>
+#include <dev/audiovar.h>
+#include <dev/mulaw.h>
+#include <dev/auconv.h>
+#elif defined(__FreeBSD__)
+#include <dev/sound/pcm/sound.h>	/* XXXXX */
+#include <dev/sound/chip.h>
+#include "feeder_if.h"
+#endif
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include <dev/usb/usb_quirks.h>
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <dev/usb/uaudioreg.h>
+#elif defined(__FreeBSD__)
+#include <dev/sound/usb/uaudioreg.h>
+#include <dev/sound/usb/uaudio.h>
+#endif
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+/* #define UAUDIO_DEBUG */
+#else
+/* #define USB_DEBUG */
+#endif
+/* #define UAUDIO_MULTIPLE_ENDPOINTS */
+#ifdef USB_DEBUG
+#define DPRINTF(x)	do { if (uaudiodebug) logprintf x; } while (0)
+#define DPRINTFN(n,x)	do { if (uaudiodebug>(n)) logprintf x; } while (0)
+int	uaudiodebug = 0;
+#if defined(__FreeBSD__)
+SYSCTL_NODE(_hw_usb, OID_AUTO, uaudio, CTLFLAG_RW, 0, "USB uaudio");
+SYSCTL_INT(_hw_usb_uaudio, OID_AUTO, debug, CTLFLAG_RW,
+	   &uaudiodebug, 0, "uaudio debug level");
+#endif
+#else
+#define DPRINTF(x)
+#define DPRINTFN(n,x)
+#endif
+
+#define UAUDIO_NCHANBUFS 6	/* number of outstanding request */
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#define UAUDIO_NFRAMES   10	/* ms of sound in each request */
+#elif defined(__FreeBSD__)
+#define UAUDIO_NFRAMES   20	/* ms of sound in each request */
+#endif
+
+
+#define MIX_MAX_CHAN 8
+struct mixerctl {
+	uint16_t	wValue[MIX_MAX_CHAN]; /* using nchan */
+	uint16_t	wIndex;
+	uint8_t		nchan;
+	uint8_t		type;
+#define MIX_ON_OFF	1
+#define MIX_SIGNED_16	2
+#define MIX_UNSIGNED_16	3
+#define MIX_SIGNED_8	4
+#define MIX_SELECTOR	5
+#define MIX_SIZE(n) ((n) == MIX_SIGNED_16 || (n) == MIX_UNSIGNED_16 ? 2 : 1)
+#define MIX_UNSIGNED(n) ((n) == MIX_UNSIGNED_16)
+	int		minval, maxval;
+	u_int		delta;
+	u_int		mul;
+#if defined(__FreeBSD__) /* XXXXX */
+	unsigned	ctl;
+#define MAX_SELECTOR_INPUT_PIN 256
+	uint8_t		slctrtype[MAX_SELECTOR_INPUT_PIN];
+#endif
+	uint8_t		class;
+#if !defined(__FreeBSD__)
+	char		ctlname[MAX_AUDIO_DEV_LEN];
+	char		*ctlunit;
+#endif
+};
+#define MAKE(h,l) (((h) << 8) | (l))
+
+struct as_info {
+	uint8_t		alt;
+	uint8_t		encoding;
+	uint8_t		attributes; /* Copy of bmAttributes of
+				     * usb_audio_streaming_endpoint_descriptor
+				     */
+	usbd_interface_handle	ifaceh;
+	const usb_interface_descriptor_t *idesc;
+	const usb_endpoint_descriptor_audio_t *edesc;
+	const usb_endpoint_descriptor_audio_t *edesc1;
+	const struct usb_audio_streaming_type1_descriptor *asf1desc;
+	int		sc_busy;	/* currently used */
+};
+
+struct chan {
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+	void	(*intr)(void *);	/* DMA completion intr handler */
+	void	*arg;		/* arg for intr() */
+#else
+	struct pcm_channel *pcm_ch;
+#endif
+	usbd_pipe_handle pipe;
+	usbd_pipe_handle sync_pipe;
+
+	u_int	sample_size;
+	u_int	sample_rate;
+	u_int	bytes_per_frame;
+	u_int	fraction;	/* fraction/1000 is the extra samples/frame */
+	u_int	residue;	/* accumulates the fractional samples */
+
+	u_char	*start;		/* upper layer buffer start */
+	u_char	*end;		/* upper layer buffer end */
+	u_char	*cur;		/* current position in upper layer buffer */
+	int	blksize;	/* chunk size to report up */
+	int	transferred;	/* transferred bytes not reported up */
+
+	int	altidx;		/* currently used altidx */
+
+	int	curchanbuf;
+	struct chanbuf {
+		struct chan	*chan;
+		usbd_xfer_handle xfer;
+		u_char		*buffer;
+		u_int16_t	sizes[UAUDIO_NFRAMES];
+		u_int16_t	offsets[UAUDIO_NFRAMES];
+		u_int16_t	size;
+	} chanbufs[UAUDIO_NCHANBUFS];
+
+	struct uaudio_softc *sc; /* our softc */
+#if defined(__FreeBSD__)
+	u_int32_t format;
+	int	precision;
+	int	channels;
+#endif
+};
+
+struct uaudio_softc {
+	USBBASEDEVICE	sc_dev;		/* base device */
+	usbd_device_handle sc_udev;	/* USB device */
+	int		sc_ac_iface;	/* Audio Control interface */
+	usbd_interface_handle	sc_ac_ifaceh;
+	struct chan	sc_playchan;	/* play channel */
+	struct chan	sc_recchan;	/* record channel */
+	int		sc_nullalt;
+	int		sc_audio_rev;
+	struct as_info	*sc_alts;	/* alternate settings */
+	int		sc_nalts;	/* # of alternate settings */
+	int		sc_altflags;
+#define HAS_8		0x01
+#define HAS_16		0x02
+#define HAS_8U		0x04
+#define HAS_ALAW	0x08
+#define HAS_MULAW	0x10
+#define UA_NOFRAC	0x20		/* don't do sample rate adjustment */
+#define HAS_24		0x40
+#define HAS_32		0x80
+	int		sc_mode;	/* play/record capability */
+	struct mixerctl *sc_ctls;	/* mixer controls */
+	int		sc_nctls;	/* # of mixer controls */
+	device_ptr_t	sc_audiodev;
+	char		sc_dying;
+#if defined(__FreeBSD__)
+	struct sbuf	uaudio_sndstat;
+	int		uaudio_sndstat_flag;
+#endif
+};
+
+struct terminal_list {
+	int size;
+	uint16_t terminals[1];
+};
+#define TERMINAL_LIST_SIZE(N)	(offsetof(struct terminal_list, terminals) \
+				+ sizeof(uint16_t) * (N))
+
+struct io_terminal {
+	union {
+		const usb_descriptor_t *desc;
+		const struct usb_audio_input_terminal *it;
+		const struct usb_audio_output_terminal *ot;
+		const struct usb_audio_mixer_unit *mu;
+		const struct usb_audio_selector_unit *su;
+		const struct usb_audio_feature_unit *fu;
+		const struct usb_audio_processing_unit *pu;
+		const struct usb_audio_extension_unit *eu;
+	} d;
+	int inputs_size;
+	struct terminal_list **inputs; /* list of source input terminals */
+	struct terminal_list *output; /* list of destination output terminals */
+	int direct;		/* directly connected to an output terminal */
+};
+
+#define UAC_OUTPUT	0
+#define UAC_INPUT	1
+#define UAC_EQUAL	2
+#define UAC_RECORD	3
+#define UAC_NCLASSES	4
+#ifdef USB_DEBUG
+#if defined(__FreeBSD__)
+#define AudioCinputs	"inputs"
+#define AudioCoutputs	"outputs"
+#define AudioCrecord	"record"
+#define AudioCequalization	"equalization"
+#endif
+Static const char *uac_names[] = {
+	AudioCoutputs, AudioCinputs, AudioCequalization, AudioCrecord,
+};
+#endif
+
+Static usbd_status uaudio_identify_ac
+	(struct uaudio_softc *, const usb_config_descriptor_t *);
+Static usbd_status uaudio_identify_as
+	(struct uaudio_softc *, const usb_config_descriptor_t *);
+Static usbd_status uaudio_process_as
+	(struct uaudio_softc *, const char *, int *, int,
+	 const usb_interface_descriptor_t *);
+
+Static void	uaudio_add_alt(struct uaudio_softc *, const struct as_info *);
+
+Static const usb_interface_descriptor_t *uaudio_find_iface
+	(const char *, int, int *, int);
+
+Static void	uaudio_mixer_add_ctl(struct uaudio_softc *, struct mixerctl *);
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static char	*uaudio_id_name
+	(struct uaudio_softc *, const struct io_terminal *, int);
+#endif
+
+#ifdef USB_DEBUG
+Static void	uaudio_dump_cluster(const struct usb_audio_cluster *);
+#endif
+Static struct usb_audio_cluster uaudio_get_cluster
+	(int, const struct io_terminal *);
+Static void	uaudio_add_input
+	(struct uaudio_softc *, const struct io_terminal *, int);
+Static void	uaudio_add_output
+	(struct uaudio_softc *, const struct io_terminal *, int);
+Static void	uaudio_add_mixer
+	(struct uaudio_softc *, const struct io_terminal *, int);
+Static void	uaudio_add_selector
+	(struct uaudio_softc *, const struct io_terminal *, int);
+#ifdef USB_DEBUG
+Static const char *uaudio_get_terminal_name(int);
+#endif
+Static int	uaudio_determine_class
+	(const struct io_terminal *, struct mixerctl *);
+#if defined(__FreeBSD__)
+Static const int uaudio_feature_name(const struct io_terminal *,
+		    struct mixerctl *);
+#else
+Static const char *uaudio_feature_name
+	(const struct io_terminal *, struct mixerctl *);
+#endif
+Static void	uaudio_add_feature
+	(struct uaudio_softc *, const struct io_terminal *, int);
+Static void	uaudio_add_processing_updown
+	(struct uaudio_softc *, const struct io_terminal *, int);
+Static void	uaudio_add_processing
+	(struct uaudio_softc *, const struct io_terminal *, int);
+Static void	uaudio_add_extension
+	(struct uaudio_softc *, const struct io_terminal *, int);
+Static struct terminal_list *uaudio_merge_terminal_list
+	(const struct io_terminal *);
+Static struct terminal_list *uaudio_io_terminaltype
+	(int, struct io_terminal *, int);
+Static usbd_status uaudio_identify
+	(struct uaudio_softc *, const usb_config_descriptor_t *);
+
+Static int	uaudio_signext(int, int);
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static int	uaudio_value2bsd(struct mixerctl *, int);
+#endif
+Static int	uaudio_bsd2value(struct mixerctl *, int);
+Static int	uaudio_get(struct uaudio_softc *, int, int, int, int, int);
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static int	uaudio_ctl_get
+	(struct uaudio_softc *, int, struct mixerctl *, int);
+#endif
+Static void	uaudio_set
+	(struct uaudio_softc *, int, int, int, int, int, int);
+Static void	uaudio_ctl_set
+	(struct uaudio_softc *, int, struct mixerctl *, int, int);
+
+Static usbd_status uaudio_set_speed(struct uaudio_softc *, int, u_int);
+
+Static usbd_status uaudio_chan_open(struct uaudio_softc *, struct chan *);
+Static void	uaudio_chan_close(struct uaudio_softc *, struct chan *);
+Static usbd_status uaudio_chan_alloc_buffers
+	(struct uaudio_softc *, struct chan *);
+Static void	uaudio_chan_free_buffers(struct uaudio_softc *, struct chan *);
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static void	uaudio_chan_init
+	(struct chan *, int, const struct audio_params *, int);
+Static void	uaudio_chan_set_param(struct chan *, u_char *, u_char *, int);
+#endif
+
+Static void	uaudio_chan_ptransfer(struct chan *);
+Static void	uaudio_chan_pintr
+	(usbd_xfer_handle, usbd_private_handle, usbd_status);
+
+Static void	uaudio_chan_rtransfer(struct chan *);
+Static void	uaudio_chan_rintr
+	(usbd_xfer_handle, usbd_private_handle, usbd_status);
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static int	uaudio_open(void *, int);
+Static void	uaudio_close(void *);
+Static int	uaudio_drain(void *);
+Static int	uaudio_query_encoding(void *, struct audio_encoding *);
+Static void	uaudio_get_minmax_rates
+	(int, const struct as_info *, const struct audio_params *,
+	 int, u_long *, u_long *);
+Static int	uaudio_match_alt_sub
+	(int, const struct as_info *, const struct audio_params *, int, u_long);
+Static int	uaudio_match_alt_chan
+	(int, const struct as_info *, struct audio_params *, int);
+Static int	uaudio_match_alt
+	(int, const struct as_info *, struct audio_params *, int);
+Static int	uaudio_set_params
+	(void *, int, int, struct audio_params *, struct audio_params *);
+Static int	uaudio_round_blocksize(void *, int);
+Static int	uaudio_trigger_output
+	(void *, void *, void *, int, void (*)(void *), void *,
+	 struct audio_params *);
+Static int	uaudio_trigger_input
+	(void *, void *, void *, int, void (*)(void *), void *,
+	 struct audio_params *);
+Static int	uaudio_halt_in_dma(void *);
+Static int	uaudio_halt_out_dma(void *);
+Static int	uaudio_getdev(void *, struct audio_device *);
+Static int	uaudio_mixer_set_port(void *, mixer_ctrl_t *);
+Static int	uaudio_mixer_get_port(void *, mixer_ctrl_t *);
+Static int	uaudio_query_devinfo(void *, mixer_devinfo_t *);
+Static int	uaudio_get_props(void *);
+
+Static const struct audio_hw_if uaudio_hw_if = {
+	uaudio_open,
+	uaudio_close,
+	uaudio_drain,
+	uaudio_query_encoding,
+	uaudio_set_params,
+	uaudio_round_blocksize,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	uaudio_halt_out_dma,
+	uaudio_halt_in_dma,
+	NULL,
+	uaudio_getdev,
+	NULL,
+	uaudio_mixer_set_port,
+	uaudio_mixer_get_port,
+	uaudio_query_devinfo,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	uaudio_get_props,
+	uaudio_trigger_output,
+	uaudio_trigger_input,
+	NULL,
+};
+
+Static struct audio_device uaudio_device = {
+	"USB audio",
+	"",
+	"uaudio"
+};
+
+#elif defined(__FreeBSD__)
+Static int	audio_attach_mi(device_t);
+Static int	uaudio_init_params(struct uaudio_softc * sc, struct chan *ch, int mode);
+static int 	uaudio_sndstat_prepare_pcm(struct sbuf *s, device_t dev, int verbose);
+
+/* for NetBSD compatibirity */
+#define	AUMODE_PLAY	0x01
+#define	AUMODE_RECORD	0x02
+
+#define	AUDIO_PROP_FULLDUPLEX	0x01
+
+#define	AUDIO_ENCODING_ULAW		1
+#define	AUDIO_ENCODING_ALAW		2
+#define	AUDIO_ENCODING_SLINEAR_LE	6
+#define	AUDIO_ENCODING_SLINEAR_BE	7
+#define	AUDIO_ENCODING_ULINEAR_LE	8
+#define	AUDIO_ENCODING_ULINEAR_BE	9
+
+#endif	/* FreeBSD */
+
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+
+USB_DECLARE_DRIVER(uaudio);
+
+#elif defined(__FreeBSD__)
+
+USB_DECLARE_DRIVER_INIT(uaudio,
+		DEVMETHOD(device_suspend, bus_generic_suspend),
+		DEVMETHOD(device_resume, bus_generic_resume),
+		DEVMETHOD(device_shutdown, bus_generic_shutdown),
+		DEVMETHOD(bus_print_child, bus_generic_print_child)
+		);
+#endif
+
+
+USB_MATCH(uaudio)
+{
+	USB_MATCH_START(uaudio, uaa);
+	usb_interface_descriptor_t *id;
+
+	if (uaa->iface == NULL)
+		return UMATCH_NONE;
+
+	id = usbd_get_interface_descriptor(uaa->iface);
+	/* Trigger on the control interface. */
+	if (id == NULL ||
+	    id->bInterfaceClass != UICLASS_AUDIO ||
+	    id->bInterfaceSubClass != UISUBCLASS_AUDIOCONTROL ||
+	    (usbd_get_quirks(uaa->device)->uq_flags & UQ_BAD_AUDIO))
+		return UMATCH_NONE;
+
+	return UMATCH_IFACECLASS_IFACESUBCLASS;
+}
+
+USB_ATTACH(uaudio)
+{
+	USB_ATTACH_START(uaudio, sc, uaa);
+	usb_interface_descriptor_t *id;
+	usb_config_descriptor_t *cdesc;
+	char devinfo[1024];
+	usbd_status err;
+	int i, j, found;
+
+#if defined(__FreeBSD__)
+	usbd_devinfo(uaa->device, 0, devinfo);
+	USB_ATTACH_SETUP;
+#else
+	usbd_devinfo(uaa->device, 0, devinfo, sizeof(devinfo));
+	printf(": %s\n", devinfo);
+#endif
+
+	sc->sc_udev = uaa->device;
+
+	cdesc = usbd_get_config_descriptor(sc->sc_udev);
+	if (cdesc == NULL) {
+		printf("%s: failed to get configuration descriptor\n",
+		       USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	err = uaudio_identify(sc, cdesc);
+	if (err) {
+		printf("%s: audio descriptors make no sense, error=%d\n",
+		       USBDEVNAME(sc->sc_dev), err);
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	sc->sc_ac_ifaceh = uaa->iface;
+	/* Pick up the AS interface. */
+	for (i = 0; i < uaa->nifaces; i++) {
+		if (uaa->ifaces[i] == NULL)
+			continue;
+		id = usbd_get_interface_descriptor(uaa->ifaces[i]);
+		if (id == NULL)
+			continue;
+		found = 0;
+		for (j = 0; j < sc->sc_nalts; j++) {
+			if (id->bInterfaceNumber ==
+			    sc->sc_alts[j].idesc->bInterfaceNumber) {
+				sc->sc_alts[j].ifaceh = uaa->ifaces[i];
+				found = 1;
+			}
+		}
+		if (found)
+			uaa->ifaces[i] = NULL;
+	}
+
+	for (j = 0; j < sc->sc_nalts; j++) {
+		if (sc->sc_alts[j].ifaceh == NULL) {
+			printf("%s: alt %d missing AS interface(s)\n",
+			    USBDEVNAME(sc->sc_dev), j);
+			USB_ATTACH_ERROR_RETURN;
+		}
+	}
+
+	printf("%s: audio rev %d.%02x\n", USBDEVNAME(sc->sc_dev),
+	       sc->sc_audio_rev >> 8, sc->sc_audio_rev & 0xff);
+
+	sc->sc_playchan.sc = sc->sc_recchan.sc = sc;
+	sc->sc_playchan.altidx = -1;
+	sc->sc_recchan.altidx = -1;
+
+	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_NO_FRAC)
+		sc->sc_altflags |= UA_NOFRAC;
+
+#ifndef USB_DEBUG
+	if (bootverbose)
+#endif
+		printf("%s: %d mixer controls\n", USBDEVNAME(sc->sc_dev),
+		    sc->sc_nctls);
+
+#if !defined(__FreeBSD__)
+	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
+			   USBDEV(sc->sc_dev));
+#endif
+
+	DPRINTF(("uaudio_attach: doing audio_attach_mi\n"));
+#if defined(__OpenBSD__)
+	audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
+#elif defined(__NetBSD__)
+	sc->sc_audiodev = audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
+#elif defined(__FreeBSD__)
+	sc->sc_dying = 0;
+	if (audio_attach_mi(sc->sc_dev)) {
+		printf("audio_attach_mi failed\n");
+		USB_ATTACH_ERROR_RETURN;
+	}
+#endif
+
+	USB_ATTACH_SUCCESS_RETURN;
+}
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+int
+uaudio_activate(device_ptr_t self, enum devact act)
+{
+	struct uaudio_softc *sc;
+	int rv;
+
+	sc = (struct uaudio_softc *)self;
+	rv = 0;
+	switch (act) {
+	case DVACT_ACTIVATE:
+		return EOPNOTSUPP;
+
+	case DVACT_DEACTIVATE:
+		if (sc->sc_audiodev != NULL)
+			rv = config_deactivate(sc->sc_audiodev);
+		sc->sc_dying = 1;
+		break;
+	}
+	return rv;
+}
+#endif
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+int
+uaudio_detach(device_ptr_t self, int flags)
+{
+	struct uaudio_softc *sc;
+	int rv;
+
+	sc = (struct uaudio_softc *)self;
+	rv = 0;
+	/* Wait for outstanding requests to complete. */
+	usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);
+
+	if (sc->sc_audiodev != NULL)
+		rv = config_detach(sc->sc_audiodev, flags);
+
+	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
+			   USBDEV(sc->sc_dev));
+
+	return rv;
+}
+#elif defined(__FreeBSD__)
+
+USB_DETACH(uaudio)
+{
+	USB_DETACH_START(uaudio, sc);
+
+	sbuf_delete(&(sc->uaudio_sndstat));
+	sc->uaudio_sndstat_flag = 0;
+
+	sc->sc_dying = 1;
+
+#if 0 /* XXX */
+	/* Wait for outstanding requests to complete. */
+	usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);
+#endif
+
+	/* do nothing ? */
+	return bus_generic_detach(sc->sc_dev);
+}
+#endif
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static int
+uaudio_query_encoding(void *addr, struct audio_encoding *fp)
+{
+	struct uaudio_softc *sc;
+	int flags;
+	int idx;
+
+	sc = addr;
+	flags = sc->sc_altflags;
+	if (sc->sc_dying)
+		return EIO;
+
+	if (sc->sc_nalts == 0 || flags == 0)
+		return ENXIO;
+
+	idx = fp->index;
+	switch (idx) {
+	case 0:
+		strlcpy(fp->name, AudioEulinear, sizeof(fp->name));
+		fp->encoding = AUDIO_ENCODING_ULINEAR;
+		fp->precision = 8;
+		fp->flags = flags&HAS_8U ? 0 : AUDIO_ENCODINGFLAG_EMULATED;
+		return (0);
+	case 1:
+		strlcpy(fp->name, AudioEmulaw, sizeof(fp->name));
+		fp->encoding = AUDIO_ENCODING_ULAW;
+		fp->precision = 8;
+		fp->flags = flags&HAS_MULAW ? 0 : AUDIO_ENCODINGFLAG_EMULATED;
+		return (0);
+	case 2:
+		strlcpy(fp->name, AudioEalaw, sizeof(fp->name));
+		fp->encoding = AUDIO_ENCODING_ALAW;
+		fp->precision = 8;
+		fp->flags = flags&HAS_ALAW ? 0 : AUDIO_ENCODINGFLAG_EMULATED;
+		return (0);
+	case 3:
+		strlcpy(fp->name, AudioEslinear, sizeof(fp->name));
+		fp->encoding = AUDIO_ENCODING_SLINEAR;
+		fp->precision = 8;
+		fp->flags = flags&HAS_8 ? 0 : AUDIO_ENCODINGFLAG_EMULATED;
+		return (0);
+	case 4:
+		strlcpy(fp->name, AudioEslinear_le, sizeof(fp->name));
+		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
+		fp->precision = 16;
+		fp->flags = 0;
+		return (0);
+	case 5:
+		strlcpy(fp->name, AudioEulinear_le, sizeof(fp->name));
+		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
+		fp->precision = 16;
+		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
+		return (0);
+	case 6:
+		strlcpy(fp->name, AudioEslinear_be, sizeof(fp->name));
+		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
+		fp->precision = 16;
+		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
+		return (0);
+	case 7:
+		strlcpy(fp->name, AudioEulinear_be, sizeof(fp->name));
+		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
+		fp->precision = 16;
+		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
+		return (0);
+	default:
+		return (EINVAL);
+	}
+}
+#endif
+
+Static const usb_interface_descriptor_t *
+uaudio_find_iface(const char *buf, int size, int *offsp, int subtype)
+{
+	const usb_interface_descriptor_t *d;
+
+	while (*offsp < size) {
+		d = (const void *)(buf + *offsp);
+		*offsp += d->bLength;
+		if (d->bDescriptorType == UDESC_INTERFACE &&
+		    d->bInterfaceClass == UICLASS_AUDIO &&
+		    d->bInterfaceSubClass == subtype)
+			return d;
+	}
+	return NULL;
+}
+
+Static void
+uaudio_mixer_add_ctl(struct uaudio_softc *sc, struct mixerctl *mc)
+{
+	int res;
+	size_t len;
+	struct mixerctl *nmc;
+
+#if defined(__FreeBSD__)
+	if (mc->class < UAC_NCLASSES) {
+		DPRINTF(("%s: adding %s.%d\n",
+			 __func__, uac_names[mc->class], mc->ctl));
+	} else {
+		DPRINTF(("%s: adding %d\n", __func__, mc->ctl));
+	}
+#else
+	if (mc->class < UAC_NCLASSES) {
+		DPRINTF(("%s: adding %s.%s\n",
+			 __func__, uac_names[mc->class], mc->ctlname));
+	} else {
+		DPRINTF(("%s: adding %s\n", __func__, mc->ctlname));
+	}
+#endif
+	len = sizeof(*mc) * (sc->sc_nctls + 1);
+	nmc = malloc(len, M_USBDEV, M_NOWAIT);
+	if (nmc == NULL) {
+		printf("uaudio_mixer_add_ctl: no memory\n");
+		return;
+	}
+	/* Copy old data, if there was any */
+	if (sc->sc_nctls != 0) {
+		memcpy(nmc, sc->sc_ctls, sizeof(*mc) * (sc->sc_nctls));
+		free(sc->sc_ctls, M_USBDEV);
+	}
+	sc->sc_ctls = nmc;
+
+	mc->delta = 0;
+	if (mc->type == MIX_ON_OFF) {
+		mc->minval = 0;
+		mc->maxval = 1;
+	} else if (mc->type == MIX_SELECTOR) {
+		;
+	} else {
+		/* Determine min and max values. */
+		mc->minval = uaudio_signext(mc->type,
+			uaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE,
+				   mc->wValue[0], mc->wIndex,
+				   MIX_SIZE(mc->type)));
+		mc->maxval = 1 + uaudio_signext(mc->type,
+			uaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,
+				   mc->wValue[0], mc->wIndex,
+				   MIX_SIZE(mc->type)));
+		mc->mul = mc->maxval - mc->minval;
+		if (mc->mul == 0)
+			mc->mul = 1;
+		res = uaudio_get(sc, GET_RES, UT_READ_CLASS_INTERFACE,
+				 mc->wValue[0], mc->wIndex,
+				 MIX_SIZE(mc->type));
+		if (res > 0)
+			mc->delta = (res * 255 + mc->mul/2) / mc->mul;
+	}
+
+	sc->sc_ctls[sc->sc_nctls++] = *mc;
+
+#ifdef USB_DEBUG
+	if (uaudiodebug > 2) {
+		int i;
+		DPRINTF(("uaudio_mixer_add_ctl: wValue=%04x",mc->wValue[0]));
+		for (i = 1; i < mc->nchan; i++)
+			DPRINTF((",%04x", mc->wValue[i]));
+#if defined(__FreeBSD__)
+		DPRINTF((" wIndex=%04x type=%d ctl='%d' "
+			 "min=%d max=%d\n",
+			 mc->wIndex, mc->type, mc->ctl,
+			 mc->minval, mc->maxval));
+#else
+		DPRINTF((" wIndex=%04x type=%d name='%s' unit='%s' "
+			 "min=%d max=%d\n",
+			 mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,
+			 mc->minval, mc->maxval));
+#endif
+	}
+#endif
+}
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static char *
+uaudio_id_name(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
+{
+	static char buf[32];
+
+	snprintf(buf, sizeof(buf), "i%d", id);
+	return buf;
+}
+#endif
+
+#ifdef USB_DEBUG
+Static void
+uaudio_dump_cluster(const struct usb_audio_cluster *cl)
+{
+	static const char *channel_names[16] = {
+		"LEFT", "RIGHT", "CENTER", "LFE",
+		"LEFT_SURROUND", "RIGHT_SURROUND", "LEFT_CENTER", "RIGHT_CENTER",
+		"SURROUND", "LEFT_SIDE", "RIGHT_SIDE", "TOP",
+		"RESERVED12", "RESERVED13", "RESERVED14", "RESERVED15",
+	};
+	int cc, i, first;
+
+	cc = UGETW(cl->wChannelConfig);
+	logprintf("cluster: bNrChannels=%u wChannelConfig=0x%.4x",
+		  cl->bNrChannels, cc);
+	first = TRUE;
+	for (i = 0; cc != 0; i++) {
+		if (cc & 1) {
+			logprintf("%c%s", first ? '<' : ',', channel_names[i]);
+			first = FALSE;
+		}
+		cc = cc >> 1;
+	}
+	logprintf("> iChannelNames=%u", cl->iChannelNames);
+}
+#endif
+
+Static struct usb_audio_cluster
+uaudio_get_cluster(int id, const struct io_terminal *iot)
+{
+	struct usb_audio_cluster r;
+	const usb_descriptor_t *dp;
+	int i;
+
+	for (i = 0; i < 25; i++) { /* avoid infinite loops */
+		dp = iot[id].d.desc;
+		if (dp == 0)
+			goto bad;
+		switch (dp->bDescriptorSubtype) {
+		case UDESCSUB_AC_INPUT:
+			r.bNrChannels = iot[id].d.it->bNrChannels;
+			USETW(r.wChannelConfig, UGETW(iot[id].d.it->wChannelConfig));
+			r.iChannelNames = iot[id].d.it->iChannelNames;
+			return r;
+		case UDESCSUB_AC_OUTPUT:
+			id = iot[id].d.ot->bSourceId;
+			break;
+		case UDESCSUB_AC_MIXER:
+			r = *(const struct usb_audio_cluster *)
+				&iot[id].d.mu->baSourceId[iot[id].d.mu->bNrInPins];
+			return r;
+		case UDESCSUB_AC_SELECTOR:
+			/* XXX This is not really right */
+			id = iot[id].d.su->baSourceId[0];
+			break;
+		case UDESCSUB_AC_FEATURE:
+			id = iot[id].d.fu->bSourceId;
+			break;
+		case UDESCSUB_AC_PROCESSING:
+			r = *(const struct usb_audio_cluster *)
+				&iot[id].d.pu->baSourceId[iot[id].d.pu->bNrInPins];
+			return r;
+		case UDESCSUB_AC_EXTENSION:
+			r = *(const struct usb_audio_cluster *)
+				&iot[id].d.eu->baSourceId[iot[id].d.eu->bNrInPins];
+			return r;
+		default:
+			goto bad;
+		}
+	}
+ bad:
+	printf("uaudio_get_cluster: bad data\n");
+	memset(&r, 0, sizeof r);
+	return r;
+
+}
+
+Static void
+uaudio_add_input(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
+{
+#ifdef USB_DEBUG
+	const struct usb_audio_input_terminal *d = iot[id].d.it;
+
+	DPRINTFN(2,("uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x "
+		    "bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d "
+		    "iChannelNames=%d iTerminal=%d\n",
+		    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,
+		    d->bNrChannels, UGETW(d->wChannelConfig),
+		    d->iChannelNames, d->iTerminal));
+#endif
+}
+
+Static void
+uaudio_add_output(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
+{
+#ifdef USB_DEBUG
+	const struct usb_audio_output_terminal *d;
+
+	d = iot[id].d.ot;
+	DPRINTFN(2,("uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x "
+		    "bAssocTerminal=%d bSourceId=%d iTerminal=%d\n",
+		    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,
+		    d->bSourceId, d->iTerminal));
+#endif
+}
+
+Static void
+uaudio_add_mixer(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
+{
+	const struct usb_audio_mixer_unit *d = iot[id].d.mu;
+	const struct usb_audio_mixer_unit_1 *d1;
+	int c, chs, ichs, ochs, i, o, bno, p, mo, mc, k;
+	const uByte *bm;
+	struct mixerctl mix;
+
+	DPRINTFN(2,("uaudio_add_mixer: bUnitId=%d bNrInPins=%d\n",
+		    d->bUnitId, d->bNrInPins));
+
+	/* Compute the number of input channels */
+	ichs = 0;
+	for (i = 0; i < d->bNrInPins; i++)
+		ichs += uaudio_get_cluster(d->baSourceId[i], iot).bNrChannels;
+
+	/* and the number of output channels */
+	d1 = (const struct usb_audio_mixer_unit_1 *)&d->baSourceId[d->bNrInPins];
+	ochs = d1->bNrChannels;
+	DPRINTFN(2,("uaudio_add_mixer: ichs=%d ochs=%d\n", ichs, ochs));
+
+	bm = d1->bmControls;
+	mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
+	uaudio_determine_class(&iot[id], &mix);
+	mix.type = MIX_SIGNED_16;
+#if !defined(__FreeBSD__)	/* XXXXX */
+	mix.ctlunit = AudioNvolume;
+#endif
+
+#define BIT(bno) ((bm[bno / 8] >> (7 - bno % 8)) & 1)
+	for (p = i = 0; i < d->bNrInPins; i++) {
+		chs = uaudio_get_cluster(d->baSourceId[i], iot).bNrChannels;
+		mc = 0;
+		for (c = 0; c < chs; c++) {
+			mo = 0;
+			for (o = 0; o < ochs; o++) {
+				bno = (p + c) * ochs + o;
+				if (BIT(bno))
+					mo++;
+			}
+			if (mo == 1)
+				mc++;
+		}
+		if (mc == chs && chs <= MIX_MAX_CHAN) {
+			k = 0;
+			for (c = 0; c < chs; c++)
+				for (o = 0; o < ochs; o++) {
+					bno = (p + c) * ochs + o;
+					if (BIT(bno))
+						mix.wValue[k++] =
+							MAKE(p+c+1, o+1);
+				}
+#if !defined(__FreeBSD__)
+			snprintf(mix.ctlname, sizeof(mix.ctlname), "mix%d-%s",
+			    d->bUnitId, uaudio_id_name(sc, iot,
+			    d->baSourceId[i]));
+#endif
+			mix.nchan = chs;
+			uaudio_mixer_add_ctl(sc, &mix);
+		} else {
+			/* XXX */
+		}
+#undef BIT
+		p += chs;
+	}
+
+}
+
+Static void
+uaudio_add_selector(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
+{
+	const struct usb_audio_selector_unit *d;
+	struct mixerctl mix;
+#if !defined(__FreeBSD__)
+	int i, wp;
+#else
+	int i;
+	struct mixerctl dummy;
+#endif
+
+	d = iot[id].d.su;
+	DPRINTFN(2,("uaudio_add_selector: bUnitId=%d bNrInPins=%d\n",
+		    d->bUnitId, d->bNrInPins));
+	mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
+	mix.wValue[0] = MAKE(0, 0);
+	uaudio_determine_class(&iot[id], &mix);
+	mix.nchan = 1;
+	mix.type = MIX_SELECTOR;
+#if defined(__FreeBSD__)
+	mix.ctl = SOUND_MIXER_NRDEVICES;	/* XXXXX */
+	mix.minval = 1;
+	mix.maxval = d->bNrInPins;
+	mix.mul = mix.maxval - mix.minval;
+	for (i = 0; i < MAX_SELECTOR_INPUT_PIN; i++) {
+		mix.slctrtype[i] = SOUND_MIXER_NRDEVICES;
+	}
+	for (i = mix.minval; i <= mix.maxval; i++) {
+		mix.slctrtype[i - 1] = uaudio_feature_name(&iot[d->baSourceId[i - 1]], &dummy);
+	}
+#else
+	mix.ctlunit = "";
+	mix.minval = 1;
+	mix.maxval = d->bNrInPins;
+	mix.mul = mix.maxval - mix.minval;
+	wp = snprintf(mix.ctlname, MAX_AUDIO_DEV_LEN, "sel%d-", d->bUnitId);
+	for (i = 1; i <= d->bNrInPins; i++) {
+		wp += snprintf(mix.ctlname + wp, MAX_AUDIO_DEV_LEN - wp,
+			       "i%d", d->baSourceId[i - 1]);
+		if (wp > MAX_AUDIO_DEV_LEN - 1)
+			break;
+	}
+#endif
+	uaudio_mixer_add_ctl(sc, &mix);
+}
+
+#ifdef USB_DEBUG
+Static const char *
+uaudio_get_terminal_name(int terminal_type)
+{
+	static char buf[100];
+
+	switch (terminal_type) {
+	/* USB terminal types */
+	case UAT_UNDEFINED:	return "UAT_UNDEFINED";
+	case UAT_STREAM:	return "UAT_STREAM";
+	case UAT_VENDOR:	return "UAT_VENDOR";
+	/* input terminal types */
+	case UATI_UNDEFINED:	return "UATI_UNDEFINED";
+	case UATI_MICROPHONE:	return "UATI_MICROPHONE";
+	case UATI_DESKMICROPHONE:	return "UATI_DESKMICROPHONE";
+	case UATI_PERSONALMICROPHONE:	return "UATI_PERSONALMICROPHONE";
+	case UATI_OMNIMICROPHONE:	return "UATI_OMNIMICROPHONE";
+	case UATI_MICROPHONEARRAY:	return "UATI_MICROPHONEARRAY";
+	case UATI_PROCMICROPHONEARR:	return "UATI_PROCMICROPHONEARR";
+	/* output terminal types */
+	case UATO_UNDEFINED:	return "UATO_UNDEFINED";
+	case UATO_SPEAKER:	return "UATO_SPEAKER";
+	case UATO_HEADPHONES:	return "UATO_HEADPHONES";
+	case UATO_DISPLAYAUDIO:	return "UATO_DISPLAYAUDIO";
+	case UATO_DESKTOPSPEAKER:	return "UATO_DESKTOPSPEAKER";
+	case UATO_ROOMSPEAKER:	return "UATO_ROOMSPEAKER";
+	case UATO_COMMSPEAKER:	return "UATO_COMMSPEAKER";
+	case UATO_SUBWOOFER:	return "UATO_SUBWOOFER";
+	/* bidir terminal types */
+	case UATB_UNDEFINED:	return "UATB_UNDEFINED";
+	case UATB_HANDSET:	return "UATB_HANDSET";
+	case UATB_HEADSET:	return "UATB_HEADSET";
+	case UATB_SPEAKERPHONE:	return "UATB_SPEAKERPHONE";
+	case UATB_SPEAKERPHONEESUP:	return "UATB_SPEAKERPHONEESUP";
+	case UATB_SPEAKERPHONEECANC:	return "UATB_SPEAKERPHONEECANC";
+	/* telephony terminal types */
+	case UATT_UNDEFINED:	return "UATT_UNDEFINED";
+	case UATT_PHONELINE:	return "UATT_PHONELINE";
+	case UATT_TELEPHONE:	return "UATT_TELEPHONE";
+	case UATT_DOWNLINEPHONE:	return "UATT_DOWNLINEPHONE";
+	/* external terminal types */
+	case UATE_UNDEFINED:	return "UATE_UNDEFINED";
+	case UATE_ANALOGCONN:	return "UATE_ANALOGCONN";
+	case UATE_LINECONN:	return "UATE_LINECONN";
+	case UATE_LEGACYCONN:	return "UATE_LEGACYCONN";
+	case UATE_DIGITALAUIFC:	return "UATE_DIGITALAUIFC";
+	case UATE_SPDIF:	return "UATE_SPDIF";
+	case UATE_1394DA:	return "UATE_1394DA";
+	case UATE_1394DV:	return "UATE_1394DV";
+	/* embedded function terminal types */
+	case UATF_UNDEFINED:	return "UATF_UNDEFINED";
+	case UATF_CALIBNOISE:	return "UATF_CALIBNOISE";
+	case UATF_EQUNOISE:	return "UATF_EQUNOISE";
+	case UATF_CDPLAYER:	return "UATF_CDPLAYER";
+	case UATF_DAT:	return "UATF_DAT";
+	case UATF_DCC:	return "UATF_DCC";
+	case UATF_MINIDISK:	return "UATF_MINIDISK";
+	case UATF_ANALOGTAPE:	return "UATF_ANALOGTAPE";
+	case UATF_PHONOGRAPH:	return "UATF_PHONOGRAPH";
+	case UATF_VCRAUDIO:	return "UATF_VCRAUDIO";
+	case UATF_VIDEODISCAUDIO:	return "UATF_VIDEODISCAUDIO";
+	case UATF_DVDAUDIO:	return "UATF_DVDAUDIO";
+	case UATF_TVTUNERAUDIO:	return "UATF_TVTUNERAUDIO";
+	case UATF_SATELLITE:	return "UATF_SATELLITE";
+	case UATF_CABLETUNER:	return "UATF_CABLETUNER";
+	case UATF_DSS:	return "UATF_DSS";
+	case UATF_RADIORECV:	return "UATF_RADIORECV";
+	case UATF_RADIOXMIT:	return "UATF_RADIOXMIT";
+	case UATF_MULTITRACK:	return "UATF_MULTITRACK";
+	case UATF_SYNTHESIZER:	return "UATF_SYNTHESIZER";
+	default:
+		snprintf(buf, sizeof(buf), "unknown type (0x%.4x)", terminal_type);
+		return buf;
+	}
+}
+#endif
+
+Static int
+uaudio_determine_class(const struct io_terminal *iot, struct mixerctl *mix)
+{
+	int terminal_type;
+
+	if (iot == NULL || iot->output == NULL) {
+		mix->class = UAC_OUTPUT;
+		return 0;
+	}
+	terminal_type = 0;
+	if (iot->output->size == 1)
+		terminal_type = iot->output->terminals[0];
+	/*
+	 * If the only output terminal is USB,
+	 * the class is UAC_RECORD.
+	 */
+	if ((terminal_type & 0xff00) == (UAT_UNDEFINED & 0xff00)) {
+		mix->class = UAC_RECORD;
+		if (iot->inputs_size == 1
+		    && iot->inputs[0] != NULL
+		    && iot->inputs[0]->size == 1)
+			return iot->inputs[0]->terminals[0];
+		else
+			return 0;
+	}
+	/*
+	 * If the ultimate destination of the unit is just one output
+	 * terminal and the unit is connected to the output terminal
+	 * directly, the class is UAC_OUTPUT.
+	 */
+	if (terminal_type != 0 && iot->direct) {
+		mix->class = UAC_OUTPUT;
+		return terminal_type;
+	}
+	/*
+	 * If the unit is connected to just one input terminal,
+	 * the class is UAC_INPUT.
+	 */
+	if (iot->inputs_size == 1 && iot->inputs[0] != NULL
+	    && iot->inputs[0]->size == 1) {
+		mix->class = UAC_INPUT;
+		return iot->inputs[0]->terminals[0];
+	}
+	/*
+	 * Otherwise, the class is UAC_OUTPUT.
+	 */
+	mix->class = UAC_OUTPUT;
+	return terminal_type;
+}
+
+#if defined(__FreeBSD__)
+const int 
+uaudio_feature_name(const struct io_terminal *iot, struct mixerctl *mix)
+{
+	int terminal_type;
+
+	terminal_type = uaudio_determine_class(iot, mix);
+	if (mix->class == UAC_RECORD && terminal_type == 0)
+		return SOUND_MIXER_IMIX;
+	DPRINTF(("%s: terminal_type=%s\n", __func__,
+		 uaudio_get_terminal_name(terminal_type)));
+	switch (terminal_type) {
+	case UAT_STREAM:
+		return SOUND_MIXER_PCM;
+
+	case UATI_MICROPHONE:
+	case UATI_DESKMICROPHONE:
+	case UATI_PERSONALMICROPHONE:
+	case UATI_OMNIMICROPHONE:
+	case UATI_MICROPHONEARRAY:
+	case UATI_PROCMICROPHONEARR:
+		return SOUND_MIXER_MIC;
+
+	case UATO_SPEAKER:
+	case UATO_DESKTOPSPEAKER:
+	case UATO_ROOMSPEAKER:
+	case UATO_COMMSPEAKER:
+		return SOUND_MIXER_SPEAKER;
+
+	case UATE_ANALOGCONN:
+	case UATE_LINECONN:
+	case UATE_LEGACYCONN:
+		return SOUND_MIXER_LINE;
+
+	case UATE_DIGITALAUIFC:
+	case UATE_SPDIF:
+	case UATE_1394DA:
+	case UATE_1394DV:
+		return SOUND_MIXER_ALTPCM;
+
+	case UATF_CDPLAYER:
+		return SOUND_MIXER_CD;
+
+	case UATF_SYNTHESIZER:
+		return SOUND_MIXER_SYNTH;
+
+	case UATF_VIDEODISCAUDIO:
+	case UATF_DVDAUDIO:
+	case UATF_TVTUNERAUDIO:
+		return SOUND_MIXER_VIDEO;
+
+/* telephony terminal types */
+	case UATT_UNDEFINED:
+	case UATT_PHONELINE:
+	case UATT_TELEPHONE:
+	case UATT_DOWNLINEPHONE:
+		return SOUND_MIXER_PHONEIN;
+/*		return SOUND_MIXER_PHONEOUT;*/
+
+	case UATF_RADIORECV:
+	case UATF_RADIOXMIT:
+		return SOUND_MIXER_RADIO;
+
+	case UAT_UNDEFINED:
+	case UAT_VENDOR:
+	case UATI_UNDEFINED:
+/* output terminal types */
+	case UATO_UNDEFINED:
+	case UATO_DISPLAYAUDIO:
+	case UATO_SUBWOOFER:
+	case UATO_HEADPHONES:
+/* bidir terminal types */
+	case UATB_UNDEFINED:
+	case UATB_HANDSET:
+	case UATB_HEADSET:
+	case UATB_SPEAKERPHONE:
+	case UATB_SPEAKERPHONEESUP:
+	case UATB_SPEAKERPHONEECANC:
+/* external terminal types */
+	case UATE_UNDEFINED:
+/* embedded function terminal types */
+	case UATF_UNDEFINED:
+	case UATF_CALIBNOISE:
+	case UATF_EQUNOISE:
+	case UATF_DAT:
+	case UATF_DCC:
+	case UATF_MINIDISK:
+	case UATF_ANALOGTAPE:
+	case UATF_PHONOGRAPH:
+	case UATF_VCRAUDIO:
+	case UATF_SATELLITE:
+	case UATF_CABLETUNER:
+	case UATF_DSS:
+	case UATF_MULTITRACK:
+	case 0xffff:
+	default:
+		DPRINTF(("%s: 'master' for 0x%.4x\n", __func__, terminal_type));
+		return SOUND_MIXER_VOLUME;
+	}
+	return SOUND_MIXER_VOLUME;
+}
+#else
+Static const char *
+uaudio_feature_name(const struct io_terminal *iot, struct mixerctl *mix)
+{
+	int terminal_type;
+
+	terminal_type = uaudio_determine_class(iot, mix);
+	if (mix->class == UAC_RECORD && terminal_type == 0)
+		return AudioNmixerout;
+	DPRINTF(("%s: terminal_type=%s\n", __func__,
+		 uaudio_get_terminal_name(terminal_type)));
+	switch (terminal_type) {
+	case UAT_STREAM:
+		return AudioNdac;
+
+	case UATI_MICROPHONE:
+	case UATI_DESKMICROPHONE:
+	case UATI_PERSONALMICROPHONE:
+	case UATI_OMNIMICROPHONE:
+	case UATI_MICROPHONEARRAY:
+	case UATI_PROCMICROPHONEARR:
+		return AudioNmicrophone;
+
+	case UATO_SPEAKER:
+	case UATO_DESKTOPSPEAKER:
+	case UATO_ROOMSPEAKER:
+	case UATO_COMMSPEAKER:
+		return AudioNspeaker;
+
+	case UATO_HEADPHONES:
+		return AudioNheadphone;
+
+	case UATO_SUBWOOFER:
+		return AudioNlfe;
+
+	/* telephony terminal types */
+	case UATT_UNDEFINED:
+	case UATT_PHONELINE:
+	case UATT_TELEPHONE:
+	case UATT_DOWNLINEPHONE:
+		return "phone";
+
+	case UATE_ANALOGCONN:
+	case UATE_LINECONN:
+	case UATE_LEGACYCONN:
+		return AudioNline;
+
+	case UATE_DIGITALAUIFC:
+	case UATE_SPDIF:
+	case UATE_1394DA:
+	case UATE_1394DV:
+		return AudioNaux;
+
+	case UATF_CDPLAYER:
+		return AudioNcd;
+
+	case UATF_SYNTHESIZER:
+		return AudioNfmsynth;
+
+	case UATF_VIDEODISCAUDIO:
+	case UATF_DVDAUDIO:
+	case UATF_TVTUNERAUDIO:
+		return AudioNvideo;
+
+	case UAT_UNDEFINED:
+	case UAT_VENDOR:
+	case UATI_UNDEFINED:
+/* output terminal types */
+	case UATO_UNDEFINED:
+	case UATO_DISPLAYAUDIO:
+/* bidir terminal types */
+	case UATB_UNDEFINED:
+	case UATB_HANDSET:
+	case UATB_HEADSET:
+	case UATB_SPEAKERPHONE:
+	case UATB_SPEAKERPHONEESUP:
+	case UATB_SPEAKERPHONEECANC:
+/* external terminal types */
+	case UATE_UNDEFINED:
+/* embedded function terminal types */
+	case UATF_UNDEFINED:
+	case UATF_CALIBNOISE:
+	case UATF_EQUNOISE:
+	case UATF_DAT:
+	case UATF_DCC:
+	case UATF_MINIDISK:
+	case UATF_ANALOGTAPE:
+	case UATF_PHONOGRAPH:
+	case UATF_VCRAUDIO:
+	case UATF_SATELLITE:
+	case UATF_CABLETUNER:
+	case UATF_DSS:
+	case UATF_RADIORECV:
+	case UATF_RADIOXMIT:
+	case UATF_MULTITRACK:
+	case 0xffff:
+	default:
+		DPRINTF(("%s: 'master' for 0x%.4x\n", __func__, terminal_type));
+		return AudioNmaster;
+	}
+	return AudioNmaster;
+}
+#endif
+
+Static void
+uaudio_add_feature(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
+{
+	const struct usb_audio_feature_unit *d;
+	const uByte *ctls;
+	int ctlsize;
+	int nchan;
+	u_int fumask, mmask, cmask;
+	struct mixerctl mix;
+	int chan, ctl, i, unit;
+#if defined(__FreeBSD__)
+	int mixernumber;
+#else
+	const char *mixername;
+#endif
+
+#define GET(i) (ctls[(i)*ctlsize] | \
+		(ctlsize > 1 ? ctls[(i)*ctlsize+1] << 8 : 0))
+	d = iot[id].d.fu;
+	ctls = d->bmaControls;
+	ctlsize = d->bControlSize;
+	nchan = (d->bLength - 7) / ctlsize;
+	mmask = GET(0);
+	/* Figure out what we can control */
+	for (cmask = 0, chan = 1; chan < nchan; chan++) {
+		DPRINTFN(9,("uaudio_add_feature: chan=%d mask=%x\n",
+			    chan, GET(chan)));
+		cmask |= GET(chan);
+	}
+
+#if !defined(__FreeBSD__)
+	DPRINTFN(1,("uaudio_add_feature: bUnitId=%d, "
+		    "%d channels, mmask=0x%04x, cmask=0x%04x\n",
+		    d->bUnitId, nchan, mmask, cmask));
+#endif
+
+	if (nchan > MIX_MAX_CHAN)
+		nchan = MIX_MAX_CHAN;
+	unit = d->bUnitId;
+	mix.wIndex = MAKE(unit, sc->sc_ac_iface);
+	for (ctl = MUTE_CONTROL; ctl < LOUDNESS_CONTROL; ctl++) {
+		fumask = FU_MASK(ctl);
+		DPRINTFN(4,("uaudio_add_feature: ctl=%d fumask=0x%04x\n",
+			    ctl, fumask));
+		if (mmask & fumask) {
+			mix.nchan = 1;
+			mix.wValue[0] = MAKE(ctl, 0);
+		} else if (cmask & fumask) {
+			mix.nchan = nchan - 1;
+			for (i = 1; i < nchan; i++) {
+				if (GET(i) & fumask)
+					mix.wValue[i-1] = MAKE(ctl, i);
+				else
+					mix.wValue[i-1] = -1;
+			}
+		} else {
+			continue;
+		}
+#undef GET
+
+#if defined(__FreeBSD__)
+		mixernumber = uaudio_feature_name(&iot[id], &mix);
+#else
+		mixername = uaudio_feature_name(&iot[id], &mix);
+#endif
+		switch (ctl) {
+		case MUTE_CONTROL:
+			mix.type = MIX_ON_OFF;
+#if defined(__FreeBSD__)
+			mix.ctl = SOUND_MIXER_NRDEVICES;
+#else
+			mix.ctlunit = "";
+			snprintf(mix.ctlname, sizeof(mix.ctlname),
+				 "%s.%s", mixername, AudioNmute);
+#endif
+			break;
+		case VOLUME_CONTROL:
+			mix.type = MIX_SIGNED_16;
+#if defined(__FreeBSD__)
+			mix.ctl = mixernumber;
+#else
+			mix.ctlunit = AudioNvolume;
+			strlcpy(mix.ctlname, mixername, sizeof(mix.ctlname));
+#endif
+			break;
+		case BASS_CONTROL:
+			mix.type = MIX_SIGNED_8;
+#if defined(__FreeBSD__)
+			mix.ctl = SOUND_MIXER_BASS;
+#else
+			mix.ctlunit = AudioNbass;
+			snprintf(mix.ctlname, sizeof(mix.ctlname),
+				 "%s.%s", mixername, AudioNbass);
+#endif
+			break;
+		case MID_CONTROL:
+			mix.type = MIX_SIGNED_8;
+#if defined(__FreeBSD__)
+			mix.ctl = SOUND_MIXER_NRDEVICES;	/* XXXXX */
+#else
+			mix.ctlunit = AudioNmid;
+			snprintf(mix.ctlname, sizeof(mix.ctlname),
+				 "%s.%s", mixername, AudioNmid);
+#endif
+			break;
+		case TREBLE_CONTROL:
+			mix.type = MIX_SIGNED_8;
+#if defined(__FreeBSD__)
+			mix.ctl = SOUND_MIXER_TREBLE;
+#else
+			mix.ctlunit = AudioNtreble;
+			snprintf(mix.ctlname, sizeof(mix.ctlname),
+				 "%s.%s", mixername, AudioNtreble);
+#endif
+			break;
+		case GRAPHIC_EQUALIZER_CONTROL:
+			continue; /* XXX don't add anything */
+			break;
+		case AGC_CONTROL:
+			mix.type = MIX_ON_OFF;
+#if defined(__FreeBSD__)
+			mix.ctl = SOUND_MIXER_NRDEVICES;	/* XXXXX */
+#else
+			mix.ctlunit = "";
+			snprintf(mix.ctlname, sizeof(mix.ctlname), "%s.%s",
+				 mixername, AudioNagc);
+#endif
+			break;
+		case DELAY_CONTROL:
+			mix.type = MIX_UNSIGNED_16;
+#if defined(__FreeBSD__)
+			mix.ctl = SOUND_MIXER_NRDEVICES;	/* XXXXX */
+#else
+			mix.ctlunit = "4 ms";
+			snprintf(mix.ctlname, sizeof(mix.ctlname),
+				 "%s.%s", mixername, AudioNdelay);
+#endif
+			break;
+		case BASS_BOOST_CONTROL:
+			mix.type = MIX_ON_OFF;
+#if defined(__FreeBSD__)
+			mix.ctl = SOUND_MIXER_NRDEVICES;	/* XXXXX */
+#else
+			mix.ctlunit = "";
+			snprintf(mix.ctlname, sizeof(mix.ctlname),
+				 "%s.%s", mixername, AudioNbassboost);
+#endif
+			break;
+		case LOUDNESS_CONTROL:
+			mix.type = MIX_ON_OFF;
+#if defined(__FreeBSD__)
+			mix.ctl = SOUND_MIXER_LOUD;	/* Is this correct ? */
+#else
+			mix.ctlunit = "";
+			snprintf(mix.ctlname, sizeof(mix.ctlname),
+				 "%s.%s", mixername, AudioNloudness);
+#endif
+			break;
+		}
+		uaudio_mixer_add_ctl(sc, &mix);
+	}
+}
+
+Static void
+uaudio_add_processing_updown(struct uaudio_softc *sc,
+			     const struct io_terminal *iot, int id)
+{
+	const struct usb_audio_processing_unit *d;
+	const struct usb_audio_processing_unit_1 *d1;
+	const struct usb_audio_processing_unit_updown *ud;
+	struct mixerctl mix;
+	int i;
+
+	d = iot[id].d.pu;
+	d1 = (const struct usb_audio_processing_unit_1 *)
+		&d->baSourceId[d->bNrInPins];
+	ud = (const struct usb_audio_processing_unit_updown *)
+		&d1->bmControls[d1->bControlSize];
+	DPRINTFN(2,("uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\n",
+		    d->bUnitId, ud->bNrModes));
+
+	if (!(d1->bmControls[0] & UA_PROC_MASK(UD_MODE_SELECT_CONTROL))) {
+		DPRINTF(("uaudio_add_processing_updown: no mode select\n"));
+		return;
+	}
+
+	mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
+	mix.nchan = 1;
+	mix.wValue[0] = MAKE(UD_MODE_SELECT_CONTROL, 0);
+	uaudio_determine_class(&iot[id], &mix);
+	mix.type = MIX_ON_OFF;	/* XXX */
+#if !defined(__FreeBSD__)
+	mix.ctlunit = "";
+	snprintf(mix.ctlname, sizeof(mix.ctlname), "pro%d-mode", d->bUnitId);
+#endif
+
+	for (i = 0; i < ud->bNrModes; i++) {
+		DPRINTFN(2,("uaudio_add_processing_updown: i=%d bm=0x%x\n",
+			    i, UGETW(ud->waModes[i])));
+		/* XXX */
+	}
+	uaudio_mixer_add_ctl(sc, &mix);
+}
+
+Static void
+uaudio_add_processing(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
+{
+	const struct usb_audio_processing_unit *d;
+	const struct usb_audio_processing_unit_1 *d1;
+	int ptype;
+	struct mixerctl mix;
+
+	d = iot[id].d.pu;
+	d1 = (const struct usb_audio_processing_unit_1 *)
+		&d->baSourceId[d->bNrInPins];
+	ptype = UGETW(d->wProcessType);
+	DPRINTFN(2,("uaudio_add_processing: wProcessType=%d bUnitId=%d "
+		    "bNrInPins=%d\n", ptype, d->bUnitId, d->bNrInPins));
+
+	if (d1->bmControls[0] & UA_PROC_ENABLE_MASK) {
+		mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
+		mix.nchan = 1;
+		mix.wValue[0] = MAKE(XX_ENABLE_CONTROL, 0);
+		uaudio_determine_class(&iot[id], &mix);
+		mix.type = MIX_ON_OFF;
+#if !defined(__FreeBSD__)
+		mix.ctlunit = "";
+		snprintf(mix.ctlname, sizeof(mix.ctlname), "pro%d.%d-enable",
+		    d->bUnitId, ptype);
+#endif
+		uaudio_mixer_add_ctl(sc, &mix);
+	}
+
+	switch(ptype) {
+	case UPDOWNMIX_PROCESS:
+		uaudio_add_processing_updown(sc, iot, id);
+		break;
+	case DOLBY_PROLOGIC_PROCESS:
+	case P3D_STEREO_EXTENDER_PROCESS:
+	case REVERBATION_PROCESS:
+	case CHORUS_PROCESS:
+	case DYN_RANGE_COMP_PROCESS:
+	default:
+#ifdef USB_DEBUG
+		printf("uaudio_add_processing: unit %d, type=%d not impl.\n",
+		       d->bUnitId, ptype);
+#endif
+		break;
+	}
+}
+
+Static void
+uaudio_add_extension(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
+{
+	const struct usb_audio_extension_unit *d;
+	const struct usb_audio_extension_unit_1 *d1;
+	struct mixerctl mix;
+
+	d = iot[id].d.eu;
+	d1 = (const struct usb_audio_extension_unit_1 *)
+		&d->baSourceId[d->bNrInPins];
+	DPRINTFN(2,("uaudio_add_extension: bUnitId=%d bNrInPins=%d\n",
+		    d->bUnitId, d->bNrInPins));
+
+	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_NO_XU)
+		return;
+
+	if (d1->bmControls[0] & UA_EXT_ENABLE_MASK) {
+		mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
+		mix.nchan = 1;
+		mix.wValue[0] = MAKE(UA_EXT_ENABLE, 0);
+		uaudio_determine_class(&iot[id], &mix);
+		mix.type = MIX_ON_OFF;
+#if !defined(__FreeBSD__)
+		mix.ctlunit = "";
+		snprintf(mix.ctlname, sizeof(mix.ctlname), "ext%d-enable",
+		    d->bUnitId);
+#endif
+		uaudio_mixer_add_ctl(sc, &mix);
+	}
+}
+
+Static struct terminal_list*
+uaudio_merge_terminal_list(const struct io_terminal *iot)
+{
+	struct terminal_list *tml;
+	uint16_t *ptm;
+	int i, len;
+
+	len = 0;
+	if (iot->inputs == NULL)
+		return NULL;
+	for (i = 0; i < iot->inputs_size; i++) {
+		if (iot->inputs[i] != NULL)
+			len += iot->inputs[i]->size;
+	}
+	tml = malloc(TERMINAL_LIST_SIZE(len), M_TEMP, M_NOWAIT);
+	if (tml == NULL) {
+		printf("uaudio_merge_terminal_list: no memory\n");
+		return NULL;
+	}
+	tml->size = 0;
+	ptm = tml->terminals;
+	for (i = 0; i < iot->inputs_size; i++) {
+		if (iot->inputs[i] == NULL)
+			continue;
+		if (iot->inputs[i]->size > len)
+			break;
+		memcpy(ptm, iot->inputs[i]->terminals,
+		       iot->inputs[i]->size * sizeof(uint16_t));
+		tml->size += iot->inputs[i]->size;
+		ptm += iot->inputs[i]->size;
+		len -= iot->inputs[i]->size;
+	}
+	return tml;
+}
+
+Static struct terminal_list *
+uaudio_io_terminaltype(int outtype, struct io_terminal *iot, int id)
+{
+	struct terminal_list *tml;
+	struct io_terminal *it;
+	int src_id, i;
+
+	it = &iot[id];
+	if (it->output != NULL) {
+		/* already has outtype? */
+		for (i = 0; i < it->output->size; i++)
+			if (it->output->terminals[i] == outtype)
+				return uaudio_merge_terminal_list(it);
+		tml = malloc(TERMINAL_LIST_SIZE(it->output->size + 1),
+			     M_TEMP, M_NOWAIT);
+		if (tml == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return uaudio_merge_terminal_list(it);
+		}
+		memcpy(tml, it->output, TERMINAL_LIST_SIZE(it->output->size));
+		tml->terminals[it->output->size] = outtype;
+		tml->size++;
+		free(it->output, M_TEMP);
+		it->output = tml;
+		if (it->inputs != NULL) {
+			for (i = 0; i < it->inputs_size; i++)
+				if (it->inputs[i] != NULL)
+					free(it->inputs[i], M_TEMP);
+			free(it->inputs, M_TEMP);
+		}
+		it->inputs_size = 0;
+		it->inputs = NULL;
+	} else {		/* end `iot[id] != NULL' */
+		it->inputs_size = 0;
+		it->inputs = NULL;
+		it->output = malloc(TERMINAL_LIST_SIZE(1), M_TEMP, M_NOWAIT);
+		if (it->output == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return NULL;
+		}
+		it->output->terminals[0] = outtype;
+		it->output->size = 1;
+		it->direct = FALSE;
+	}
+
+	switch (it->d.desc->bDescriptorSubtype) {
+	case UDESCSUB_AC_INPUT:
+		it->inputs = malloc(sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
+		if (it->inputs == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return NULL;
+		}
+		tml = malloc(TERMINAL_LIST_SIZE(1), M_TEMP, M_NOWAIT);
+		if (tml == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			free(it->inputs, M_TEMP);
+			it->inputs = NULL;
+			return NULL;
+		}
+		it->inputs[0] = tml;
+		tml->terminals[0] = UGETW(it->d.it->wTerminalType);
+		tml->size = 1;
+		it->inputs_size = 1;
+		return uaudio_merge_terminal_list(it);
+	case UDESCSUB_AC_FEATURE:
+		src_id = it->d.fu->bSourceId;
+		it->inputs = malloc(sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
+		if (it->inputs == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return uaudio_io_terminaltype(outtype, iot, src_id);
+		}
+		it->inputs[0] = uaudio_io_terminaltype(outtype, iot, src_id);
+		it->inputs_size = 1;
+		return uaudio_merge_terminal_list(it);
+	case UDESCSUB_AC_OUTPUT:
+		it->inputs = malloc(sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
+		if (it->inputs == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return NULL;
+		}
+		src_id = it->d.ot->bSourceId;
+		it->inputs[0] = uaudio_io_terminaltype(outtype, iot, src_id);
+		it->inputs_size = 1;
+		iot[src_id].direct = TRUE;
+		return NULL;
+	case UDESCSUB_AC_MIXER:
+		it->inputs_size = 0;
+		it->inputs = malloc(sizeof(struct terminal_list *)
+				    * it->d.mu->bNrInPins, M_TEMP, M_NOWAIT);
+		if (it->inputs == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return NULL;
+		}
+		for (i = 0; i < it->d.mu->bNrInPins; i++) {
+			src_id = it->d.mu->baSourceId[i];
+			it->inputs[i] = uaudio_io_terminaltype(outtype, iot,
+							       src_id);
+			it->inputs_size++;
+		}
+		return uaudio_merge_terminal_list(it);
+	case UDESCSUB_AC_SELECTOR:
+		it->inputs_size = 0;
+		it->inputs = malloc(sizeof(struct terminal_list *)
+				    * it->d.su->bNrInPins, M_TEMP, M_NOWAIT);
+		if (it->inputs == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return NULL;
+		}
+		for (i = 0; i < it->d.su->bNrInPins; i++) {
+			src_id = it->d.su->baSourceId[i];
+			it->inputs[i] = uaudio_io_terminaltype(outtype, iot,
+							       src_id);
+			it->inputs_size++;
+		}
+		return uaudio_merge_terminal_list(it);
+	case UDESCSUB_AC_PROCESSING:
+		it->inputs_size = 0;
+		it->inputs = malloc(sizeof(struct terminal_list *)
+				    * it->d.pu->bNrInPins, M_TEMP, M_NOWAIT);
+		if (it->inputs == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return NULL;
+		}
+		for (i = 0; i < it->d.pu->bNrInPins; i++) {
+			src_id = it->d.pu->baSourceId[i];
+			it->inputs[i] = uaudio_io_terminaltype(outtype, iot,
+							       src_id);
+			it->inputs_size++;
+		}
+		return uaudio_merge_terminal_list(it);
+	case UDESCSUB_AC_EXTENSION:
+		it->inputs_size = 0;
+		it->inputs = malloc(sizeof(struct terminal_list *)
+				    * it->d.eu->bNrInPins, M_TEMP, M_NOWAIT);
+		if (it->inputs == NULL) {
+			printf("uaudio_io_terminaltype: no memory\n");
+			return NULL;
+		}
+		for (i = 0; i < it->d.eu->bNrInPins; i++) {
+			src_id = it->d.eu->baSourceId[i];
+			it->inputs[i] = uaudio_io_terminaltype(outtype, iot,
+							       src_id);
+			it->inputs_size++;
+		}
+		return uaudio_merge_terminal_list(it);
+	case UDESCSUB_AC_HEADER:
+	default:
+		return NULL;
+	}
+}
+
+Static usbd_status
+uaudio_identify(struct uaudio_softc *sc, const usb_config_descriptor_t *cdesc)
+{
+	usbd_status err;
+
+	err = uaudio_identify_ac(sc, cdesc);
+	if (err)
+		return err;
+	return uaudio_identify_as(sc, cdesc);
+}
+
+Static void
+uaudio_add_alt(struct uaudio_softc *sc, const struct as_info *ai)
+{
+	size_t len;
+	struct as_info *nai;
+
+	len = sizeof(*ai) * (sc->sc_nalts + 1);
+	nai = malloc(len, M_USBDEV, M_NOWAIT);
+	if (nai == NULL) {
+		printf("uaudio_add_alt: no memory\n");
+		return;
+	}
+	/* Copy old data, if there was any */
+	if (sc->sc_nalts != 0) {
+		memcpy(nai, sc->sc_alts, sizeof(*ai) * (sc->sc_nalts));
+		free(sc->sc_alts, M_USBDEV);
+	}
+	sc->sc_alts = nai;
+	DPRINTFN(2,("uaudio_add_alt: adding alt=%d, enc=%d\n",
+		    ai->alt, ai->encoding));
+	sc->sc_alts[sc->sc_nalts++] = *ai;
+}
+
+Static usbd_status
+uaudio_process_as(struct uaudio_softc *sc, const char *buf, int *offsp,
+		  int size, const usb_interface_descriptor_t *id)
+#define offs (*offsp)
+{
+	const struct usb_audio_streaming_interface_descriptor *asid;
+	const struct usb_audio_streaming_type1_descriptor *asf1d;
+	const usb_endpoint_descriptor_audio_t *ed;
+	const usb_endpoint_descriptor_audio_t *epdesc1;
+	const struct usb_audio_streaming_endpoint_descriptor *sed;
+	int format, chan, prec, enc;
+	int dir, type, sync;
+	struct as_info ai;
+	const char *format_str;
+
+	asid = (const void *)(buf + offs);
+
+	if (asid->bDescriptorType != UDESC_CS_INTERFACE ||
+	    asid->bDescriptorSubtype != AS_GENERAL)
+		return USBD_INVAL;
+	DPRINTF(("uaudio_process_as: asid: bTerminakLink=%d wFormatTag=%d\n",
+		 asid->bTerminalLink, UGETW(asid->wFormatTag)));
+	offs += asid->bLength;
+	if (offs > size)
+		return USBD_INVAL;
+
+	asf1d = (const void *)(buf + offs);
+	if (asf1d->bDescriptorType != UDESC_CS_INTERFACE ||
+	    asf1d->bDescriptorSubtype != FORMAT_TYPE)
+		return USBD_INVAL;
+	offs += asf1d->bLength;
+	if (offs > size)
+		return USBD_INVAL;
+
+	if (asf1d->bFormatType != FORMAT_TYPE_I) {
+		printf("%s: ignored setting with type %d format\n",
+		       USBDEVNAME(sc->sc_dev), UGETW(asid->wFormatTag));
+		return USBD_NORMAL_COMPLETION;
+	}
+
+	ed = (const void *)(buf + offs);
+	if (ed->bDescriptorType != UDESC_ENDPOINT)
+		return USBD_INVAL;
+	DPRINTF(("uaudio_process_as: endpoint[0] bLength=%d bDescriptorType=%d "
+		 "bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d "
+		 "bInterval=%d bRefresh=%d bSynchAddress=%d\n",
+		 ed->bLength, ed->bDescriptorType, ed->bEndpointAddress,
+		 ed->bmAttributes, UGETW(ed->wMaxPacketSize),
+		 ed->bInterval, ed->bRefresh, ed->bSynchAddress));
+	offs += ed->bLength;
+	if (offs > size)
+		return USBD_INVAL;
+	if (UE_GET_XFERTYPE(ed->bmAttributes) != UE_ISOCHRONOUS)
+		return USBD_INVAL;
+
+	dir = UE_GET_DIR(ed->bEndpointAddress);
+	type = UE_GET_ISO_TYPE(ed->bmAttributes);
+	if ((usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_INP_ASYNC) &&
+	    dir == UE_DIR_IN && type == UE_ISO_ADAPT)
+		type = UE_ISO_ASYNC;
+
+	/* We can't handle endpoints that need a sync pipe yet. */
+	sync = FALSE;
+	if (dir == UE_DIR_IN && type == UE_ISO_ADAPT) {
+		sync = TRUE;
+#ifndef UAUDIO_MULTIPLE_ENDPOINTS
+		printf("%s: ignored input endpoint of type adaptive\n",
+		       USBDEVNAME(sc->sc_dev));
+		return USBD_NORMAL_COMPLETION;
+#endif
+	}
+	if (dir != UE_DIR_IN && type == UE_ISO_ASYNC) {
+		sync = TRUE;
+#ifndef UAUDIO_MULTIPLE_ENDPOINTS
+		printf("%s: ignored output endpoint of type async\n",
+		       USBDEVNAME(sc->sc_dev));
+		return USBD_NORMAL_COMPLETION;
+#endif
+	}
+
+	sed = (const void *)(buf + offs);
+	if (sed->bDescriptorType != UDESC_CS_ENDPOINT ||
+	    sed->bDescriptorSubtype != AS_GENERAL)
+		return USBD_INVAL;
+	DPRINTF((" streadming_endpoint: offset=%d bLength=%d\n", offs, sed->bLength));
+	offs += sed->bLength;
+	if (offs > size)
+		return USBD_INVAL;
+
+	if (sync && id->bNumEndpoints <= 1) {
+		printf("%s: a sync-pipe endpoint but no other endpoint\n",
+		       USBDEVNAME(sc->sc_dev));
+		return USBD_INVAL;
+	}
+	if (!sync && id->bNumEndpoints > 1) {
+		printf("%s: non sync-pipe endpoint but multiple endpoints\n",
+		       USBDEVNAME(sc->sc_dev));
+		return USBD_INVAL;
+	}
+	epdesc1 = NULL;
+	if (id->bNumEndpoints > 1) {
+		epdesc1 = (const void*)(buf + offs);
+		if (epdesc1->bDescriptorType != UDESC_ENDPOINT)
+			return USBD_INVAL;
+		DPRINTF(("uaudio_process_as: endpoint[1] bLength=%d "
+			 "bDescriptorType=%d bEndpointAddress=%d "
+			 "bmAttributes=0x%x wMaxPacketSize=%d bInterval=%d "
+			 "bRefresh=%d bSynchAddress=%d\n",
+			 epdesc1->bLength, epdesc1->bDescriptorType,
+			 epdesc1->bEndpointAddress, epdesc1->bmAttributes,
+			 UGETW(epdesc1->wMaxPacketSize), epdesc1->bInterval,
+			 epdesc1->bRefresh, epdesc1->bSynchAddress));
+		offs += epdesc1->bLength;
+		if (offs > size)
+			return USBD_INVAL;
+		if (epdesc1->bSynchAddress != 0) {
+			printf("%s: invalid endpoint: bSynchAddress=0\n",
+			       USBDEVNAME(sc->sc_dev));
+			return USBD_INVAL;
+		}
+		if (UE_GET_XFERTYPE(epdesc1->bmAttributes) != UE_ISOCHRONOUS) {
+			printf("%s: invalid endpoint: bmAttributes=0x%x\n",
+			       USBDEVNAME(sc->sc_dev), epdesc1->bmAttributes);
+			return USBD_INVAL;
+		}
+		if (epdesc1->bEndpointAddress != ed->bSynchAddress) {
+			printf("%s: invalid endpoint addresses: "
+			       "ep[0]->bSynchAddress=0x%x "
+			       "ep[1]->bEndpointAddress=0x%x\n",
+			       USBDEVNAME(sc->sc_dev), ed->bSynchAddress,
+			       epdesc1->bEndpointAddress);
+			return USBD_INVAL;
+		}
+		/* UE_GET_ADDR(epdesc1->bEndpointAddress), and epdesc1->bRefresh */
+	}
+
+	format = UGETW(asid->wFormatTag);
+	chan = asf1d->bNrChannels;
+	prec = asf1d->bBitResolution;
+	if (prec != 8 && prec != 16 && prec != 24 && prec != 32) {
+		printf("%s: ignored setting with precision %d\n",
+		       USBDEVNAME(sc->sc_dev), prec);
+		return USBD_NORMAL_COMPLETION;
+	}
+	switch (format) {
+	case UA_FMT_PCM:
+		if (prec == 8) {
+			sc->sc_altflags |= HAS_8;
+		} else if (prec == 16) {
+			sc->sc_altflags |= HAS_16;
+		} else if (prec == 24) {
+			sc->sc_altflags |= HAS_24;
+		} else if (prec == 32) {
+			sc->sc_altflags |= HAS_32;
+		}
+		enc = AUDIO_ENCODING_SLINEAR_LE;
+		format_str = "pcm";
+		break;
+	case UA_FMT_PCM8:
+		enc = AUDIO_ENCODING_ULINEAR_LE;
+		sc->sc_altflags |= HAS_8U;
+		format_str = "pcm8";
+		break;
+	case UA_FMT_ALAW:
+		enc = AUDIO_ENCODING_ALAW;
+		sc->sc_altflags |= HAS_ALAW;
+		format_str = "alaw";
+		break;
+	case UA_FMT_MULAW:
+		enc = AUDIO_ENCODING_ULAW;
+		sc->sc_altflags |= HAS_MULAW;
+		format_str = "mulaw";
+		break;
+	case UA_FMT_IEEE_FLOAT:
+	default:
+		printf("%s: ignored setting with format %d\n",
+		       USBDEVNAME(sc->sc_dev), format);
+		return USBD_NORMAL_COMPLETION;
+	}
+#ifdef USB_DEBUG
+	printf("%s: %s: %dch, %d/%dbit, %s,", USBDEVNAME(sc->sc_dev),
+	       dir == UE_DIR_IN ? "recording" : "playback",
+	       chan, prec, asf1d->bSubFrameSize * 8, format_str);
+	if (asf1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
+		printf(" %d-%dHz\n", UA_SAMP_LO(asf1d), UA_SAMP_HI(asf1d));
+	} else {
+		int r;
+		printf(" %d", UA_GETSAMP(asf1d, 0));
+		for (r = 1; r < asf1d->bSamFreqType; r++)
+			printf(",%d", UA_GETSAMP(asf1d, r));
+		printf("Hz\n");
+	}
+#endif
+#if defined(__FreeBSD__)
+	if (sc->uaudio_sndstat_flag != 0) {
+		sbuf_printf(&(sc->uaudio_sndstat), "\n\t");
+		sbuf_printf(&(sc->uaudio_sndstat), 
+		    "mode %d:(%s) %dch, %d/%dbit, %s,", 
+		    id->bAlternateSetting,
+		    dir == UE_DIR_IN ? "input" : "output",
+		    chan, prec, asf1d->bSubFrameSize * 8, format_str);
+		if (asf1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
+			sbuf_printf(&(sc->uaudio_sndstat), " %d-%dHz", 
+			    UA_SAMP_LO(asf1d), UA_SAMP_HI(asf1d));
+		} else {
+			int r;
+			sbuf_printf(&(sc->uaudio_sndstat), 
+			    " %d", UA_GETSAMP(asf1d, 0));
+			for (r = 1; r < asf1d->bSamFreqType; r++)
+				sbuf_printf(&(sc->uaudio_sndstat), 
+				    ",%d", UA_GETSAMP(asf1d, r));
+			sbuf_printf(&(sc->uaudio_sndstat), "Hz");
+		}
+	}
+#endif
+	ai.alt = id->bAlternateSetting;
+	ai.encoding = enc;
+	ai.attributes = sed->bmAttributes;
+	ai.idesc = id;
+	ai.edesc = ed;
+	ai.edesc1 = epdesc1;
+	ai.asf1desc = asf1d;
+	ai.sc_busy = 0;
+	uaudio_add_alt(sc, &ai);
+#ifdef USB_DEBUG
+	if (ai.attributes & UA_SED_FREQ_CONTROL)
+		DPRINTFN(1, ("uaudio_process_as:  FREQ_CONTROL\n"));
+	if (ai.attributes & UA_SED_PITCH_CONTROL)
+		DPRINTFN(1, ("uaudio_process_as:  PITCH_CONTROL\n"));
+#endif
+	sc->sc_mode |= (dir == UE_DIR_OUT) ? AUMODE_PLAY : AUMODE_RECORD;
+
+	return USBD_NORMAL_COMPLETION;
+}
+#undef offs
+
+Static usbd_status
+uaudio_identify_as(struct uaudio_softc *sc,
+		   const usb_config_descriptor_t *cdesc)
+{
+	const usb_interface_descriptor_t *id;
+	const char *buf;
+	int size, offs;
+
+	size = UGETW(cdesc->wTotalLength);
+	buf = (const char *)cdesc;
+
+	/* Locate the AudioStreaming interface descriptor. */
+	offs = 0;
+	id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM);
+	if (id == NULL)
+		return USBD_INVAL;
+
+#if defined(__FreeBSD__)
+	sc->uaudio_sndstat_flag = 0;
+	if (sbuf_new(&(sc->uaudio_sndstat), NULL, 4096, SBUF_AUTOEXTEND) != NULL)
+		sc->uaudio_sndstat_flag = 1;
+#endif
+	/* Loop through all the alternate settings. */
+	while (offs <= size) {
+		DPRINTFN(2, ("uaudio_identify: interface=%d offset=%d\n",
+		    id->bInterfaceNumber, offs));
+		switch (id->bNumEndpoints) {
+		case 0:
+			DPRINTFN(2, ("uaudio_identify: AS null alt=%d\n",
+				     id->bAlternateSetting));
+			sc->sc_nullalt = id->bAlternateSetting;
+			break;
+		case 1:
+#ifdef UAUDIO_MULTIPLE_ENDPOINTS
+		case 2:
+#endif
+			uaudio_process_as(sc, buf, &offs, size, id);
+			break;
+		default:
+			printf("%s: ignored audio interface with %d "
+			       "endpoints\n",
+			       USBDEVNAME(sc->sc_dev), id->bNumEndpoints);
+			break;
+		}
+		id = uaudio_find_iface(buf, size, &offs,UISUBCLASS_AUDIOSTREAM);
+		if (id == NULL)
+			break;
+	}
+#if defined(__FreeBSD__)
+	sbuf_finish(&(sc->uaudio_sndstat));
+#endif
+	if (offs > size)
+		return USBD_INVAL;
+	DPRINTF(("uaudio_identify_as: %d alts available\n", sc->sc_nalts));
+
+	if (sc->sc_mode == 0) {
+		printf("%s: no usable endpoint found\n",
+		       USBDEVNAME(sc->sc_dev));
+		return USBD_INVAL;
+	}
+
+	return USBD_NORMAL_COMPLETION;
+}
+
+Static usbd_status
+uaudio_identify_ac(struct uaudio_softc *sc, const usb_config_descriptor_t *cdesc)
+{
+	struct io_terminal* iot;
+	const usb_interface_descriptor_t *id;
+	const struct usb_audio_control_descriptor *acdp;
+	const usb_descriptor_t *dp;
+	const struct usb_audio_output_terminal *pot;
+	struct terminal_list *tml;
+	const char *buf, *ibuf, *ibufend;
+	int size, offs, aclen, ndps, i, j;
+
+	size = UGETW(cdesc->wTotalLength);
+	buf = (const char *)cdesc;
+
+	/* Locate the AudioControl interface descriptor. */
+	offs = 0;
+	id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL);
+	if (id == NULL)
+		return USBD_INVAL;
+	if (offs + sizeof *acdp > size)
+		return USBD_INVAL;
+	sc->sc_ac_iface = id->bInterfaceNumber;
+	DPRINTFN(2,("uaudio_identify_ac: AC interface is %d\n", sc->sc_ac_iface));
+
+	/* A class-specific AC interface header should follow. */
+	ibuf = buf + offs;
+	acdp = (const struct usb_audio_control_descriptor *)ibuf;
+	if (acdp->bDescriptorType != UDESC_CS_INTERFACE ||
+	    acdp->bDescriptorSubtype != UDESCSUB_AC_HEADER)
+		return USBD_INVAL;
+	aclen = UGETW(acdp->wTotalLength);
+	if (offs + aclen > size)
+		return USBD_INVAL;
+
+	if (!(usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_BAD_ADC) &&
+	     UGETW(acdp->bcdADC) != UAUDIO_VERSION)
+		return USBD_INVAL;
+
+	sc->sc_audio_rev = UGETW(acdp->bcdADC);
+	DPRINTFN(2,("uaudio_identify_ac: found AC header, vers=%03x, len=%d\n",
+		 sc->sc_audio_rev, aclen));
+
+	sc->sc_nullalt = -1;
+
+	/* Scan through all the AC specific descriptors */
+	ibufend = ibuf + aclen;
+	dp = (const usb_descriptor_t *)ibuf;
+	ndps = 0;
+	iot = malloc(sizeof(struct io_terminal) * 256, M_TEMP, M_NOWAIT | M_ZERO);
+	if (iot == NULL) {
+		printf("%s: no memory\n", __func__);
+		return USBD_NOMEM;
+	}
+	for (;;) {
+		ibuf += dp->bLength;
+		if (ibuf >= ibufend)
+			break;
+		dp = (const usb_descriptor_t *)ibuf;
+		if (ibuf + dp->bLength > ibufend) {
+			free(iot, M_TEMP);
+			return USBD_INVAL;
+		}
+		if (dp->bDescriptorType != UDESC_CS_INTERFACE) {
+			printf("uaudio_identify_ac: skip desc type=0x%02x\n",
+			       dp->bDescriptorType);
+			continue;
+		}
+		i = ((const struct usb_audio_input_terminal *)dp)->bTerminalId;
+		iot[i].d.desc = dp;
+		if (i > ndps)
+			ndps = i;
+	}
+	ndps++;
+
+	/* construct io_terminal */
+	for (i = 0; i < ndps; i++) {
+		dp = iot[i].d.desc;
+		if (dp == NULL)
+			continue;
+		if (dp->bDescriptorSubtype != UDESCSUB_AC_OUTPUT)
+			continue;
+		pot = iot[i].d.ot;
+		tml = uaudio_io_terminaltype(UGETW(pot->wTerminalType), iot, i);
+		if (tml != NULL)
+			free(tml, M_TEMP);
+	}
+
+#ifdef USB_DEBUG
+	for (i = 0; i < 256; i++) {
+		struct usb_audio_cluster cluster;
+
+		if (iot[i].d.desc == NULL)
+			continue;
+		logprintf("id %d:\t", i);
+		switch (iot[i].d.desc->bDescriptorSubtype) {
+		case UDESCSUB_AC_INPUT:
+			logprintf("AC_INPUT type=%s\n", uaudio_get_terminal_name
+				  (UGETW(iot[i].d.it->wTerminalType)));
+			logprintf("\t");
+			cluster = uaudio_get_cluster(i, iot);
+			uaudio_dump_cluster(&cluster);
+			logprintf("\n");
+			break;
+		case UDESCSUB_AC_OUTPUT:
+			logprintf("AC_OUTPUT type=%s ", uaudio_get_terminal_name
+				  (UGETW(iot[i].d.ot->wTerminalType)));
+			logprintf("src=%d\n", iot[i].d.ot->bSourceId);
+			break;
+		case UDESCSUB_AC_MIXER:
+			logprintf("AC_MIXER src=");
+			for (j = 0; j < iot[i].d.mu->bNrInPins; j++)
+				logprintf("%d ", iot[i].d.mu->baSourceId[j]);
+			logprintf("\n\t");
+			cluster = uaudio_get_cluster(i, iot);
+			uaudio_dump_cluster(&cluster);
+			logprintf("\n");
+			break;
+		case UDESCSUB_AC_SELECTOR:
+			logprintf("AC_SELECTOR src=");
+			for (j = 0; j < iot[i].d.su->bNrInPins; j++)
+				logprintf("%d ", iot[i].d.su->baSourceId[j]);
+			logprintf("\n");
+			break;
+		case UDESCSUB_AC_FEATURE:
+			logprintf("AC_FEATURE src=%d\n", iot[i].d.fu->bSourceId);
+			break;
+		case UDESCSUB_AC_PROCESSING:
+			logprintf("AC_PROCESSING src=");
+			for (j = 0; j < iot[i].d.pu->bNrInPins; j++)
+				logprintf("%d ", iot[i].d.pu->baSourceId[j]);
+			logprintf("\n\t");
+			cluster = uaudio_get_cluster(i, iot);
+			uaudio_dump_cluster(&cluster);
+			logprintf("\n");
+			break;
+		case UDESCSUB_AC_EXTENSION:
+			logprintf("AC_EXTENSION src=");
+			for (j = 0; j < iot[i].d.eu->bNrInPins; j++)
+				logprintf("%d ", iot[i].d.eu->baSourceId[j]);
+			logprintf("\n\t");
+			cluster = uaudio_get_cluster(i, iot);
+			uaudio_dump_cluster(&cluster);
+			logprintf("\n");
+			break;
+		default:
+			logprintf("unknown audio control (subtype=%d)\n",
+				  iot[i].d.desc->bDescriptorSubtype);
+		}
+		for (j = 0; j < iot[i].inputs_size; j++) {
+			int k;
+			logprintf("\tinput%d: ", j);
+			tml = iot[i].inputs[j];
+			if (tml == NULL) {
+				logprintf("NULL\n");
+				continue;
+			}
+			for (k = 0; k < tml->size; k++)
+				logprintf("%s ", uaudio_get_terminal_name
+					  (tml->terminals[k]));
+			logprintf("\n");
+		}
+		logprintf("\toutput: ");
+		tml = iot[i].output;
+		for (j = 0; j < tml->size; j++)
+			logprintf("%s ", uaudio_get_terminal_name(tml->terminals[j]));
+		logprintf("\n");
+	}
+#endif
+
+	for (i = 0; i < ndps; i++) {
+		dp = iot[i].d.desc;
+		if (dp == NULL)
+			continue;
+		DPRINTF(("uaudio_identify_ac: id=%d subtype=%d\n",
+			 i, dp->bDescriptorSubtype));
+		switch (dp->bDescriptorSubtype) {
+		case UDESCSUB_AC_HEADER:
+			printf("uaudio_identify_ac: unexpected AC header\n");
+			break;
+		case UDESCSUB_AC_INPUT:
+			uaudio_add_input(sc, iot, i);
+			break;
+		case UDESCSUB_AC_OUTPUT:
+			uaudio_add_output(sc, iot, i);
+			break;
+		case UDESCSUB_AC_MIXER:
+			uaudio_add_mixer(sc, iot, i);
+			break;
+		case UDESCSUB_AC_SELECTOR:
+			uaudio_add_selector(sc, iot, i);
+			break;
+		case UDESCSUB_AC_FEATURE:
+			uaudio_add_feature(sc, iot, i);
+			break;
+		case UDESCSUB_AC_PROCESSING:
+			uaudio_add_processing(sc, iot, i);
+			break;
+		case UDESCSUB_AC_EXTENSION:
+			uaudio_add_extension(sc, iot, i);
+			break;
+		default:
+			printf("uaudio_identify_ac: bad AC desc subtype=0x%02x\n",
+			       dp->bDescriptorSubtype);
+			break;
+		}
+	}
+
+	/* delete io_terminal */
+	for (i = 0; i < 256; i++) {
+		if (iot[i].d.desc == NULL)
+			continue;
+		if (iot[i].inputs != NULL) {
+			for (j = 0; j < iot[i].inputs_size; j++) {
+				if (iot[i].inputs[j] != NULL)
+					free(iot[i].inputs[j], M_TEMP);
+			}
+			free(iot[i].inputs, M_TEMP);
+		}
+		if (iot[i].output != NULL)
+			free(iot[i].output, M_TEMP);
+		iot[i].d.desc = NULL;
+	}
+	free(iot, M_TEMP);
+
+	return USBD_NORMAL_COMPLETION;
+}
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static int
+uaudio_query_devinfo(void *addr, mixer_devinfo_t *mi)
+{
+	struct uaudio_softc *sc;
+	struct mixerctl *mc;
+	int n, nctls, i;
+
+	sc = addr;
+	DPRINTFN(2,("uaudio_query_devinfo: index=%d\n", mi->index));
+	if (sc->sc_dying)
+		return EIO;
+
+	n = mi->index;
+	nctls = sc->sc_nctls;
+
+	switch (n) {
+	case UAC_OUTPUT:
+		mi->type = AUDIO_MIXER_CLASS;
+		mi->mixer_class = UAC_OUTPUT;
+		mi->next = mi->prev = AUDIO_MIXER_LAST;
+		strlcpy(mi->label.name, AudioCoutputs, sizeof(mi->label.name));
+		return 0;
+	case UAC_INPUT:
+		mi->type = AUDIO_MIXER_CLASS;
+		mi->mixer_class = UAC_INPUT;
+		mi->next = mi->prev = AUDIO_MIXER_LAST;
+		strlcpy(mi->label.name, AudioCinputs, sizeof(mi->label.name));
+		return 0;
+	case UAC_EQUAL:
+		mi->type = AUDIO_MIXER_CLASS;
+		mi->mixer_class = UAC_EQUAL;
+		mi->next = mi->prev = AUDIO_MIXER_LAST;
+		strlcpy(mi->label.name, AudioCequalization,
+		    sizeof(mi->label.name));
+		return 0;
+	case UAC_RECORD:
+		mi->type = AUDIO_MIXER_CLASS;
+		mi->mixer_class = UAC_RECORD;
+		mi->next = mi->prev = AUDIO_MIXER_LAST;
+		strlcpy(mi->label.name, AudioCrecord, sizeof(mi->label.name));
+		return 0;
+	default:
+		break;
+	}
+
+	n -= UAC_NCLASSES;
+	if (n < 0 || n >= nctls)
+		return ENXIO;
+
+	mc = &sc->sc_ctls[n];
+	strlcpy(mi->label.name, mc->ctlname, sizeof(mi->label.name));
+	mi->mixer_class = mc->class;
+	mi->next = mi->prev = AUDIO_MIXER_LAST;	/* XXX */
+	switch (mc->type) {
+	case MIX_ON_OFF:
+		mi->type = AUDIO_MIXER_ENUM;
+		mi->un.e.num_mem = 2;
+		strlcpy(mi->un.e.member[0].label.name, AudioNoff,
+		    sizeof(mi->un.e.member[0].label.name));
+		mi->un.e.member[0].ord = 0;
+		strlcpy(mi->un.e.member[1].label.name, AudioNon,
+		    sizeof(mi->un.e.member[1].label.name));
+		mi->un.e.member[1].ord = 1;
+		break;
+	case MIX_SELECTOR:
+		mi->type = AUDIO_MIXER_ENUM;
+		mi->un.e.num_mem = mc->maxval - mc->minval + 1;
+		for (i = 0; i <= mc->maxval - mc->minval; i++) {
+			snprintf(mi->un.e.member[i].label.name,
+				 sizeof(mi->un.e.member[i].label.name),
+				 "%d", i + mc->minval);
+			mi->un.e.member[i].ord = i + mc->minval;
+		}
+		break;
+	default:
+		mi->type = AUDIO_MIXER_VALUE;
+		strncpy(mi->un.v.units.name, mc->ctlunit, MAX_AUDIO_DEV_LEN);
+		mi->un.v.num_channels = mc->nchan;
+		mi->un.v.delta = mc->delta;
+		break;
+	}
+	return 0;
+}
+
+Static int
+uaudio_open(void *addr, int flags)
+{
+	struct uaudio_softc *sc;
+
+	sc = addr;
+	DPRINTF(("uaudio_open: sc=%p\n", sc));
+	if (sc->sc_dying)
+		return EIO;
+
+	if ((flags & FWRITE) && !(sc->sc_mode & AUMODE_PLAY))
+		return EACCES;
+	if ((flags & FREAD) && !(sc->sc_mode & AUMODE_RECORD))
+		return EACCES;
+
+	return 0;
+}
+
+/*
+ * Close function is called at splaudio().
+ */
+Static void
+uaudio_close(void *addr)
+{
+}
+
+Static int
+uaudio_drain(void *addr)
+{
+	struct uaudio_softc *sc;
+
+	sc = addr;
+	usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);
+
+	return 0;
+}
+
+Static int
+uaudio_halt_out_dma(void *addr)
+{
+	struct uaudio_softc *sc;
+
+	sc = addr;
+	if (sc->sc_dying)
+		return EIO;
+
+	DPRINTF(("uaudio_halt_out_dma: enter\n"));
+	if (sc->sc_playchan.pipe != NULL) {
+		uaudio_chan_close(sc, &sc->sc_playchan);
+		sc->sc_playchan.pipe = NULL;
+		uaudio_chan_free_buffers(sc, &sc->sc_playchan);
+		sc->sc_playchan.intr = NULL;
+	}
+	return 0;
+}
+
+Static int
+uaudio_halt_in_dma(void *addr)
+{
+	struct uaudio_softc *sc;
+
+	DPRINTF(("uaudio_halt_in_dma: enter\n"));
+	sc = addr;
+	if (sc->sc_recchan.pipe != NULL) {
+		uaudio_chan_close(sc, &sc->sc_recchan);
+		sc->sc_recchan.pipe = NULL;
+		uaudio_chan_free_buffers(sc, &sc->sc_recchan);
+		sc->sc_recchan.intr = NULL;
+	}
+	return 0;
+}
+
+Static int
+uaudio_getdev(void *addr, struct audio_device *retp)
+{
+	struct uaudio_softc *sc;
+
+	DPRINTF(("uaudio_mixer_getdev:\n"));
+	sc = addr;
+	if (sc->sc_dying)
+		return EIO;
+
+	*retp = uaudio_device;
+	return 0;
+}
+
+/*
+ * Make sure the block size is large enough to hold all outstanding transfers.
+ */
+Static int
+uaudio_round_blocksize(void *addr, int blk)
+{
+	struct uaudio_softc *sc;
+	int b;
+
+	sc = addr;
+	DPRINTF(("uaudio_round_blocksize: blk=%d mode=%s\n", blk,
+		mode == AUMODE_PLAY ? "AUMODE_PLAY" : "AUMODE_RECORD"));
+
+	/* chan.bytes_per_frame can be 0. */
+	if (mode == AUMODE_PLAY || sc->sc_recchan.bytes_per_frame <= 0) {
+		b = param->sample_rate * UAUDIO_NFRAMES * UAUDIO_NCHANBUFS;
+
+		/*
+		 * This does not make accurate value in the case
+		 * of b % USB_FRAMES_PER_SECOND != 0
+		 */
+		b /= USB_FRAMES_PER_SECOND;
+
+		b *= param->precision / 8 * param->channels;
+	} else {
+		/*
+		 * use wMaxPacketSize in bytes_per_frame.
+		 * See uaudio_set_params() and uaudio_chan_init()
+		 */
+		b = sc->sc_recchan.bytes_per_frame
+			* UAUDIO_NFRAMES * UAUDIO_NCHANBUFS;
+	}
+
+	if (b <= 0)
+		b = 1;
+	blk = blk <= b ? b : blk / b * b;
+
+#ifdef DIAGNOSTIC
+	if (blk <= 0) {
+		printf("uaudio_round_blocksize: blk=%d\n", blk);
+		blk = 512;
+	}
+#endif
+
+	DPRINTF(("uaudio_round_blocksize: resultant blk=%d\n", blk));
+	return blk;
+}
+
+Static int
+uaudio_get_props(void *addr)
+{
+	return AUDIO_PROP_FULLDUPLEX | AUDIO_PROP_INDEPENDENT;
+
+}
+#endif	/* NetBSD or OpenBSD */
+
+Static int
+uaudio_get(struct uaudio_softc *sc, int which, int type, int wValue,
+	   int wIndex, int len)
+{
+	usb_device_request_t req;
+	uint8_t data[4];
+	usbd_status err;
+	int val;
+
+#if defined(__FreeBSD__)
+	if (sc->sc_dying)
+		return EIO;
+#endif
+
+	if (wValue == -1)
+		return 0;
+
+	req.bmRequestType = type;
+	req.bRequest = which;
+	USETW(req.wValue, wValue);
+	USETW(req.wIndex, wIndex);
+	USETW(req.wLength, len);
+	DPRINTFN(2,("uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x "
+		    "wIndex=0x%04x len=%d\n",
+		    type, which, wValue, wIndex, len));
+	err = usbd_do_request(sc->sc_udev, &req, data);
+	if (err) {
+		DPRINTF(("uaudio_get: err=%s\n", usbd_errstr(err)));
+		return -1;
+	}
+	switch (len) {
+	case 1:
+		val = data[0];
+		break;
+	case 2:
+		val = data[0] | (data[1] << 8);
+		break;
+	default:
+		DPRINTF(("uaudio_get: bad length=%d\n", len));
+		return -1;
+	}
+	DPRINTFN(2,("uaudio_get: val=%d\n", val));
+	return val;
+}
+
+Static void
+uaudio_set(struct uaudio_softc *sc, int which, int type, int wValue,
+	   int wIndex, int len, int val)
+{
+	usb_device_request_t req;
+	uint8_t data[4];
+	usbd_status err;
+
+#if defined(__FreeBSD__)
+	if (sc->sc_dying)
+		return;
+#endif
+
+	if (wValue == -1)
+		return;
+
+	req.bmRequestType = type;
+	req.bRequest = which;
+	USETW(req.wValue, wValue);
+	USETW(req.wIndex, wIndex);
+	USETW(req.wLength, len);
+	switch (len) {
+	case 1:
+		data[0] = val;
+		break;
+	case 2:
+		data[0] = val;
+		data[1] = val >> 8;
+		break;
+	default:
+		return;
+	}
+	DPRINTFN(2,("uaudio_set: type=0x%02x req=0x%02x wValue=0x%04x "
+		    "wIndex=0x%04x len=%d, val=%d\n",
+		    type, which, wValue, wIndex, len, val & 0xffff));
+	err = usbd_do_request(sc->sc_udev, &req, data);
+#ifdef USB_DEBUG
+	if (err)
+		DPRINTF(("uaudio_set: err=%d\n", err));
+#endif
+}
+
+Static int
+uaudio_signext(int type, int val)
+{
+	if (!MIX_UNSIGNED(type)) {
+		if (MIX_SIZE(type) == 2)
+			val = (int16_t)val;
+		else
+			val = (int8_t)val;
+	}
+	return val;
+}
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static int
+uaudio_value2bsd(struct mixerctl *mc, int val)
+{
+	DPRINTFN(5, ("uaudio_value2bsd: type=%03x val=%d min=%d max=%d ",
+		     mc->type, val, mc->minval, mc->maxval));
+	if (mc->type == MIX_ON_OFF) {
+		val = (val != 0);
+	} else if (mc->type == MIX_SELECTOR) {
+		if (val < mc->minval || val > mc->maxval)
+			val = mc->minval;
+	} else
+		val = ((uaudio_signext(mc->type, val) - mc->minval) * 255
+			+ mc->mul/2) / mc->mul;
+	DPRINTFN(5, ("val'=%d\n", val));
+	return val;
+}
+#endif
+
+int
+uaudio_bsd2value(struct mixerctl *mc, int val)
+{
+	DPRINTFN(5,("uaudio_bsd2value: type=%03x val=%d min=%d max=%d ",
+		    mc->type, val, mc->minval, mc->maxval));
+	if (mc->type == MIX_ON_OFF) {
+		val = (val != 0);
+	} else if (mc->type == MIX_SELECTOR) {
+		if (val < mc->minval || val > mc->maxval)
+			val = mc->minval;
+	} else
+		val = (val + mc->delta/2) * mc->mul / 255 + mc->minval;
+	DPRINTFN(5, ("val'=%d\n", val));
+	return val;
+}
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static int
+uaudio_ctl_get(struct uaudio_softc *sc, int which, struct mixerctl *mc,
+	       int chan)
+{
+	int val;
+
+	DPRINTFN(5,("uaudio_ctl_get: which=%d chan=%d\n", which, chan));
+	val = uaudio_get(sc, which, UT_READ_CLASS_INTERFACE, mc->wValue[chan],
+			 mc->wIndex, MIX_SIZE(mc->type));
+	return uaudio_value2bsd(mc, val);
+}
+#endif
+
+Static void
+uaudio_ctl_set(struct uaudio_softc *sc, int which, struct mixerctl *mc,
+	       int chan, int val)
+{
+	val = uaudio_bsd2value(mc, val);
+	uaudio_set(sc, which, UT_WRITE_CLASS_INTERFACE, mc->wValue[chan],
+		   mc->wIndex, MIX_SIZE(mc->type), val);
+}
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static int
+uaudio_mixer_get_port(void *addr, mixer_ctrl_t *cp)
+{
+	struct uaudio_softc *sc;
+	struct mixerctl *mc;
+	int i, n, vals[MIX_MAX_CHAN], val;
+
+	DPRINTFN(2,("uaudio_mixer_get_port: index=%d\n", cp->dev));
+	sc = addr;
+	if (sc->sc_dying)
+		return EIO;
+
+	n = cp->dev - UAC_NCLASSES;
+	if (n < 0 || n >= sc->sc_nctls)
+		return ENXIO;
+	mc = &sc->sc_ctls[n];
+
+	if (mc->type == MIX_ON_OFF) {
+		if (cp->type != AUDIO_MIXER_ENUM)
+			return EINVAL;
+		cp->un.ord = uaudio_ctl_get(sc, GET_CUR, mc, 0);
+	} else if (mc->type == MIX_SELECTOR) {
+		if (cp->type != AUDIO_MIXER_ENUM)
+			return EINVAL;
+		cp->un.ord = uaudio_ctl_get(sc, GET_CUR, mc, 0);
+	} else {
+		if (cp->type != AUDIO_MIXER_VALUE)
+			return (EINVAL);
+		if (cp->un.value.num_channels != 1 &&
+		    cp->un.value.num_channels != mc->nchan)
+			return EINVAL;
+		for (i = 0; i < mc->nchan; i++)
+			vals[i] = uaudio_ctl_get(sc, GET_CUR, mc, i);
+		if (cp->un.value.num_channels == 1 && mc->nchan != 1) {
+			for (val = 0, i = 0; i < mc->nchan; i++)
+				val += vals[i];
+			vals[0] = val / mc->nchan;
+		}
+		for (i = 0; i < cp->un.value.num_channels; i++)
+			cp->un.value.level[i] = vals[i];
+	}
+
+	return 0;
+}
+
+Static int
+uaudio_mixer_set_port(void *addr, mixer_ctrl_t *cp)
+{
+	struct uaudio_softc *sc;
+	struct mixerctl *mc;
+	int i, n, vals[MIX_MAX_CHAN];
+
+	DPRINTFN(2,("uaudio_mixer_set_port: index = %d\n", cp->dev));
+	sc = addr;
+	if (sc->sc_dying)
+		return EIO;
+
+	n = cp->dev - UAC_NCLASSES;
+	if (n < 0 || n >= sc->sc_nctls)
+		return ENXIO;
+	mc = &sc->sc_ctls[n];
+
+	if (mc->type == MIX_ON_OFF) {
+		if (cp->type != AUDIO_MIXER_ENUM)
+			return EINVAL;
+		uaudio_ctl_set(sc, SET_CUR, mc, 0, cp->un.ord);
+	} else if (mc->type == MIX_SELECTOR) {
+		if (cp->type != AUDIO_MIXER_ENUM)
+			return EINVAL;
+		uaudio_ctl_set(sc, SET_CUR, mc, 0, cp->un.ord);
+	} else {
+		if (cp->type != AUDIO_MIXER_VALUE)
+			return EINVAL;
+		if (cp->un.value.num_channels == 1)
+			for (i = 0; i < mc->nchan; i++)
+				vals[i] = cp->un.value.level[0];
+		else if (cp->un.value.num_channels == mc->nchan)
+			for (i = 0; i < mc->nchan; i++)
+				vals[i] = cp->un.value.level[i];
+		else
+			return EINVAL;
+		for (i = 0; i < mc->nchan; i++)
+			uaudio_ctl_set(sc, SET_CUR, mc, i, vals[i]);
+	}
+	return 0;
+}
+
+Static int
+uaudio_trigger_input(void *addr, void *start, void *end, int blksize,
+		     void (*intr)(void *), void *arg,
+		     struct audio_params *param)
+{
+	struct uaudio_softc *sc;
+	struct chan *ch;
+	usbd_status err;
+	int i, s;
+
+	sc = addr;
+	if (sc->sc_dying)
+		return EIO;
+
+	DPRINTFN(3,("uaudio_trigger_input: sc=%p start=%p end=%p "
+		    "blksize=%d\n", sc, start, end, blksize));
+	ch = &sc->sc_recchan;
+	uaudio_chan_set_param(ch, start, end, blksize);
+	DPRINTFN(3,("uaudio_trigger_input: sample_size=%d bytes/frame=%d "
+		    "fraction=0.%03d\n", ch->sample_size, ch->bytes_per_frame,
+		    ch->fraction));
+
+	err = uaudio_chan_alloc_buffers(sc, ch);
+	if (err)
+		return EIO;
+
+	err = uaudio_chan_open(sc, ch);
+	if (err) {
+		uaudio_chan_free_buffers(sc, ch);
+		return EIO;
+	}
+
+	ch->intr = intr;
+	ch->arg = arg;
+
+	s = splusb();
+	for (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX -1 shouldn't be needed */
+		uaudio_chan_rtransfer(ch);
+	splx(s);
+
+	return 0;
+}
+
+Static int
+uaudio_trigger_output(void *addr, void *start, void *end, int blksize,
+		      void (*intr)(void *), void *arg,
+		      struct audio_params *param)
+{
+	struct uaudio_softc *sc;
+	struct chan *ch;
+	usbd_status err;
+	int i, s;
+
+	sc = addr;
+	if (sc->sc_dying)
+		return EIO;
+
+	DPRINTFN(3,("uaudio_trigger_output: sc=%p start=%p end=%p "
+		    "blksize=%d\n", sc, start, end, blksize));
+	ch = &sc->sc_playchan;
+	uaudio_chan_set_param(ch, start, end, blksize);
+	DPRINTFN(3,("uaudio_trigger_output: sample_size=%d bytes/frame=%d "
+		    "fraction=0.%03d\n", ch->sample_size, ch->bytes_per_frame,
+		    ch->fraction));
+
+	err = uaudio_chan_alloc_buffers(sc, ch);
+	if (err)
+		return EIO;
+
+	err = uaudio_chan_open(sc, ch);
+	if (err) {
+		uaudio_chan_free_buffers(sc, ch);
+		return EIO;
+	}
+
+	ch->intr = intr;
+	ch->arg = arg;
+
+	s = splusb();
+	for (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX */
+		uaudio_chan_ptransfer(ch);
+	splx(s);
+
+	return 0;
+}
+#endif	/* NetBSD or OpenBSD */
+
+/* Set up a pipe for a channel. */
+Static usbd_status
+uaudio_chan_open(struct uaudio_softc *sc, struct chan *ch)
+{
+	struct as_info *as;
+	int endpt;
+	usbd_status err;
+
+#if defined(__FreeBSD__)
+	if (sc->sc_dying)
+		return EIO;
+#endif
+
+	as = &sc->sc_alts[ch->altidx];
+	endpt = as->edesc->bEndpointAddress;
+	DPRINTF(("uaudio_chan_open: endpt=0x%02x, speed=%d, alt=%d\n",
+		 endpt, ch->sample_rate, as->alt));
+
+	/* Set alternate interface corresponding to the mode. */
+	err = usbd_set_interface(as->ifaceh, as->alt);
+	if (err)
+		return err;
+
+	/*
+	 * If just one sampling rate is supported,
+	 * no need to call uaudio_set_speed().
+	 * Roland SD-90 freezes by a SAMPLING_FREQ_CONTROL request.
+	 */
+	if (as->asf1desc->bSamFreqType != 1) {
+		err = uaudio_set_speed(sc, endpt, ch->sample_rate);
+		if (err)
+			DPRINTF(("uaudio_chan_open: set_speed failed err=%s\n",
+				 usbd_errstr(err)));
+	}
+
+	ch->pipe = 0;
+	ch->sync_pipe = 0;
+	DPRINTF(("uaudio_chan_open: create pipe to 0x%02x\n", endpt));
+	err = usbd_open_pipe(as->ifaceh, endpt, 0, &ch->pipe);
+	if (err)
+		return err;
+	if (as->edesc1 != NULL) {
+		endpt = as->edesc1->bEndpointAddress;
+		DPRINTF(("uaudio_chan_open: create sync-pipe to 0x%02x\n", endpt));
+		err = usbd_open_pipe(as->ifaceh, endpt, 0, &ch->sync_pipe);
+	}
+	return err;
+}
+
+Static void
+uaudio_chan_close(struct uaudio_softc *sc, struct chan *ch)
+{
+	struct as_info *as;
+
+#if defined(__FreeBSD__)
+	if (sc->sc_dying)
+		return ;
+#endif
+
+	as = &sc->sc_alts[ch->altidx];
+	as->sc_busy = 0;
+	if (sc->sc_nullalt >= 0) {
+		DPRINTF(("uaudio_chan_close: set null alt=%d\n",
+			 sc->sc_nullalt));
+		usbd_set_interface(as->ifaceh, sc->sc_nullalt);
+	}
+	if (ch->pipe) {
+		usbd_abort_pipe(ch->pipe);
+		usbd_close_pipe(ch->pipe);
+	}
+	if (ch->sync_pipe) {
+		usbd_abort_pipe(ch->sync_pipe);
+		usbd_close_pipe(ch->sync_pipe);
+	}
+}
+
+Static usbd_status
+uaudio_chan_alloc_buffers(struct uaudio_softc *sc, struct chan *ch)
+{
+	usbd_xfer_handle xfer;
+	void *buf;
+	int i, size;
+
+	size = (ch->bytes_per_frame + ch->sample_size) * UAUDIO_NFRAMES;
+	for (i = 0; i < UAUDIO_NCHANBUFS; i++) {
+		xfer = usbd_alloc_xfer(sc->sc_udev);
+		if (xfer == 0)
+			goto bad;
+		ch->chanbufs[i].xfer = xfer;
+		buf = usbd_alloc_buffer(xfer, size);
+		if (buf == 0) {
+			i++;
+			goto bad;
+		}
+		ch->chanbufs[i].buffer = buf;
+		ch->chanbufs[i].chan = ch;
+	}
+
+	return USBD_NORMAL_COMPLETION;
+
+bad:
+	while (--i >= 0)
+		/* implicit buffer free */
+		usbd_free_xfer(ch->chanbufs[i].xfer);
+	return USBD_NOMEM;
+}
+
+Static void
+uaudio_chan_free_buffers(struct uaudio_softc *sc, struct chan *ch)
+{
+	int i;
+
+	for (i = 0; i < UAUDIO_NCHANBUFS; i++)
+		usbd_free_xfer(ch->chanbufs[i].xfer);
+}
+
+/* Called at splusb() */
+Static void
+uaudio_chan_ptransfer(struct chan *ch)
+{
+	struct chanbuf *cb;
+	int i, n, size, residue, total;
+
+	if (ch->sc->sc_dying)
+		return;
+
+	/* Pick the next channel buffer. */
+	cb = &ch->chanbufs[ch->curchanbuf];
+	if (++ch->curchanbuf >= UAUDIO_NCHANBUFS)
+		ch->curchanbuf = 0;
+
+	/* Compute the size of each frame in the next transfer. */
+	residue = ch->residue;
+	total = 0;
+	for (i = 0; i < UAUDIO_NFRAMES; i++) {
+		size = ch->bytes_per_frame;
+		residue += ch->fraction;
+		if (residue >= USB_FRAMES_PER_SECOND) {
+			if ((ch->sc->sc_altflags & UA_NOFRAC) == 0)
+				size += ch->sample_size;
+			residue -= USB_FRAMES_PER_SECOND;
+		}
+		cb->sizes[i] = size;
+		total += size;
+	}
+	ch->residue = residue;
+	cb->size = total;
+
+	/*
+	 * Transfer data from upper layer buffer to channel buffer, taking
+	 * care of wrapping the upper layer buffer.
+	 */
+	n = min(total, ch->end - ch->cur);
+	memcpy(cb->buffer, ch->cur, n);
+	ch->cur += n;
+	if (ch->cur >= ch->end)
+		ch->cur = ch->start;
+	if (total > n) {
+		total -= n;
+		memcpy(cb->buffer + n, ch->cur, total);
+		ch->cur += total;
+	}
+
+#ifdef USB_DEBUG
+	if (uaudiodebug > 8) {
+		DPRINTF(("uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\n",
+			 cb->buffer, ch->residue));
+		for (i = 0; i < UAUDIO_NFRAMES; i++) {
+			DPRINTF(("   [%d] length %d\n", i, cb->sizes[i]));
+		}
+	}
+#endif
+
+	DPRINTFN(5,("uaudio_chan_transfer: ptransfer xfer=%p\n", cb->xfer));
+	/* Fill the request */
+	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
+			     UAUDIO_NFRAMES, USBD_NO_COPY,
+			     uaudio_chan_pintr);
+
+	(void)usbd_transfer(cb->xfer);
+}
+
+Static void
+uaudio_chan_pintr(usbd_xfer_handle xfer, usbd_private_handle priv,
+		  usbd_status status)
+{
+	struct chanbuf *cb;
+	struct chan *ch;
+	u_int32_t count;
+	int s;
+
+	cb = priv;
+	ch = cb->chan;
+	/* Return if we are aborting. */
+	if (status == USBD_CANCELLED)
+		return;
+
+	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
+	DPRINTFN(5,("uaudio_chan_pintr: count=%d, transferred=%d\n",
+		    count, ch->transferred));
+#ifdef DIAGNOSTIC
+	if (count != cb->size) {
+		printf("uaudio_chan_pintr: count(%d) != size(%d)\n",
+		       count, cb->size);
+	}
+#endif
+
+	ch->transferred += cb->size;
+#if defined(__FreeBSD__)
+	/* s = spltty(); */
+	s = splhigh();
+	chn_intr(ch->pcm_ch);
+	splx(s);
+#else
+	s = splaudio();
+	/* Call back to upper layer */
+	while (ch->transferred >= ch->blksize) {
+		ch->transferred -= ch->blksize;
+		DPRINTFN(5,("uaudio_chan_pintr: call %p(%p)\n",
+			    ch->intr, ch->arg));
+		ch->intr(ch->arg);
+	}
+	splx(s);
+#endif
+
+	/* start next transfer */
+	uaudio_chan_ptransfer(ch);
+}
+
+/* Called at splusb() */
+Static void
+uaudio_chan_rtransfer(struct chan *ch)
+{
+	struct chanbuf *cb;
+	int i, size, residue, total;
+
+	if (ch->sc->sc_dying)
+		return;
+
+	/* Pick the next channel buffer. */
+	cb = &ch->chanbufs[ch->curchanbuf];
+	if (++ch->curchanbuf >= UAUDIO_NCHANBUFS)
+		ch->curchanbuf = 0;
+
+	/* Compute the size of each frame in the next transfer. */
+	residue = ch->residue;
+	total = 0;
+	for (i = 0; i < UAUDIO_NFRAMES; i++) {
+		size = ch->bytes_per_frame;
+		cb->sizes[i] = size;
+		cb->offsets[i] = total;
+		total += size;
+	}
+	ch->residue = residue;
+	cb->size = total;
+
+#ifdef USB_DEBUG
+	if (uaudiodebug > 8) {
+		DPRINTF(("uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\n",
+			 cb->buffer, ch->residue));
+		for (i = 0; i < UAUDIO_NFRAMES; i++) {
+			DPRINTF(("   [%d] length %d\n", i, cb->sizes[i]));
+		}
+	}
+#endif
+
+	DPRINTFN(5,("uaudio_chan_rtransfer: transfer xfer=%p\n", cb->xfer));
+	/* Fill the request */
+	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
+			     UAUDIO_NFRAMES, USBD_NO_COPY,
+			     uaudio_chan_rintr);
+
+	(void)usbd_transfer(cb->xfer);
+}
+
+Static void
+uaudio_chan_rintr(usbd_xfer_handle xfer, usbd_private_handle priv,
+		  usbd_status status)
+{
+	struct chanbuf *cb = priv;
+	struct chan *ch = cb->chan;
+	u_int32_t count;
+	int s, i, n, frsize;
+
+	/* Return if we are aborting. */
+	if (status == USBD_CANCELLED)
+		return;
+
+	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
+	DPRINTFN(5,("uaudio_chan_rintr: count=%d, transferred=%d\n",
+		    count, ch->transferred));
+
+	/* count < cb->size is normal for asynchronous source */
+#ifdef DIAGNOSTIC
+	if (count > cb->size) {
+		printf("uaudio_chan_rintr: count(%d) > size(%d)\n",
+		       count, cb->size);
+	}
+#endif
+
+	/*
+	 * Transfer data from channel buffer to upper layer buffer, taking
+	 * care of wrapping the upper layer buffer.
+	 */
+	for(i = 0; i < UAUDIO_NFRAMES; i++) {
+		frsize = cb->sizes[i];
+		n = min(frsize, ch->end - ch->cur);
+		memcpy(ch->cur, cb->buffer + cb->offsets[i], n);
+		ch->cur += n;
+		if (ch->cur >= ch->end)
+			ch->cur = ch->start;
+		if (frsize > n) {
+			memcpy(ch->cur, cb->buffer + cb->offsets[i] + n,
+			    frsize - n);
+			ch->cur += frsize - n;
+		}
+	}
+
+	/* Call back to upper layer */
+	ch->transferred += count;
+#if defined(__FreeBSD__)
+	s = spltty();
+	chn_intr(ch->pcm_ch);
+	splx(s);
+#else
+	s = splaudio();
+	while (ch->transferred >= ch->blksize) {
+		ch->transferred -= ch->blksize;
+		DPRINTFN(5,("uaudio_chan_rintr: call %p(%p)\n",
+			    ch->intr, ch->arg));
+		ch->intr(ch->arg);
+	}
+	splx(s);
+#endif
+
+	/* start next transfer */
+	uaudio_chan_rtransfer(ch);
+}
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+Static void
+uaudio_chan_init(struct chan *ch, int altidx, const struct audio_params *param,
+    int maxpktsize)
+{
+	int samples_per_frame, sample_size;
+
+	ch->altidx = altidx;
+	sample_size = param->precision * param->factor * param->hw_channels / 8;
+	samples_per_frame = param->hw_sample_rate / USB_FRAMES_PER_SECOND;
+	ch->sample_size = sample_size;
+	ch->sample_rate = param->hw_sample_rate;
+	if (maxpktsize == 0) {
+		ch->fraction = param->hw_sample_rate % USB_FRAMES_PER_SECOND;
+		ch->bytes_per_frame = samples_per_frame * sample_size;
+	} else {
+		ch->fraction = 0;
+		ch->bytes_per_frame = maxpktsize;
+	}
+	ch->residue = 0;
+}
+
+Static void
+uaudio_chan_set_param(struct chan *ch, u_char *start, u_char *end, int blksize)
+{
+	ch->start = start;
+	ch->end = end;
+	ch->cur = start;
+	ch->blksize = blksize;
+	ch->transferred = 0;
+	ch->curchanbuf = 0;
+}
+
+Static void
+uaudio_get_minmax_rates(int nalts, const struct as_info *alts,
+			const struct audio_params *p, int mode,
+			u_long *min, u_long *max)
+{
+	const struct usb_audio_streaming_type1_descriptor *a1d;
+	int i, j;
+
+	*min = ULONG_MAX;
+	*max = 0;
+	for (i = 0; i < nalts; i++) {
+		a1d = alts[i].asf1desc;
+		if (alts[i].sc_busy)
+			continue;
+		if (p->hw_channels != a1d->bNrChannels)
+			continue;
+		if (p->hw_precision != a1d->bBitResolution)
+			continue;
+		if (p->hw_encoding != alts[i].encoding)
+			continue;
+		if (mode != UE_GET_DIR(alts[i].edesc->bEndpointAddress))
+			continue;
+		if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
+			DPRINTFN(2,("uaudio_get_minmax_rates: cont %d-%d\n",
+				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
+			if (UA_SAMP_LO(a1d) < *min)
+				*min = UA_SAMP_LO(a1d);
+			if (UA_SAMP_HI(a1d) > *max)
+				*max = UA_SAMP_HI(a1d);
+		} else {
+			for (j = 0; j < a1d->bSamFreqType; j++) {
+				DPRINTFN(2,("uaudio_get_minmax_rates: disc #%d: %d\n",
+					    j, UA_GETSAMP(a1d, j)));
+				if (UA_GETSAMP(a1d, j) < *min)
+					*min = UA_GETSAMP(a1d, j);
+				if (UA_GETSAMP(a1d, j) > *max)
+					*max = UA_GETSAMP(a1d, j);
+			}
+		}
+	}
+}
+
+Static int
+uaudio_match_alt_sub(int nalts, const struct as_info *alts,
+		     const struct audio_params *p, int mode, u_long rate)
+{
+	const struct usb_audio_streaming_type1_descriptor *a1d;
+	int i, j;
+
+	DPRINTF(("uaudio_match_alt_sub: search for %luHz %dch\n",
+		 rate, p->hw_channels));
+	for (i = 0; i < nalts; i++) {
+		a1d = alts[i].asf1desc;
+		if (alts[i].sc_busy)
+			continue;
+		if (p->hw_channels != a1d->bNrChannels)
+			continue;
+		if (p->hw_precision != a1d->bBitResolution)
+			continue;
+		if (p->hw_encoding != alts[i].encoding)
+			continue;
+		if (mode != UE_GET_DIR(alts[i].edesc->bEndpointAddress))
+			continue;
+		if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
+			DPRINTFN(3,("uaudio_match_alt_sub: cont %d-%d\n",
+				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
+			if (UA_SAMP_LO(a1d) <= rate && rate <= UA_SAMP_HI(a1d))
+				return i;
+		} else {
+			for (j = 0; j < a1d->bSamFreqType; j++) {
+				DPRINTFN(3,("uaudio_match_alt_sub: disc #%d: %d\n",
+					    j, UA_GETSAMP(a1d, j)));
+				/* XXX allow for some slack */
+				if (UA_GETSAMP(a1d, j) == rate)
+					return i;
+			}
+		}
+	}
+	return -1;
+}
+
+Static int
+uaudio_match_alt_chan(int nalts, const struct as_info *alts,
+		      struct audio_params *p, int mode)
+{
+	int i, n;
+	u_long min, max;
+	u_long rate;
+
+	/* Exact match */
+	DPRINTF(("uaudio_match_alt_chan: examine %ldHz %dch %dbit.\n",
+		 p->sample_rate, p->hw_channels, p->hw_precision));
+	i = uaudio_match_alt_sub(nalts, alts, p, mode, p->sample_rate);
+	if (i >= 0)
+		return i;
+
+	uaudio_get_minmax_rates(nalts, alts, p, mode, &min, &max);
+	DPRINTF(("uaudio_match_alt_chan: min=%lu max=%lu\n", min, max));
+	if (max <= 0)
+		return -1;
+	/* Search for biggers */
+	n = 2;
+	while ((rate = p->sample_rate * n++) <= max) {
+		i = uaudio_match_alt_sub(nalts, alts, p, mode, rate);
+		if (i >= 0) {
+			p->hw_sample_rate = rate;
+			return i;
+		}
+	}
+	if (p->sample_rate >= min) {
+		i = uaudio_match_alt_sub(nalts, alts, p, mode, max);
+		if (i >= 0) {
+			p->hw_sample_rate = max;
+			return i;
+		}
+	} else {
+		i = uaudio_match_alt_sub(nalts, alts, p, mode, min);
+		if (i >= 0) {
+			p->hw_sample_rate = min;
+			return i;
+		}
+	}
+	return -1;
+}
+
+Static int
+uaudio_match_alt(int nalts, const struct as_info *alts,
+		 struct audio_params *p, int mode)
+{
+	int i, n;
+
+	mode = mode == AUMODE_PLAY ? UE_DIR_OUT : UE_DIR_IN;
+	i = uaudio_match_alt_chan(nalts, alts, p, mode);
+	if (i >= 0)
+		return i;
+
+	for (n = p->channels + 1; n <= AUDIO_MAX_CHANNELS; n++) {
+		p->hw_channels = n;
+		i = uaudio_match_alt_chan(nalts, alts, p, mode);
+		if (i >= 0)
+			return i;
+	}
+
+	if (p->channels != 2)
+		return -1;
+	p->hw_channels = 1;
+	return uaudio_match_alt_chan(nalts, alts, p, mode);
+}
+
+Static int
+uaudio_set_params(void *addr, int setmode, int usemode,
+		  struct audio_params *play, struct audio_params *rec)
+{
+	struct uaudio_softc *sc;
+	int flags;
+	int factor;
+	int enc, i;
+	int paltidx, raltidx;
+	void (*swcode)(void *, u_char *buf, int cnt);
+	struct audio_params *p;
+	int mode;
+
+	sc = addr;
+	flags = sc->sc_altflags;
+	paltidx = -1;
+	raltidx = -1;
+	if (sc->sc_dying)
+		return EIO;
+
+	if (((usemode & AUMODE_PLAY) && sc->sc_playchan.pipe != NULL) ||
+	    ((usemode & AUMODE_RECORD) && sc->sc_recchan.pipe != NULL))
+		return EBUSY;
+
+	if ((usemode & AUMODE_PLAY) && sc->sc_playchan.altidx != -1)
+		sc->sc_alts[sc->sc_playchan.altidx].sc_busy = 0;
+	if ((usemode & AUMODE_RECORD) && sc->sc_recchan.altidx != -1)
+		sc->sc_alts[sc->sc_recchan.altidx].sc_busy = 0;
+
+	/* Some uaudio devices are unidirectional.  Don't try to find a
+	   matching mode for the unsupported direction. */
+	setmode &= sc->sc_mode;
+
+	for (mode = AUMODE_RECORD; mode != -1;
+	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
+		if ((setmode & mode) == 0)
+			continue;
+
+		p = (mode == AUMODE_PLAY) ? play : rec;
+
+		factor = 1;
+		swcode = 0;
+		enc = p->encoding;
+		switch (enc) {
+		case AUDIO_ENCODING_SLINEAR_BE:
+			/* FALLTHROUGH */
+		case AUDIO_ENCODING_SLINEAR_LE:
+			if (enc == AUDIO_ENCODING_SLINEAR_BE
+			    && p->precision == 16 && (flags & HAS_16)) {
+				swcode = swap_bytes;
+				enc = AUDIO_ENCODING_SLINEAR_LE;
+			} else if (p->precision == 8) {
+				if (flags & HAS_8) {
+					/* No conversion */
+				} else if (flags & HAS_8U) {
+					swcode = change_sign8;
+					enc = AUDIO_ENCODING_ULINEAR_LE;
+				} else if (flags & HAS_16) {
+					factor = 2;
+					p->hw_precision = 16;
+					if (mode == AUMODE_PLAY)
+						swcode = linear8_to_linear16_le;
+					else
+						swcode = linear16_to_linear8_le;
+				}
+			}
+			break;
+		case AUDIO_ENCODING_ULINEAR_BE:
+			/* FALLTHROUGH */
+		case AUDIO_ENCODING_ULINEAR_LE:
+			if (p->precision == 16) {
+				if (enc == AUDIO_ENCODING_ULINEAR_LE)
+					swcode = change_sign16_le;
+				else if (mode == AUMODE_PLAY)
+					swcode = swap_bytes_change_sign16_le;
+				else
+					swcode = change_sign16_swap_bytes_le;
+				enc = AUDIO_ENCODING_SLINEAR_LE;
+			} else if (p->precision == 8) {
+				if (flags & HAS_8U) {
+					/* No conversion */
+				} else if (flags & HAS_8) {
+					swcode = change_sign8;
+					enc = AUDIO_ENCODING_SLINEAR_LE;
+				} else if (flags & HAS_16) {
+					factor = 2;
+					p->hw_precision = 16;
+					enc = AUDIO_ENCODING_SLINEAR_LE;
+					if (mode == AUMODE_PLAY)
+						swcode = ulinear8_to_slinear16_le;
+					else
+						swcode = slinear16_to_ulinear8_le;
+				}
+			}
+			break;
+		case AUDIO_ENCODING_ULAW:
+			if (flags & HAS_MULAW)
+				break;
+			if (flags & HAS_16) {
+				if (mode == AUMODE_PLAY)
+					swcode = mulaw_to_slinear16_le;
+				else
+					swcode = slinear16_to_mulaw_le;
+				factor = 2;
+				enc = AUDIO_ENCODING_SLINEAR_LE;
+				p->hw_precision = 16;
+			} else if (flags & HAS_8U) {
+				if (mode == AUMODE_PLAY)
+					swcode = mulaw_to_ulinear8;
+				else
+					swcode = ulinear8_to_mulaw;
+				enc = AUDIO_ENCODING_ULINEAR_LE;
+			} else if (flags & HAS_8) {
+				if (mode == AUMODE_PLAY)
+					swcode = mulaw_to_slinear8;
+				else
+					swcode = slinear8_to_mulaw;
+				enc = AUDIO_ENCODING_SLINEAR_LE;
+			} else
+				return (EINVAL);
+			break;
+		case AUDIO_ENCODING_ALAW:
+			if (flags & HAS_ALAW)
+				break;
+			if (mode == AUMODE_PLAY && (flags & HAS_16)) {
+				swcode = alaw_to_slinear16_le;
+				factor = 2;
+				enc = AUDIO_ENCODING_SLINEAR_LE;
+				p->hw_precision = 16;
+			} else if (flags & HAS_8U) {
+				if (mode == AUMODE_PLAY)
+					swcode = alaw_to_ulinear8;
+				else
+					swcode = ulinear8_to_alaw;
+				enc = AUDIO_ENCODING_ULINEAR_LE;
+			} else if (flags & HAS_8) {
+				if (mode == AUMODE_PLAY)
+					swcode = alaw_to_slinear8;
+				else
+					swcode = slinear8_to_alaw;
+				enc = AUDIO_ENCODING_SLINEAR_LE;
+			} else
+				return (EINVAL);
+			break;
+		default:
+			return (EINVAL);
+		}
+		/* XXX do some other conversions... */
+
+		DPRINTF(("uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\n",
+			 p->channels, p->hw_precision, enc, p->sample_rate));
+
+		p->hw_encoding = enc;
+		i = uaudio_match_alt(sc->sc_nalts, sc->sc_alts, p, mode);
+		if (i < 0)
+			return (EINVAL);
+
+		p->sw_code = swcode;
+		p->factor  = factor;
+
+		if (mode == AUMODE_PLAY)
+			paltidx = i;
+		else
+			raltidx = i;
+	}
+
+	if ((setmode & AUMODE_PLAY)) {
+		/* XXX abort transfer if currently happening? */
+		uaudio_chan_init(&sc->sc_playchan, paltidx, play, 0);
+	}
+	if ((setmode & AUMODE_RECORD)) {
+		/* XXX abort transfer if currently happening? */
+		uaudio_chan_init(&sc->sc_recchan, raltidx, rec,
+		    UGETW(sc->sc_alts[raltidx].edesc->wMaxPacketSize));
+	}
+
+	if ((usemode & AUMODE_PLAY) && sc->sc_playchan.altidx != -1)
+		sc->sc_alts[sc->sc_playchan.altidx].sc_busy = 1;
+	if ((usemode & AUMODE_RECORD) && sc->sc_recchan.altidx != -1)
+		sc->sc_alts[sc->sc_recchan.altidx].sc_busy = 1;
+
+	DPRINTF(("uaudio_set_params: use altidx=p%d/r%d, altno=p%d/r%d\n",
+		 sc->sc_playchan.altidx, sc->sc_recchan.altidx,
+		 (sc->sc_playchan.altidx >= 0)
+		   ?sc->sc_alts[sc->sc_playchan.altidx].idesc->bAlternateSetting
+		   : -1,
+		 (sc->sc_recchan.altidx >= 0)
+		   ? sc->sc_alts[sc->sc_recchan.altidx].idesc->bAlternateSetting
+		   : -1));
+
+	return 0;
+}
+#endif /* NetBSD or OpenBSD */
+
+Static usbd_status
+uaudio_set_speed(struct uaudio_softc *sc, int endpt, u_int speed)
+{
+	usb_device_request_t req;
+	uint8_t data[3];
+
+	DPRINTFN(5,("uaudio_set_speed: endpt=%d speed=%u\n", endpt, speed));
+	req.bmRequestType = UT_WRITE_CLASS_ENDPOINT;
+	req.bRequest = SET_CUR;
+	USETW2(req.wValue, SAMPLING_FREQ_CONTROL, 0);
+	USETW(req.wIndex, endpt);
+	USETW(req.wLength, 3);
+	data[0] = speed;
+	data[1] = speed >> 8;
+	data[2] = speed >> 16;
+
+	return usbd_do_request(sc->sc_udev, &req, data);
+}
+
+
+#if defined(__FreeBSD__)
+/************************************************************/
+int
+uaudio_init_params(struct uaudio_softc *sc, struct chan *ch, int mode)
+{
+	int i, j, enc;
+	int samples_per_frame, sample_size;
+
+	if ((sc->sc_playchan.pipe != NULL) || (sc->sc_recchan.pipe != NULL))
+		return (-1);
+
+	switch(ch->format & 0x000FFFFF) {
+	case AFMT_U8:
+		enc = AUDIO_ENCODING_ULINEAR_LE;
+		ch->precision = 8;
+		break;
+	case AFMT_S8:
+		enc = AUDIO_ENCODING_SLINEAR_LE;
+		ch->precision = 8;
+		break;
+	case AFMT_A_LAW:	/* ? */
+		enc = AUDIO_ENCODING_ALAW;
+		ch->precision = 8;
+		break;
+	case AFMT_MU_LAW:	/* ? */
+		enc = AUDIO_ENCODING_ULAW;
+		ch->precision = 8;
+		break;
+	case AFMT_S16_LE:
+		enc = AUDIO_ENCODING_SLINEAR_LE;
+		ch->precision = 16;
+		break;
+	case AFMT_S16_BE:
+		enc = AUDIO_ENCODING_SLINEAR_BE;
+		ch->precision = 16;
+		break;
+	case AFMT_U16_LE:
+		enc = AUDIO_ENCODING_ULINEAR_LE;
+		ch->precision = 16;
+		break;
+	case AFMT_U16_BE:
+		enc = AUDIO_ENCODING_ULINEAR_BE;
+		ch->precision = 16;
+		break;
+	case AFMT_S24_LE:
+		enc = AUDIO_ENCODING_SLINEAR_LE;
+		ch->precision = 24;
+		break;
+	case AFMT_S24_BE:
+		enc = AUDIO_ENCODING_SLINEAR_BE;
+		ch->precision = 24;
+		break;
+	case AFMT_U24_LE:
+		enc = AUDIO_ENCODING_ULINEAR_LE;
+		ch->precision = 24;
+		break;
+	case AFMT_U24_BE:
+		enc = AUDIO_ENCODING_ULINEAR_BE;
+		ch->precision = 24;
+		break;
+	case AFMT_S32_LE:
+		enc = AUDIO_ENCODING_SLINEAR_LE;
+		ch->precision = 32;
+		break;
+	case AFMT_S32_BE:
+		enc = AUDIO_ENCODING_SLINEAR_BE;
+		ch->precision = 32;
+		break;
+	case AFMT_U32_LE:
+		enc = AUDIO_ENCODING_ULINEAR_LE;
+		ch->precision = 32;
+		break;
+	case AFMT_U32_BE:
+		enc = AUDIO_ENCODING_ULINEAR_BE;
+		ch->precision = 32;
+		break;
+	default:
+		enc = 0;
+		ch->precision = 16;
+		printf("Unknown format %x\n", ch->format);
+	}
+
+	if (ch->format & AFMT_STEREO) {
+		ch->channels = 2;
+	} else {
+		ch->channels = 1;
+	}
+
+/*	for (mode =  ......	 */
+		for (i = 0; i < sc->sc_nalts; i++) {
+			const struct usb_audio_streaming_type1_descriptor *a1d =
+				sc->sc_alts[i].asf1desc;
+			if (ch->channels == a1d->bNrChannels &&
+			    ch->precision == a1d->bBitResolution &&
+#if 0
+			    enc == sc->sc_alts[i].encoding) {
+#else
+			    enc == sc->sc_alts[i].encoding &&
+			    (mode == AUMODE_PLAY ? UE_DIR_OUT : UE_DIR_IN) ==
+			    UE_GET_DIR(sc->sc_alts[i].edesc->bEndpointAddress)) {
+#endif
+				if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
+					DPRINTFN(2,("uaudio_set_params: cont %d-%d\n",
+					    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
+					if (UA_SAMP_LO(a1d) <= ch->sample_rate &&
+					    ch->sample_rate <= UA_SAMP_HI(a1d)) {
+						if (mode == AUMODE_PLAY)
+							sc->sc_playchan.altidx = i;
+						else
+							sc->sc_recchan.altidx = i;
+						goto found;
+					}
+				} else {
+					for (j = 0; j < a1d->bSamFreqType; j++) {
+						DPRINTFN(2,("uaudio_set_params: disc #"
+						    "%d: %d\n", j, UA_GETSAMP(a1d, j)));
+						/* XXX allow for some slack */
+						if (UA_GETSAMP(a1d, j) ==
+						    ch->sample_rate) {
+							if (mode == AUMODE_PLAY)
+								sc->sc_playchan.altidx = i;
+							else
+								sc->sc_recchan.altidx = i;
+							goto found;
+						}
+					}
+				}
+			}
+		}
+		/* return (EINVAL); */
+		if (mode == AUMODE_PLAY) 
+			printf("uaudio: This device can't play in rate=%d.\n", ch->sample_rate);
+		else
+			printf("uaudio: This device can't record in rate=%d.\n", ch->sample_rate);
+		return (-1);
+
+	found:
+#if 0 /* XXX */
+		p->sw_code = swcode;
+		p->factor  = factor;
+		if (usemode == mode)
+			sc->sc_curaltidx = i;
+#endif
+/*	} */
+
+	sample_size = ch->precision * ch->channels / 8;
+	samples_per_frame = ch->sample_rate / USB_FRAMES_PER_SECOND;
+	ch->fraction = ch->sample_rate % USB_FRAMES_PER_SECOND;
+	ch->sample_size = sample_size;
+	ch->bytes_per_frame = samples_per_frame * sample_size;
+	ch->residue = 0;
+
+	ch->cur = ch->start;
+	ch->transferred = 0;
+	ch->curchanbuf = 0;
+	return (0);
+}
+
+struct uaudio_conversion {
+	uint8_t uaudio_fmt;
+	uint8_t uaudio_prec;
+	uint32_t freebsd_fmt;
+};
+
+const struct uaudio_conversion const accepted_conversion[] = {
+	{AUDIO_ENCODING_ULINEAR_LE, 8, AFMT_U8},
+	{AUDIO_ENCODING_ULINEAR_LE, 16, AFMT_U16_LE},
+	{AUDIO_ENCODING_ULINEAR_LE, 24, AFMT_U24_LE},
+	{AUDIO_ENCODING_ULINEAR_LE, 32, AFMT_U32_LE},
+	{AUDIO_ENCODING_ULINEAR_BE, 16, AFMT_U16_BE},
+	{AUDIO_ENCODING_ULINEAR_BE, 24, AFMT_U24_BE},
+	{AUDIO_ENCODING_ULINEAR_BE, 32, AFMT_U32_BE},
+	{AUDIO_ENCODING_SLINEAR_LE, 8, AFMT_S8},
+	{AUDIO_ENCODING_SLINEAR_LE, 16, AFMT_S16_LE},
+	{AUDIO_ENCODING_SLINEAR_LE, 24, AFMT_S24_LE},
+	{AUDIO_ENCODING_SLINEAR_LE, 32, AFMT_S32_LE},
+	{AUDIO_ENCODING_SLINEAR_BE, 16, AFMT_S16_BE},
+	{AUDIO_ENCODING_SLINEAR_BE, 24, AFMT_S24_BE},
+	{AUDIO_ENCODING_SLINEAR_BE, 32, AFMT_S32_BE},
+	{AUDIO_ENCODING_ALAW, 8, AFMT_A_LAW},
+	{AUDIO_ENCODING_ULAW, 8, AFMT_MU_LAW},
+	{0,0,0}
+};
+
+unsigned
+uaudio_query_formats(device_t dev, int reqdir, unsigned maxfmt, struct pcmchan_caps *cap)
+{
+	struct uaudio_softc *sc;
+	const struct usb_audio_streaming_type1_descriptor *asf1d;
+	const struct uaudio_conversion *iterator;
+	unsigned fmtcount, foundcount;
+	u_int32_t fmt;
+	uint8_t format, numchan, subframesize, prec, dir, iscontinuous;
+	int freq, freq_min, freq_max;
+	char *numchannel_descr;
+	char freq_descr[64];
+	int i,r;
+
+	sc = device_get_softc(dev);
+	if (sc == NULL)
+		return 0;
+
+	cap->minspeed = cap->maxspeed = 0;
+	foundcount = fmtcount = 0;
+
+	for (i = 0; i < sc->sc_nalts; i++) {
+		dir = UE_GET_DIR(sc->sc_alts[i].edesc->bEndpointAddress);
+
+		if ((dir == UE_DIR_OUT) != (reqdir == PCMDIR_PLAY))
+			continue;
+
+		asf1d = sc->sc_alts[i].asf1desc;
+		format = sc->sc_alts[i].encoding;
+
+		numchan = asf1d->bNrChannels;
+		subframesize = asf1d->bSubFrameSize;
+		prec = asf1d->bBitResolution;	/* precision */
+		iscontinuous = asf1d->bSamFreqType == UA_SAMP_CONTNUOUS;
+
+		if (iscontinuous)
+			snprintf(freq_descr, sizeof(freq_descr), "continous min %d max %d", UA_SAMP_LO(asf1d), UA_SAMP_HI(asf1d));
+		else
+			snprintf(freq_descr, sizeof(freq_descr), "fixed frequency (%d listed formats)", asf1d->bSamFreqType);
+
+		if (numchan == 1)
+			numchannel_descr = " (mono)";
+		else if (numchan == 2)
+			numchannel_descr = " (stereo)";
+		else
+			numchannel_descr = "";
+
+		if (bootverbose) {
+			device_printf(dev, "uaudio_query_formats: found a native %s channel%s %s %dbit %dbytes/subframe X %d channels = %d bytes per sample\n",
+					(dir==UE_DIR_OUT)?"playback":"record",
+					numchannel_descr, freq_descr,
+					prec, subframesize, numchan, subframesize*numchan);
+		}
+		/*
+		 * Now start rejecting the ones that don't map to FreeBSD
+		 */
+
+		if (numchan != 1 && numchan != 2)
+			continue;
+
+		for (iterator = accepted_conversion ; iterator->uaudio_fmt != 0 ; iterator++)
+			if (iterator->uaudio_fmt == format && iterator->uaudio_prec == prec)
+				break;
+
+		if (iterator->uaudio_fmt == 0)
+			continue;
+
+		fmt = iterator->freebsd_fmt;
+
+		if (numchan == 2)
+			fmt |= AFMT_STEREO;
+
+		foundcount++;
+
+		if (fmtcount >= maxfmt)
+			continue;
+
+		cap->fmtlist[fmtcount++] = fmt;
+
+		if (iscontinuous) {
+			freq_min = UA_SAMP_LO(asf1d);
+			freq_max = UA_SAMP_HI(asf1d);
+
+			if (cap->minspeed == 0 || freq_min < cap->minspeed)
+				cap->minspeed = freq_min;
+			if (cap->maxspeed == 0)
+				cap->maxspeed = cap->minspeed;
+			if (freq_max > cap->maxspeed)
+				cap->maxspeed = freq_max;
+		} else {
+			for (r = 0; r < asf1d->bSamFreqType; r++) {
+				freq = UA_GETSAMP(asf1d, r);
+				if (cap->minspeed == 0 || freq < cap->minspeed)
+					cap->minspeed = freq;
+				if (cap->maxspeed == 0)
+					cap->maxspeed = cap->minspeed;
+				if (freq > cap->maxspeed)
+					cap->maxspeed = freq;
+			}
+		}
+	}
+	cap->fmtlist[fmtcount] = 0;
+	return foundcount;
+}
+
+void
+uaudio_chan_set_param_pcm_dma_buff(device_t dev, u_char *start, u_char *end,
+		struct pcm_channel *pc, int dir)
+{
+	struct uaudio_softc *sc;
+	struct chan *ch;
+
+	sc = device_get_softc(dev);
+#ifndef NO_RECORDING
+	if (dir == PCMDIR_PLAY)
+		ch = &sc->sc_playchan;
+	else
+		ch = &sc->sc_recchan;
+#else
+	ch = &sc->sc_playchan;
+#endif
+
+	ch->start = start;
+	ch->end = end;
+
+	ch->pcm_ch = pc;
+
+	return;
+}
+
+void
+uaudio_chan_set_param_blocksize(device_t dev, u_int32_t blocksize, int dir)
+{
+	struct uaudio_softc *sc;
+	struct chan *ch;
+
+	sc = device_get_softc(dev);
+#ifndef NO_RECORDING
+	if (dir == PCMDIR_PLAY)
+		ch = &sc->sc_playchan;
+	else
+		ch = &sc->sc_recchan;
+#else
+	ch = &sc->sc_playchan;
+#endif
+
+	ch->blksize = blocksize;
+
+	return;
+}
+
+int
+uaudio_chan_set_param_speed(device_t dev, u_int32_t speed, int reqdir)
+{
+	const struct uaudio_conversion *iterator;
+	struct uaudio_softc *sc;
+	struct chan *ch;
+	int i, r, score, hiscore, bestspeed;
+
+	sc = device_get_softc(dev);
+#ifndef NO_RECORDING
+	if (reqdir == PCMDIR_PLAY)
+		ch = &sc->sc_playchan;
+	else
+		ch = &sc->sc_recchan;
+#else
+	ch = &sc->sc_playchan;
+#endif
+	/*
+	 * We are successful if we find an endpoint that matches our selected format and it
+	 * supports the requested speed.
+	 */
+	hiscore = 0;
+	bestspeed = 1;
+	for (i = 0; i < sc->sc_nalts; i++) {
+		int dir = UE_GET_DIR(sc->sc_alts[i].edesc->bEndpointAddress);
+		int format = sc->sc_alts[i].encoding;
+		const struct usb_audio_streaming_type1_descriptor *asf1d = sc->sc_alts[i].asf1desc;
+		int iscontinuous = asf1d->bSamFreqType == UA_SAMP_CONTNUOUS;
+
+		if ((dir == UE_DIR_OUT) != (reqdir == PCMDIR_PLAY))
+			continue;
+
+		for (iterator = accepted_conversion ; iterator->uaudio_fmt != 0 ; iterator++)
+			if (iterator->uaudio_fmt != format || iterator->freebsd_fmt != (ch->format&0xfffffff))
+				continue;
+			if (iscontinuous) {
+				if (speed >= UA_SAMP_LO(asf1d) && speed <= UA_SAMP_HI(asf1d)) {
+					ch->sample_rate = speed;
+					return speed;
+				} else if (speed < UA_SAMP_LO(asf1d)) {
+					score = 0xfff * speed / UA_SAMP_LO(asf1d);
+					if (score > hiscore) {
+						bestspeed = UA_SAMP_LO(asf1d);
+						hiscore = score;
+					}
+				} else if (speed < UA_SAMP_HI(asf1d)) {
+					score = 0xfff * UA_SAMP_HI(asf1d) / speed;
+					if (score > hiscore) {
+						bestspeed = UA_SAMP_HI(asf1d);
+						hiscore = score;
+					}
+				}
+				continue;
+			}
+			for (r = 0; r < asf1d->bSamFreqType; r++) {
+				if (speed == UA_GETSAMP(asf1d, r)) {
+					ch->sample_rate = speed;
+					return speed;
+				}
+				if (speed > UA_GETSAMP(asf1d, r))
+					score = 0xfff * UA_GETSAMP(asf1d, r) / speed;
+				else
+					score = 0xfff * speed / UA_GETSAMP(asf1d, r);
+				if (score > hiscore) { 
+					bestspeed = UA_GETSAMP(asf1d, r);
+					hiscore = score;
+				}
+			}
+	}
+	if (bestspeed != 1) {
+		ch->sample_rate = bestspeed;
+		return bestspeed;
+	}
+
+	return 0;
+}
+
+int
+uaudio_chan_getptr(device_t dev, int dir)
+{
+	struct uaudio_softc *sc;
+	struct chan *ch;
+	int ptr;
+
+	sc = device_get_softc(dev);
+#ifndef NO_RECORDING
+	if (dir == PCMDIR_PLAY)
+		ch = &sc->sc_playchan;
+	else
+		ch = &sc->sc_recchan;
+#else
+	ch = &sc->sc_playchan;
+#endif
+
+	ptr = ch->cur - ch->start;
+
+	return ptr;
+}
+
+void
+uaudio_chan_set_param_format(device_t dev, u_int32_t format, int dir)
+{
+	struct uaudio_softc *sc;
+	struct chan *ch;
+
+	sc = device_get_softc(dev);
+#ifndef NO_RECORDING
+	if (dir == PCMDIR_PLAY)
+		ch = &sc->sc_playchan;
+	else
+		ch = &sc->sc_recchan;
+#else
+	ch = &sc->sc_playchan;
+#endif
+
+	ch->format = format;
+
+	return;
+}
+
+int
+uaudio_halt_out_dma(device_t dev)
+{
+	struct uaudio_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	DPRINTF(("uaudio_halt_out_dma: enter\n"));
+	if (sc->sc_playchan.pipe != NULL) {
+		uaudio_chan_close(sc, &sc->sc_playchan);
+		sc->sc_playchan.pipe = 0;
+		uaudio_chan_free_buffers(sc, &sc->sc_playchan);
+	}
+        return (0);
+}
+
+int
+uaudio_halt_in_dma(device_t dev)
+{
+	struct uaudio_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	if (sc->sc_dying)
+		return (EIO);
+
+	DPRINTF(("uaudio_halt_in_dma: enter\n"));
+	if (sc->sc_recchan.pipe != NULL) {
+		uaudio_chan_close(sc, &sc->sc_recchan);
+		sc->sc_recchan.pipe = NULL;
+		uaudio_chan_free_buffers(sc, &sc->sc_recchan);
+/*		sc->sc_recchan.intr = NULL; */
+	}
+	return (0);
+}
+
+int
+uaudio_trigger_input(device_t dev)
+{
+	struct uaudio_softc *sc;
+	struct chan *ch;
+	usbd_status err;
+	int i, s;
+
+	sc = device_get_softc(dev);
+	ch = &sc->sc_recchan;
+
+	if (sc->sc_dying)
+		return (EIO);
+
+/*	uaudio_chan_set_param(ch, start, end, blksize) */
+	if (uaudio_init_params(sc, ch, AUMODE_RECORD))
+		return (EIO);
+
+	err = uaudio_chan_alloc_buffers(sc, ch);
+	if (err)
+		return (EIO);
+
+	err = uaudio_chan_open(sc, ch);
+	if (err) {
+		uaudio_chan_free_buffers(sc, ch);
+		return (EIO);
+	}
+
+/*	ch->intr = intr;
+	ch->arg = arg; */
+
+	s = splusb();
+	for (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX -1 shouldn't be needed */
+		uaudio_chan_rtransfer(ch);
+	splx(s);
+
+	return (0);
+}
+
+int
+uaudio_trigger_output(device_t dev)
+{
+	struct uaudio_softc *sc;
+	struct chan *ch;
+	usbd_status err;
+	int i, s;
+
+	sc = device_get_softc(dev);
+	ch = &sc->sc_playchan;
+
+	if (sc->sc_dying)
+		return (EIO);
+
+	if (uaudio_init_params(sc, ch, AUMODE_PLAY))
+		return (EIO);
+
+	err = uaudio_chan_alloc_buffers(sc, ch);
+	if (err)
+		return (EIO);
+
+	err = uaudio_chan_open(sc, ch);
+	if (err) {
+		uaudio_chan_free_buffers(sc, ch);
+		return (EIO);
+	}
+
+	s = splusb();
+	for (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX */
+		uaudio_chan_ptransfer(ch);
+	splx(s);
+
+        return (0);
+}
+
+u_int32_t
+uaudio_query_mix_info(device_t dev)
+{
+	int i;
+	u_int32_t mask = 0;
+	struct uaudio_softc *sc;
+	struct mixerctl *mc;
+
+	sc = device_get_softc(dev);
+	for (i=0; i < sc->sc_nctls; i++) {
+		mc = &sc->sc_ctls[i];
+		if (mc->ctl != SOUND_MIXER_NRDEVICES) {
+			/* Set device mask bits. 
+			   See /usr/include/machine/soundcard.h */
+			mask |= (1 << mc->ctl);
+		}
+	}
+	return mask;
+}
+
+u_int32_t
+uaudio_query_recsrc_info(device_t dev)
+{
+	int i, rec_selector_id;
+	u_int32_t mask = 0;
+	struct uaudio_softc *sc;
+	struct mixerctl *mc;
+
+	sc = device_get_softc(dev);
+	rec_selector_id = -1;
+	for (i=0; i < sc->sc_nctls; i++) {
+		mc = &sc->sc_ctls[i];
+		if (mc->ctl == SOUND_MIXER_NRDEVICES && 
+		    mc->type == MIX_SELECTOR && mc->class == UAC_RECORD) {
+			if (rec_selector_id == -1) {
+				rec_selector_id = i;
+			} else {
+				printf("There are many selectors.  Can't recognize which selector is a record source selector.\n");
+				return mask;
+			}
+		}
+	}
+	if (rec_selector_id == -1)
+		return mask;
+	mc = &sc->sc_ctls[rec_selector_id];
+	for (i = mc->minval; i <= mc->maxval; i++) {
+		if (mc->slctrtype[i - 1] == SOUND_MIXER_NRDEVICES)
+			continue;
+		mask |= 1 << mc->slctrtype[i - 1];
+	}
+	return mask;
+}
+
+void
+uaudio_mixer_set(device_t dev, unsigned type, unsigned left, unsigned right)
+{
+	int i;
+	struct uaudio_softc *sc;
+	struct mixerctl *mc;
+
+	sc = device_get_softc(dev);
+	for (i=0; i < sc->sc_nctls; i++) {
+		mc = &sc->sc_ctls[i];
+		if (mc->ctl == type) {
+			if (mc->nchan == 2) {
+				/* set Right */
+				uaudio_ctl_set(sc, SET_CUR, mc, 1, (int)(right*255)/100);
+			}
+			/* set Left or Mono */
+			uaudio_ctl_set(sc, SET_CUR, mc, 0, (int)(left*255)/100);
+		}
+	}
+	return;
+}
+
+u_int32_t
+uaudio_mixer_setrecsrc(device_t dev, u_int32_t src)
+{
+	int i, rec_selector_id;
+	struct uaudio_softc *sc;
+	struct mixerctl *mc;
+
+	sc = device_get_softc(dev);
+	rec_selector_id = -1;
+	for (i=0; i < sc->sc_nctls; i++) {
+		mc = &sc->sc_ctls[i];
+		if (mc->ctl == SOUND_MIXER_NRDEVICES && 
+		    mc->type == MIX_SELECTOR && mc->class == UAC_RECORD) {
+			if (rec_selector_id == -1) {
+				rec_selector_id = i;
+			} else {
+				return src; /* Can't recognize which selector is record source selector */
+			}
+		}
+	}
+	if (rec_selector_id == -1)
+		return src;
+	mc = &sc->sc_ctls[rec_selector_id];
+	for (i = mc->minval; i <= mc->maxval; i++) {
+		if (src != (1 << mc->slctrtype[i - 1]))
+			continue;
+		uaudio_ctl_set(sc, SET_CUR, mc, 0, i);
+		return (1 << mc->slctrtype[i - 1]);
+	}
+	uaudio_ctl_set(sc, SET_CUR, mc, 0, mc->minval);
+	return (1 << mc->slctrtype[mc->minval - 1]);
+}
+
+static int
+uaudio_sndstat_prepare_pcm(struct sbuf *s, device_t dev, int verbose)
+{
+    	struct snddev_info *d;
+    	struct snddev_channel *sce;
+	struct pcm_channel *c;
+	struct pcm_feeder *f;
+    	int pc, rc, vc;
+	device_t pa_dev = device_get_parent(dev);
+	struct uaudio_softc *sc = device_get_softc(pa_dev);
+
+	if (verbose < 1)
+		return 0;
+
+	d = device_get_softc(dev);
+	if (!d)
+		return ENXIO;
+
+	snd_mtxlock(d->lock);
+	if (SLIST_EMPTY(&d->channels)) {
+		sbuf_printf(s, " (mixer only)");
+		snd_mtxunlock(d->lock);
+		return 0;
+	}
+	pc = rc = vc = 0;
+	SLIST_FOREACH(sce, &d->channels, link) {
+		c = sce->channel;
+		if (c->direction == PCMDIR_PLAY) {
+			if (c->flags & CHN_F_VIRTUAL)
+				vc++;
+			else
+				pc++;
+		} else
+			rc++;
+	}
+	sbuf_printf(s, " (%dp/%dr/%dv channels%s%s)", 
+			d->playcount, d->reccount, d->vchancount,
+			(d->flags & SD_F_SIMPLEX)? "" : " duplex",
+#ifdef USING_DEVFS
+			(device_get_unit(dev) == snd_unit)? " default" : ""
+#else
+			""
+#endif
+			);
+
+	if (sc->uaudio_sndstat_flag != 0) {
+		sbuf_cat(s, sbuf_data(&(sc->uaudio_sndstat)));
+	}
+
+	if (verbose <= 1) {
+		snd_mtxunlock(d->lock);
+		return 0;
+	}
+
+	SLIST_FOREACH(sce, &d->channels, link) {
+		c = sce->channel;
+		sbuf_printf(s, "\n\t");
+
+		KASSERT(c->bufhard != NULL && c->bufsoft != NULL,
+			("hosed pcm channel setup"));
+
+		/* it would be better to indent child channels */
+		sbuf_printf(s, "%s[%s]: ", c->parentchannel? c->parentchannel->name : "", c->name);
+		sbuf_printf(s, "spd %d", c->speed);
+		if (c->speed != sndbuf_getspd(c->bufhard))
+			sbuf_printf(s, "/%d", sndbuf_getspd(c->bufhard));
+		sbuf_printf(s, ", fmt 0x%08x", c->format);
+		if (c->format != sndbuf_getfmt(c->bufhard))
+			sbuf_printf(s, "/0x%08x", sndbuf_getfmt(c->bufhard));
+		sbuf_printf(s, ", flags 0x%08x, 0x%08x", c->flags, c->feederflags);
+		if (c->pid != -1)
+			sbuf_printf(s, ", pid %d", c->pid);
+		sbuf_printf(s, "\n\t");
+
+		sbuf_printf(s, "interrupts %d, ", c->interrupts);
+		if (c->direction == PCMDIR_REC)
+			sbuf_printf(s, "overruns %d, hfree %d, sfree %d",
+				c->xruns, sndbuf_getfree(c->bufhard), sndbuf_getfree(c->bufsoft));
+		else
+			sbuf_printf(s, "underruns %d, ready %d",
+				c->xruns, sndbuf_getready(c->bufsoft));
+		sbuf_printf(s, "\n\t");
+
+		sbuf_printf(s, "{%s}", (c->direction == PCMDIR_REC)? "hardware" : "userland");
+		sbuf_printf(s, " -> ");
+		f = c->feeder;
+		while (f->source != NULL)
+			f = f->source;
+		while (f != NULL) {
+			sbuf_printf(s, "%s", f->class->name);
+			if (f->desc->type == FEEDER_FMT)
+				sbuf_printf(s, "(0x%08x -> 0x%08x)", f->desc->in, f->desc->out);
+			if (f->desc->type == FEEDER_RATE)
+				sbuf_printf(s, "(%d -> %d)", FEEDER_GET(f, FEEDRATE_SRC), FEEDER_GET(f, FEEDRATE_DST));
+			if (f->desc->type == FEEDER_ROOT || f->desc->type == FEEDER_MIXER)
+				sbuf_printf(s, "(0x%08x)", f->desc->out);
+			sbuf_printf(s, " -> ");
+			f = f->parent;
+		}
+		sbuf_printf(s, "{%s}", (c->direction == PCMDIR_REC)? "userland" : "hardware");
+	}
+	snd_mtxunlock(d->lock);
+
+	return 0;
+}
+
+void
+uaudio_sndstat_register(device_t dev)
+{
+	struct snddev_info *d = device_get_softc(dev);
+	sndstat_register(dev, d->status, uaudio_sndstat_prepare_pcm);
+}
+	
+Static int
+audio_attach_mi(device_t dev)
+{
+	device_t child;
+	struct sndcard_func *func;
+
+	/* Attach the children. */
+	/* PCM Audio */
+	func = malloc(sizeof(struct sndcard_func), M_DEVBUF, M_NOWAIT);
+	if (func == NULL)
+		return (ENOMEM);
+	bzero(func, sizeof(*func));
+	func->func = SCF_PCM;
+	child = device_add_child(dev, "pcm", -1);
+	device_set_ivars(child, func);
+
+	bus_generic_attach(dev);
+
+	return 0; /* XXXXX */
+}
+
+DRIVER_MODULE(uaudio, uhub, uaudio_driver, uaudio_devclass, usbd_driver_load, 0);
+MODULE_VERSION(uaudio, 1);
+
+#endif
diff -rubN /usr/src1/src/sys/dev/sound/usb/uaudio.c.rej /usr/src/sys/dev/sound/usb/uaudio.c.rej
--- /usr/src1/src/sys/dev/sound/usb/uaudio.c.rej	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/sound/usb/uaudio.c.rej	Thu Jun  8 21:13:09 2006
@@ -0,0 +1,18 @@
+***************
+*** 3687,3695 ****
+  	int i, j, enc;
+  	int samples_per_frame, sample_size;
+  
+- 	if ((sc->sc_playchan.pipe != NULL) || (sc->sc_recchan.pipe != NULL))
+- 		return (-1);
+- 
+  	switch(ch->format & 0x0000FFFF) {
+  	case AFMT_U8:
+  		enc = AUDIO_ENCODING_ULINEAR_LE;
+--- 3687,3692 ----
+  	int i, j, enc;
+  	int samples_per_frame, sample_size;
+  
+  	switch(ch->format & 0x0000FFFF) {
+  	case AFMT_U8:
+  		enc = AUDIO_ENCODING_ULINEAR_LE;
diff -rubN /usr/src1/src/sys/dev/usb/hid.c /usr/src/sys/dev/usb/hid.c
--- /usr/src1/src/sys/dev/usb/hid.c	Sat Mar 25 04:46:52 2006
+++ /usr/src/sys/dev/usb/hid.c	Thu Jun  8 21:13:09 2006
@@ -55,7 +55,6 @@
 #ifdef USB_DEBUG
 #define DPRINTF(x)	if (usbdebug) logprintf x
 #define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
-extern int usbdebug;
 #else
 #define DPRINTF(x)
 #define DPRINTFN(n,x)
diff -rubN /usr/src1/src/sys/dev/usb/hid.c.orig /usr/src/sys/dev/usb/hid.c.orig
--- /usr/src1/src/sys/dev/usb/hid.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/hid.c.orig	Sat Mar 25 04:46:52 2006
@@ -0,0 +1,463 @@
+/*	$NetBSD: hid.c,v 1.17 2001/11/13 06:24:53 lukem Exp $	*/
+
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/usb/hid.c,v 1.25.2.1 2006/03/25 04:46:52 iedowse Exp $");
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#if defined(__NetBSD__)
+#include <sys/kernel.h>
+#endif
+#include <sys/malloc.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbhid.h>
+
+#include <dev/usb/hid.h>
+
+#ifdef USB_DEBUG
+#define DPRINTF(x)	if (usbdebug) logprintf x
+#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
+extern int usbdebug;
+#else
+#define DPRINTF(x)
+#define DPRINTFN(n,x)
+#endif
+
+Static void hid_clear_local(struct hid_item *);
+
+#define MAXUSAGE 100
+struct hid_data {
+	u_char *start;
+	u_char *end;
+	u_char *p;
+	struct hid_item cur;
+	int32_t usages[MAXUSAGE];
+	int nu;
+	int minset;
+	int multi;
+	int multimax;
+	int kindset;
+};
+
+Static void
+hid_clear_local(struct hid_item *c)
+{
+
+	c->usage = 0;
+	c->usage_minimum = 0;
+	c->usage_maximum = 0;
+	c->designator_index = 0;
+	c->designator_minimum = 0;
+	c->designator_maximum = 0;
+	c->string_index = 0;
+	c->string_minimum = 0;
+	c->string_maximum = 0;
+	c->set_delimiter = 0;
+}
+
+struct hid_data *
+hid_start_parse(void *d, int len, int kindset)
+{
+	struct hid_data *s;
+
+	s = malloc(sizeof *s, M_TEMP, M_WAITOK|M_ZERO);
+	s->start = s->p = d;
+	s->end = (char *)d + len;
+	s->kindset = kindset;
+	return (s);
+}
+
+void
+hid_end_parse(struct hid_data *s)
+{
+
+	while (s->cur.next != NULL) {
+		struct hid_item *hi = s->cur.next->next;
+		free(s->cur.next, M_TEMP);
+		s->cur.next = hi;
+	}
+	free(s, M_TEMP);
+}
+
+int
+hid_get_item(struct hid_data *s, struct hid_item *h)
+{
+	struct hid_item *c = &s->cur;
+	unsigned int bTag, bType, bSize;
+	u_int32_t oldpos;
+	u_char *data;
+	int32_t dval;
+	u_char *p;
+	struct hid_item *hi;
+	int i;
+
+ top:
+	if (s->multimax != 0) {
+		if (s->multi < s->multimax) {
+			c->usage = s->usages[min(s->multi, s->nu-1)];
+			s->multi++;
+			*h = *c;
+			c->loc.pos += c->loc.size;
+			h->next = 0;
+			return (1);
+		} else {
+			c->loc.count = s->multimax;
+			s->multimax = 0;
+			s->nu = 0;
+			hid_clear_local(c);
+		}
+	}
+	for (;;) {
+		p = s->p;
+		if (p >= s->end)
+			return (0);
+
+		bSize = *p++;
+		if (bSize == 0xfe) {
+			/* long item */
+			bSize = *p++;
+			bSize |= *p++ << 8;
+			bTag = *p++;
+			data = p;
+			p += bSize;
+			bType = 0xff; /* XXX what should it be */
+		} else {
+			/* short item */
+			bTag = bSize >> 4;
+			bType = (bSize >> 2) & 3;
+			bSize &= 3;
+			if (bSize == 3) bSize = 4;
+			data = p;
+			p += bSize;
+		}
+		s->p = p;
+		switch(bSize) {
+		case 0:
+			dval = 0;
+			break;
+		case 1:
+			dval = (int8_t)*data++;
+			break;
+		case 2:
+			dval = *data++;
+			dval |= *data++ << 8;
+			dval = (int16_t)dval;
+			break;
+		case 4:
+			dval = *data++;
+			dval |= *data++ << 8;
+			dval |= *data++ << 16;
+			dval |= *data++ << 24;
+			break;
+		default:
+			printf("BAD LENGTH %d\n", bSize);
+			continue;
+		}
+
+		switch (bType) {
+		case 0:			/* Main */
+			switch (bTag) {
+			case 8:		/* Input */
+				if (!(s->kindset & (1 << hid_input)))
+					continue;
+				c->kind = hid_input;
+				c->flags = dval;
+			ret:
+				if (c->flags & HIO_VARIABLE) {
+					s->multimax = c->loc.count;
+					s->multi = 0;
+					c->loc.count = 1;
+					if (s->minset) {
+						for (i = c->usage_minimum;
+						     i <= c->usage_maximum;
+						     i++) {
+							s->usages[s->nu] = i;
+							if (s->nu < MAXUSAGE-1)
+								s->nu++;
+						}
+						s->minset = 0;
+					}
+					goto top;
+				} else {
+					*h = *c;
+					h->next = 0;
+					c->loc.pos +=
+						c->loc.size * c->loc.count;
+					hid_clear_local(c);
+					s->minset = 0;
+					return (1);
+				}
+			case 9:		/* Output */
+				if (!(s->kindset & (1 << hid_output)))
+					continue;
+				c->kind = hid_output;
+				c->flags = dval;
+				goto ret;
+			case 10:	/* Collection */
+				c->kind = hid_collection;
+				c->collection = dval;
+				c->collevel++;
+				*h = *c;
+				hid_clear_local(c);
+				s->nu = 0;
+				return (1);
+			case 11:	/* Feature */
+				if (!(s->kindset & (1 << hid_feature)))
+					continue;
+				c->kind = hid_feature;
+				c->flags = dval;
+				goto ret;
+			case 12:	/* End collection */
+				c->kind = hid_endcollection;
+				c->collevel--;
+				*h = *c;
+				hid_clear_local(c);
+				s->nu = 0;
+				return (1);
+			default:
+				printf("Main bTag=%d\n", bTag);
+				break;
+			}
+			break;
+		case 1:		/* Global */
+			switch (bTag) {
+			case 0:
+				c->_usage_page = dval << 16;
+				break;
+			case 1:
+				c->logical_minimum = dval;
+				break;
+			case 2:
+				c->logical_maximum = dval;
+				break;
+			case 3:
+				c->physical_maximum = dval;
+				break;
+			case 4:
+				c->physical_maximum = dval;
+				break;
+			case 5:
+				c->unit_exponent = dval;
+				break;
+			case 6:
+				c->unit = dval;
+				break;
+			case 7:
+				c->loc.size = dval;
+				break;
+			case 8:
+				c->report_ID = dval;
+				break;
+			case 9:
+				c->loc.count = dval;
+				break;
+			case 10: /* Push */
+				hi = malloc(sizeof *hi, M_TEMP, M_WAITOK);
+				*hi = s->cur;
+				c->next = hi;
+				break;
+			case 11: /* Pop */
+				hi = c->next;
+				oldpos = c->loc.pos;
+				s->cur = *hi;
+				c->loc.pos = oldpos;
+				free(hi, M_TEMP);
+				break;
+			default:
+				printf("Global bTag=%d\n", bTag);
+				break;
+			}
+			break;
+		case 2:		/* Local */
+			switch (bTag) {
+			case 0:
+				if (bSize == 1)
+					dval = c->_usage_page | (dval&0xff);
+				else if (bSize == 2)
+					dval = c->_usage_page | (dval&0xffff);
+				c->usage = dval;
+				if (s->nu < MAXUSAGE)
+					s->usages[s->nu++] = dval;
+				/* else XXX */
+				break;
+			case 1:
+				s->minset = 1;
+				if (bSize == 1)
+					dval = c->_usage_page | (dval&0xff);
+				else if (bSize == 2)
+					dval = c->_usage_page | (dval&0xffff);
+				c->usage_minimum = dval;
+				break;
+			case 2:
+				if (bSize == 1)
+					dval = c->_usage_page | (dval&0xff);
+				else if (bSize == 2)
+					dval = c->_usage_page | (dval&0xffff);
+				c->usage_maximum = dval;
+				break;
+			case 3:
+				c->designator_index = dval;
+				break;
+			case 4:
+				c->designator_minimum = dval;
+				break;
+			case 5:
+				c->designator_maximum = dval;
+				break;
+			case 7:
+				c->string_index = dval;
+				break;
+			case 8:
+				c->string_minimum = dval;
+				break;
+			case 9:
+				c->string_maximum = dval;
+				break;
+			case 10:
+				c->set_delimiter = dval;
+				break;
+			default:
+				printf("Local bTag=%d\n", bTag);
+				break;
+			}
+			break;
+		default:
+			printf("default bType=%d\n", bType);
+			break;
+		}
+	}
+}
+
+int
+hid_report_size(void *buf, int len, enum hid_kind k, u_int8_t *idp)
+{
+	struct hid_data *d;
+	struct hid_item h;
+	int hi, lo, size, id;
+
+	id = 0;
+	hi = lo = -1;
+	for (d = hid_start_parse(buf, len, 1<<k); hid_get_item(d, &h); )
+		if (h.kind == k) {
+			if (h.report_ID != 0 && !id)
+				id = h.report_ID;
+			if (h.report_ID == id) {
+				if (lo < 0)
+					lo = h.loc.pos;
+				hi = h.loc.pos + h.loc.size * h.loc.count;
+			}
+		}
+	hid_end_parse(d);
+	size = hi - lo;
+	if (id != 0) {
+		size += 8;
+		*idp = id;	/* XXX wrong */
+	} else
+		*idp = 0;
+	return ((size + 7) / 8);
+}
+
+int
+hid_locate(void *desc, int size, u_int32_t u, enum hid_kind k,
+	   struct hid_location *loc, u_int32_t *flags)
+{
+	struct hid_data *d;
+	struct hid_item h;
+
+	for (d = hid_start_parse(desc, size, 1<<k); hid_get_item(d, &h); ) {
+		if (h.kind == k && !(h.flags & HIO_CONST) && h.usage == u) {
+			if (loc != NULL)
+				*loc = h.loc;
+			if (flags != NULL)
+				*flags = h.flags;
+			hid_end_parse(d);
+			return (1);
+		}
+	}
+	hid_end_parse(d);
+	loc->size = 0;
+	return (0);
+}
+
+u_long
+hid_get_data(u_char *buf, struct hid_location *loc)
+{
+	u_int hpos = loc->pos;
+	u_int hsize = loc->size;
+	u_int32_t data;
+	int i, s;
+
+	DPRINTFN(10, ("hid_get_data: loc %d/%d\n", hpos, hsize));
+
+	if (hsize == 0)
+		return (0);
+
+	data = 0;
+	s = hpos / 8;
+	for (i = hpos; i < hpos+hsize; i += 8)
+		data |= buf[i / 8] << ((i / 8 - s) * 8);
+	data >>= hpos % 8;
+	data &= (1 << hsize) - 1;
+	hsize = 32 - hsize;
+	/* Sign extend */
+	data = ((int32_t)data << hsize) >> hsize;
+	DPRINTFN(10,("hid_get_data: loc %d/%d = %lu\n",
+		    loc->pos, loc->size, (long)data));
+	return (data);
+}
+
+int
+hid_is_collection(void *desc, int size, u_int32_t usage)
+{
+	struct hid_data *hd;
+	struct hid_item hi;
+	int err;
+
+	hd = hid_start_parse(desc, size, hid_input);
+	if (hd == NULL)
+		return (0);
+
+	err = hid_get_item(hd, &hi) &&
+	    hi.kind == hid_collection &&
+	    hi.usage == usage;
+	hid_end_parse(hd);
+	return (err);
+}
diff -rubN /usr/src1/src/sys/dev/usb/if_ural.c /usr/src/sys/dev/usb/if_ural.c
--- /usr/src1/src/sys/dev/usb/if_ural.c	Mon Apr  3 17:18:22 2006
+++ /usr/src/sys/dev/usb/if_ural.c	Thu Jun  8 21:13:09 2006
@@ -37,11 +37,6 @@
 #include <sys/bus.h>
 #include <sys/endian.h>
 
-#include <machine/bus.h>
-#include <machine/resource.h>
-#include <machine/clock.h>
-#include <sys/rman.h>
-
 #include <net/bpf.h>
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -808,8 +803,12 @@
 ural_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
 {
 	struct ural_softc *sc = ic->ic_ifp->if_softc;
-
+#if 0
 	usb_rem_task(sc->sc_udev, &sc->sc_task);
+#else
+	printf("%s: cannot call usb_rem_task here, "
+	       "because it can sleep! (fixme)\n", __FUNCTION__);
+#endif
 	callout_stop(&sc->scan_ch);
 	callout_stop(&sc->amrr_ch);
 
diff -rubN /usr/src1/src/sys/dev/usb/if_ural.c.orig /usr/src/sys/dev/usb/if_ural.c.orig
--- /usr/src1/src/sys/dev/usb/if_ural.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/if_ural.c.orig	Mon Apr  3 17:18:22 2006
@@ -0,0 +1,2403 @@
+/*	$FreeBSD: src/sys/dev/usb/if_ural.c,v 1.10.2.7 2006/04/03 17:18:22 sam Exp $	*/
+
+/*-
+ * Copyright (c) 2005, 2006
+ *	Damien Bergamini <damien.bergamini@free.fr>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/usb/if_ural.c,v 1.10.2.7 2006/04/03 17:18:22 sam Exp $");
+
+/*-
+ * Ralink Technology RT2500USB chipset driver
+ * http://www.ralinktech.com/
+ */
+
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/sockio.h>
+#include <sys/mbuf.h>
+#include <sys/kernel.h>
+#include <sys/socket.h>
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/endian.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <machine/clock.h>
+#include <sys/rman.h>
+
+#include <net/bpf.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <net/ethernet.h>
+#include <net/if_dl.h>
+#include <net/if_media.h>
+#include <net/if_types.h>
+
+#include <net80211/ieee80211_var.h>
+#include <net80211/ieee80211_radiotap.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/in_var.h>
+#include <netinet/ip.h>
+#include <netinet/if_ether.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include "usbdevs.h"
+
+#include <dev/usb/if_uralreg.h>
+#include <dev/usb/if_uralvar.h>
+
+#ifdef USB_DEBUG
+#define DPRINTF(x)	do { if (uraldebug > 0) logprintf x; } while (0)
+#define DPRINTFN(n, x)	do { if (uraldebug >= (n)) logprintf x; } while (0)
+int uraldebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, ural, CTLFLAG_RW, 0, "USB ural");
+SYSCTL_INT(_hw_usb_ural, OID_AUTO, debug, CTLFLAG_RW, &uraldebug, 0,
+    "ural debug level");
+#else
+#define DPRINTF(x)
+#define DPRINTFN(n, x)
+#endif
+
+/* various supported device vendors/products */
+static const struct usb_devno ural_devs[] = {
+	{ USB_VENDOR_ASUS,		USB_PRODUCT_ASUS_WL167G },
+	{ USB_VENDOR_ASUS,		USB_PRODUCT_RALINK_RT2570 },
+	{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D7050 },
+	{ USB_VENDOR_CONCEPTRONIC,	USB_PRODUCT_CONCEPTRONIC_C54U },
+	{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DWLG122 },
+	{ USB_VENDOR_GIGABYTE,		USB_PRODUCT_GIGABYTE_GNWBKG },
+	{ USB_VENDOR_GUILLEMOT,		USB_PRODUCT_GUILLEMOT_HWGUSB254 },
+	{ USB_VENDOR_LINKSYS4,		USB_PRODUCT_LINKSYS4_WUSB54G },
+	{ USB_VENDOR_LINKSYS4,		USB_PRODUCT_LINKSYS4_WUSB54GP },
+	{ USB_VENDOR_LINKSYS4,		USB_PRODUCT_LINKSYS4_HU200TS },
+	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_KG54 },
+	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_KG54AI },
+	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_KG54YB },
+	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_NINWIFI },
+	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2570 },
+	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2570_2 },
+	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2570_3 },
+	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2570 },
+	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2570_2 },
+	{ USB_VENDOR_VTECH,		USB_PRODUCT_VTECH_RT2570 },
+	{ USB_VENDOR_ZINWELL,		USB_PRODUCT_ZINWELL_RT2570 }
+};
+
+MODULE_DEPEND(ural, wlan, 1, 1, 1);
+
+Static int		ural_alloc_tx_list(struct ural_softc *);
+Static void		ural_free_tx_list(struct ural_softc *);
+Static int		ural_alloc_rx_list(struct ural_softc *);
+Static void		ural_free_rx_list(struct ural_softc *);
+Static int		ural_media_change(struct ifnet *);
+Static void		ural_next_scan(void *);
+Static void		ural_task(void *);
+Static int		ural_newstate(struct ieee80211com *,
+			    enum ieee80211_state, int);
+Static int		ural_rxrate(struct ural_rx_desc *);
+Static void		ural_txeof(usbd_xfer_handle, usbd_private_handle,
+			    usbd_status);
+Static void		ural_rxeof(usbd_xfer_handle, usbd_private_handle,
+			    usbd_status);
+Static int		ural_ack_rate(struct ieee80211com *, int);
+Static uint16_t		ural_txtime(int, int, uint32_t);
+Static uint8_t		ural_plcp_signal(int);
+Static void		ural_setup_tx_desc(struct ural_softc *,
+			    struct ural_tx_desc *, uint32_t, int, int);
+Static int		ural_tx_bcn(struct ural_softc *, struct mbuf *,
+			    struct ieee80211_node *);
+Static int		ural_tx_mgt(struct ural_softc *, struct mbuf *,
+			    struct ieee80211_node *);
+Static int		ural_tx_data(struct ural_softc *, struct mbuf *,
+			    struct ieee80211_node *);
+Static void		ural_start(struct ifnet *);
+Static void		ural_watchdog(struct ifnet *);
+Static int		ural_reset(struct ifnet *);
+Static int		ural_ioctl(struct ifnet *, u_long, caddr_t);
+Static void		ural_set_testmode(struct ural_softc *);
+Static void		ural_eeprom_read(struct ural_softc *, uint16_t, void *,
+			    int);
+Static uint16_t		ural_read(struct ural_softc *, uint16_t);
+Static void		ural_read_multi(struct ural_softc *, uint16_t, void *,
+			    int);
+Static void		ural_write(struct ural_softc *, uint16_t, uint16_t);
+Static void		ural_write_multi(struct ural_softc *, uint16_t, void *,
+			    int);
+Static void		ural_bbp_write(struct ural_softc *, uint8_t, uint8_t);
+Static uint8_t		ural_bbp_read(struct ural_softc *, uint8_t);
+Static void		ural_rf_write(struct ural_softc *, uint8_t, uint32_t);
+Static void		ural_set_chan(struct ural_softc *,
+			    struct ieee80211_channel *);
+Static void		ural_disable_rf_tune(struct ural_softc *);
+Static void		ural_enable_tsf_sync(struct ural_softc *);
+Static void		ural_update_slot(struct ifnet *);
+Static void		ural_set_txpreamble(struct ural_softc *);
+Static void		ural_set_basicrates(struct ural_softc *);
+Static void		ural_set_bssid(struct ural_softc *, uint8_t *);
+Static void		ural_set_macaddr(struct ural_softc *, uint8_t *);
+Static void		ural_update_promisc(struct ural_softc *);
+Static const char	*ural_get_rf(int);
+Static void		ural_read_eeprom(struct ural_softc *);
+Static int		ural_bbp_init(struct ural_softc *);
+Static void		ural_set_txantenna(struct ural_softc *, int);
+Static void		ural_set_rxantenna(struct ural_softc *, int);
+Static void		ural_init(void *);
+Static void		ural_stop(void *);
+Static void		ural_amrr_start(struct ural_softc *,
+			    struct ieee80211_node *);
+Static void		ural_amrr_timeout(void *);
+Static void		ural_amrr_update(usbd_xfer_handle, usbd_private_handle,
+			    usbd_status status);
+Static void		ural_ratectl(struct ural_amrr *,
+			    struct ieee80211_node *);
+
+/*
+ * Supported rates for 802.11a/b/g modes (in 500Kbps unit).
+ */
+static const struct ieee80211_rateset ural_rateset_11a =
+	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };
+
+static const struct ieee80211_rateset ural_rateset_11b =
+	{ 4, { 2, 4, 11, 22 } };
+
+static const struct ieee80211_rateset ural_rateset_11g =
+	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };
+
+/*
+ * Default values for MAC registers; values taken from the reference driver.
+ */
+static const struct {
+	uint16_t	reg;
+	uint16_t	val;
+} ural_def_mac[] = {
+	{ RAL_TXRX_CSR5,  0x8c8d },
+	{ RAL_TXRX_CSR6,  0x8b8a },
+	{ RAL_TXRX_CSR7,  0x8687 },
+	{ RAL_TXRX_CSR8,  0x0085 },
+	{ RAL_MAC_CSR13,  0x1111 },
+	{ RAL_MAC_CSR14,  0x1e11 },
+	{ RAL_TXRX_CSR21, 0xe78f },
+	{ RAL_MAC_CSR9,   0xff1d },
+	{ RAL_MAC_CSR11,  0x0002 },
+	{ RAL_MAC_CSR22,  0x0053 },
+	{ RAL_MAC_CSR15,  0x0000 },
+	{ RAL_MAC_CSR8,   0x0780 },
+	{ RAL_TXRX_CSR19, 0x0000 },
+	{ RAL_TXRX_CSR18, 0x005a },
+	{ RAL_PHY_CSR2,   0x0000 },
+	{ RAL_TXRX_CSR0,  0x1ec0 },
+	{ RAL_PHY_CSR4,   0x000f }
+};
+
+/*
+ * Default values for BBP registers; values taken from the reference driver.
+ */
+static const struct {
+	uint8_t	reg;
+	uint8_t	val;
+} ural_def_bbp[] = {
+	{  3, 0x02 },
+	{  4, 0x19 },
+	{ 14, 0x1c },
+	{ 15, 0x30 },
+	{ 16, 0xac },
+	{ 17, 0x48 },
+	{ 18, 0x18 },
+	{ 19, 0xff },
+	{ 20, 0x1e },
+	{ 21, 0x08 },
+	{ 22, 0x08 },
+	{ 23, 0x08 },
+	{ 24, 0x80 },
+	{ 25, 0x50 },
+	{ 26, 0x08 },
+	{ 27, 0x23 },
+	{ 30, 0x10 },
+	{ 31, 0x2b },
+	{ 32, 0xb9 },
+	{ 34, 0x12 },
+	{ 35, 0x50 },
+	{ 39, 0xc4 },
+	{ 40, 0x02 },
+	{ 41, 0x60 },
+	{ 53, 0x10 },
+	{ 54, 0x18 },
+	{ 56, 0x08 },
+	{ 57, 0x10 },
+	{ 58, 0x08 },
+	{ 61, 0x60 },
+	{ 62, 0x10 },
+	{ 75, 0xff }
+};
+
+/*
+ * Default values for RF register R2 indexed by channel numbers.
+ */
+static const uint32_t ural_rf2522_r2[] = {
+	0x307f6, 0x307fb, 0x30800, 0x30805, 0x3080a, 0x3080f, 0x30814,
+	0x30819, 0x3081e, 0x30823, 0x30828, 0x3082d, 0x30832, 0x3083e
+};
+
+static const uint32_t ural_rf2523_r2[] = {
+	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,
+	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346
+};
+
+static const uint32_t ural_rf2524_r2[] = {
+	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,
+	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346
+};
+
+static const uint32_t ural_rf2525_r2[] = {
+	0x20327, 0x20328, 0x20329, 0x2032a, 0x2032b, 0x2032c, 0x2032d,
+	0x2032e, 0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20346
+};
+
+static const uint32_t ural_rf2525_hi_r2[] = {
+	0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20344, 0x20345,
+	0x20346, 0x20347, 0x20348, 0x20349, 0x2034a, 0x2034b, 0x2034e
+};
+
+static const uint32_t ural_rf2525e_r2[] = {
+	0x2044d, 0x2044e, 0x2044f, 0x20460, 0x20461, 0x20462, 0x20463,
+	0x20464, 0x20465, 0x20466, 0x20467, 0x20468, 0x20469, 0x2046b
+};
+
+static const uint32_t ural_rf2526_hi_r2[] = {
+	0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d, 0x0022d,
+	0x0022e, 0x0022e, 0x0022f, 0x0022d, 0x00240, 0x00240, 0x00241
+};
+
+static const uint32_t ural_rf2526_r2[] = {
+	0x00226, 0x00227, 0x00227, 0x00228, 0x00228, 0x00229, 0x00229,
+	0x0022a, 0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d
+};
+
+/*
+ * For dual-band RF, RF registers R1 and R4 also depend on channel number;
+ * values taken from the reference driver.
+ */
+static const struct {
+	uint8_t		chan;
+	uint32_t	r1;
+	uint32_t	r2;
+	uint32_t	r4;
+} ural_rf5222[] = {
+	{   1, 0x08808, 0x0044d, 0x00282 },
+	{   2, 0x08808, 0x0044e, 0x00282 },
+	{   3, 0x08808, 0x0044f, 0x00282 },
+	{   4, 0x08808, 0x00460, 0x00282 },
+	{   5, 0x08808, 0x00461, 0x00282 },
+	{   6, 0x08808, 0x00462, 0x00282 },
+	{   7, 0x08808, 0x00463, 0x00282 },
+	{   8, 0x08808, 0x00464, 0x00282 },
+	{   9, 0x08808, 0x00465, 0x00282 },
+	{  10, 0x08808, 0x00466, 0x00282 },
+	{  11, 0x08808, 0x00467, 0x00282 },
+	{  12, 0x08808, 0x00468, 0x00282 },
+	{  13, 0x08808, 0x00469, 0x00282 },
+	{  14, 0x08808, 0x0046b, 0x00286 },
+
+	{  36, 0x08804, 0x06225, 0x00287 },
+	{  40, 0x08804, 0x06226, 0x00287 },
+	{  44, 0x08804, 0x06227, 0x00287 },
+	{  48, 0x08804, 0x06228, 0x00287 },
+	{  52, 0x08804, 0x06229, 0x00287 },
+	{  56, 0x08804, 0x0622a, 0x00287 },
+	{  60, 0x08804, 0x0622b, 0x00287 },
+	{  64, 0x08804, 0x0622c, 0x00287 },
+
+	{ 100, 0x08804, 0x02200, 0x00283 },
+	{ 104, 0x08804, 0x02201, 0x00283 },
+	{ 108, 0x08804, 0x02202, 0x00283 },
+	{ 112, 0x08804, 0x02203, 0x00283 },
+	{ 116, 0x08804, 0x02204, 0x00283 },
+	{ 120, 0x08804, 0x02205, 0x00283 },
+	{ 124, 0x08804, 0x02206, 0x00283 },
+	{ 128, 0x08804, 0x02207, 0x00283 },
+	{ 132, 0x08804, 0x02208, 0x00283 },
+	{ 136, 0x08804, 0x02209, 0x00283 },
+	{ 140, 0x08804, 0x0220a, 0x00283 },
+
+	{ 149, 0x08808, 0x02429, 0x00281 },
+	{ 153, 0x08808, 0x0242b, 0x00281 },
+	{ 157, 0x08808, 0x0242d, 0x00281 },
+	{ 161, 0x08808, 0x0242f, 0x00281 }
+};
+
+USB_DECLARE_DRIVER(ural);
+
+USB_MATCH(ural)
+{
+	USB_MATCH_START(ural, uaa);
+
+	if (uaa->iface != NULL)
+		return UMATCH_NONE;
+
+	return (usb_lookup(ural_devs, uaa->vendor, uaa->product) != NULL) ?
+	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
+}
+
+USB_ATTACH(ural)
+{
+	USB_ATTACH_START(ural, sc, uaa);
+	struct ifnet *ifp;
+	struct ieee80211com *ic = &sc->sc_ic;
+	usb_interface_descriptor_t *id;
+	usb_endpoint_descriptor_t *ed;
+	usbd_status error;
+	char devinfo[1024];
+	int i;
+
+	sc->sc_udev = uaa->device;
+
+	usbd_devinfo(sc->sc_udev, 0, devinfo);
+	USB_ATTACH_SETUP;
+
+	if (usbd_set_config_no(sc->sc_udev, RAL_CONFIG_NO, 0) != 0) {
+		printf("%s: could not set configuration no\n",
+		    USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	/* get the first interface handle */
+	error = usbd_device2interface_handle(sc->sc_udev, RAL_IFACE_INDEX,
+	    &sc->sc_iface);
+	if (error != 0) {
+		printf("%s: could not get interface handle\n",
+		    USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	/*
+	 * Find endpoints.
+	 */
+	id = usbd_get_interface_descriptor(sc->sc_iface);
+
+	sc->sc_rx_no = sc->sc_tx_no = -1;
+	for (i = 0; i < id->bNumEndpoints; i++) {
+		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
+		if (ed == NULL) {
+			printf("%s: no endpoint descriptor for %d\n",
+			    USBDEVNAME(sc->sc_dev), i);
+			USB_ATTACH_ERROR_RETURN;
+		}
+
+		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
+		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
+			sc->sc_rx_no = ed->bEndpointAddress;
+		else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
+		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
+			sc->sc_tx_no = ed->bEndpointAddress;
+	}
+	if (sc->sc_rx_no == -1 || sc->sc_tx_no == -1) {
+		printf("%s: missing endpoint\n", USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	mtx_init(&sc->sc_mtx, USBDEVNAME(sc->sc_dev), MTX_NETWORK_LOCK,
+	    MTX_DEF | MTX_RECURSE);
+
+	usb_init_task(&sc->sc_task, ural_task, sc);
+	callout_init(&sc->scan_ch, debug_mpsafenet ? CALLOUT_MPSAFE : 0);
+	callout_init(&sc->amrr_ch, 0);
+
+	/* retrieve RT2570 rev. no */
+	sc->asic_rev = ural_read(sc, RAL_MAC_CSR0);
+
+	/* retrieve MAC address and various other things from EEPROM */
+	ural_read_eeprom(sc);
+
+	printf("%s: MAC/BBP RT2570 (rev 0x%02x), RF %s\n",
+	    USBDEVNAME(sc->sc_dev), sc->asic_rev, ural_get_rf(sc->rf_rev));
+
+	ifp = sc->sc_ifp = if_alloc(IFT_ETHER);
+	if (ifp == NULL) {
+		printf("%s: can not if_alloc()\n", USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	ifp->if_softc = sc;
+	if_initname(ifp, "ural", USBDEVUNIT(sc->sc_dev));
+	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST |
+	    IFF_NEEDSGIANT; /* USB stack is still under Giant lock */
+	ifp->if_init = ural_init;
+	ifp->if_ioctl = ural_ioctl;
+	ifp->if_start = ural_start;
+	ifp->if_watchdog = ural_watchdog;
+	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
+	ifp->if_snd.ifq_drv_maxlen = IFQ_MAXLEN;
+	IFQ_SET_READY(&ifp->if_snd);
+
+	ic->ic_ifp = ifp;
+	ic->ic_phytype = IEEE80211_T_OFDM; /* not only, but not used */
+	ic->ic_opmode = IEEE80211_M_STA; /* default to BSS mode */
+	ic->ic_state = IEEE80211_S_INIT;
+
+	/* set device capabilities */
+	ic->ic_caps =
+	    IEEE80211_C_IBSS |		/* IBSS mode supported */
+	    IEEE80211_C_MONITOR |	/* monitor mode supported */
+	    IEEE80211_C_HOSTAP |	/* HostAp mode supported */
+	    IEEE80211_C_TXPMGT |	/* tx power management */
+	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
+	    IEEE80211_C_SHSLOT |	/* short slot time supported */
+	    IEEE80211_C_WPA;		/* 802.11i */
+
+	if (sc->rf_rev == RAL_RF_5222) {
+		/* set supported .11a rates */
+		ic->ic_sup_rates[IEEE80211_MODE_11A] = ural_rateset_11a;
+
+		/* set supported .11a channels */
+		for (i = 36; i <= 64; i += 4) {
+			ic->ic_channels[i].ic_freq =
+			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
+			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
+		}
+		for (i = 100; i <= 140; i += 4) {
+			ic->ic_channels[i].ic_freq =
+			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
+			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
+		}
+		for (i = 149; i <= 161; i += 4) {
+			ic->ic_channels[i].ic_freq =
+			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
+			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
+		}
+	}
+
+	/* set supported .11b and .11g rates */
+	ic->ic_sup_rates[IEEE80211_MODE_11B] = ural_rateset_11b;
+	ic->ic_sup_rates[IEEE80211_MODE_11G] = ural_rateset_11g;
+
+	/* set supported .11b and .11g channels (1 through 14) */
+	for (i = 1; i <= 14; i++) {
+		ic->ic_channels[i].ic_freq =
+		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
+		ic->ic_channels[i].ic_flags =
+		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
+		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
+	}
+
+	ieee80211_ifattach(ic);
+	ic->ic_reset = ural_reset;
+	/* enable s/w bmiss handling in sta mode */
+	ic->ic_flags_ext |= IEEE80211_FEXT_SWBMISS;
+
+	/* override state transition machine */
+	sc->sc_newstate = ic->ic_newstate;
+	ic->ic_newstate = ural_newstate;
+	ieee80211_media_init(ic, ural_media_change, ieee80211_media_status);
+
+	bpfattach2(ifp, DLT_IEEE802_11_RADIO,
+	    sizeof (struct ieee80211_frame) + 64, &sc->sc_drvbpf);
+
+	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
+	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
+	sc->sc_rxtap.wr_ihdr.it_present = htole32(RAL_RX_RADIOTAP_PRESENT);
+
+	sc->sc_txtap_len = sizeof sc->sc_txtapu;
+	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
+	sc->sc_txtap.wt_ihdr.it_present = htole32(RAL_TX_RADIOTAP_PRESENT);
+
+	if (bootverbose)
+		ieee80211_announce(ic);
+
+	USB_ATTACH_SUCCESS_RETURN;
+}
+
+USB_DETACH(ural)
+{
+	USB_DETACH_START(ural, sc);
+	struct ieee80211com *ic = &sc->sc_ic;
+	struct ifnet *ifp = ic->ic_ifp;
+
+	ural_stop(sc);
+	usb_rem_task(sc->sc_udev, &sc->sc_task);
+	callout_stop(&sc->scan_ch);
+	callout_stop(&sc->amrr_ch);
+
+	if (sc->amrr_xfer != NULL) {
+		usbd_free_xfer(sc->amrr_xfer);
+		sc->amrr_xfer = NULL;
+	}
+
+	if (sc->sc_rx_pipeh != NULL) {
+		usbd_abort_pipe(sc->sc_rx_pipeh);
+		usbd_close_pipe(sc->sc_rx_pipeh);
+	}
+
+	if (sc->sc_tx_pipeh != NULL) {
+		usbd_abort_pipe(sc->sc_tx_pipeh);
+		usbd_close_pipe(sc->sc_tx_pipeh);
+	}
+
+	ural_free_rx_list(sc);
+	ural_free_tx_list(sc);
+
+	bpfdetach(ifp);
+	ieee80211_ifdetach(ic);
+	if_free(ifp);
+
+	mtx_destroy(&sc->sc_mtx);
+
+	return 0;
+}
+
+Static int
+ural_alloc_tx_list(struct ural_softc *sc)
+{
+	struct ural_tx_data *data;
+	int i, error;
+
+	sc->tx_queued = 0;
+
+	for (i = 0; i < RAL_TX_LIST_COUNT; i++) {
+		data = &sc->tx_data[i];
+
+		data->sc = sc;
+
+		data->xfer = usbd_alloc_xfer(sc->sc_udev);
+		if (data->xfer == NULL) {
+			printf("%s: could not allocate tx xfer\n",
+			    USBDEVNAME(sc->sc_dev));
+			error = ENOMEM;
+			goto fail;
+		}
+
+		data->buf = usbd_alloc_buffer(data->xfer,
+		    RAL_TX_DESC_SIZE + MCLBYTES);
+		if (data->buf == NULL) {
+			printf("%s: could not allocate tx buffer\n",
+			    USBDEVNAME(sc->sc_dev));
+			error = ENOMEM;
+			goto fail;
+		}
+	}
+
+	return 0;
+
+fail:	ural_free_tx_list(sc);
+	return error;
+}
+
+Static void
+ural_free_tx_list(struct ural_softc *sc)
+{
+	struct ural_tx_data *data;
+	int i;
+
+	for (i = 0; i < RAL_TX_LIST_COUNT; i++) {
+		data = &sc->tx_data[i];
+
+		if (data->xfer != NULL) {
+			usbd_free_xfer(data->xfer);
+			data->xfer = NULL;
+		}
+
+		if (data->ni != NULL) {
+			ieee80211_free_node(data->ni);
+			data->ni = NULL;
+		}
+	}
+}
+
+Static int
+ural_alloc_rx_list(struct ural_softc *sc)
+{
+	struct ural_rx_data *data;
+	int i, error;
+
+	for (i = 0; i < RAL_RX_LIST_COUNT; i++) {
+		data = &sc->rx_data[i];
+
+		data->sc = sc;
+
+		data->xfer = usbd_alloc_xfer(sc->sc_udev);
+		if (data->xfer == NULL) {
+			printf("%s: could not allocate rx xfer\n",
+			    USBDEVNAME(sc->sc_dev));
+			error = ENOMEM;
+			goto fail;
+		}
+
+		if (usbd_alloc_buffer(data->xfer, MCLBYTES) == NULL) {
+			printf("%s: could not allocate rx buffer\n",
+			    USBDEVNAME(sc->sc_dev));
+			error = ENOMEM;
+			goto fail;
+		}
+
+		data->m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
+		if (data->m == NULL) {
+			printf("%s: could not allocate rx mbuf\n",
+			    USBDEVNAME(sc->sc_dev));
+			error = ENOMEM;
+			goto fail;
+		}
+
+		data->buf = mtod(data->m, uint8_t *);
+	}
+
+	return 0;
+
+fail:	ural_free_tx_list(sc);
+	return error;
+}
+
+Static void
+ural_free_rx_list(struct ural_softc *sc)
+{
+	struct ural_rx_data *data;
+	int i;
+
+	for (i = 0; i < RAL_RX_LIST_COUNT; i++) {
+		data = &sc->rx_data[i];
+
+		if (data->xfer != NULL) {
+			usbd_free_xfer(data->xfer);
+			data->xfer = NULL;
+		}
+
+		if (data->m != NULL) {
+			m_freem(data->m);
+			data->m = NULL;
+		}
+	}
+}
+
+Static int
+ural_media_change(struct ifnet *ifp)
+{
+	struct ural_softc *sc = ifp->if_softc;
+	int error;
+
+	RAL_LOCK(sc);
+
+	error = ieee80211_media_change(ifp);
+	if (error != ENETRESET) {
+		RAL_UNLOCK(sc);
+		return error;
+	}
+
+	if ((ifp->if_flags & IFF_UP) &&
+	    (ifp->if_drv_flags & IFF_DRV_RUNNING))
+		ural_init(sc);
+
+	RAL_UNLOCK(sc);
+
+	return 0;
+}
+
+/*
+ * This function is called periodically (every 200ms) during scanning to
+ * switch from one channel to another.
+ */
+Static void
+ural_next_scan(void *arg)
+{
+	struct ural_softc *sc = arg;
+	struct ieee80211com *ic = &sc->sc_ic;
+
+	if (ic->ic_state == IEEE80211_S_SCAN)
+		ieee80211_next_scan(ic);
+}
+
+Static void
+ural_task(void *arg)
+{
+	struct ural_softc *sc = arg;
+	struct ieee80211com *ic = &sc->sc_ic;
+	enum ieee80211_state ostate;
+	struct ieee80211_node *ni;
+	struct mbuf *m;
+
+	ostate = ic->ic_state;
+
+	switch (sc->sc_state) {
+	case IEEE80211_S_INIT:
+		if (ostate == IEEE80211_S_RUN) {
+			/* abort TSF synchronization */
+			ural_write(sc, RAL_TXRX_CSR19, 0);
+
+			/* force tx led to stop blinking */
+			ural_write(sc, RAL_MAC_CSR20, 0);
+		}
+		break;
+
+	case IEEE80211_S_SCAN:
+		ural_set_chan(sc, ic->ic_curchan);
+		callout_reset(&sc->scan_ch, hz / 5, ural_next_scan, sc);
+		break;
+
+	case IEEE80211_S_AUTH:
+		ural_set_chan(sc, ic->ic_curchan);
+		break;
+
+	case IEEE80211_S_ASSOC:
+		ural_set_chan(sc, ic->ic_curchan);
+		break;
+
+	case IEEE80211_S_RUN:
+		ural_set_chan(sc, ic->ic_curchan);
+
+		ni = ic->ic_bss;
+
+		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
+			ural_update_slot(ic->ic_ifp);
+			ural_set_txpreamble(sc);
+			ural_set_basicrates(sc);
+			ural_set_bssid(sc, ni->ni_bssid);
+		}
+
+		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
+		    ic->ic_opmode == IEEE80211_M_IBSS) {
+			m = ieee80211_beacon_alloc(ic, ni, &sc->sc_bo);
+			if (m == NULL) {
+				printf("%s: could not allocate beacon\n",
+				    USBDEVNAME(sc->sc_dev));
+				return;
+			}
+
+			if (ural_tx_bcn(sc, m, ni) != 0) {
+				printf("%s: could not send beacon\n",
+				    USBDEVNAME(sc->sc_dev));
+				return;
+			}
+		}
+
+		/* make tx led blink on tx (controlled by ASIC) */
+		ural_write(sc, RAL_MAC_CSR20, 1);
+
+		if (ic->ic_opmode != IEEE80211_M_MONITOR)
+			ural_enable_tsf_sync(sc);
+
+		/* enable automatic rate adaptation in STA mode */
+		if (ic->ic_opmode == IEEE80211_M_STA &&
+		    ic->ic_fixed_rate == IEEE80211_FIXED_RATE_NONE)
+			ural_amrr_start(sc, ni);
+
+		break;
+	}
+
+	sc->sc_newstate(ic, sc->sc_state, -1);
+}
+
+Static int
+ural_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
+{
+	struct ural_softc *sc = ic->ic_ifp->if_softc;
+
+	usb_rem_task(sc->sc_udev, &sc->sc_task);
+	callout_stop(&sc->scan_ch);
+	callout_stop(&sc->amrr_ch);
+
+	/* do it in a process context */
+	sc->sc_state = nstate;
+	usb_add_task(sc->sc_udev, &sc->sc_task);
+
+	return 0;
+}
+
+/* quickly determine if a given rate is CCK or OFDM */
+#define RAL_RATE_IS_OFDM(rate) ((rate) >= 12 && (rate) != 22)
+
+#define RAL_ACK_SIZE	14	/* 10 + 4(FCS) */
+#define RAL_CTS_SIZE	14	/* 10 + 4(FCS) */
+
+#define RAL_SIFS		10	/* us */
+
+#define RAL_RXTX_TURNAROUND	5	/* us */
+
+/*
+ * This function is only used by the Rx radiotap code.
+ */
+Static int
+ural_rxrate(struct ural_rx_desc *desc)
+{
+	if (le32toh(desc->flags) & RAL_RX_OFDM) {
+		/* reverse function of ural_plcp_signal */
+		switch (desc->rate) {
+		case 0xb:	return 12;
+		case 0xf:	return 18;
+		case 0xa:	return 24;
+		case 0xe:	return 36;
+		case 0x9:	return 48;
+		case 0xd:	return 72;
+		case 0x8:	return 96;
+		case 0xc:	return 108;
+		}
+	} else {
+		if (desc->rate == 10)
+			return 2;
+		if (desc->rate == 20)
+			return 4;
+		if (desc->rate == 55)
+			return 11;
+		if (desc->rate == 110)
+			return 22;
+	}
+	return 2;	/* should not get there */
+}
+
+Static void
+ural_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
+{
+	struct ural_tx_data *data = priv;
+	struct ural_softc *sc = data->sc;
+	struct ifnet *ifp = sc->sc_ic.ic_ifp;
+
+	if (status != USBD_NORMAL_COMPLETION) {
+		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
+			return;
+
+		printf("%s: could not transmit buffer: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(status));
+
+		if (status == USBD_STALLED)
+			usbd_clear_endpoint_stall_async(sc->sc_rx_pipeh);
+
+		ifp->if_oerrors++;
+		return;
+	}
+
+	m_freem(data->m);
+	data->m = NULL;
+	ieee80211_free_node(data->ni);
+	data->ni = NULL;
+
+	sc->tx_queued--;
+	ifp->if_opackets++;
+
+	DPRINTFN(10, ("tx done\n"));
+
+	sc->sc_tx_timer = 0;
+	ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+	ural_start(ifp);
+}
+
+Static void
+ural_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
+{
+	struct ural_rx_data *data = priv;
+	struct ural_softc *sc = data->sc;
+	struct ieee80211com *ic = &sc->sc_ic;
+	struct ifnet *ifp = ic->ic_ifp;
+	struct ural_rx_desc *desc;
+	struct ieee80211_frame *wh;
+	struct ieee80211_node *ni;
+	struct mbuf *mnew, *m;
+	int len;
+
+	if (status != USBD_NORMAL_COMPLETION) {
+		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
+			return;
+
+		if (status == USBD_STALLED)
+			usbd_clear_endpoint_stall_async(sc->sc_rx_pipeh);
+		goto skip;
+	}
+
+	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);
+
+	if (len < RAL_RX_DESC_SIZE + IEEE80211_MIN_LEN) {
+		DPRINTF(("%s: xfer too short %d\n", USBDEVNAME(sc->sc_dev),
+		    len));
+		ifp->if_ierrors++;
+		goto skip;
+	}
+
+	/* rx descriptor is located at the end */
+	desc = (struct ural_rx_desc *)(data->buf + len - RAL_RX_DESC_SIZE);
+
+	if ((le32toh(desc->flags) & RAL_RX_PHY_ERROR) ||
+	    (le32toh(desc->flags) & RAL_RX_CRC_ERROR)) {
+		/*
+		 * This should not happen since we did not request to receive
+		 * those frames when we filled RAL_TXRX_CSR2.
+		 */
+		DPRINTFN(5, ("PHY or CRC error\n"));
+		ifp->if_ierrors++;
+		goto skip;
+	}
+
+	mnew = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
+	if (mnew == NULL) {
+		ifp->if_ierrors++;
+		goto skip;
+	}
+
+	m = data->m;
+	data->m = mnew;
+	data->buf = mtod(data->m, uint8_t *);
+
+	/* finalize mbuf */
+	m->m_pkthdr.rcvif = ifp;
+	m->m_pkthdr.len = m->m_len = (le32toh(desc->flags) >> 16) & 0xfff;
+	m->m_flags |= M_HASFCS;	/* h/w leaves FCS */
+
+	if (sc->sc_drvbpf != NULL) {
+		struct ural_rx_radiotap_header *tap = &sc->sc_rxtap;
+
+		tap->wr_flags = IEEE80211_RADIOTAP_F_FCS;   
+		tap->wr_rate = ural_rxrate(desc);
+		tap->wr_chan_freq = htole16(ic->ic_curchan->ic_freq);
+		tap->wr_chan_flags = htole16(ic->ic_curchan->ic_flags);
+		tap->wr_antenna = sc->rx_ant;
+		tap->wr_antsignal = desc->rssi;
+
+		bpf_mtap2(sc->sc_drvbpf, tap, sc->sc_rxtap_len, m);
+	}
+
+	wh = mtod(m, struct ieee80211_frame *);
+	ni = ieee80211_find_rxnode(ic, (struct ieee80211_frame_min *)wh);
+
+	/* send the frame to the 802.11 layer */
+	ieee80211_input(ic, m, ni, desc->rssi, 0);
+
+	/* node is no longer needed */
+	ieee80211_free_node(ni);
+
+	DPRINTFN(15, ("rx done\n"));
+
+skip:	/* setup a new transfer */
+	usbd_setup_xfer(xfer, sc->sc_rx_pipeh, data, data->buf, MCLBYTES,
+	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, ural_rxeof);
+	usbd_transfer(xfer);
+}
+
+/*
+ * Return the expected ack rate for a frame transmitted at rate `rate'.
+ * XXX: this should depend on the destination node basic rate set.
+ */
+Static int
+ural_ack_rate(struct ieee80211com *ic, int rate)
+{
+	switch (rate) {
+	/* CCK rates */
+	case 2:
+		return 2;
+	case 4:
+	case 11:
+	case 22:
+		return (ic->ic_curmode == IEEE80211_MODE_11B) ? 4 : rate;
+
+	/* OFDM rates */
+	case 12:
+	case 18:
+		return 12;
+	case 24:
+	case 36:
+		return 24;
+	case 48:
+	case 72:
+	case 96:
+	case 108:
+		return 48;
+	}
+
+	/* default to 1Mbps */
+	return 2;
+}
+
+/*
+ * Compute the duration (in us) needed to transmit `len' bytes at rate `rate'.
+ * The function automatically determines the operating mode depending on the
+ * given rate. `flags' indicates whether short preamble is in use or not.
+ */
+Static uint16_t
+ural_txtime(int len, int rate, uint32_t flags)
+{
+	uint16_t txtime;
+
+	if (RAL_RATE_IS_OFDM(rate)) {
+		/* IEEE Std 802.11a-1999, pp. 37 */
+		txtime = (8 + 4 * len + 3 + rate - 1) / rate;
+		txtime = 16 + 4 + 4 * txtime + 6;
+	} else {
+		/* IEEE Std 802.11b-1999, pp. 28 */
+		txtime = (16 * len + rate - 1) / rate;
+		if (rate != 2 && (flags & IEEE80211_F_SHPREAMBLE))
+			txtime +=  72 + 24;
+		else
+			txtime += 144 + 48;
+	}
+	return txtime;
+}
+
+Static uint8_t
+ural_plcp_signal(int rate)
+{
+	switch (rate) {
+	/* CCK rates (returned values are device-dependent) */
+	case 2:		return 0x0;
+	case 4:		return 0x1;
+	case 11:	return 0x2;
+	case 22:	return 0x3;
+
+	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
+	case 12:	return 0xb;
+	case 18:	return 0xf;
+	case 24:	return 0xa;
+	case 36:	return 0xe;
+	case 48:	return 0x9;
+	case 72:	return 0xd;
+	case 96:	return 0x8;
+	case 108:	return 0xc;
+
+	/* unsupported rates (should not get there) */
+	default:	return 0xff;
+	}
+}
+
+Static void
+ural_setup_tx_desc(struct ural_softc *sc, struct ural_tx_desc *desc,
+    uint32_t flags, int len, int rate)
+{
+	struct ieee80211com *ic = &sc->sc_ic;
+	uint16_t plcp_length;
+	int remainder;
+
+	desc->flags = htole32(flags);
+	desc->flags |= htole32(RAL_TX_NEWSEQ);
+	desc->flags |= htole32(len << 16);
+
+	desc->wme = htole16(RAL_AIFSN(2) | RAL_LOGCWMIN(3) | RAL_LOGCWMAX(5));
+	desc->wme |= htole16(RAL_IVOFFSET(sizeof (struct ieee80211_frame)));
+
+	/* setup PLCP fields */
+	desc->plcp_signal  = ural_plcp_signal(rate);
+	desc->plcp_service = 4;
+
+	len += IEEE80211_CRC_LEN;
+	if (RAL_RATE_IS_OFDM(rate)) {
+		desc->flags |= htole32(RAL_TX_OFDM);
+
+		plcp_length = len & 0xfff;
+		desc->plcp_length_hi = plcp_length >> 6;
+		desc->plcp_length_lo = plcp_length & 0x3f;
+	} else {
+		plcp_length = (16 * len + rate - 1) / rate;
+		if (rate == 22) {
+			remainder = (16 * len) % 22;
+			if (remainder != 0 && remainder < 7)
+				desc->plcp_service |= RAL_PLCP_LENGEXT;
+		}
+		desc->plcp_length_hi = plcp_length >> 8;
+		desc->plcp_length_lo = plcp_length & 0xff;
+
+		if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
+			desc->plcp_signal |= 0x08;
+	}
+
+	desc->iv = 0;
+	desc->eiv = 0;
+}
+
+#define RAL_TX_TIMEOUT	5000
+
+Static int
+ural_tx_bcn(struct ural_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
+{
+	struct ural_tx_desc *desc;
+	usbd_xfer_handle xfer;
+	uint8_t cmd = 0;
+	usbd_status error;
+	uint8_t *buf;
+	int xferlen, rate;
+
+	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;
+
+	xfer = usbd_alloc_xfer(sc->sc_udev);
+	if (xfer == NULL)
+		return ENOMEM;
+
+	/* xfer length needs to be a multiple of two! */
+	xferlen = (RAL_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;
+
+	buf = usbd_alloc_buffer(xfer, xferlen);
+	if (buf == NULL) {
+		usbd_free_xfer(xfer);
+		return ENOMEM;
+	}
+
+	usbd_setup_xfer(xfer, sc->sc_tx_pipeh, NULL, &cmd, sizeof cmd,
+	    USBD_FORCE_SHORT_XFER, RAL_TX_TIMEOUT, NULL);
+
+	error = usbd_sync_transfer(xfer);
+	if (error != 0) {
+		usbd_free_xfer(xfer);
+		return error;
+	}
+
+	desc = (struct ural_tx_desc *)buf;
+
+	m_copydata(m0, 0, m0->m_pkthdr.len, buf + RAL_TX_DESC_SIZE);
+	ural_setup_tx_desc(sc, desc, RAL_TX_IFS_NEWBACKOFF | RAL_TX_TIMESTAMP,
+	    m0->m_pkthdr.len, rate);
+
+	DPRINTFN(10, ("sending beacon frame len=%u rate=%u xfer len=%u\n",
+	    m0->m_pkthdr.len, rate, xferlen));
+
+	usbd_setup_xfer(xfer, sc->sc_tx_pipeh, NULL, buf, xferlen,
+	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RAL_TX_TIMEOUT, NULL);
+
+	error = usbd_sync_transfer(xfer);
+	usbd_free_xfer(xfer);
+
+	return error;
+}
+
+Static int
+ural_tx_mgt(struct ural_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
+{
+	struct ieee80211com *ic = &sc->sc_ic;
+	struct ural_tx_desc *desc;
+	struct ural_tx_data *data;
+	struct ieee80211_frame *wh;
+	uint32_t flags = 0;
+	uint16_t dur;
+	usbd_status error;
+	int xferlen, rate;
+
+	data = &sc->tx_data[0];
+	desc = (struct ural_tx_desc *)data->buf;
+
+	rate = IEEE80211_IS_CHAN_5GHZ(ic->ic_curchan) ? 12 : 2;
+
+	data->m = m0;
+	data->ni = ni;
+
+	wh = mtod(m0, struct ieee80211_frame *);
+
+	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
+		flags |= RAL_TX_ACK;
+
+		dur = ural_txtime(RAL_ACK_SIZE, rate, ic->ic_flags) + RAL_SIFS;
+		*(uint16_t *)wh->i_dur = htole16(dur);
+
+		/* tell hardware to add timestamp for probe responses */
+		if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
+		    IEEE80211_FC0_TYPE_MGT &&
+		    (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
+		    IEEE80211_FC0_SUBTYPE_PROBE_RESP)
+			flags |= RAL_TX_TIMESTAMP;
+	}
+
+	if (sc->sc_drvbpf != NULL) {
+		struct ural_tx_radiotap_header *tap = &sc->sc_txtap;
+
+		tap->wt_flags = 0;
+		tap->wt_rate = rate;
+		tap->wt_chan_freq = htole16(ic->ic_curchan->ic_freq);
+		tap->wt_chan_flags = htole16(ic->ic_curchan->ic_flags);
+		tap->wt_antenna = sc->tx_ant;
+
+		bpf_mtap2(sc->sc_drvbpf, tap, sc->sc_txtap_len, m0);
+	}
+
+	m_copydata(m0, 0, m0->m_pkthdr.len, data->buf + RAL_TX_DESC_SIZE);
+	ural_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate);
+
+	/* align end on a 2-bytes boundary */
+	xferlen = (RAL_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;
+
+	/*
+	 * No space left in the last URB to store the extra 2 bytes, force
+	 * sending of another URB.
+	 */
+	if ((xferlen % 64) == 0)
+		xferlen += 2;
+
+	DPRINTFN(10, ("sending mgt frame len=%u rate=%u xfer len=%u\n",
+	    m0->m_pkthdr.len, rate, xferlen));
+
+	usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf,
+	    xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RAL_TX_TIMEOUT,
+	    ural_txeof);
+
+	error = usbd_transfer(data->xfer);
+	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS)
+		return error;
+
+	sc->tx_queued++;
+
+	return 0;
+}
+
+Static int
+ural_tx_data(struct ural_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
+{
+	struct ieee80211com *ic = &sc->sc_ic;
+	struct ural_tx_desc *desc;
+	struct ural_tx_data *data;
+	struct ieee80211_frame *wh;
+	struct ieee80211_key *k;
+	uint32_t flags = 0;
+	uint16_t dur;
+	usbd_status error;
+	int xferlen, rate;
+
+	wh = mtod(m0, struct ieee80211_frame *);
+
+	if (ic->ic_fixed_rate != IEEE80211_FIXED_RATE_NONE)
+		rate = ic->ic_bss->ni_rates.rs_rates[ic->ic_fixed_rate];
+	else
+		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
+
+	rate &= IEEE80211_RATE_VAL;
+
+	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
+		k = ieee80211_crypto_encap(ic, ni, m0);
+		if (k == NULL) {
+			m_freem(m0);
+			return ENOBUFS;
+		}
+
+		/* packet header may have moved, reset our local pointer */
+		wh = mtod(m0, struct ieee80211_frame *);
+	}
+
+	data = &sc->tx_data[0];
+	desc = (struct ural_tx_desc *)data->buf;
+
+	data->m = m0;
+	data->ni = ni;
+
+	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
+		flags |= RAL_TX_ACK;
+		flags |= RAL_TX_RETRY(7);
+
+		dur = ural_txtime(RAL_ACK_SIZE, ural_ack_rate(ic, rate),
+		    ic->ic_flags) + RAL_SIFS;
+		*(uint16_t *)wh->i_dur = htole16(dur);
+	}
+
+	if (sc->sc_drvbpf != NULL) {
+		struct ural_tx_radiotap_header *tap = &sc->sc_txtap;
+
+		tap->wt_flags = 0;
+		tap->wt_rate = rate;
+		tap->wt_chan_freq = htole16(ic->ic_curchan->ic_freq);
+		tap->wt_chan_flags = htole16(ic->ic_curchan->ic_flags);
+		tap->wt_antenna = sc->tx_ant;
+
+		bpf_mtap2(sc->sc_drvbpf, tap, sc->sc_txtap_len, m0);
+	}
+
+	m_copydata(m0, 0, m0->m_pkthdr.len, data->buf + RAL_TX_DESC_SIZE);
+	ural_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate);
+
+	/* align end on a 2-bytes boundary */
+	xferlen = (RAL_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;
+
+	/*
+	 * No space left in the last URB to store the extra 2 bytes, force
+	 * sending of another URB.
+	 */
+	if ((xferlen % 64) == 0)
+		xferlen += 2;
+
+	DPRINTFN(10, ("sending data frame len=%u rate=%u xfer len=%u\n",
+	    m0->m_pkthdr.len, rate, xferlen));
+
+	usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf,
+	    xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RAL_TX_TIMEOUT,
+	    ural_txeof);
+
+	error = usbd_transfer(data->xfer);
+	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS)
+		return error;
+
+	sc->tx_queued++;
+
+	return 0;
+}
+
+Static void
+ural_start(struct ifnet *ifp)
+{
+	struct ural_softc *sc = ifp->if_softc;
+	struct ieee80211com *ic = &sc->sc_ic;
+	struct mbuf *m0;
+	struct ether_header *eh;
+	struct ieee80211_node *ni;
+
+	for (;;) {
+		IF_POLL(&ic->ic_mgtq, m0);
+		if (m0 != NULL) {
+			if (sc->tx_queued >= RAL_TX_LIST_COUNT) {
+				ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+				break;
+			}
+			IF_DEQUEUE(&ic->ic_mgtq, m0);
+
+			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
+			m0->m_pkthdr.rcvif = NULL;
+
+			if (ic->ic_rawbpf != NULL)
+				bpf_mtap(ic->ic_rawbpf, m0);
+
+			if (ural_tx_mgt(sc, m0, ni) != 0)
+				break;
+
+		} else {
+			if (ic->ic_state != IEEE80211_S_RUN)
+				break;
+			IFQ_DRV_DEQUEUE(&ifp->if_snd, m0);
+			if (m0 == NULL)
+				break;
+			if (sc->tx_queued >= RAL_TX_LIST_COUNT) {
+				IFQ_DRV_PREPEND(&ifp->if_snd, m0);
+				ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+				break;
+			}
+
+			if (m0->m_len < sizeof (struct ether_header) &&
+			    !(m0 = m_pullup(m0, sizeof (struct ether_header))))
+				continue;
+
+			eh = mtod(m0, struct ether_header *);
+			ni = ieee80211_find_txnode(ic, eh->ether_dhost);
+			if (ni == NULL) {
+				m_freem(m0);
+				continue;
+			}
+			BPF_MTAP(ifp, m0);
+
+			m0 = ieee80211_encap(ic, m0, ni);
+			if (m0 == NULL) {
+				ieee80211_free_node(ni);
+				continue;
+			}
+
+			if (ic->ic_rawbpf != NULL)
+				bpf_mtap(ic->ic_rawbpf, m0);
+
+			if (ural_tx_data(sc, m0, ni) != 0) {
+				ieee80211_free_node(ni);
+				ifp->if_oerrors++;
+				break;
+			}
+		}
+
+		sc->sc_tx_timer = 5;
+		ifp->if_timer = 1;
+	}
+}
+
+Static void
+ural_watchdog(struct ifnet *ifp)
+{
+	struct ural_softc *sc = ifp->if_softc;
+	struct ieee80211com *ic = &sc->sc_ic;
+
+	RAL_LOCK(sc);
+
+	ifp->if_timer = 0;
+
+	if (sc->sc_tx_timer > 0) {
+		if (--sc->sc_tx_timer == 0) {
+			device_printf(sc->sc_dev, "device timeout\n");
+			/*ural_init(sc); XXX needs a process context! */
+			ifp->if_oerrors++;
+			RAL_UNLOCK(sc);
+			return;
+		}
+		ifp->if_timer = 1;
+	}
+
+	ieee80211_watchdog(ic);
+
+	RAL_UNLOCK(sc);
+}
+
+/*
+ * This function allows for fast channel switching in monitor mode (used by
+ * net-mgmt/kismet). In IBSS mode, we must explicitly reset the interface to
+ * generate a new beacon frame.
+ */
+Static int
+ural_reset(struct ifnet *ifp)
+{
+	struct ural_softc *sc = ifp->if_softc;
+	struct ieee80211com *ic = &sc->sc_ic;
+
+	if (ic->ic_opmode != IEEE80211_M_MONITOR)
+		return ENETRESET;
+
+	ural_set_chan(sc, ic->ic_curchan);
+
+	return 0;
+}
+
+Static int
+ural_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
+{
+	struct ural_softc *sc = ifp->if_softc;
+	struct ieee80211com *ic = &sc->sc_ic;
+	int error = 0;
+
+	RAL_LOCK(sc);
+
+	switch (cmd) {
+	case SIOCSIFFLAGS:
+		if (ifp->if_flags & IFF_UP) {
+			if (ifp->if_drv_flags & IFF_DRV_RUNNING)
+				ural_update_promisc(sc);
+			else
+				ural_init(sc);
+		} else {
+			if (ifp->if_drv_flags & IFF_DRV_RUNNING)
+				ural_stop(sc);
+		}
+		break;
+
+	default:
+		error = ieee80211_ioctl(ic, cmd, data);
+	}
+
+	if (error == ENETRESET) {
+		if ((ifp->if_flags & IFF_UP) &&
+		    (ifp->if_drv_flags & IFF_DRV_RUNNING) &&
+		    (ic->ic_roaming != IEEE80211_ROAMING_MANUAL))
+			ural_init(sc);
+		error = 0;
+	}
+
+	RAL_UNLOCK(sc);
+
+	return error;
+}
+
+Static void
+ural_set_testmode(struct ural_softc *sc)
+{
+	usb_device_request_t req;
+	usbd_status error;
+
+	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
+	req.bRequest = RAL_VENDOR_REQUEST;
+	USETW(req.wValue, 4);
+	USETW(req.wIndex, 1);
+	USETW(req.wLength, 0);
+
+	error = usbd_do_request(sc->sc_udev, &req, NULL);
+	if (error != 0) {
+		printf("%s: could not set test mode: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
+	}
+}
+
+Static void
+ural_eeprom_read(struct ural_softc *sc, uint16_t addr, void *buf, int len)
+{
+	usb_device_request_t req;
+	usbd_status error;
+
+	req.bmRequestType = UT_READ_VENDOR_DEVICE;
+	req.bRequest = RAL_READ_EEPROM;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, addr);
+	USETW(req.wLength, len);
+
+	error = usbd_do_request(sc->sc_udev, &req, buf);
+	if (error != 0) {
+		printf("%s: could not read EEPROM: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
+	}
+}
+
+Static uint16_t
+ural_read(struct ural_softc *sc, uint16_t reg)
+{
+	usb_device_request_t req;
+	usbd_status error;
+	uint16_t val;
+
+	req.bmRequestType = UT_READ_VENDOR_DEVICE;
+	req.bRequest = RAL_READ_MAC;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, reg);
+	USETW(req.wLength, sizeof (uint16_t));
+
+	error = usbd_do_request(sc->sc_udev, &req, &val);
+	if (error != 0) {
+		printf("%s: could not read MAC register: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
+		return 0;
+	}
+
+	return le16toh(val);
+}
+
+Static void
+ural_read_multi(struct ural_softc *sc, uint16_t reg, void *buf, int len)
+{
+	usb_device_request_t req;
+	usbd_status error;
+
+	req.bmRequestType = UT_READ_VENDOR_DEVICE;
+	req.bRequest = RAL_READ_MULTI_MAC;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, reg);
+	USETW(req.wLength, len);
+
+	error = usbd_do_request(sc->sc_udev, &req, buf);
+	if (error != 0) {
+		printf("%s: could not read MAC register: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
+	}
+}
+
+Static void
+ural_write(struct ural_softc *sc, uint16_t reg, uint16_t val)
+{
+	usb_device_request_t req;
+	usbd_status error;
+
+	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
+	req.bRequest = RAL_WRITE_MAC;
+	USETW(req.wValue, val);
+	USETW(req.wIndex, reg);
+	USETW(req.wLength, 0);
+
+	error = usbd_do_request(sc->sc_udev, &req, NULL);
+	if (error != 0) {
+		printf("%s: could not write MAC register: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
+	}
+}
+
+Static void
+ural_write_multi(struct ural_softc *sc, uint16_t reg, void *buf, int len)
+{
+	usb_device_request_t req;
+	usbd_status error;
+
+	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
+	req.bRequest = RAL_WRITE_MULTI_MAC;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, reg);
+	USETW(req.wLength, len);
+
+	error = usbd_do_request(sc->sc_udev, &req, buf);
+	if (error != 0) {
+		printf("%s: could not write MAC register: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
+	}
+}
+
+Static void
+ural_bbp_write(struct ural_softc *sc, uint8_t reg, uint8_t val)
+{
+	uint16_t tmp;
+	int ntries;
+
+	for (ntries = 0; ntries < 5; ntries++) {
+		if (!(ural_read(sc, RAL_PHY_CSR8) & RAL_BBP_BUSY))
+			break;
+	}
+	if (ntries == 5) {
+		printf("%s: could not write to BBP\n", USBDEVNAME(sc->sc_dev));
+		return;
+	}
+
+	tmp = reg << 8 | val;
+	ural_write(sc, RAL_PHY_CSR7, tmp);
+}
+
+Static uint8_t
+ural_bbp_read(struct ural_softc *sc, uint8_t reg)
+{
+	uint16_t val;
+	int ntries;
+
+	val = RAL_BBP_WRITE | reg << 8;
+	ural_write(sc, RAL_PHY_CSR7, val);
+
+	for (ntries = 0; ntries < 5; ntries++) {
+		if (!(ural_read(sc, RAL_PHY_CSR8) & RAL_BBP_BUSY))
+			break;
+	}
+	if (ntries == 5) {
+		printf("%s: could not read BBP\n", USBDEVNAME(sc->sc_dev));
+		return 0;
+	}
+
+	return ural_read(sc, RAL_PHY_CSR7) & 0xff;
+}
+
+Static void
+ural_rf_write(struct ural_softc *sc, uint8_t reg, uint32_t val)
+{
+	uint32_t tmp;
+	int ntries;
+
+	for (ntries = 0; ntries < 5; ntries++) {
+		if (!(ural_read(sc, RAL_PHY_CSR10) & RAL_RF_LOBUSY))
+			break;
+	}
+	if (ntries == 5) {
+		printf("%s: could not write to RF\n", USBDEVNAME(sc->sc_dev));
+		return;
+	}
+
+	tmp = RAL_RF_BUSY | RAL_RF_20BIT | (val & 0xfffff) << 2 | (reg & 0x3);
+	ural_write(sc, RAL_PHY_CSR9,  tmp & 0xffff);
+	ural_write(sc, RAL_PHY_CSR10, tmp >> 16);
+
+	/* remember last written value in sc */
+	sc->rf_regs[reg] = val;
+
+	DPRINTFN(15, ("RF R[%u] <- 0x%05x\n", reg & 0x3, val & 0xfffff));
+}
+
+Static void
+ural_set_chan(struct ural_softc *sc, struct ieee80211_channel *c)
+{
+	struct ieee80211com *ic = &sc->sc_ic;
+	uint8_t power, tmp;
+	u_int i, chan;
+
+	chan = ieee80211_chan2ieee(ic, c);
+	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
+		return;
+
+	if (IEEE80211_IS_CHAN_2GHZ(c))
+		power = min(sc->txpow[chan - 1], 31);
+	else
+		power = 31;
+
+	/* adjust txpower using ifconfig settings */
+	power -= (100 - ic->ic_txpowlimit) / 8;
+
+	DPRINTFN(2, ("setting channel to %u, txpower to %u\n", chan, power));
+
+	switch (sc->rf_rev) {
+	case RAL_RF_2522:
+		ural_rf_write(sc, RAL_RF1, 0x00814);
+		ural_rf_write(sc, RAL_RF2, ural_rf2522_r2[chan - 1]);
+		ural_rf_write(sc, RAL_RF3, power << 7 | 0x00040);
+		break;
+
+	case RAL_RF_2523:
+		ural_rf_write(sc, RAL_RF1, 0x08804);
+		ural_rf_write(sc, RAL_RF2, ural_rf2523_r2[chan - 1]);
+		ural_rf_write(sc, RAL_RF3, power << 7 | 0x38044);
+		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00280 : 0x00286);
+		break;
+
+	case RAL_RF_2524:
+		ural_rf_write(sc, RAL_RF1, 0x0c808);
+		ural_rf_write(sc, RAL_RF2, ural_rf2524_r2[chan - 1]);
+		ural_rf_write(sc, RAL_RF3, power << 7 | 0x00040);
+		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00280 : 0x00286);
+		break;
+
+	case RAL_RF_2525:
+		ural_rf_write(sc, RAL_RF1, 0x08808);
+		ural_rf_write(sc, RAL_RF2, ural_rf2525_hi_r2[chan - 1]);
+		ural_rf_write(sc, RAL_RF3, power << 7 | 0x18044);
+		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00280 : 0x00286);
+
+		ural_rf_write(sc, RAL_RF1, 0x08808);
+		ural_rf_write(sc, RAL_RF2, ural_rf2525_r2[chan - 1]);
+		ural_rf_write(sc, RAL_RF3, power << 7 | 0x18044);
+		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00280 : 0x00286);
+		break;
+
+	case RAL_RF_2525E:
+		ural_rf_write(sc, RAL_RF1, 0x08808);
+		ural_rf_write(sc, RAL_RF2, ural_rf2525e_r2[chan - 1]);
+		ural_rf_write(sc, RAL_RF3, power << 7 | 0x18044);
+		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00286 : 0x00282);
+		break;
+
+	case RAL_RF_2526:
+		ural_rf_write(sc, RAL_RF2, ural_rf2526_hi_r2[chan - 1]);
+		ural_rf_write(sc, RAL_RF4, (chan & 1) ? 0x00386 : 0x00381);
+		ural_rf_write(sc, RAL_RF1, 0x08804);
+
+		ural_rf_write(sc, RAL_RF2, ural_rf2526_r2[chan - 1]);
+		ural_rf_write(sc, RAL_RF3, power << 7 | 0x18044);
+		ural_rf_write(sc, RAL_RF4, (chan & 1) ? 0x00386 : 0x00381);
+		break;
+
+	/* dual-band RF */
+	case RAL_RF_5222:
+		for (i = 0; i < ural_rf5222[i].chan != chan; i++);
+
+		ural_rf_write(sc, RAL_RF1, ural_rf5222[i].r1);
+		ural_rf_write(sc, RAL_RF2, ural_rf5222[i].r2);
+		ural_rf_write(sc, RAL_RF3, power << 7 | 0x00040);
+		ural_rf_write(sc, RAL_RF4, ural_rf5222[i].r4);
+		break;
+	}
+
+	if (ic->ic_opmode != IEEE80211_M_MONITOR &&
+	    ic->ic_state != IEEE80211_S_SCAN) {
+		/* set Japan filter bit for channel 14 */
+		tmp = ural_bbp_read(sc, 70);
+
+		tmp &= ~RAL_JAPAN_FILTER;
+		if (chan == 14)
+			tmp |= RAL_JAPAN_FILTER;
+
+		ural_bbp_write(sc, 70, tmp);
+
+		/* clear CRC errors */
+		ural_read(sc, RAL_STA_CSR0);
+
+		DELAY(10000);
+		ural_disable_rf_tune(sc);
+	}
+}
+
+/*
+ * Disable RF auto-tuning.
+ */
+Static void
+ural_disable_rf_tune(struct ural_softc *sc)
+{
+	uint32_t tmp;
+
+	if (sc->rf_rev != RAL_RF_2523) {
+		tmp = sc->rf_regs[RAL_RF1] & ~RAL_RF1_AUTOTUNE;
+		ural_rf_write(sc, RAL_RF1, tmp);
+	}
+
+	tmp = sc->rf_regs[RAL_RF3] & ~RAL_RF3_AUTOTUNE;
+	ural_rf_write(sc, RAL_RF3, tmp);
+
+	DPRINTFN(2, ("disabling RF autotune\n"));
+}
+
+/*
+ * Refer to IEEE Std 802.11-1999 pp. 123 for more information on TSF
+ * synchronization.
+ */
+Static void
+ural_enable_tsf_sync(struct ural_softc *sc)
+{
+	struct ieee80211com *ic = &sc->sc_ic;
+	uint16_t logcwmin, preload, tmp;
+
+	/* first, disable TSF synchronization */
+	ural_write(sc, RAL_TXRX_CSR19, 0);
+
+	tmp = (16 * ic->ic_bss->ni_intval) << 4;
+	ural_write(sc, RAL_TXRX_CSR18, tmp);
+
+	logcwmin = (ic->ic_opmode == IEEE80211_M_IBSS) ? 2 : 0;
+	preload = (ic->ic_opmode == IEEE80211_M_IBSS) ? 320 : 6;
+	tmp = logcwmin << 12 | preload;
+	ural_write(sc, RAL_TXRX_CSR20, tmp);
+
+	/* finally, enable TSF synchronization */
+	tmp = RAL_ENABLE_TSF | RAL_ENABLE_TBCN;
+	if (ic->ic_opmode == IEEE80211_M_STA)
+		tmp |= RAL_ENABLE_TSF_SYNC(1);
+	else
+		tmp |= RAL_ENABLE_TSF_SYNC(2) | RAL_ENABLE_BEACON_GENERATOR;
+	ural_write(sc, RAL_TXRX_CSR19, tmp);
+
+	DPRINTF(("enabling TSF synchronization\n"));
+}
+
+Static void
+ural_update_slot(struct ifnet *ifp)
+{
+	struct ural_softc *sc = ifp->if_softc;
+	struct ieee80211com *ic = &sc->sc_ic;
+	uint16_t slottime, sifs, eifs;
+
+	slottime = (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;
+
+	/*
+	 * These settings may sound a bit inconsistent but this is what the
+	 * reference driver does.
+	 */
+	if (ic->ic_curmode == IEEE80211_MODE_11B) {
+		sifs = 16 - RAL_RXTX_TURNAROUND;
+		eifs = 364;
+	} else {
+		sifs = 10 - RAL_RXTX_TURNAROUND;
+		eifs = 64;
+	}
+
+	ural_write(sc, RAL_MAC_CSR10, slottime);
+	ural_write(sc, RAL_MAC_CSR11, sifs);
+	ural_write(sc, RAL_MAC_CSR12, eifs);
+}
+
+Static void
+ural_set_txpreamble(struct ural_softc *sc)
+{
+	uint16_t tmp;
+
+	tmp = ural_read(sc, RAL_TXRX_CSR10);
+
+	tmp &= ~RAL_SHORT_PREAMBLE;
+	if (sc->sc_ic.ic_flags & IEEE80211_F_SHPREAMBLE)
+		tmp |= RAL_SHORT_PREAMBLE;
+
+	ural_write(sc, RAL_TXRX_CSR10, tmp);
+}
+
+Static void
+ural_set_basicrates(struct ural_softc *sc)
+{
+	struct ieee80211com *ic = &sc->sc_ic;
+
+	/* update basic rate set */
+	if (ic->ic_curmode == IEEE80211_MODE_11B) {
+		/* 11b basic rates: 1, 2Mbps */
+		ural_write(sc, RAL_TXRX_CSR11, 0x3);
+	} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
+		/* 11a basic rates: 6, 12, 24Mbps */
+		ural_write(sc, RAL_TXRX_CSR11, 0x150);
+	} else {
+		/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
+		ural_write(sc, RAL_TXRX_CSR11, 0x15f);
+	}
+}
+
+Static void
+ural_set_bssid(struct ural_softc *sc, uint8_t *bssid)
+{
+	uint16_t tmp;
+
+	tmp = bssid[0] | bssid[1] << 8;
+	ural_write(sc, RAL_MAC_CSR5, tmp);
+
+	tmp = bssid[2] | bssid[3] << 8;
+	ural_write(sc, RAL_MAC_CSR6, tmp);
+
+	tmp = bssid[4] | bssid[5] << 8;
+	ural_write(sc, RAL_MAC_CSR7, tmp);
+
+	DPRINTF(("setting BSSID to %6D\n", bssid, ":"));
+}
+
+Static void
+ural_set_macaddr(struct ural_softc *sc, uint8_t *addr)
+{
+	uint16_t tmp;
+
+	tmp = addr[0] | addr[1] << 8;
+	ural_write(sc, RAL_MAC_CSR2, tmp);
+
+	tmp = addr[2] | addr[3] << 8;
+	ural_write(sc, RAL_MAC_CSR3, tmp);
+
+	tmp = addr[4] | addr[5] << 8;
+	ural_write(sc, RAL_MAC_CSR4, tmp);
+
+	DPRINTF(("setting MAC address to %6D\n", addr, ":"));
+}
+
+Static void
+ural_update_promisc(struct ural_softc *sc)
+{
+	struct ifnet *ifp = sc->sc_ic.ic_ifp;
+	uint32_t tmp;
+
+	tmp = ural_read(sc, RAL_TXRX_CSR2);
+
+	tmp &= ~RAL_DROP_NOT_TO_ME;
+	if (!(ifp->if_flags & IFF_PROMISC))
+		tmp |= RAL_DROP_NOT_TO_ME;
+
+	ural_write(sc, RAL_TXRX_CSR2, tmp);
+
+	DPRINTF(("%s promiscuous mode\n", (ifp->if_flags & IFF_PROMISC) ?
+	    "entering" : "leaving"));
+}
+
+Static const char *
+ural_get_rf(int rev)
+{
+	switch (rev) {
+	case RAL_RF_2522:	return "RT2522";
+	case RAL_RF_2523:	return "RT2523";
+	case RAL_RF_2524:	return "RT2524";
+	case RAL_RF_2525:	return "RT2525";
+	case RAL_RF_2525E:	return "RT2525e";
+	case RAL_RF_2526:	return "RT2526";
+	case RAL_RF_5222:	return "RT5222";
+	default:		return "unknown";
+	}
+}
+
+Static void
+ural_read_eeprom(struct ural_softc *sc)
+{
+	struct ieee80211com *ic = &sc->sc_ic;
+	uint16_t val;
+
+	ural_eeprom_read(sc, RAL_EEPROM_CONFIG0, &val, 2);
+	val = le16toh(val);
+	sc->rf_rev =   (val >> 11) & 0x7;
+	sc->hw_radio = (val >> 10) & 0x1;
+	sc->led_mode = (val >> 6)  & 0x7;
+	sc->rx_ant =   (val >> 4)  & 0x3;
+	sc->tx_ant =   (val >> 2)  & 0x3;
+	sc->nb_ant =   val & 0x3;
+
+	/* read MAC address */
+	ural_eeprom_read(sc, RAL_EEPROM_ADDRESS, ic->ic_myaddr, 6);
+
+	/* read default values for BBP registers */
+	ural_eeprom_read(sc, RAL_EEPROM_BBP_BASE, sc->bbp_prom, 2 * 16);
+
+	/* read Tx power for all b/g channels */
+	ural_eeprom_read(sc, RAL_EEPROM_TXPOWER, sc->txpow, 14);
+}
+
+Static int
+ural_bbp_init(struct ural_softc *sc)
+{
+#define N(a)	(sizeof (a) / sizeof ((a)[0]))
+	int i, ntries;
+
+	/* wait for BBP to be ready */
+	for (ntries = 0; ntries < 100; ntries++) {
+		if (ural_bbp_read(sc, RAL_BBP_VERSION) != 0)
+			break;
+		DELAY(1000);
+	}
+	if (ntries == 100) {
+		device_printf(sc->sc_dev, "timeout waiting for BBP\n");
+		return EIO;
+	}
+
+	/* initialize BBP registers to default values */
+	for (i = 0; i < N(ural_def_bbp); i++)
+		ural_bbp_write(sc, ural_def_bbp[i].reg, ural_def_bbp[i].val);
+
+#if 0
+	/* initialize BBP registers to values stored in EEPROM */
+	for (i = 0; i < 16; i++) {
+		if (sc->bbp_prom[i].reg == 0xff)
+			continue;
+		ural_bbp_write(sc, sc->bbp_prom[i].reg, sc->bbp_prom[i].val);
+	}
+#endif
+
+	return 0;
+#undef N
+}
+
+Static void
+ural_set_txantenna(struct ural_softc *sc, int antenna)
+{
+	uint16_t tmp;
+	uint8_t tx;
+
+	tx = ural_bbp_read(sc, RAL_BBP_TX) & ~RAL_BBP_ANTMASK;
+	if (antenna == 1)
+		tx |= RAL_BBP_ANTA;
+	else if (antenna == 2)
+		tx |= RAL_BBP_ANTB;
+	else
+		tx |= RAL_BBP_DIVERSITY;
+
+	/* need to force I/Q flip for RF 2525e, 2526 and 5222 */
+	if (sc->rf_rev == RAL_RF_2525E || sc->rf_rev == RAL_RF_2526 ||
+	    sc->rf_rev == RAL_RF_5222)
+		tx |= RAL_BBP_FLIPIQ;
+
+	ural_bbp_write(sc, RAL_BBP_TX, tx);
+
+	/* update values in PHY_CSR5 and PHY_CSR6 */
+	tmp = ural_read(sc, RAL_PHY_CSR5) & ~0x7;
+	ural_write(sc, RAL_PHY_CSR5, tmp | (tx & 0x7));
+
+	tmp = ural_read(sc, RAL_PHY_CSR6) & ~0x7;
+	ural_write(sc, RAL_PHY_CSR6, tmp | (tx & 0x7));
+}
+
+Static void
+ural_set_rxantenna(struct ural_softc *sc, int antenna)
+{
+	uint8_t rx;
+
+	rx = ural_bbp_read(sc, RAL_BBP_RX) & ~RAL_BBP_ANTMASK;
+	if (antenna == 1)
+		rx |= RAL_BBP_ANTA;
+	else if (antenna == 2)
+		rx |= RAL_BBP_ANTB;
+	else
+		rx |= RAL_BBP_DIVERSITY;
+
+	/* need to force no I/Q flip for RF 2525e and 2526 */
+	if (sc->rf_rev == RAL_RF_2525E || sc->rf_rev == RAL_RF_2526)
+		rx &= ~RAL_BBP_FLIPIQ;
+
+	ural_bbp_write(sc, RAL_BBP_RX, rx);
+}
+
+Static void
+ural_init(void *priv)
+{
+#define N(a)	(sizeof (a) / sizeof ((a)[0]))
+	struct ural_softc *sc = priv;
+	struct ieee80211com *ic = &sc->sc_ic;
+	struct ifnet *ifp = ic->ic_ifp;
+	struct ieee80211_key *wk;
+	struct ural_rx_data *data;
+	uint16_t tmp;
+	usbd_status error;
+	int i, ntries;
+
+	ural_set_testmode(sc);
+	ural_write(sc, 0x308, 0x00f0);	/* XXX magic */
+
+	ural_stop(sc);
+
+	/* initialize MAC registers to default values */
+	for (i = 0; i < N(ural_def_mac); i++)
+		ural_write(sc, ural_def_mac[i].reg, ural_def_mac[i].val);
+
+	/* wait for BBP and RF to wake up (this can take a long time!) */
+	for (ntries = 0; ntries < 100; ntries++) {
+		tmp = ural_read(sc, RAL_MAC_CSR17);
+		if ((tmp & (RAL_BBP_AWAKE | RAL_RF_AWAKE)) ==
+		    (RAL_BBP_AWAKE | RAL_RF_AWAKE))
+			break;
+		DELAY(1000);
+	}
+	if (ntries == 100) {
+		printf("%s: timeout waiting for BBP/RF to wakeup\n",
+		    USBDEVNAME(sc->sc_dev));
+		goto fail;
+	}
+
+	/* we're ready! */
+	ural_write(sc, RAL_MAC_CSR1, RAL_HOST_READY);
+
+	/* set basic rate set (will be updated later) */
+	ural_write(sc, RAL_TXRX_CSR11, 0x15f);
+
+	if (ural_bbp_init(sc) != 0)
+		goto fail;
+
+	/* set default BSS channel */
+	ural_set_chan(sc, ic->ic_curchan);
+
+	/* clear statistic registers (STA_CSR0 to STA_CSR10) */
+	ural_read_multi(sc, RAL_STA_CSR0, sc->sta, sizeof sc->sta);
+
+	ural_set_txantenna(sc, sc->tx_ant);
+	ural_set_rxantenna(sc, sc->rx_ant);
+
+	IEEE80211_ADDR_COPY(ic->ic_myaddr, IF_LLADDR(ifp));
+	ural_set_macaddr(sc, ic->ic_myaddr);
+
+	/*
+	 * Copy WEP keys into adapter's memory (SEC_CSR0 to SEC_CSR31).
+	 */
+	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
+		wk = &ic->ic_crypto.cs_nw_keys[i];
+		ural_write_multi(sc, wk->wk_keyix * IEEE80211_KEYBUF_SIZE +
+		    RAL_SEC_CSR0, wk->wk_key, IEEE80211_KEYBUF_SIZE);
+	}
+
+	/*
+	 * Allocate xfer for AMRR statistics requests.
+	 */
+	sc->amrr_xfer = usbd_alloc_xfer(sc->sc_udev);
+	if (sc->amrr_xfer == NULL) {
+		printf("%s: could not allocate AMRR xfer\n",
+		    USBDEVNAME(sc->sc_dev));
+		goto fail;
+	}
+
+	/*
+	 * Open Tx and Rx USB bulk pipes.
+	 */
+	error = usbd_open_pipe(sc->sc_iface, sc->sc_tx_no, USBD_EXCLUSIVE_USE,
+	    &sc->sc_tx_pipeh);
+	if (error != 0) {
+		printf("%s: could not open Tx pipe: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
+		goto fail;
+	}
+
+	error = usbd_open_pipe(sc->sc_iface, sc->sc_rx_no, USBD_EXCLUSIVE_USE,
+	    &sc->sc_rx_pipeh);
+	if (error != 0) {
+		printf("%s: could not open Rx pipe: %s\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
+		goto fail;
+	}
+
+	/*
+	 * Allocate Tx and Rx xfer queues.
+	 */
+	error = ural_alloc_tx_list(sc);
+	if (error != 0) {
+		printf("%s: could not allocate Tx list\n",
+		    USBDEVNAME(sc->sc_dev));
+		goto fail;
+	}
+
+	error = ural_alloc_rx_list(sc);
+	if (error != 0) {
+		printf("%s: could not allocate Rx list\n",
+		    USBDEVNAME(sc->sc_dev));
+		goto fail;
+	}
+
+	/*
+	 * Start up the receive pipe.
+	 */
+	for (i = 0; i < RAL_RX_LIST_COUNT; i++) {
+		data = &sc->rx_data[i];
+
+		usbd_setup_xfer(data->xfer, sc->sc_rx_pipeh, data, data->buf,
+		    MCLBYTES, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, ural_rxeof);
+		usbd_transfer(data->xfer);
+	}
+
+	/* kick Rx */
+	tmp = RAL_DROP_PHY | RAL_DROP_CRC;
+	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
+		tmp |= RAL_DROP_CTL | RAL_DROP_BAD_VERSION;
+		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
+			tmp |= RAL_DROP_TODS;
+		if (!(ifp->if_flags & IFF_PROMISC))
+			tmp |= RAL_DROP_NOT_TO_ME;
+	}
+	ural_write(sc, RAL_TXRX_CSR2, tmp);
+
+	ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+	ifp->if_drv_flags |= IFF_DRV_RUNNING;
+
+	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
+		if (ic->ic_roaming != IEEE80211_ROAMING_MANUAL)
+			ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
+	} else
+		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
+
+	return;
+
+fail:	ural_stop(sc);
+#undef N
+}
+
+Static void
+ural_stop(void *priv)
+{
+	struct ural_softc *sc = priv;
+	struct ieee80211com *ic = &sc->sc_ic;
+	struct ifnet *ifp = ic->ic_ifp;
+
+	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
+
+	sc->sc_tx_timer = 0;
+	ifp->if_timer = 0;
+	ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
+
+	/* disable Rx */
+	ural_write(sc, RAL_TXRX_CSR2, RAL_DISABLE_RX);
+
+	/* reset ASIC and BBP (but won't reset MAC registers!) */
+	ural_write(sc, RAL_MAC_CSR1, RAL_RESET_ASIC | RAL_RESET_BBP);
+	ural_write(sc, RAL_MAC_CSR1, 0);
+
+	if (sc->amrr_xfer != NULL) {
+		usbd_free_xfer(sc->amrr_xfer);
+		sc->amrr_xfer = NULL;
+	}
+
+	if (sc->sc_rx_pipeh != NULL) {
+		usbd_abort_pipe(sc->sc_rx_pipeh);
+		usbd_close_pipe(sc->sc_rx_pipeh);
+		sc->sc_rx_pipeh = NULL;
+	}
+
+	if (sc->sc_tx_pipeh != NULL) {
+		usbd_abort_pipe(sc->sc_tx_pipeh);
+		usbd_close_pipe(sc->sc_tx_pipeh);
+		sc->sc_tx_pipeh = NULL;
+	}
+
+	ural_free_rx_list(sc);
+	ural_free_tx_list(sc);
+}
+
+#define URAL_AMRR_MIN_SUCCESS_THRESHOLD	 1
+#define URAL_AMRR_MAX_SUCCESS_THRESHOLD	10
+
+Static void
+ural_amrr_start(struct ural_softc *sc, struct ieee80211_node *ni)
+{
+	struct ural_amrr *amrr = &sc->amrr;
+	int i;
+
+	/* clear statistic registers (STA_CSR0 to STA_CSR10) */
+	ural_read_multi(sc, RAL_STA_CSR0, sc->sta, sizeof sc->sta);
+
+	amrr->success = 0;
+	amrr->recovery = 0;
+	amrr->txcnt = amrr->retrycnt = 0;
+	amrr->success_threshold = URAL_AMRR_MIN_SUCCESS_THRESHOLD;
+
+	/* set rate to some reasonable initial value */
+	for (i = ni->ni_rates.rs_nrates - 1;
+	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
+	     i--);
+
+	ni->ni_txrate = i;
+
+	callout_reset(&sc->amrr_ch, hz, ural_amrr_timeout, sc);
+}
+
+Static void
+ural_amrr_timeout(void *arg)
+{
+	struct ural_softc *sc = (struct ural_softc *)arg;
+	usb_device_request_t req;
+	int s;
+
+	s = splusb();
+
+	/*
+	 * Asynchronously read statistic registers (cleared by read).
+	 */
+	req.bmRequestType = UT_READ_VENDOR_DEVICE;
+	req.bRequest = RAL_READ_MULTI_MAC;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, RAL_STA_CSR0);
+	USETW(req.wLength, sizeof sc->sta);
+
+	usbd_setup_default_xfer(sc->amrr_xfer, sc->sc_udev, sc,
+	    USBD_DEFAULT_TIMEOUT, &req, sc->sta, sizeof sc->sta, 0,
+	    ural_amrr_update);
+	(void)usbd_transfer(sc->amrr_xfer);
+
+	splx(s);
+}
+
+Static void
+ural_amrr_update(usbd_xfer_handle xfer, usbd_private_handle priv,
+    usbd_status status)
+{
+	struct ural_softc *sc = (struct ural_softc *)priv;
+	struct ural_amrr *amrr = &sc->amrr;
+	struct ifnet *ifp = sc->sc_ic.ic_ifp;
+
+	if (status != USBD_NORMAL_COMPLETION) {
+		device_printf(sc->sc_dev, "could not retrieve Tx statistics - "
+		    "cancelling automatic rate control\n");
+		return;
+	}
+
+	/* count TX retry-fail as Tx errors */
+	ifp->if_oerrors += sc->sta[9];
+
+	amrr->retrycnt =
+	    sc->sta[7] +	/* TX one-retry ok count */
+	    sc->sta[8] +	/* TX more-retry ok count */
+	    sc->sta[9];		/* TX retry-fail count */
+
+	amrr->txcnt =
+	    amrr->retrycnt +
+	    sc->sta[6];		/* TX no-retry ok count */
+
+	ural_ratectl(amrr, sc->sc_ic.ic_bss);
+
+	callout_reset(&sc->amrr_ch, hz, ural_amrr_timeout, sc);
+}
+
+/*-
+ * Naive implementation of the Adaptive Multi Rate Retry algorithm:
+ *     "IEEE 802.11 Rate Adaptation: A Practical Approach"
+ *     Mathieu Lacage, Hossein Manshaei, Thierry Turletti
+ *     INRIA Sophia - Projet Planete
+ *     http://www-sop.inria.fr/rapports/sophia/RR-5208.html
+ *
+ * This algorithm is particularly well suited for ural since it does not
+ * require per-frame retry statistics.  Note however that since h/w does
+ * not provide per-frame stats, we can't do per-node rate adaptation and
+ * thus automatic rate adaptation is only enabled in STA operating mode.
+ */
+#define is_success(amrr)	\
+	((amrr)->retrycnt < (amrr)->txcnt / 10)
+#define is_failure(amrr)	\
+	((amrr)->retrycnt > (amrr)->txcnt / 3)
+#define is_enough(amrr)		\
+	((amrr)->txcnt > 10)
+#define is_min_rate(ni)		\
+	((ni)->ni_txrate == 0)
+#define is_max_rate(ni)		\
+	((ni)->ni_txrate == (ni)->ni_rates.rs_nrates - 1)
+#define increase_rate(ni)	\
+	((ni)->ni_txrate++)
+#define decrease_rate(ni)	\
+	((ni)->ni_txrate--)
+#define reset_cnt(amrr)		\
+	do { (amrr)->txcnt = (amrr)->retrycnt = 0; } while (0)
+Static void
+ural_ratectl(struct ural_amrr *amrr, struct ieee80211_node *ni)
+{
+	int need_change = 0;
+
+	if (is_success(amrr) && is_enough(amrr)) {
+		amrr->success++;
+		if (amrr->success >= amrr->success_threshold &&
+		    !is_max_rate(ni)) {
+			amrr->recovery = 1;
+			amrr->success = 0;
+			increase_rate(ni);
+			need_change = 1;
+		} else {
+			amrr->recovery = 0;
+		}
+	} else if (is_failure(amrr)) {
+		amrr->success = 0;
+		if (!is_min_rate(ni)) {
+			if (amrr->recovery) {
+				amrr->success_threshold *= 2;
+				if (amrr->success_threshold >
+				    URAL_AMRR_MAX_SUCCESS_THRESHOLD)
+					amrr->success_threshold =
+					    URAL_AMRR_MAX_SUCCESS_THRESHOLD;
+			} else {
+				amrr->success_threshold =
+				    URAL_AMRR_MIN_SUCCESS_THRESHOLD;
+			}
+			decrease_rate(ni);
+			need_change = 1;
+		}
+		amrr->recovery = 0;	/* original paper was incorrect */
+	}
+
+	if (is_enough(amrr) || need_change)
+		reset_cnt(amrr);
+}
+
+DRIVER_MODULE(ural, uhub, ural_driver, ural_devclass, usbd_driver_load, 0);
diff -rubN /usr/src1/src/sys/dev/usb/ucycom.c /usr/src/sys/dev/usb/ucycom.c
--- /usr/src1/src/sys/dev/usb/ucycom.c	Tue Oct 12 09:21:03 2004
+++ /usr/src/sys/dev/usb/ucycom.c	Thu Jun  8 21:13:09 2006
@@ -46,6 +46,7 @@
 #include <sys/conf.h>
 #include <sys/kernel.h>
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/sysctl.h>
 #include <sys/bus.h>
 #include <sys/tty.h>
diff -rubN /usr/src1/src/sys/dev/usb/ucycom.c.orig /usr/src/sys/dev/usb/ucycom.c.orig
--- /usr/src1/src/sys/dev/usb/ucycom.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/ucycom.c.orig	Tue Oct 12 09:21:03 2004
@@ -0,0 +1,553 @@
+/*-
+ * Copyright (c) 2004 Dag-Erling Codan Smrgrav
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/dev/usb/ucycom.c,v 1.3 2004/10/12 09:21:03 phk Exp $
+ */
+
+/*
+ * Device driver for Cypress CY7C637xx and CY7C640/1xx series USB to
+ * RS232 bridges.
+ *
+ * Normally, a driver for a USB-to-serial chip would hang off the ucom(4)
+ * driver, but ucom(4) was written under the assumption that all USB-to-
+ * serial chips use bulk pipes for I/O, while the Cypress parts use HID
+ * reports.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/usb/ucycom.c,v 1.3 2004/10/12 09:21:03 phk Exp $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/sysctl.h>
+#include <sys/bus.h>
+#include <sys/tty.h>
+
+#include "usbdevs.h"
+#include <dev/usb/usb.h>
+#include <dev/usb/usb_port.h>
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include <dev/usb/usbhid.h>
+#include <dev/usb/hid.h>
+
+#define UCYCOM_EP_INPUT		 0
+#define UCYCOM_EP_OUTPUT	 1
+
+#define UCYCOM_MAX_IOLEN	 32U
+
+struct ucycom_softc {
+	device_t		 sc_dev;
+	struct tty		*sc_tty;
+	int			 sc_error;
+	unsigned long		 sc_cintr;
+	unsigned long		 sc_cin;
+	unsigned long		 sc_clost;
+	unsigned long		 sc_cout;
+
+	/* usb parameters */
+	usbd_device_handle	 sc_usbdev;
+	usbd_interface_handle	 sc_iface;
+	usbd_pipe_handle	 sc_pipe;
+	uint8_t			 sc_iep; /* input endpoint */
+	uint8_t			 sc_fid; /* feature report id*/
+	uint8_t			 sc_iid; /* input report id */
+	uint8_t			 sc_oid; /* output report id */
+	size_t			 sc_flen; /* feature report length */
+	size_t			 sc_ilen; /* input report length */
+	size_t			 sc_olen; /* output report length */
+	uint8_t			 sc_ibuf[UCYCOM_MAX_IOLEN];
+
+	/* model and settings */
+	uint32_t		 sc_model;
+#define	MODEL_CY7C63743		 0x63743
+#define	MODEL_CY7C64013		 0x64013
+	uint32_t		 sc_baud;
+	uint8_t			 sc_cfg;
+#define UCYCOM_CFG_RESET	 0x80
+#define UCYCOM_CFG_PARODD	 0x20
+#define UCYCOM_CFG_PAREN	 0x10
+#define UCYCOM_CFG_STOPB	 0x08
+#define UCYCOM_CFG_DATAB	 0x03
+	uint8_t			 sc_ist; /* status flags from last input */
+	uint8_t			 sc_ost; /* status flags for next output */
+
+	/* flags */
+	char			 sc_dying;
+};
+
+static int ucycom_probe(device_t);
+static int ucycom_attach(device_t);
+static int ucycom_detach(device_t);
+static t_open_t ucycom_open;
+static t_close_t ucycom_close;
+static void ucycom_start(struct tty *);
+static void ucycom_stop(struct tty *, int);
+static int ucycom_param(struct tty *, struct termios *);
+static int ucycom_configure(struct ucycom_softc *, uint32_t, uint8_t);
+static void ucycom_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
+
+static device_method_t ucycom_methods[] = {
+	DEVMETHOD(device_probe, ucycom_probe),
+	DEVMETHOD(device_attach, ucycom_attach),
+	DEVMETHOD(device_detach, ucycom_detach),
+	{ 0, 0 }
+};
+
+static driver_t ucycom_driver = {
+	"ucycom",
+	ucycom_methods,
+	sizeof(struct ucycom_softc),
+};
+
+static devclass_t ucycom_devclass;
+
+DRIVER_MODULE(ucycom, uhub, ucycom_driver, ucycom_devclass, usbd_driver_load, 0);
+MODULE_VERSION(ucycom, 1);
+MODULE_DEPEND(ucycom, usb, 1, 1, 1);
+
+/*
+ * Supported devices
+ */
+
+static struct ucycom_device {
+	uint16_t		 vendor;
+	uint16_t		 product;
+	uint32_t		 model;
+} ucycom_devices[] = {
+	{ USB_VENDOR_DELORME, USB_PRODUCT_DELORME_EARTHMATE, MODEL_CY7C64013 },
+	{ 0, 0, 0 },
+};
+
+#define UCYCOM_DEFAULT_RATE	 4800
+#define UCYCOM_DEFAULT_CFG	 0x03 /* N-8-1 */
+
+/*****************************************************************************
+ *
+ * Driver interface
+ *
+ */
+
+static int
+ucycom_probe(device_t dev)
+{
+	struct usb_attach_arg *uaa;
+	struct ucycom_device *ud;
+
+	uaa = device_get_ivars(dev);
+	if (uaa->iface != NULL)
+		return (UMATCH_NONE);
+	for (ud = ucycom_devices; ud->model != 0; ++ud)
+		if (ud->vendor == uaa->vendor && ud->product == uaa->product)
+			return (UMATCH_VENDOR_PRODUCT);
+	return (UMATCH_NONE);
+}
+
+static int
+ucycom_attach(device_t dev)
+{
+	struct usb_attach_arg *uaa;
+	struct ucycom_softc *sc;
+	struct ucycom_device *ud;
+	usb_endpoint_descriptor_t *ued;
+	char *devinfo;
+	void *urd;
+	int error, urdlen;
+
+	/* get arguments and softc */
+	uaa = device_get_ivars(dev);
+	sc = device_get_softc(dev);
+	bzero(sc, sizeof *sc);
+	sc->sc_dev = dev;
+	sc->sc_usbdev = uaa->device;
+
+	/* get device description */
+	/* XXX usb_devinfo() has little or no overflow protection */
+	devinfo = malloc(1024, M_USBDEV, M_WAITOK);
+	usbd_devinfo(sc->sc_usbdev, 0, devinfo);
+	device_set_desc_copy(dev, devinfo);
+	device_printf(dev, "%s\n", devinfo);
+	free(devinfo, M_USBDEV);
+
+	/* get chip model */
+	for (ud = ucycom_devices; ud->model != 0; ++ud)
+		if (ud->vendor == uaa->vendor && ud->product == uaa->product)
+			sc->sc_model = ud->model;
+	if (sc->sc_model == 0) {
+		device_printf(dev, "unsupported device\n");
+		return (ENXIO);
+	}
+	device_printf(dev, "Cypress CY7C%X USB to RS232 bridge\n", sc->sc_model);
+
+	/* select configuration */
+	error = usbd_set_config_index(sc->sc_usbdev, 0, 1 /* verbose */);
+	if (error != 0) {
+		device_printf(dev, "failed to select configuration: %s\n",
+		    usbd_errstr(error));
+		return (ENXIO);
+	}
+
+	/* get first interface handle */
+	error = usbd_device2interface_handle(sc->sc_usbdev, 0, &sc->sc_iface);
+	if (error != 0) {
+		device_printf(dev, "failed to get interface handle: %s\n",
+		    usbd_errstr(error));
+		return (ENXIO);
+	}
+
+	/* get report descriptor */
+	error = usbd_read_report_desc(sc->sc_iface, &urd, &urdlen, M_USBDEV);
+	if (error != 0) {
+		device_printf(dev, "failed to get report descriptor: %s\n",
+		    usbd_errstr(error));
+		return (ENXIO);
+	}
+
+	/* get report sizes */
+	sc->sc_flen = hid_report_size(urd, urdlen, hid_feature, &sc->sc_fid);
+	sc->sc_ilen = hid_report_size(urd, urdlen, hid_input, &sc->sc_iid);
+	sc->sc_olen = hid_report_size(urd, urdlen, hid_output, &sc->sc_oid);
+
+	if (sc->sc_ilen > UCYCOM_MAX_IOLEN || sc->sc_olen > UCYCOM_MAX_IOLEN) {
+		device_printf(dev, "I/O report size too big (%zu, %zu, %u)\n",
+		    sc->sc_ilen, sc->sc_olen, UCYCOM_MAX_IOLEN);
+		return (ENXIO);
+	}
+
+	/* get and verify input endpoint descriptor */
+	ued = usbd_interface2endpoint_descriptor(sc->sc_iface, UCYCOM_EP_INPUT);
+	if (ued == NULL) {
+		device_printf(dev, "failed to get input endpoint descriptor\n");
+		return (ENXIO);
+	}
+	if (UE_GET_DIR(ued->bEndpointAddress) != UE_DIR_IN) {
+		device_printf(dev, "not an input endpoint\n");
+		return (ENXIO);
+	}
+	if ((ued->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
+		device_printf(dev, "not an interrupt endpoint\n");
+		return (ENXIO);
+	}
+	sc->sc_iep = ued->bEndpointAddress;
+
+	/* set up tty */
+	sc->sc_tty = ttyalloc();
+	sc->sc_tty->t_sc = sc;
+	sc->sc_tty->t_oproc = ucycom_start;
+	sc->sc_tty->t_stop = ucycom_stop;
+	sc->sc_tty->t_param = ucycom_param;
+	sc->sc_tty->t_open = ucycom_open;
+	sc->sc_tty->t_close = ucycom_close;
+
+	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, "intr", CTLFLAG_RD, &sc->sc_cintr, 0,
+	    "interrupt count");
+	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, "in", CTLFLAG_RD, &sc->sc_cin, 0,
+	    "input bytes read");
+	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, "lost", CTLFLAG_RD, &sc->sc_clost, 0,
+	    "input bytes lost");
+	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, "out", CTLFLAG_RD, &sc->sc_cout, 0,
+	    "output bytes");
+
+	/* create character device node */
+	ttycreate(sc->sc_tty, NULL, 0, 0, "y%r", device_get_unit(sc->sc_dev));
+
+	return (0);
+}
+
+static int
+ucycom_detach(device_t dev)
+{
+	struct ucycom_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	ttyfree(sc->sc_tty);
+
+	return (0);
+}
+
+/*****************************************************************************
+ *
+ * Device interface
+ *
+ */
+
+static int
+ucycom_open(struct tty *tp, struct cdev *cdev)
+{
+	struct ucycom_softc *sc = tp->t_sc;
+	int error;
+
+	/* set default configuration */
+	ucycom_configure(sc, UCYCOM_DEFAULT_RATE, UCYCOM_DEFAULT_CFG);
+
+	/* open interrupt pipe */
+	error = usbd_open_pipe_intr(sc->sc_iface, sc->sc_iep, 0,
+	    &sc->sc_pipe, sc, sc->sc_ibuf, sc->sc_ilen,
+	    ucycom_intr, USBD_DEFAULT_INTERVAL);
+	if (error != 0) {
+		device_printf(sc->sc_dev, "failed to open interrupt pipe: %s\n",
+		    usbd_errstr(error));
+		return (ENXIO);
+	}
+
+	if (bootverbose)
+		device_printf(sc->sc_dev, "%s bypass l_rint()\n",
+		    (sc->sc_tty->t_state & TS_CAN_BYPASS_L_RINT) ?
+		    "can" : "can't");
+
+	/* done! */
+	return (0);
+}
+
+static void
+ucycom_close(struct tty *tp)
+{
+	struct ucycom_softc *sc = tp->t_sc;
+
+	/* stop interrupts and close the interrupt pipe */
+	usbd_abort_pipe(sc->sc_pipe);
+	usbd_close_pipe(sc->sc_pipe);
+	sc->sc_pipe = 0;
+
+	return;
+}
+
+/*****************************************************************************
+ *
+ * TTY interface
+ *
+ */
+
+static void
+ucycom_start(struct tty *tty)
+{
+	struct ucycom_softc *sc = tty->t_sc;
+	uint8_t report[sc->sc_olen];
+	int error, len;
+
+	while (sc->sc_error == 0 && sc->sc_tty->t_outq.c_cc > 0) {
+		switch (sc->sc_model) {
+		case MODEL_CY7C63743:
+			len = q_to_b(&sc->sc_tty->t_outq,
+			    report + 1, sc->sc_olen - 1);
+			sc->sc_cout += len;
+			report[0] = len;
+			len += 1;
+			break;
+		case MODEL_CY7C64013:
+			len = q_to_b(&sc->sc_tty->t_outq,
+			    report + 2, sc->sc_olen - 2);
+			sc->sc_cout += len;
+			report[0] = 0;
+			report[1] = len;
+			len += 2;
+			break;
+		default:
+			panic("unsupported model (driver error)");
+		}
+
+		while (len < sc->sc_olen)
+			report[len++] = 0;
+		error = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
+		    sc->sc_oid, report, sc->sc_olen);
+#if 0
+		if (error != 0) {
+			device_printf(sc->sc_dev,
+			    "failed to set output report: %s\n",
+			    usbd_errstr(error));
+			sc->sc_error = error;
+		}
+#endif
+	}
+}
+
+static void
+ucycom_stop(struct tty *tty, int flags)
+{
+	struct ucycom_softc *sc;
+
+	sc = tty->t_sc;
+	if (bootverbose)
+		device_printf(sc->sc_dev, "%s()\n", __func__);
+}
+
+static int
+ucycom_param(struct tty *tty, struct termios *t)
+{
+	struct ucycom_softc *sc;
+	uint32_t baud;
+	uint8_t cfg;
+	int error;
+
+	sc = tty->t_sc;
+
+	if (t->c_ispeed != t->c_ospeed)
+		return (EINVAL);
+	baud = t->c_ispeed;
+
+	if (t->c_cflag & CIGNORE) {
+		cfg = sc->sc_cfg;
+	} else {
+		cfg = 0;
+		switch (t->c_cflag & CSIZE) {
+		case CS8:
+			++cfg;
+		case CS7:
+			++cfg;
+		case CS6:
+			++cfg;
+		case CS5:
+			break;
+		default:
+			return (EINVAL);
+		}
+		if (t->c_cflag & CSTOPB)
+			cfg |= UCYCOM_CFG_STOPB;
+		if (t->c_cflag & PARENB)
+			cfg |= UCYCOM_CFG_PAREN;
+		if (t->c_cflag & PARODD)
+			cfg |= UCYCOM_CFG_PARODD;
+	}
+
+	error = ucycom_configure(sc, baud, cfg);
+	return (error);
+}
+
+/*****************************************************************************
+ *
+ * Hardware interface
+ *
+ */
+
+static int
+ucycom_configure(struct ucycom_softc *sc, uint32_t baud, uint8_t cfg)
+{
+	uint8_t report[sc->sc_flen];
+	int error;
+
+	switch (baud) {
+	case 600:
+	case 1200:
+	case 2400:
+	case 4800:
+	case 9600:
+	case 19200:
+	case 38400:
+	case 57600:
+#if 0
+	/*
+	 * Stock chips only support standard baud rates in the 600 - 57600
+	 * range, but higher rates can be achieved using custom firmware.
+	 */
+	case 115200:
+	case 153600:
+	case 192000:
+#endif
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	if (bootverbose)
+		device_printf(sc->sc_dev, "%d baud, %c-%d-%d\n", baud,
+		    (cfg & UCYCOM_CFG_PAREN) ?
+		    ((cfg & UCYCOM_CFG_PARODD) ? 'O' : 'E') : 'N',
+		    5 + (cfg & UCYCOM_CFG_DATAB),
+		    (cfg & UCYCOM_CFG_STOPB) ? 2 : 1);
+	report[0] = baud & 0xff;
+	report[1] = (baud >> 8) & 0xff;
+	report[2] = (baud >> 16) & 0xff;
+	report[3] = (baud >> 24) & 0xff;
+	report[4] = cfg;
+	error = usbd_set_report(sc->sc_iface, UHID_FEATURE_REPORT,
+	    sc->sc_fid, report, sc->sc_flen);
+	if (error != 0) {
+		device_printf(sc->sc_dev, "%s\n", usbd_errstr(error));
+		return (EIO);
+	}
+	sc->sc_baud = baud;
+	sc->sc_cfg = cfg;
+	return (0);
+}
+
+static void
+ucycom_intr(usbd_xfer_handle xfer, usbd_private_handle scp, usbd_status status)
+{
+	struct ucycom_softc *sc = scp;
+	uint8_t *data;
+	int i, len, lost;
+
+	sc->sc_cintr++;
+
+	switch (sc->sc_model) {
+	case MODEL_CY7C63743:
+		sc->sc_ist = sc->sc_ibuf[0] & ~0x07;
+		len = sc->sc_ibuf[0] & 0x07;
+		data = sc->sc_ibuf + 1;
+		break;
+	case MODEL_CY7C64013:
+		sc->sc_ist = sc->sc_ibuf[0] & ~0x07;
+		len = sc->sc_ibuf[1];
+		data = sc->sc_ibuf + 2;
+		break;
+	default:
+		panic("unsupported model (driver error)");
+	}
+
+	switch (status) {
+	case USBD_NORMAL_COMPLETION:
+		break;
+	default:
+		/* XXX */
+		return;
+	}
+
+	if (sc->sc_tty->t_state & TS_CAN_BYPASS_L_RINT) {
+		/* XXX flow control! */
+		lost = b_to_q(data, len, &sc->sc_tty->t_rawq);
+		sc->sc_tty->t_rawcc += len - lost;
+		ttwakeup(sc->sc_tty);
+	} else {
+		for (i = 0, lost = len; i < len; ++i, --lost)
+			if (ttyld_rint(sc->sc_tty, data[i]) != 0)
+				break;
+	}
+	sc->sc_cin += len - lost;
+	sc->sc_clost += lost;
+}
diff -rubN /usr/src1/src/sys/dev/usb/udbp.c /usr/src/sys/dev/usb/udbp.c
--- /usr/src1/src/sys/dev/usb/udbp.c	Thu Jan  6 01:43:28 2005
+++ /usr/src/sys/dev/usb/udbp.c	Thu Jun  8 21:13:09 2006
@@ -91,7 +91,6 @@
 #include <sys/errno.h>
 #include <sys/sysctl.h>
 #include <net/if.h>
-#include <machine/bus.h>
 
 #include <dev/usb/usb.h>
 #include <dev/usb/usbdi.h>
diff -rubN /usr/src1/src/sys/dev/usb/udbp.c.orig /usr/src/sys/dev/usb/udbp.c.orig
--- /usr/src1/src/sys/dev/usb/udbp.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/udbp.c.orig	Thu Jan  6 01:43:28 2005
@@ -0,0 +1,841 @@
+/*-
+ * Copyright (c) 1996-2000 Whistle Communications, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of author nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NICK HIBMA AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/usb/udbp.c,v 1.29 2005/01/06 01:43:28 imp Exp $");
+
+/* Driver for arbitrary double bulk pipe devices.
+ * The driver assumes that there will be the same driver on the other side.
+ *
+ * XXX Some more information on what the framing of the IP packets looks like.
+ *
+ * To take full advantage of bulk transmission, packets should be chosen
+ * between 1k and 5k in size (1k to make sure the sending side starts
+ * straming, and <5k to avoid overflowing the system with small TDs).
+ */
+
+
+/* probe/attach/detach:
+ *  Connect the driver to the hardware and netgraph
+ *
+ * udbp_setup_out_transfer(sc);
+ *  Setup an outbound transfer. Only one transmit can be active at the same
+ *  time.
+ *  XXX If it is required that the driver is able to queue multiple requests
+ *      let me know. That is slightly difficult, due to the fact that we
+ *	cannot call usbd_alloc_xfer in int context.
+ *
+ * udbp_setup_in_transfer(sc)
+ *  Prepare an in transfer that will be waiting for data to come in. It
+ *  is submitted and sits there until data is available.
+ *  The callback resubmits a new transfer on completion.
+ *
+ *  The reason we submit a bulk in transfer is that USB does not know about
+ *  interrupts. The bulk transfer continuously polls the device for data.
+ *  While the device has no data available, the device NAKs the TDs. As soon
+ *  as there is data, the transfer happens and the data comes flowing in.
+ *
+ *  In case you were wondering, interrupt transfers happen exactly that way.
+ *  It therefore doesn't make sense to use the interrupt pipe to signal
+ *  'data ready' and then schedule a bulk transfer to fetch it. That would
+ *  incur a 2ms delay at least, without reducing bandwidth requirements.
+ *
+ */
+
+
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/conf.h>
+#include <sys/file.h>
+#if __FreeBSD_version >= 500014
+#include <sys/selinfo.h>
+#else
+#include <sys/select.h>
+#endif
+#include <sys/poll.h>
+#include <sys/mbuf.h>
+#include <sys/socket.h>
+#include <sys/ctype.h>
+#include <sys/errno.h>
+#include <sys/sysctl.h>
+#include <net/if.h>
+#include <machine/bus.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include <dev/usb/usbdivar.h>
+#include <dev/usb/usbhid.h>
+
+#include "usbdevs.h"
+
+
+#include <netgraph/ng_message.h>
+#include <netgraph/ng_parse.h>
+#include <dev/usb/udbp.h>
+#include <netgraph/netgraph.h>
+
+#ifdef USB_DEBUG
+#define DPRINTF(x)	if (udbpdebug) logprintf x
+#define DPRINTFN(n,x)	if (udbpdebug>(n)) logprintf x
+int	udbpdebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, udbp, CTLFLAG_RW, 0, "USB udbp");
+SYSCTL_INT(_hw_usb_udbp, OID_AUTO, debug, CTLFLAG_RW,
+	   &udbpdebug, 0, "udbp debug level");
+#else
+#define DPRINTF(x)
+#define DPRINTFN(n,x)
+#endif
+
+#define MS_TO_TICKS(ms) ((ms) * hz / 1000)
+
+#define UDBP_TIMEOUT	2000	/* timeout on outbound transfers, in msecs */
+#define UDBP_BUFFERSIZE	2048	/* maximum number of bytes in one transfer */
+
+
+struct udbp_softc {
+	device_t		sc_dev;		/* base device */
+	usbd_interface_handle	sc_iface;
+
+	usbd_pipe_handle	sc_bulkin_pipe;
+	int			sc_bulkin;
+	usbd_xfer_handle	sc_bulkin_xfer;
+	void 			*sc_bulkin_buffer;
+	int			sc_bulkin_bufferlen;
+	int			sc_bulkin_datalen;
+
+	usbd_pipe_handle	sc_bulkout_pipe;
+	int			sc_bulkout;
+	usbd_xfer_handle	sc_bulkout_xfer;
+	void 			*sc_bulkout_buffer;
+	int			sc_bulkout_bufferlen;
+	int			sc_bulkout_datalen;
+
+	int			flags;
+#	define			DISCONNECTED		0x01
+#	define			OUT_BUSY		0x02
+#	define			NETGRAPH_INITIALISED	0x04
+	node_p		node;		/* back pointer to node */
+	hook_p  	hook;		/* pointer to the hook */
+	u_int   	packets_in;	/* packets in from downstream */
+	u_int   	packets_out;	/* packets out towards downstream */
+	struct	ifqueue	xmitq_hipri;	/* hi-priority transmit queue */
+	struct	ifqueue	xmitq;		/* low-priority transmit queue */
+
+};
+typedef struct udbp_softc *udbp_p;
+
+
+
+Static ng_constructor_t	ng_udbp_constructor;
+Static ng_rcvmsg_t	ng_udbp_rcvmsg;
+Static ng_shutdown_t	ng_udbp_rmnode;
+Static ng_newhook_t	ng_udbp_newhook;
+Static ng_connect_t	ng_udbp_connect;
+Static ng_rcvdata_t	ng_udbp_rcvdata;
+Static ng_disconnect_t	ng_udbp_disconnect;
+
+/* Parse type for struct ngudbpstat */
+Static const struct ng_parse_struct_field
+	ng_udbp_stat_type_fields[] = NG_UDBP_STATS_TYPE_INFO;
+Static const struct ng_parse_type ng_udbp_stat_type = {
+	&ng_parse_struct_type,
+	&ng_udbp_stat_type_fields
+};
+
+/* List of commands and how to convert arguments to/from ASCII */
+Static const struct ng_cmdlist ng_udbp_cmdlist[] = {
+	{
+	  NGM_UDBP_COOKIE,
+	  NGM_UDBP_GET_STATUS,
+	  "getstatus",
+	  NULL,
+	  &ng_udbp_stat_type,
+	},
+	{
+	  NGM_UDBP_COOKIE,
+	  NGM_UDBP_SET_FLAG,
+	  "setflag",
+	  &ng_parse_int32_type,
+	  NULL
+	},
+	{ 0 }
+};
+
+/* Netgraph node type descriptor */
+Static struct ng_type ng_udbp_typestruct = {
+	.version =	NG_ABI_VERSION,
+	.name =		NG_UDBP_NODE_TYPE,
+	.constructor =	ng_udbp_constructor,
+	.rcvmsg =	ng_udbp_rcvmsg,
+	.shutdown =	ng_udbp_rmnode,
+	.newhook =	ng_udbp_newhook,
+	.connect =	ng_udbp_connect,
+	.rcvdata =	ng_udbp_rcvdata,
+	.disconnect =	ng_udbp_disconnect,
+	.cmdlist =	ng_udbp_cmdlist,
+};
+
+Static int udbp_setup_in_transfer	(udbp_p sc);
+Static void udbp_in_transfer_cb		(usbd_xfer_handle xfer,
+					usbd_private_handle priv,
+					usbd_status err);
+
+Static int udbp_setup_out_transfer	(udbp_p sc);
+Static void udbp_out_transfer_cb	(usbd_xfer_handle xfer,
+					usbd_private_handle priv,
+					usbd_status err);
+
+USB_DECLARE_DRIVER(udbp);
+
+USB_MATCH(udbp)
+{
+	USB_MATCH_START(udbp, uaa);
+	usb_interface_descriptor_t *id;
+	if (!uaa->iface)
+	  return (UMATCH_NONE);
+	id = usbd_get_interface_descriptor(uaa->iface);
+
+	/* XXX Julian, add the id of the device if you have one to test
+	 * things with. run 'usbdevs -v' and note the 3 ID's that appear.
+	 * The Vendor Id and Product Id are in hex and the Revision Id is in
+	 * bcd. But as usual if the revision is 0x101 then you should compare
+	 * the revision id in the device descriptor with 0x101
+	 * Or go search the file usbdevs.h. Maybe the device is already in
+	 * there.
+	 */
+	if ((uaa->vendor == USB_VENDOR_NETCHIP &&
+	     uaa->product == USB_PRODUCT_NETCHIP_TURBOCONNECT))
+		return(UMATCH_VENDOR_PRODUCT);
+
+	if ((uaa->vendor == USB_VENDOR_PROLIFIC &&
+	     (uaa->product == USB_PRODUCT_PROLIFIC_PL2301 ||
+	      uaa->product == USB_PRODUCT_PROLIFIC_PL2302)))
+		return(UMATCH_VENDOR_PRODUCT);
+
+	if ((uaa->vendor == USB_VENDOR_ANCHOR &&
+	     uaa->product == USB_PRODUCT_ANCHOR_EZLINK))
+		return(UMATCH_VENDOR_PRODUCT);
+
+	return (UMATCH_NONE);
+}
+
+USB_ATTACH(udbp)
+{
+	USB_ATTACH_START(udbp, sc, uaa);
+	usbd_interface_handle iface = uaa->iface;
+	usb_interface_descriptor_t *id;
+	usb_endpoint_descriptor_t *ed, *ed_bulkin = NULL, *ed_bulkout = NULL;
+	usbd_status err;
+	char devinfo[1024];
+	int i;
+	static int ngudbp_done_init=0;
+
+	sc->flags |= DISCONNECTED;
+	/* fetch the interface handle for the first interface */
+	(void) usbd_device2interface_handle(uaa->device, 0, &iface);
+	id = usbd_get_interface_descriptor(iface);
+	usbd_devinfo(uaa->device, USBD_SHOW_INTERFACE_CLASS, devinfo);
+	USB_ATTACH_SETUP;
+
+	/* Find the two first bulk endpoints */
+	for (i = 0 ; i < id->bNumEndpoints; i++) {
+		ed = usbd_interface2endpoint_descriptor(iface, i);
+		if (!ed) {
+			printf("%s: could not read endpoint descriptor\n",
+			       USBDEVNAME(sc->sc_dev));
+			USB_ATTACH_ERROR_RETURN;
+		}
+
+		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN
+		    && (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
+			ed_bulkin = ed;
+		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT
+		    && (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
+		        ed_bulkout = ed;
+		}
+
+		if (ed_bulkin && ed_bulkout)	/* found all we need */
+			break;
+	}
+
+	/* Verify that we goething sensible */
+	if (ed_bulkin == NULL || ed_bulkout == NULL) {
+		printf("%s: bulk-in and/or bulk-out endpoint not found\n",
+			USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	if (ed_bulkin->wMaxPacketSize[0] != ed_bulkout->wMaxPacketSize[0] ||
+	   ed_bulkin->wMaxPacketSize[1] != ed_bulkout->wMaxPacketSize[1]) {
+		printf("%s: bulk-in and bulk-out have different packet sizes %d %d %d %d\n",
+			USBDEVNAME(sc->sc_dev),
+		       ed_bulkin->wMaxPacketSize[0],
+		       ed_bulkout->wMaxPacketSize[0],
+		       ed_bulkin->wMaxPacketSize[1],
+		       ed_bulkout->wMaxPacketSize[1]);
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	sc->sc_bulkin = ed_bulkin->bEndpointAddress;
+	sc->sc_bulkout = ed_bulkout->bEndpointAddress;
+
+	DPRINTF(("%s: Bulk-in: 0x%02x, bulk-out 0x%02x, packet size = %d\n",
+		USBDEVNAME(sc->sc_dev), sc->sc_bulkin, sc->sc_bulkout,
+		ed_bulkin->wMaxPacketSize[0]));
+
+	/* Allocate the in transfer struct */
+	sc->sc_bulkin_xfer = usbd_alloc_xfer(uaa->device);
+	if (!sc->sc_bulkin_xfer) {
+		goto bad;
+	}
+	sc->sc_bulkout_xfer = usbd_alloc_xfer(uaa->device);
+	if (!sc->sc_bulkout_xfer) {
+		goto bad;
+	}
+	sc->sc_bulkin_buffer = malloc(UDBP_BUFFERSIZE, M_USBDEV, M_WAITOK);
+	if (!sc->sc_bulkin_buffer) {
+		goto bad;
+	}
+	sc->sc_bulkout_buffer = malloc(UDBP_BUFFERSIZE, M_USBDEV, M_WAITOK);
+	if (!sc->sc_bulkout_xfer || !sc->sc_bulkout_buffer) {
+		goto bad;
+	}
+	sc->sc_bulkin_bufferlen = UDBP_BUFFERSIZE;
+	sc->sc_bulkout_bufferlen = UDBP_BUFFERSIZE;
+
+	/* We have decided on which endpoints to use, now open the pipes */
+	err = usbd_open_pipe(iface, sc->sc_bulkin,
+				USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
+	if (err) {
+		printf("%s: cannot open bulk-in pipe (addr %d)\n",
+			USBDEVNAME(sc->sc_dev), sc->sc_bulkin);
+		goto bad;
+	}
+	err = usbd_open_pipe(iface, sc->sc_bulkout,
+				USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
+	if (err) {
+		printf("%s: cannot open bulk-out pipe (addr %d)\n",
+			USBDEVNAME(sc->sc_dev), sc->sc_bulkout);
+		goto bad;
+	}
+
+	if (!ngudbp_done_init){
+		ngudbp_done_init=1;
+		if (ng_newtype(&ng_udbp_typestruct)) {
+			printf("ngudbp install failed\n");
+			goto bad;
+		}
+	}
+
+	if ((err = ng_make_node_common(&ng_udbp_typestruct, &sc->node)) == 0) {
+		char	nodename[128];
+		sprintf(nodename, "%s", USBDEVNAME(sc->sc_dev));
+		if ((err = ng_name_node(sc->node, nodename))) {
+			NG_NODE_UNREF(sc->node);
+			sc->node = NULL;
+			goto bad;
+		} else {
+			NG_NODE_SET_PRIVATE(sc->node, sc);
+			sc->xmitq.ifq_maxlen = IFQ_MAXLEN;
+			sc->xmitq_hipri.ifq_maxlen = IFQ_MAXLEN;
+			mtx_init(&sc->xmitq.ifq_mtx, "usb_xmitq", NULL,
+			    MTX_DEF);
+			mtx_init(&sc->xmitq_hipri.ifq_mtx,
+			    "usb_xmitq_hipri", NULL, MTX_DEF);
+		}
+	}
+	sc->flags = NETGRAPH_INITIALISED;
+	/* sc->flags &= ~DISCONNECTED; */ /* XXX */
+
+
+	/* the device is now operational */
+
+
+	/* schedule the first incoming xfer */
+	err = udbp_setup_in_transfer(sc);
+	if (err) {
+		goto bad;
+	}
+	USB_ATTACH_SUCCESS_RETURN;
+bad:
+#if 0 /* probably done in udbp_detach() */
+		if (sc->sc_bulkout_buffer) {
+			FREE(sc->sc_bulkout_buffer, M_USBDEV);
+		}
+		if (sc->sc_bulkin_buffer) {
+			FREE(sc->sc_bulkin_buffer, M_USBDEV);
+		}
+		if (sc->sc_bulkout_xfer) {
+			usbd_free_xfer(sc->sc_bulkout_xfer);
+		}
+		if (sc->sc_bulkin_xfer) {
+			usbd_free_xfer(sc->sc_bulkin_xfer);
+		}
+#endif
+		udbp_detach(self);
+		USB_ATTACH_ERROR_RETURN;
+}
+
+
+USB_DETACH(udbp)
+{
+	USB_DETACH_START(udbp, sc);
+
+	sc->flags |= DISCONNECTED;
+
+	DPRINTF(("%s: disconnected\n", USBDEVNAME(self)));
+
+	if (sc->sc_bulkin_pipe) {
+		usbd_abort_pipe(sc->sc_bulkin_pipe);
+		usbd_close_pipe(sc->sc_bulkin_pipe);
+	}
+	if (sc->sc_bulkout_pipe) {
+		usbd_abort_pipe(sc->sc_bulkout_pipe);
+		usbd_close_pipe(sc->sc_bulkout_pipe);
+	}
+
+	if (sc->flags & NETGRAPH_INITIALISED) {
+		ng_rmnode_self(sc->node);
+		NG_NODE_SET_PRIVATE(sc->node, NULL);
+		NG_NODE_UNREF(sc->node);
+		sc->node = NULL;	/* Paranoid */
+	}
+
+	if (sc->sc_bulkin_xfer)
+		usbd_free_xfer(sc->sc_bulkin_xfer);
+	if (sc->sc_bulkout_xfer)
+		usbd_free_xfer(sc->sc_bulkout_xfer);
+
+	if (sc->sc_bulkin_buffer)
+		free(sc->sc_bulkin_buffer, M_USBDEV);
+	if (sc->sc_bulkout_buffer)
+		free(sc->sc_bulkout_buffer, M_USBDEV);
+	return 0;
+}
+
+
+Static int
+udbp_setup_in_transfer(udbp_p sc)
+{
+	void *priv = sc;	/* XXX this should probably be some pointer to
+				 * struct describing the transfer (mbuf?)
+				 * See also below.
+				 */
+	usbd_status err;
+
+	/* XXX
+	 * How should we arrange for 2 extra bytes at the start of the
+	 * packet?
+	 */
+
+	/* Initialise a USB transfer and then schedule it */
+
+	(void) usbd_setup_xfer( sc->sc_bulkin_xfer,
+				sc->sc_bulkin_pipe,
+				priv,
+				sc->sc_bulkin_buffer,
+				sc->sc_bulkin_bufferlen,
+				USBD_SHORT_XFER_OK,
+				USBD_NO_TIMEOUT,
+				udbp_in_transfer_cb);
+
+	err = usbd_transfer(sc->sc_bulkin_xfer);
+	if (err && err != USBD_IN_PROGRESS) {
+		DPRINTF(("%s: failed to setup in-transfer, %s\n",
+			USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
+		return(err);
+	}
+
+	return (USBD_NORMAL_COMPLETION);
+}
+
+Static void
+udbp_in_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
+			usbd_status err)
+{
+	udbp_p 		sc = priv;		/* XXX see priv above */
+	int		s;
+	int		len;
+	struct		mbuf *m;
+
+	if (err) {
+		if (err != USBD_CANCELLED) {
+			DPRINTF(("%s: bulk-out transfer failed: %s\n",
+				USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
+		} else {
+			/* USBD_CANCELLED happens at unload of the driver */
+			return;
+		}
+
+		/* Transfer has failed, packet is not received */
+	} else {
+
+		len = xfer->actlen;
+
+		s = splimp(); /* block network stuff too */
+		if (sc->hook) {
+			/* get packet from device and send on */
+			m = m_devget(sc->sc_bulkin_buffer, len, 0, NULL, NULL);
+	    		NG_SEND_DATA_ONLY(err, sc->hook, m);
+		}
+		splx(s);
+
+	}
+	/* schedule the next in transfer */
+	udbp_setup_in_transfer(sc);
+}
+
+
+Static int
+udbp_setup_out_transfer(udbp_p sc)
+{
+	void *priv = sc;	/* XXX this should probably be some pointer to
+				 * struct describing the transfer (mbuf?)
+				 * See also below.
+				 */
+	int pktlen;
+	usbd_status err;
+	int s, s1;
+	struct mbuf *m;
+
+
+	s = splusb();
+	if (sc->flags & OUT_BUSY)
+		panic("out transfer already in use, we should add queuing");
+	sc->flags |= OUT_BUSY;
+	splx(s);
+	s1 = splimp(); /* Queueing happens at splnet */
+	IF_DEQUEUE(&sc->xmitq_hipri, m);
+	if (m == NULL) {
+		IF_DEQUEUE(&sc->xmitq, m);
+	}
+	splx(s1);
+
+	if (!m) {
+		sc->flags &= ~OUT_BUSY;
+		return (USBD_NORMAL_COMPLETION);
+	}
+
+	pktlen = m->m_pkthdr.len;
+	if (pktlen > sc->sc_bulkout_bufferlen) {
+		printf("%s: Packet too large, %d > %d\n",
+			USBDEVNAME(sc->sc_dev), pktlen,
+			sc->sc_bulkout_bufferlen);
+		return (USBD_IOERROR);
+	}
+
+	m_copydata(m, 0, pktlen, sc->sc_bulkout_buffer);
+	m_freem(m);
+
+	/* Initialise a USB transfer and then schedule it */
+
+	(void) usbd_setup_xfer( sc->sc_bulkout_xfer,
+				sc->sc_bulkout_pipe,
+				priv,
+				sc->sc_bulkout_buffer,
+				pktlen,
+				USBD_SHORT_XFER_OK,
+				UDBP_TIMEOUT,
+				udbp_out_transfer_cb);
+
+	err = usbd_transfer(sc->sc_bulkout_xfer);
+	if (err && err != USBD_IN_PROGRESS) {
+		DPRINTF(("%s: failed to setup out-transfer, %s\n",
+			USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
+		return(err);
+	}
+
+	return (USBD_NORMAL_COMPLETION);
+}
+
+Static void
+udbp_out_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
+			usbd_status err)
+{
+	udbp_p sc = priv;		/* XXX see priv above */
+	int s;
+
+	if (err) {
+		DPRINTF(("%s: bulk-out transfer failed: %s\n",
+			USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
+		/* Transfer has failed, packet is not transmitted */
+		/* XXX Invalidate packet */
+		return;
+	}
+
+	/* packet has been transmitted */
+
+	s = splusb();			/* mark the buffer available */
+	sc->flags &= ~OUT_BUSY;
+	udbp_setup_out_transfer(sc);
+	splx(s);
+}
+
+DRIVER_MODULE(udbp, uhub, udbp_driver, udbp_devclass, usbd_driver_load, 0);
+MODULE_DEPEND(udbp, netgraph, NG_ABI_VERSION, NG_ABI_VERSION, NG_ABI_VERSION);
+
+
+/***********************************************************************
+ * Start of Netgraph methods
+ **********************************************************************/
+
+/*
+ * If this is a device node so this work is done in the attach()
+ * routine and the constructor will return EINVAL as you should not be able
+ * to create nodes that depend on hardware (unless you can add the hardware :)
+ */
+Static int
+ng_udbp_constructor(node_p node)
+{
+	return (EINVAL);
+}
+
+/*
+ * Give our ok for a hook to be added...
+ * If we are not running this might kick a device into life.
+ * Possibly decode information out of the hook name.
+ * Add the hook's private info to the hook structure.
+ * (if we had some). In this example, we assume that there is a
+ * an array of structs, called 'channel' in the private info,
+ * one for each active channel. The private
+ * pointer of each hook points to the appropriate UDBP_hookinfo struct
+ * so that the source of an input packet is easily identified.
+ */
+Static int
+ng_udbp_newhook(node_p node, hook_p hook, const char *name)
+{
+	const udbp_p sc = NG_NODE_PRIVATE(node);
+
+#if 0
+	/* Possibly start up the device if it's not already going */
+	if ((sc->flags & SCF_RUNNING) == 0) {
+		ng_udbp_start_hardware(sc);
+	}
+#endif
+
+	if (strcmp(name, NG_UDBP_HOOK_NAME) == 0) {
+		sc->hook = hook;
+		NG_HOOK_SET_PRIVATE(hook, NULL);
+	} else {
+		return (EINVAL);	/* not a hook we know about */
+	}
+	return(0);
+}
+
+/*
+ * Get a netgraph control message.
+ * Check it is one we understand. If needed, send a response.
+ * We could save the address for an async action later, but don't here.
+ * Always free the message.
+ * The response should be in a malloc'd region that the caller can 'free'.
+ * A response is not required.
+ * Theoretically you could respond defferently to old message types if
+ * the cookie in the header didn't match what we consider to be current
+ * (so that old userland programs could continue to work).
+ */
+Static int
+ng_udbp_rcvmsg(node_p node, item_p item, hook_p lasthook)
+{
+	const udbp_p sc = NG_NODE_PRIVATE(node);
+	struct ng_mesg *resp = NULL;
+	int error = 0;
+	struct ng_mesg *msg;
+
+	NGI_GET_MSG(item, msg);
+	/* Deal with message according to cookie and command */
+	switch (msg->header.typecookie) {
+	case NGM_UDBP_COOKIE:
+		switch (msg->header.cmd) {
+		case NGM_UDBP_GET_STATUS:
+		    {
+			struct ngudbpstat *stats;
+
+			NG_MKRESPONSE(resp, msg, sizeof(*stats), M_NOWAIT);
+			if (!resp) {
+				error = ENOMEM;
+				break;
+			}
+			stats = (struct ngudbpstat *) resp->data;
+			stats->packets_in = sc->packets_in;
+			stats->packets_out = sc->packets_out;
+			break;
+		    }
+		case NGM_UDBP_SET_FLAG:
+			if (msg->header.arglen != sizeof(u_int32_t)) {
+				error = EINVAL;
+				break;
+			}
+			sc->flags = *((u_int32_t *) msg->data);
+			break;
+		default:
+			error = EINVAL;		/* unknown command */
+			break;
+		}
+		break;
+	default:
+		error = EINVAL;			/* unknown cookie type */
+		break;
+	}
+
+	/* Take care of synchronous response, if any */
+	NG_RESPOND_MSG(error, node, item, resp);
+	NG_FREE_MSG(msg);
+	return(error);
+}
+
+/*
+ * Accept data from the hook and queue it for output.
+ */
+Static int
+ng_udbp_rcvdata(hook_p hook, item_p item)
+{
+	const udbp_p sc = NG_NODE_PRIVATE(NG_HOOK_NODE(hook));
+	int error;
+	struct ifqueue	*xmitq_p;
+	int	s;
+	struct mbuf *m;
+	struct ng_tag_prio *ptag;
+
+	NGI_GET_M(item, m);
+	NG_FREE_ITEM(item);
+
+	/*
+	 * Now queue the data for when it can be sent
+	 */
+	if ((ptag = (struct ng_tag_prio *)m_tag_locate(m, NGM_GENERIC_COOKIE,
+	    NG_TAG_PRIO, NULL)) != NULL && (ptag->priority > NG_PRIO_CUTOFF) )
+		xmitq_p = (&sc->xmitq_hipri);
+	else
+		xmitq_p = (&sc->xmitq);
+
+	s = splusb();
+	IF_LOCK(xmitq_p);
+	if (_IF_QFULL(xmitq_p)) {
+		_IF_DROP(xmitq_p);
+		IF_UNLOCK(xmitq_p);
+		splx(s);
+		error = ENOBUFS;
+		goto bad;
+	}
+	_IF_ENQUEUE(xmitq_p, m);
+	IF_UNLOCK(xmitq_p);
+	if (!(sc->flags & OUT_BUSY))
+		udbp_setup_out_transfer(sc);
+	splx(s);
+	return (0);
+
+bad:	/*
+         * It was an error case.
+	 * check if we need to free the mbuf, and then return the error
+	 */
+	NG_FREE_M(m);
+	return (error);
+}
+
+/*
+ * Do local shutdown processing..
+ * We are a persistant device, we refuse to go away, and
+ * only remove our links and reset ourself.
+ */
+Static int
+ng_udbp_rmnode(node_p node)
+{
+	const udbp_p sc = NG_NODE_PRIVATE(node);
+	int err;
+
+	if (sc->flags & DISCONNECTED) {
+		/*
+		 * WE are really going away.. hardware must have gone.
+		 * Assume that the hardware drive part will clear up the
+		 * sc, in fact it may already have done so..
+		 * In which case we may have just segfaulted..XXX
+		 */
+		return (0);
+	}
+
+	/* stolen from attach routine */
+	/* Drain the queues */
+	IF_DRAIN(&sc->xmitq_hipri);
+	IF_DRAIN(&sc->xmitq);
+
+	sc->packets_in = 0;		/* reset stats */
+	sc->packets_out = 0;
+	NG_NODE_UNREF(node);			/* forget it ever existed */
+
+	if ((err = ng_make_node_common(&ng_udbp_typestruct, &sc->node)) == 0) {
+		char	nodename[128];
+		sprintf(nodename, "%s", USBDEVNAME(sc->sc_dev));
+		if ((err = ng_name_node(sc->node, nodename))) {
+			NG_NODE_UNREF(sc->node); /* out damned spot! */
+			sc->flags &= ~NETGRAPH_INITIALISED;
+			sc->node = NULL;
+		} else {
+			NG_NODE_SET_PRIVATE(sc->node, sc);
+		}
+	}
+	return (err);
+}
+
+/*
+ * This is called once we've already connected a new hook to the other node.
+ * It gives us a chance to balk at the last minute.
+ */
+Static int
+ng_udbp_connect(hook_p hook)
+{
+	/* probably not at splnet, force outward queueing */
+	NG_HOOK_FORCE_QUEUE(NG_HOOK_PEER(hook));
+	/* be really amiable and just say "YUP that's OK by me! " */
+	return (0);
+}
+
+/*
+ * Dook disconnection
+ *
+ * For this type, removal of the last link destroys the node
+ */
+Static int
+ng_udbp_disconnect(hook_p hook)
+{
+	const udbp_p sc = NG_NODE_PRIVATE(NG_HOOK_NODE(hook));
+	sc->hook = NULL;
+
+	if ((NG_NODE_NUMHOOKS(NG_HOOK_NODE(hook)) == 0)
+	&& (NG_NODE_IS_VALID(NG_HOOK_NODE(hook))))
+		ng_rmnode_self(NG_HOOK_NODE(hook));
+	return (0);
+}
+
diff -rubN /usr/src1/src/sys/dev/usb/ukbd.c /usr/src/sys/dev/usb/ukbd.c
--- /usr/src1/src/sys/dev/usb/ukbd.c	Wed Mar  1 02:34:16 2006
+++ /usr/src/sys/dev/usb/ukbd.c	Thu Jun  8 21:14:34 2006
@@ -53,6 +53,7 @@
 #include <sys/kernel.h>
 #include <sys/ioccom.h>
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/bus.h>
 #include <sys/file.h>
 #if __FreeBSD_version >= 500000
@@ -237,7 +238,7 @@
 {
 	keyboard_t *kbd = (keyboard_t *)addr;
 
-	(*kbdsw[kbd->kb_index]->intr)(kbd, (void *)status);
+	(*kbdsw[kbd->kb_index]->intr)(kbd, ((u_int8_t *)0) + status);
 }
 
 DRIVER_MODULE(ukbd, uhub, ukbd_driver, ukbd_devclass, ukbd_driver_load, 0);
@@ -683,7 +684,7 @@
 	kbd = (keyboard_t *)arg;
 	state = (ukbd_state_t *)kbd->kb_data;
 	s = splusb();
-	(*kbdsw[kbd->kb_index]->intr)(kbd, (void *)USBD_NORMAL_COMPLETION);
+	(*kbdsw[kbd->kb_index]->intr)(kbd, ((u_int8_t *)0) + USBD_NORMAL_COMPLETION);
 	usb_callout(state->ks_timeout_handle, hz / 40, ukbd_timeout, arg);
 	splx(s);
 }
@@ -691,7 +692,7 @@
 Static int
 ukbd_interrupt(keyboard_t *kbd, void *arg)
 {
-	usbd_status status = (usbd_status)arg;
+	usbd_status status = ((u_int8_t *)arg) - ((u_int8_t *)0);
 	ukbd_state_t *state;
 	struct ukbd_data *ud;
 	struct timeval tv;
diff -rubN /usr/src1/src/sys/dev/usb/ukbd.c.orig /usr/src/sys/dev/usb/ukbd.c.orig
--- /usr/src1/src/sys/dev/usb/ukbd.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/ukbd.c.orig	Wed Mar  1 02:34:16 2006
@@ -0,0 +1,1480 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Modifications for SUN TYPE 6 USB Keyboard by
+ *  Jrg Peter Schley (jps@scxnet.de)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/usb/ukbd.c,v 1.52.2.1 2006/03/01 02:34:16 emax Exp $");
+
+/*
+ * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
+ */
+
+#include "opt_kbd.h"
+#include "opt_ukbd.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/ioccom.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/file.h>
+#if __FreeBSD_version >= 500000
+#include <sys/limits.h>
+#else
+#include <machine/limits.h>
+#endif
+#if __FreeBSD_version >= 500014
+#include <sys/selinfo.h>
+#else
+#include <sys/select.h>
+#endif
+#include <sys/sysctl.h>
+#include <sys/uio.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbhid.h>
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include "usbdevs.h"
+#include <dev/usb/usb_quirks.h>
+#include <dev/usb/hid.h>
+
+#include <sys/kbio.h>
+#include <dev/kbd/kbdreg.h>
+
+#define UKBD_EMULATE_ATSCANCODE	1
+
+#define DRIVER_NAME	"ukbd"
+
+#define delay(d)         DELAY(d)
+
+#ifdef USB_DEBUG
+#define DPRINTF(x)	if (ukbddebug) logprintf x
+#define DPRINTFN(n,x)	if (ukbddebug>(n)) logprintf x
+int	ukbddebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, ukbd, CTLFLAG_RW, 0, "USB ukbd");
+SYSCTL_INT(_hw_usb_ukbd, OID_AUTO, debug, CTLFLAG_RW,
+	   &ukbddebug, 0, "ukbd debug level");
+#else
+#define DPRINTF(x)
+#define DPRINTFN(n,x)
+#endif
+
+#define UPROTO_BOOT_KEYBOARD 1
+
+#define NKEYCODE 6
+
+struct ukbd_data {
+	u_int8_t	modifiers;
+#define MOD_CONTROL_L	0x01
+#define MOD_CONTROL_R	0x10
+#define MOD_SHIFT_L	0x02
+#define MOD_SHIFT_R	0x20
+#define MOD_ALT_L	0x04
+#define MOD_ALT_R	0x40
+#define MOD_WIN_L	0x08
+#define MOD_WIN_R	0x80
+	u_int8_t	reserved;
+	u_int8_t	keycode[NKEYCODE];
+};
+
+#define MAXKEYS (NMOD+2*NKEYCODE)
+
+typedef struct ukbd_softc {
+	device_t		sc_dev;		/* base device */
+} ukbd_softc_t;
+
+#define	UKBD_CHUNK	128	/* chunk size for read */
+#define	UKBD_BSIZE	1020	/* buffer size */
+
+typedef void usbd_intr_t(usbd_xfer_handle, usbd_private_handle, usbd_status);
+typedef void usbd_disco_t(void *);
+
+Static int		ukbd_resume(device_t self);
+Static usbd_intr_t	ukbd_intr;
+Static int		ukbd_driver_load(module_t mod, int what, void *arg);
+
+USB_DECLARE_DRIVER_INIT(ukbd, DEVMETHOD(device_resume, ukbd_resume));
+
+USB_MATCH(ukbd)
+{
+	USB_MATCH_START(ukbd, uaa);
+
+	keyboard_switch_t *sw;
+	void *arg[2];
+	int unit = device_get_unit(self);
+
+	sw = kbd_get_switch(DRIVER_NAME);
+	if (sw == NULL)
+		return (UMATCH_NONE);
+
+	arg[0] = (void *)uaa;
+	arg[1] = (void *)ukbd_intr;
+	if ((*sw->probe)(unit, (void *)arg, 0))
+		return (UMATCH_NONE);
+
+	return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
+}
+
+USB_ATTACH(ukbd)
+{
+	USB_ATTACH_START(ukbd, sc, uaa);
+	usbd_interface_handle iface = uaa->iface;
+	usb_interface_descriptor_t *id;
+	char devinfo[1024];
+
+	keyboard_switch_t *sw;
+	keyboard_t *kbd;
+	void *arg[2];
+	int unit = device_get_unit(self);
+
+	sw = kbd_get_switch(DRIVER_NAME);
+	if (sw == NULL)
+		USB_ATTACH_ERROR_RETURN;
+
+	id = usbd_get_interface_descriptor(iface);
+	usbd_devinfo(uaa->device, USBD_SHOW_INTERFACE_CLASS, devinfo);
+	USB_ATTACH_SETUP;
+
+	arg[0] = (void *)uaa;
+	arg[1] = (void *)ukbd_intr;
+	kbd = NULL;
+	if ((*sw->probe)(unit, (void *)arg, 0))
+		USB_ATTACH_ERROR_RETURN;
+	if ((*sw->init)(unit, &kbd, (void *)arg, 0))
+		USB_ATTACH_ERROR_RETURN;
+	(*sw->enable)(kbd);
+
+#ifdef KBD_INSTALL_CDEV
+	if (kbd_attach(kbd))
+		USB_ATTACH_ERROR_RETURN;
+#endif
+	if (bootverbose)
+		(*sw->diag)(kbd, bootverbose);
+
+	USB_ATTACH_SUCCESS_RETURN;
+}
+
+int
+ukbd_detach(device_t self)
+{
+	keyboard_t *kbd;
+	int error;
+
+	kbd = kbd_get_keyboard(kbd_find_keyboard(DRIVER_NAME,
+						 device_get_unit(self)));
+	if (kbd == NULL) {
+		DPRINTF(("%s: keyboard not attached!?\n", USBDEVNAME(self)));
+		return ENXIO;
+	}
+	(*kbdsw[kbd->kb_index]->disable)(kbd);
+
+#ifdef KBD_INSTALL_CDEV
+	error = kbd_detach(kbd);
+	if (error)
+		return error;
+#endif
+	error = (*kbdsw[kbd->kb_index]->term)(kbd);
+	if (error)
+		return error;
+
+	DPRINTF(("%s: disconnected\n", USBDEVNAME(self)));
+
+	return (0);
+}
+
+Static int
+ukbd_resume(device_t self)
+{
+	keyboard_t *kbd;
+
+	kbd = kbd_get_keyboard(kbd_find_keyboard(DRIVER_NAME,
+						 device_get_unit(self)));
+	if (kbd)
+		(*kbdsw[kbd->kb_index]->clear_state)(kbd);
+	return (0);
+}
+
+void
+ukbd_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
+{
+	keyboard_t *kbd = (keyboard_t *)addr;
+
+	(*kbdsw[kbd->kb_index]->intr)(kbd, (void *)status);
+}
+
+DRIVER_MODULE(ukbd, uhub, ukbd_driver, ukbd_devclass, ukbd_driver_load, 0);
+
+
+#define UKBD_DEFAULT	0
+
+#define KEY_ERROR	0x01
+
+#define KEY_PRESS	0
+#define KEY_RELEASE	0x400
+#define KEY_INDEX(c)	((c) & ~KEY_RELEASE)
+
+#define SCAN_PRESS	0
+#define SCAN_RELEASE	0x80
+#define SCAN_PREFIX_E0	0x100
+#define SCAN_PREFIX_E1	0x200
+#define SCAN_PREFIX_CTL	0x400
+#define SCAN_PREFIX_SHIFT 0x800
+#define SCAN_PREFIX	(SCAN_PREFIX_E0 | SCAN_PREFIX_E1 | SCAN_PREFIX_CTL \
+			 | SCAN_PREFIX_SHIFT)
+#define SCAN_CHAR(c)	((c) & 0x7f)
+
+#define NMOD 8
+Static struct {
+	int mask, key;
+} ukbd_mods[NMOD] = {
+	{ MOD_CONTROL_L, 0xe0 },
+	{ MOD_CONTROL_R, 0xe4 },
+	{ MOD_SHIFT_L,   0xe1 },
+	{ MOD_SHIFT_R,   0xe5 },
+	{ MOD_ALT_L,     0xe2 },
+	{ MOD_ALT_R,     0xe6 },
+	{ MOD_WIN_L,     0xe3 },
+	{ MOD_WIN_R,	 0xe7 },
+};
+
+#define NN 0			/* no translation */
+/*
+ * Translate USB keycodes to AT keyboard scancodes.
+ */
+/*
+ * FIXME: Mac USB keyboard generates:
+ * 0x53: keypad NumLock/Clear
+ * 0x66: Power
+ * 0x67: keypad =
+ * 0x68: F13
+ * 0x69: F14
+ * 0x6a: F15
+ */
+Static u_int8_t ukbd_trtab[256] = {
+	   0,   0,   0,   0,  30,  48,  46,  32, /* 00 - 07 */
+	  18,  33,  34,  35,  23,  36,  37,  38, /* 08 - 0F */
+	  50,  49,  24,  25,  16,  19,  31,  20, /* 10 - 17 */
+	  22,  47,  17,  45,  21,  44,   2,   3, /* 18 - 1F */
+	   4,   5,   6,   7,   8,   9,  10,  11, /* 20 - 27 */
+	  28,   1,  14,  15,  57,  12,  13,  26, /* 28 - 2F */
+	  27,  43,  43,  39,  40,  41,  51,  52, /* 30 - 37 */
+	  53,  58,  59,  60,  61,  62,  63,  64, /* 38 - 3F */
+	  65,  66,  67,  68,  87,  88,  92,  70, /* 40 - 47 */
+	 104, 102,  94,  96, 103,  99, 101,  98, /* 48 - 4F */
+	  97, 100,  95,  69,  91,  55,  74,  78, /* 50 - 57 */
+	  89,  79,  80,  81,  75,  76,  77,  71, /* 58 - 5F */
+          72,  73,  82,  83,  86, 107, 122,  NN, /* 60 - 67 */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 68 - 6F */
+          NN,  NN,  NN,  NN, 115, 108, 111, 113, /* 70 - 77 */
+         109, 110, 112, 118, 114, 116, 117, 119, /* 78 - 7F */
+         121, 120,  NN,  NN,  NN,  NN,  NN, 115, /* 80 - 87 */
+         112, 125, 121, 123,  NN,  NN,  NN,  NN, /* 88 - 8F */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 90 - 97 */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 98 - 9F */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* A0 - A7 */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* A8 - AF */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* B0 - B7 */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* B8 - BF */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* C0 - C7 */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* C8 - CF */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* D0 - D7 */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* D8 - DF */
+          29,  42,  56, 105,  90,  54,  93, 106, /* E0 - E7 */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* E8 - EF */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* F0 - F7 */
+          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* F8 - FF */
+};
+
+typedef struct ukbd_state {
+	usbd_interface_handle ks_iface;	/* interface */
+	usbd_pipe_handle ks_intrpipe;	/* interrupt pipe */
+	struct usb_attach_arg *ks_uaa;
+	int ks_ep_addr;
+
+	struct ukbd_data ks_ndata;
+	struct ukbd_data ks_odata;
+	u_long		ks_ntime[NKEYCODE];
+	u_long		ks_otime[NKEYCODE];
+
+#define INPUTBUFSIZE	(NMOD + 2*NKEYCODE)
+	u_int		ks_input[INPUTBUFSIZE];	/* input buffer */
+	int		ks_inputs;
+	int		ks_inputhead;
+	int		ks_inputtail;
+
+	int		ks_ifstate;
+#define	INTRENABLED	(1 << 0)
+#define	DISCONNECTED	(1 << 1)
+
+	usb_callout_t ks_timeout_handle;
+
+	int		ks_mode;	/* input mode (K_XLATE,K_RAW,K_CODE) */
+	int		ks_flags;	/* flags */
+#define COMPOSE		(1 << 0)
+	int		ks_polling;
+	int		ks_state;	/* shift/lock key state */
+	int		ks_accents;	/* accent key index (> 0) */
+	u_int		ks_composed_char; /* composed char code (> 0) */
+#ifdef UKBD_EMULATE_ATSCANCODE
+	u_int		ks_buffered_char[2];
+#endif
+} ukbd_state_t;
+
+/* keyboard driver declaration */
+Static int		ukbd_configure(int flags);
+Static kbd_probe_t	ukbd_probe;
+Static kbd_init_t	ukbd_init;
+Static kbd_term_t	ukbd_term;
+Static kbd_intr_t	ukbd_interrupt;
+Static kbd_test_if_t	ukbd_test_if;
+Static kbd_enable_t	ukbd_enable;
+Static kbd_disable_t	ukbd_disable;
+Static kbd_read_t	ukbd_read;
+Static kbd_check_t	ukbd_check;
+Static kbd_read_char_t	ukbd_read_char;
+Static kbd_check_char_t	ukbd_check_char;
+Static kbd_ioctl_t	ukbd_ioctl;
+Static kbd_lock_t	ukbd_lock;
+Static kbd_clear_state_t ukbd_clear_state;
+Static kbd_get_state_t	ukbd_get_state;
+Static kbd_set_state_t	ukbd_set_state;
+Static kbd_poll_mode_t	ukbd_poll;
+
+keyboard_switch_t ukbdsw = {
+	ukbd_probe,
+	ukbd_init,
+	ukbd_term,
+	ukbd_interrupt,
+	ukbd_test_if,
+	ukbd_enable,
+	ukbd_disable,
+	ukbd_read,
+	ukbd_check,
+	ukbd_read_char,
+	ukbd_check_char,
+	ukbd_ioctl,
+	ukbd_lock,
+	ukbd_clear_state,
+	ukbd_get_state,
+	ukbd_set_state,
+	genkbd_get_fkeystr,
+	ukbd_poll,
+	genkbd_diag,
+};
+
+KEYBOARD_DRIVER(ukbd, ukbdsw, ukbd_configure);
+
+/* local functions */
+Static int		ukbd_enable_intr(keyboard_t *kbd, int on,
+					 usbd_intr_t *func);
+Static void		ukbd_timeout(void *arg);
+
+Static int		ukbd_getc(ukbd_state_t *state);
+Static int		probe_keyboard(struct usb_attach_arg *uaa, int flags);
+Static int		init_keyboard(ukbd_state_t *state, int *type,
+				      int flags);
+Static void		set_leds(ukbd_state_t *state, int leds);
+Static int		set_typematic(keyboard_t *kbd, int code);
+#ifdef UKBD_EMULATE_ATSCANCODE
+Static int		keycode2scancode(int keycode, int shift, int up);
+#endif
+
+/* local variables */
+
+/* the initial key map, accent map and fkey strings */
+#ifdef UKBD_DFLT_KEYMAP
+#define KBD_DFLT_KEYMAP
+#include "ukbdmap.h"
+#endif
+#include <dev/kbd/kbdtables.h>
+
+/* structures for the default keyboard */
+Static keyboard_t	default_kbd;
+Static ukbd_state_t	default_kbd_state;
+Static keymap_t		default_keymap;
+Static accentmap_t	default_accentmap;
+Static fkeytab_t	default_fkeytab[NUM_FKEYS];
+
+/*
+ * The back door to the keyboard driver!
+ * This function is called by the console driver, via the kbdio module,
+ * to tickle keyboard drivers when the low-level console is being initialized.
+ * Almost nothing in the kernel has been initialied yet.  Try to probe
+ * keyboards if possible.
+ * NOTE: because of the way the low-level conole is initialized, this routine
+ * may be called more than once!!
+ */
+Static int
+ukbd_configure(int flags)
+{
+	return 0;
+
+#if 0 /* not yet */
+	keyboard_t *kbd;
+	device_t device;
+	struct usb_attach_arg *uaa;
+	void *arg[2];
+
+	device = devclass_get_device(ukbd_devclass, UKBD_DEFAULT);
+	if (device == NULL)
+		return 0;
+	uaa = (struct usb_attach_arg *)device_get_ivars(device);
+	if (uaa == NULL)
+		return 0;
+
+	/* probe the default keyboard */
+	arg[0] = (void *)uaa;
+	arg[1] = (void *)ukbd_intr;
+	kbd = NULL;
+	if (ukbd_probe(UKBD_DEFAULT, arg, flags))
+		return 0;
+	if (ukbd_init(UKBD_DEFAULT, &kbd, arg, flags))
+		return 0;
+
+	/* return the number of found keyboards */
+	return 1;
+#endif
+}
+
+/* low-level functions */
+
+/* detect a keyboard */
+Static int
+ukbd_probe(int unit, void *arg, int flags)
+{
+	void **data;
+	struct usb_attach_arg *uaa;
+
+	data = (void **)arg;
+	uaa = (struct usb_attach_arg *)data[0];
+
+	/* XXX */
+	if (unit == UKBD_DEFAULT) {
+		if (KBD_IS_PROBED(&default_kbd))
+			return 0;
+	}
+	if (probe_keyboard(uaa, flags))
+		return ENXIO;
+	return 0;
+}
+
+/* reset and initialize the device */
+Static int
+ukbd_init(int unit, keyboard_t **kbdp, void *arg, int flags)
+{
+	keyboard_t *kbd;
+	ukbd_state_t *state;
+	keymap_t *keymap;
+	accentmap_t *accmap;
+	fkeytab_t *fkeymap;
+	int fkeymap_size;
+	void **data = (void **)arg;
+	struct usb_attach_arg *uaa = (struct usb_attach_arg *)data[0];
+
+	/* XXX */
+	if (unit == UKBD_DEFAULT) {
+		*kbdp = kbd = &default_kbd;
+		if (KBD_IS_INITIALIZED(kbd) && KBD_IS_CONFIGURED(kbd))
+			return 0;
+		state = &default_kbd_state;
+		keymap = &default_keymap;
+		accmap = &default_accentmap;
+		fkeymap = default_fkeytab;
+		fkeymap_size =
+			sizeof(default_fkeytab)/sizeof(default_fkeytab[0]);
+	} else if (*kbdp == NULL) {
+		*kbdp = kbd = malloc(sizeof(*kbd), M_DEVBUF, M_NOWAIT);
+		if (kbd == NULL)
+			return ENOMEM;
+		bzero(kbd, sizeof(*kbd));
+		state = malloc(sizeof(*state), M_DEVBUF, M_NOWAIT);
+		keymap = malloc(sizeof(key_map), M_DEVBUF, M_NOWAIT);
+		accmap = malloc(sizeof(accent_map), M_DEVBUF, M_NOWAIT);
+		fkeymap = malloc(sizeof(fkey_tab), M_DEVBUF, M_NOWAIT);
+		fkeymap_size = sizeof(fkey_tab)/sizeof(fkey_tab[0]);
+		if ((state == NULL) || (keymap == NULL) || (accmap == NULL)
+		     || (fkeymap == NULL)) {
+			if (state != NULL)
+				free(state, M_DEVBUF);
+			if (keymap != NULL)
+				free(keymap, M_DEVBUF);
+			if (accmap != NULL)
+				free(accmap, M_DEVBUF);
+			if (fkeymap != NULL)
+				free(fkeymap, M_DEVBUF);
+			free(kbd, M_DEVBUF);
+			return ENOMEM;
+		}
+	} else if (KBD_IS_INITIALIZED(*kbdp) && KBD_IS_CONFIGURED(*kbdp)) {
+		return 0;
+	} else {
+		kbd = *kbdp;
+		state = (ukbd_state_t *)kbd->kb_data;
+		keymap = kbd->kb_keymap;
+		accmap = kbd->kb_accentmap;
+		fkeymap = kbd->kb_fkeytab;
+		fkeymap_size = kbd->kb_fkeytab_size;
+	}
+
+	if (!KBD_IS_PROBED(kbd)) {
+		kbd_init_struct(kbd, DRIVER_NAME, KB_OTHER, unit, flags, 0, 0);
+		bzero(state, sizeof(*state));
+		bcopy(&key_map, keymap, sizeof(key_map));
+		bcopy(&accent_map, accmap, sizeof(accent_map));
+		bcopy(fkey_tab, fkeymap,
+		      imin(fkeymap_size*sizeof(fkeymap[0]), sizeof(fkey_tab)));
+		kbd_set_maps(kbd, keymap, accmap, fkeymap, fkeymap_size);
+		kbd->kb_data = (void *)state;
+
+		if (probe_keyboard(uaa, flags))
+			return ENXIO;
+		else
+			KBD_FOUND_DEVICE(kbd);
+		ukbd_clear_state(kbd);
+		state->ks_mode = K_XLATE;
+		state->ks_iface = uaa->iface;
+		state->ks_uaa = uaa;
+		state->ks_ifstate = 0;
+		usb_callout_init(state->ks_timeout_handle);
+		/*
+		 * FIXME: set the initial value for lock keys in ks_state
+		 * according to the BIOS data?
+		 */
+		KBD_PROBE_DONE(kbd);
+	}
+	if (!KBD_IS_INITIALIZED(kbd) && !(flags & KB_CONF_PROBE_ONLY)) {
+		if (KBD_HAS_DEVICE(kbd)
+		    && init_keyboard((ukbd_state_t *)kbd->kb_data,
+				     &kbd->kb_type, kbd->kb_flags))
+			return ENXIO;
+		ukbd_ioctl(kbd, KDSETLED, (caddr_t)&(state->ks_state));
+		KBD_INIT_DONE(kbd);
+	}
+	if (!KBD_IS_CONFIGURED(kbd)) {
+		if (kbd_register(kbd) < 0)
+			return ENXIO;
+		if (ukbd_enable_intr(kbd, TRUE, (usbd_intr_t *)data[1]) == 0)
+			ukbd_timeout((void *)kbd);
+		KBD_CONFIG_DONE(kbd);
+	}
+
+	return 0;
+}
+
+Static int
+ukbd_enable_intr(keyboard_t *kbd, int on, usbd_intr_t *func)
+{
+	ukbd_state_t *state = (ukbd_state_t *)kbd->kb_data;
+	usbd_status err;
+
+	if (on) {
+		/* Set up interrupt pipe. */
+		if (state->ks_ifstate & INTRENABLED)
+			return EBUSY;
+
+		state->ks_ifstate |= INTRENABLED;
+		err = usbd_open_pipe_intr(state->ks_iface, state->ks_ep_addr,
+					USBD_SHORT_XFER_OK,
+					&state->ks_intrpipe, kbd,
+					&state->ks_ndata,
+					sizeof(state->ks_ndata), func,
+					USBD_DEFAULT_INTERVAL);
+		if (err)
+			return (EIO);
+	} else {
+		/* Disable interrupts. */
+		usbd_abort_pipe(state->ks_intrpipe);
+		usbd_close_pipe(state->ks_intrpipe);
+
+		state->ks_ifstate &= ~INTRENABLED;
+	}
+
+	return (0);
+}
+
+/* finish using this keyboard */
+Static int
+ukbd_term(keyboard_t *kbd)
+{
+	ukbd_state_t *state;
+	int error;
+	int s;
+
+	s = splusb();
+
+	state = (ukbd_state_t *)kbd->kb_data;
+	DPRINTF(("ukbd_term: ks_ifstate=0x%x\n", state->ks_ifstate));
+
+	usb_uncallout(state->ks_timeout_handle, ukbd_timeout, kbd);
+
+	if (state->ks_ifstate & INTRENABLED)
+		ukbd_enable_intr(kbd, FALSE, NULL);
+	if (state->ks_ifstate & INTRENABLED) {
+		splx(s);
+		DPRINTF(("ukbd_term: INTRENABLED!\n"));
+		return ENXIO;
+	}
+
+	error = kbd_unregister(kbd);
+	DPRINTF(("ukbd_term: kbd_unregister() %d\n", error));
+	if (error == 0) {
+		kbd->kb_flags = 0;
+		if (kbd != &default_kbd) {
+			free(kbd->kb_keymap, M_DEVBUF);
+			free(kbd->kb_accentmap, M_DEVBUF);
+			free(kbd->kb_fkeytab, M_DEVBUF);
+			free(state, M_DEVBUF);
+			free(kbd, M_DEVBUF);
+		}
+	}
+
+	splx(s);
+	return error;
+}
+
+
+/* keyboard interrupt routine */
+
+Static void
+ukbd_timeout(void *arg)
+{
+	keyboard_t *kbd;
+	ukbd_state_t *state;
+	int s;
+
+	kbd = (keyboard_t *)arg;
+	state = (ukbd_state_t *)kbd->kb_data;
+	s = splusb();
+	(*kbdsw[kbd->kb_index]->intr)(kbd, (void *)USBD_NORMAL_COMPLETION);
+	usb_callout(state->ks_timeout_handle, hz / 40, ukbd_timeout, arg);
+	splx(s);
+}
+
+Static int
+ukbd_interrupt(keyboard_t *kbd, void *arg)
+{
+	usbd_status status = (usbd_status)arg;
+	ukbd_state_t *state;
+	struct ukbd_data *ud;
+	struct timeval tv;
+	u_long now;
+	int mod, omod;
+	int key, c;
+	int i, j;
+
+	DPRINTFN(5, ("ukbd_intr: status=%d\n", status));
+	if (status == USBD_CANCELLED)
+		return 0;
+
+	state = (ukbd_state_t *)kbd->kb_data;
+	ud = &state->ks_ndata;
+
+	if (status != USBD_NORMAL_COMPLETION) {
+		DPRINTF(("ukbd_intr: status=%d\n", status));
+		if (status == USBD_STALLED)
+		    usbd_clear_endpoint_stall_async(state->ks_intrpipe);
+		return 0;
+	}
+
+	if (ud->keycode[0] == KEY_ERROR)
+		return 0;		/* ignore  */
+
+	getmicrouptime(&tv);
+	now = (u_long)tv.tv_sec*1000 + (u_long)tv.tv_usec/1000;
+
+#define ADDKEY1(c) 		\
+	if (state->ks_inputs < INPUTBUFSIZE) {				\
+		state->ks_input[state->ks_inputtail] = (c);		\
+		++state->ks_inputs;					\
+		state->ks_inputtail = (state->ks_inputtail + 1)%INPUTBUFSIZE; \
+	}
+
+	mod = ud->modifiers;
+	omod = state->ks_odata.modifiers;
+	if (mod != omod) {
+		for (i = 0; i < NMOD; i++)
+			if (( mod & ukbd_mods[i].mask) !=
+			    (omod & ukbd_mods[i].mask))
+				ADDKEY1(ukbd_mods[i].key |
+				       (mod & ukbd_mods[i].mask
+					  ? KEY_PRESS : KEY_RELEASE));
+	}
+
+	/* Check for released keys. */
+	for (i = 0; i < NKEYCODE; i++) {
+		key = state->ks_odata.keycode[i];
+		if (key == 0)
+			continue;
+		for (j = 0; j < NKEYCODE; j++) {
+			if (ud->keycode[j] == 0)
+				continue;
+			if (key == ud->keycode[j])
+				goto rfound;
+		}
+		ADDKEY1(key | KEY_RELEASE);
+	rfound:
+		;
+	}
+
+	/* Check for pressed keys. */
+	for (i = 0; i < NKEYCODE; i++) {
+		key = ud->keycode[i];
+		if (key == 0)
+			continue;
+		state->ks_ntime[i] = now + kbd->kb_delay1;
+		for (j = 0; j < NKEYCODE; j++) {
+			if (state->ks_odata.keycode[j] == 0)
+				continue;
+			if (key == state->ks_odata.keycode[j]) {
+				state->ks_ntime[i] = state->ks_otime[j];
+				if (state->ks_otime[j] > now)
+					goto pfound;
+				state->ks_ntime[i] = now + kbd->kb_delay2;
+				break;
+			}
+		}
+		ADDKEY1(key | KEY_PRESS);
+	pfound:
+		;
+	}
+
+	state->ks_odata = *ud;
+	bcopy(state->ks_ntime, state->ks_otime, sizeof(state->ks_ntime));
+	if (state->ks_inputs <= 0)
+		return 0;
+
+#ifdef USB_DEBUG
+	for (i = state->ks_inputhead, j = 0; j < state->ks_inputs; ++j,
+		i = (i + 1)%INPUTBUFSIZE) {
+		c = state->ks_input[i];
+		DPRINTF(("0x%x (%d) %s\n", c, c,
+			(c & KEY_RELEASE) ? "released":"pressed"));
+	}
+	if (ud->modifiers)
+		DPRINTF(("mod:0x%04x ", ud->modifiers));
+        for (i = 0; i < NKEYCODE; i++) {
+		if (ud->keycode[i])
+			DPRINTF(("%d ", ud->keycode[i]));
+	}
+	DPRINTF(("\n"));
+#endif /* USB_DEBUG */
+
+	if (state->ks_polling)
+		return 0;
+
+	if (KBD_IS_ACTIVE(kbd) && KBD_IS_BUSY(kbd)) {
+		/* let the callback function to process the input */
+		(*kbd->kb_callback.kc_func)(kbd, KBDIO_KEYINPUT,
+					    kbd->kb_callback.kc_arg);
+	} else {
+		/* read and discard the input; no one is waiting for it */
+		do {
+			c = ukbd_read_char(kbd, FALSE);
+		} while (c != NOKEY);
+	}
+
+	return 0;
+}
+
+Static int
+ukbd_getc(ukbd_state_t *state)
+{
+	int c;
+	int s;
+
+	if (state->ks_polling) {
+		DPRINTFN(1,("ukbd_getc: polling\n"));
+		s = splusb();
+		while (state->ks_inputs <= 0)
+			usbd_dopoll(state->ks_iface);
+		splx(s);
+	}
+	s = splusb();
+	if (state->ks_inputs <= 0) {
+		c = -1;
+	} else {
+		c = state->ks_input[state->ks_inputhead];
+		--state->ks_inputs;
+		state->ks_inputhead = (state->ks_inputhead + 1)%INPUTBUFSIZE;
+	}
+	splx(s);
+	return c;
+}
+
+/* test the interface to the device */
+Static int
+ukbd_test_if(keyboard_t *kbd)
+{
+	return 0;
+}
+
+/*
+ * Enable the access to the device; until this function is called,
+ * the client cannot read from the keyboard.
+ */
+Static int
+ukbd_enable(keyboard_t *kbd)
+{
+	int s;
+
+	s = splusb();
+	KBD_ACTIVATE(kbd);
+	splx(s);
+	return 0;
+}
+
+/* disallow the access to the device */
+Static int
+ukbd_disable(keyboard_t *kbd)
+{
+	int s;
+
+	s = splusb();
+	KBD_DEACTIVATE(kbd);
+	splx(s);
+	return 0;
+}
+
+/* read one byte from the keyboard if it's allowed */
+Static int
+ukbd_read(keyboard_t *kbd, int wait)
+{
+	ukbd_state_t *state;
+	int usbcode;
+#ifdef UKBD_EMULATE_ATSCANCODE
+	int keycode;
+	int scancode;
+#endif
+
+	state = (ukbd_state_t *)kbd->kb_data;
+#ifdef UKBD_EMULATE_ATSCANCODE
+	if (state->ks_buffered_char[0]) {
+		scancode = state->ks_buffered_char[0];
+		if (scancode & SCAN_PREFIX) {
+			state->ks_buffered_char[0] = scancode & ~SCAN_PREFIX;
+			return ((scancode & SCAN_PREFIX_E0) ? 0xe0 : 0xe1);
+		} else {
+			state->ks_buffered_char[0] = state->ks_buffered_char[1];
+			state->ks_buffered_char[1] = 0;
+			return scancode;
+		}
+	}
+#endif /* UKBD_EMULATE_ATSCANCODE */
+
+	/* XXX */
+	usbcode = ukbd_getc(state);
+	if (!KBD_IS_ACTIVE(kbd) || (usbcode == -1))
+		return -1;
+	++kbd->kb_count;
+#ifdef UKBD_EMULATE_ATSCANCODE
+	keycode = ukbd_trtab[KEY_INDEX(usbcode)];
+	if (keycode == NN)
+		return -1;
+
+	scancode = keycode2scancode(keycode, state->ks_ndata.modifiers,
+				    usbcode & KEY_RELEASE);
+	if (scancode & SCAN_PREFIX) {
+		if (scancode & SCAN_PREFIX_CTL) {
+			state->ks_buffered_char[0] =
+				0x1d | (scancode & SCAN_RELEASE); /* Ctrl */
+			state->ks_buffered_char[1] = scancode & ~SCAN_PREFIX;
+		} else if (scancode & SCAN_PREFIX_SHIFT) {
+			state->ks_buffered_char[0] =
+				0x2a | (scancode & SCAN_RELEASE); /* Shift */
+			state->ks_buffered_char[1] =
+				scancode & ~SCAN_PREFIX_SHIFT;
+		} else {
+			state->ks_buffered_char[0] = scancode & ~SCAN_PREFIX;
+			state->ks_buffered_char[1] = 0;
+		}
+		return ((scancode & SCAN_PREFIX_E0) ? 0xe0 : 0xe1);
+	}
+	return scancode;
+#else /* !UKBD_EMULATE_ATSCANCODE */
+	return usbcode;
+#endif /* UKBD_EMULATE_ATSCANCODE */
+}
+
+/* check if data is waiting */
+Static int
+ukbd_check(keyboard_t *kbd)
+{
+	if (!KBD_IS_ACTIVE(kbd))
+		return FALSE;
+#ifdef UKBD_EMULATE_ATSCANCODE
+	if (((ukbd_state_t *)kbd->kb_data)->ks_buffered_char[0])
+		return TRUE;
+#endif
+	if (((ukbd_state_t *)kbd->kb_data)->ks_inputs > 0)
+		return TRUE;
+	return FALSE;
+}
+
+/* read char from the keyboard */
+Static u_int
+ukbd_read_char(keyboard_t *kbd, int wait)
+{
+	ukbd_state_t *state;
+	u_int action;
+	int usbcode;
+	int keycode;
+#ifdef UKBD_EMULATE_ATSCANCODE
+	int scancode;
+#endif
+
+	state = (ukbd_state_t *)kbd->kb_data;
+next_code:
+	/* do we have a composed char to return? */
+	if (!(state->ks_flags & COMPOSE) && (state->ks_composed_char > 0)) {
+		action = state->ks_composed_char;
+		state->ks_composed_char = 0;
+		if (action > UCHAR_MAX)
+			return ERRKEY;
+		return action;
+	}
+
+#ifdef UKBD_EMULATE_ATSCANCODE
+	/* do we have a pending raw scan code? */
+	if (state->ks_mode == K_RAW) {
+		if (state->ks_buffered_char[0]) {
+			scancode = state->ks_buffered_char[0];
+			if (scancode & SCAN_PREFIX) {
+				state->ks_buffered_char[0] =
+					scancode & ~SCAN_PREFIX;
+				return ((scancode & SCAN_PREFIX_E0) ? 0xe0 : 0xe1);
+			} else {
+				state->ks_buffered_char[0] =
+					state->ks_buffered_char[1];
+				state->ks_buffered_char[1] = 0;
+				return scancode;
+			}
+		}
+	}
+#endif /* UKBD_EMULATE_ATSCANCODE */
+
+	/* see if there is something in the keyboard port */
+	/* XXX */
+	usbcode = ukbd_getc(state);
+	if (usbcode == -1)
+		return NOKEY;
+	++kbd->kb_count;
+
+#ifdef UKBD_EMULATE_ATSCANCODE
+	/* USB key index -> key code -> AT scan code */
+	keycode = ukbd_trtab[KEY_INDEX(usbcode)];
+	if (keycode == NN)
+		return NOKEY;
+
+	/* return an AT scan code for the K_RAW mode */
+	if (state->ks_mode == K_RAW) {
+		scancode = keycode2scancode(keycode, state->ks_ndata.modifiers,
+					    usbcode & KEY_RELEASE);
+		if (scancode & SCAN_PREFIX) {
+			if (scancode & SCAN_PREFIX_CTL) {
+				state->ks_buffered_char[0] =
+					0x1d | (scancode & SCAN_RELEASE);
+				state->ks_buffered_char[1] =
+					scancode & ~SCAN_PREFIX;
+			} else if (scancode & SCAN_PREFIX_SHIFT) {
+				state->ks_buffered_char[0] =
+					0x2a | (scancode & SCAN_RELEASE);
+				state->ks_buffered_char[1] =
+					scancode & ~SCAN_PREFIX_SHIFT;
+			} else {
+				state->ks_buffered_char[0] =
+					scancode & ~SCAN_PREFIX;
+				state->ks_buffered_char[1] = 0;
+			}
+			return ((scancode & SCAN_PREFIX_E0) ? 0xe0 : 0xe1);
+		}
+		return scancode;
+	}
+#else /* !UKBD_EMULATE_ATSCANCODE */
+	/* return the byte as is for the K_RAW mode */
+	if (state->ks_mode == K_RAW)
+		return usbcode;
+
+	/* USB key index -> key code */
+	keycode = ukbd_trtab[KEY_INDEX(usbcode)];
+	if (keycode == NN)
+		return NOKEY;
+#endif /* UKBD_EMULATE_ATSCANCODE */
+
+	switch (keycode) {
+	case 0x38:	/* left alt (compose key) */
+		if (usbcode & KEY_RELEASE) {
+			if (state->ks_flags & COMPOSE) {
+				state->ks_flags &= ~COMPOSE;
+				if (state->ks_composed_char > UCHAR_MAX)
+					state->ks_composed_char = 0;
+			}
+		} else {
+			if (!(state->ks_flags & COMPOSE)) {
+				state->ks_flags |= COMPOSE;
+				state->ks_composed_char = 0;
+			}
+		}
+		break;
+	/* XXX: I don't like these... */
+	case 0x5c:	/* print screen */
+		if (state->ks_flags & ALTS)
+			keycode = 0x54;	/* sysrq */
+		break;
+	case 0x68:	/* pause/break */
+		if (state->ks_flags & CTLS)
+			keycode = 0x6c;	/* break */
+		break;
+	}
+
+	/* return the key code in the K_CODE mode */
+	if (usbcode & KEY_RELEASE)
+		keycode |= SCAN_RELEASE;
+	if (state->ks_mode == K_CODE)
+		return keycode;
+
+	/* compose a character code */
+	if (state->ks_flags & COMPOSE) {
+		switch (keycode) {
+		/* key pressed, process it */
+		case 0x47: case 0x48: case 0x49:	/* keypad 7,8,9 */
+			state->ks_composed_char *= 10;
+			state->ks_composed_char += keycode - 0x40;
+			if (state->ks_composed_char > UCHAR_MAX)
+				return ERRKEY;
+			goto next_code;
+		case 0x4B: case 0x4C: case 0x4D:	/* keypad 4,5,6 */
+			state->ks_composed_char *= 10;
+			state->ks_composed_char += keycode - 0x47;
+			if (state->ks_composed_char > UCHAR_MAX)
+				return ERRKEY;
+			goto next_code;
+		case 0x4F: case 0x50: case 0x51:	/* keypad 1,2,3 */
+			state->ks_composed_char *= 10;
+			state->ks_composed_char += keycode - 0x4E;
+			if (state->ks_composed_char > UCHAR_MAX)
+				return ERRKEY;
+			goto next_code;
+		case 0x52:				/* keypad 0 */
+			state->ks_composed_char *= 10;
+			if (state->ks_composed_char > UCHAR_MAX)
+				return ERRKEY;
+			goto next_code;
+
+		/* key released, no interest here */
+		case SCAN_RELEASE | 0x47:
+		case SCAN_RELEASE | 0x48:
+		case SCAN_RELEASE | 0x49:		/* keypad 7,8,9 */
+		case SCAN_RELEASE | 0x4B:
+		case SCAN_RELEASE | 0x4C:
+		case SCAN_RELEASE | 0x4D:		/* keypad 4,5,6 */
+		case SCAN_RELEASE | 0x4F:
+		case SCAN_RELEASE | 0x50:
+		case SCAN_RELEASE | 0x51:		/* keypad 1,2,3 */
+		case SCAN_RELEASE | 0x52:		/* keypad 0 */
+			goto next_code;
+
+		case 0x38:				/* left alt key */
+			break;
+
+		default:
+			if (state->ks_composed_char > 0) {
+				state->ks_flags &= ~COMPOSE;
+				state->ks_composed_char = 0;
+				return ERRKEY;
+			}
+			break;
+		}
+	}
+
+	/* keycode to key action */
+	action = genkbd_keyaction(kbd, SCAN_CHAR(keycode),
+				  keycode & SCAN_RELEASE, &state->ks_state,
+				  &state->ks_accents);
+	if (action == NOKEY)
+		goto next_code;
+	else
+		return action;
+}
+
+/* check if char is waiting */
+Static int
+ukbd_check_char(keyboard_t *kbd)
+{
+	ukbd_state_t *state;
+
+	if (!KBD_IS_ACTIVE(kbd))
+		return FALSE;
+	state = (ukbd_state_t *)kbd->kb_data;
+	if (!(state->ks_flags & COMPOSE) && (state->ks_composed_char > 0))
+		return TRUE;
+	return ukbd_check(kbd);
+}
+
+/* some useful control functions */
+Static int
+ukbd_ioctl(keyboard_t *kbd, u_long cmd, caddr_t arg)
+{
+	/* trasnlate LED_XXX bits into the device specific bits */
+	static u_char ledmap[8] = {
+		0, 2, 1, 3, 4, 6, 5, 7,
+	};
+	ukbd_state_t *state = kbd->kb_data;
+	int s;
+	int i;
+
+	s = splusb();
+	switch (cmd) {
+
+	case KDGKBMODE:		/* get keyboard mode */
+		*(int *)arg = state->ks_mode;
+		break;
+	case KDSKBMODE:		/* set keyboard mode */
+		switch (*(int *)arg) {
+		case K_XLATE:
+			if (state->ks_mode != K_XLATE) {
+				/* make lock key state and LED state match */
+				state->ks_state &= ~LOCK_MASK;
+				state->ks_state |= KBD_LED_VAL(kbd);
+			}
+			/* FALLTHROUGH */
+		case K_RAW:
+		case K_CODE:
+			if (state->ks_mode != *(int *)arg) {
+				ukbd_clear_state(kbd);
+				state->ks_mode = *(int *)arg;
+			}
+			break;
+		default:
+			splx(s);
+			return EINVAL;
+		}
+		break;
+
+	case KDGETLED:		/* get keyboard LED */
+		*(int *)arg = KBD_LED_VAL(kbd);
+		break;
+	case KDSETLED:		/* set keyboard LED */
+		/* NOTE: lock key state in ks_state won't be changed */
+		if (*(int *)arg & ~LOCK_MASK) {
+			splx(s);
+			return EINVAL;
+		}
+		i = *(int *)arg;
+		/* replace CAPS LED with ALTGR LED for ALTGR keyboards */
+		if (kbd->kb_keymap->n_keys > ALTGR_OFFSET) {
+			if (i & ALKED)
+				i |= CLKED;
+			else
+				i &= ~CLKED;
+		}
+		if (KBD_HAS_DEVICE(kbd)) {
+			set_leds(state, ledmap[i & LED_MASK]);
+			/* XXX: error check? */
+		}
+		KBD_LED_VAL(kbd) = *(int *)arg;
+		break;
+
+	case KDGKBSTATE:	/* get lock key state */
+		*(int *)arg = state->ks_state & LOCK_MASK;
+		break;
+	case KDSKBSTATE:	/* set lock key state */
+		if (*(int *)arg & ~LOCK_MASK) {
+			splx(s);
+			return EINVAL;
+		}
+		state->ks_state &= ~LOCK_MASK;
+		state->ks_state |= *(int *)arg;
+		splx(s);
+		/* set LEDs and quit */
+		return ukbd_ioctl(kbd, KDSETLED, arg);
+
+	case KDSETREPEAT:	/* set keyboard repeat rate (new interface) */
+		splx(s);
+		if (!KBD_HAS_DEVICE(kbd))
+			return 0;
+		if (((int *)arg)[1] < 0)
+			return EINVAL;
+		if (((int *)arg)[0] < 0)
+			return EINVAL;
+		else if (((int *)arg)[0] == 0)	/* fastest possible value */
+			kbd->kb_delay1 = 200;
+		else
+			kbd->kb_delay1 = ((int *)arg)[0];
+		kbd->kb_delay2 = ((int *)arg)[1];
+		return 0;
+
+	case KDSETRAD:		/* set keyboard repeat rate (old interface) */
+		splx(s);
+		return set_typematic(kbd, *(int *)arg);
+
+	case PIO_KEYMAP:	/* set keyboard translation table */
+	case PIO_KEYMAPENT:	/* set keyboard translation table entry */
+	case PIO_DEADKEYMAP:	/* set accent key translation table */
+		state->ks_accents = 0;
+		/* FALLTHROUGH */
+	default:
+		splx(s);
+		return genkbd_commonioctl(kbd, cmd, arg);
+
+#ifdef USB_DEBUG
+	case USB_SETDEBUG:
+		ukbddebug = *(int *)arg;
+		break;
+#endif
+	}
+
+	splx(s);
+	return 0;
+}
+
+/* lock the access to the keyboard */
+Static int
+ukbd_lock(keyboard_t *kbd, int lock)
+{
+	/* XXX ? */
+	return TRUE;
+}
+
+/* clear the internal state of the keyboard */
+Static void
+ukbd_clear_state(keyboard_t *kbd)
+{
+	ukbd_state_t *state;
+
+	state = (ukbd_state_t *)kbd->kb_data;
+	state->ks_flags = 0;
+	state->ks_polling = 0;
+	state->ks_state &= LOCK_MASK;	/* preserve locking key state */
+	state->ks_accents = 0;
+	state->ks_composed_char = 0;
+#ifdef UKBD_EMULATE_ATSCANCODE
+	state->ks_buffered_char[0] = 0;
+	state->ks_buffered_char[1] = 0;
+#endif
+	bzero(&state->ks_ndata, sizeof(state->ks_ndata));
+	bzero(&state->ks_odata, sizeof(state->ks_odata));
+	bzero(&state->ks_ntime, sizeof(state->ks_ntime));
+	bzero(&state->ks_otime, sizeof(state->ks_otime));
+}
+
+/* save the internal state */
+Static int
+ukbd_get_state(keyboard_t *kbd, void *buf, size_t len)
+{
+	if (len == 0)
+		return sizeof(ukbd_state_t);
+	if (len < sizeof(ukbd_state_t))
+		return -1;
+	bcopy(kbd->kb_data, buf, sizeof(ukbd_state_t));
+	return 0;
+}
+
+/* set the internal state */
+Static int
+ukbd_set_state(keyboard_t *kbd, void *buf, size_t len)
+{
+	if (len < sizeof(ukbd_state_t))
+		return ENOMEM;
+	bcopy(buf, kbd->kb_data, sizeof(ukbd_state_t));
+	return 0;
+}
+
+Static int
+ukbd_poll(keyboard_t *kbd, int on)
+{
+	ukbd_state_t *state;
+	usbd_device_handle dev;
+	int s;
+
+	state = (ukbd_state_t *)kbd->kb_data;
+	usbd_interface2device_handle(state->ks_iface, &dev);
+
+	s = splusb();
+	if (on) {
+		if (state->ks_polling == 0)
+			usbd_set_polling(dev, on);
+		++state->ks_polling;
+	} else {
+		--state->ks_polling;
+		if (state->ks_polling == 0)
+			usbd_set_polling(dev, on);
+	}
+	splx(s);
+	return 0;
+}
+
+/* local functions */
+
+Static int
+probe_keyboard(struct usb_attach_arg *uaa, int flags)
+{
+	usb_interface_descriptor_t *id;
+
+	if (!uaa->iface)	/* we attach to ifaces only */
+		return EINVAL;
+
+	/* Check that this is a keyboard that speaks the boot protocol. */
+	id = usbd_get_interface_descriptor(uaa->iface);
+	if (id
+	    && id->bInterfaceClass == UICLASS_HID
+	    && id->bInterfaceSubClass == UISUBCLASS_BOOT
+	    && id->bInterfaceProtocol == UPROTO_BOOT_KEYBOARD)
+		return 0;	/* found it */
+
+	return EINVAL;
+}
+
+Static int
+init_keyboard(ukbd_state_t *state, int *type, int flags)
+{
+	usb_endpoint_descriptor_t *ed;
+	usbd_status err;
+
+	*type = KB_OTHER;
+
+	state->ks_ifstate |= DISCONNECTED;
+
+	ed = usbd_interface2endpoint_descriptor(state->ks_iface, 0);
+	if (!ed) {
+		printf("ukbd: could not read endpoint descriptor\n");
+		return EIO;
+	}
+
+	DPRINTFN(10,("ukbd:init_keyboard: \
+bLength=%d bDescriptorType=%d bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d bInterval=%d\n",
+	       ed->bLength, ed->bDescriptorType,
+	       UE_GET_ADDR(ed->bEndpointAddress),
+	       UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN ? "in":"out",
+	       UE_GET_XFERTYPE(ed->bmAttributes),
+	       UGETW(ed->wMaxPacketSize), ed->bInterval));
+
+	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
+	    UE_GET_XFERTYPE(ed->bmAttributes) != UE_INTERRUPT) {
+		printf("ukbd: unexpected endpoint\n");
+		return EINVAL;
+	}
+
+	if ((usbd_get_quirks(state->ks_uaa->device)->uq_flags & UQ_NO_SET_PROTO) == 0) {
+		err = usbd_set_protocol(state->ks_iface, 0);
+		DPRINTFN(5, ("ukbd:init_keyboard: protocol set\n"));
+		if (err) {
+			printf("ukbd: set protocol failed\n");
+			return EIO;
+		}
+	}
+	/* Ignore if SETIDLE fails since it is not crucial. */
+	usbd_set_idle(state->ks_iface, 0, 0);
+
+	state->ks_ep_addr = ed->bEndpointAddress;
+	state->ks_ifstate &= ~DISCONNECTED;
+
+	return 0;
+}
+
+Static void
+set_leds(ukbd_state_t *state, int leds)
+{
+	u_int8_t res = leds;
+
+	DPRINTF(("ukbd:set_leds: state=%p leds=%d\n", state, leds));
+
+	usbd_set_report_async(state->ks_iface, UHID_OUTPUT_REPORT, 0, &res, 1);
+}
+
+Static int
+set_typematic(keyboard_t *kbd, int code)
+{
+	static int delays[] = { 250, 500, 750, 1000 };
+	static int rates[] = {  34,  38,  42,  46,  50,  55,  59,  63,
+				68,  76,  84,  92, 100, 110, 118, 126,
+			       136, 152, 168, 184, 200, 220, 236, 252,
+			       272, 304, 336, 368, 400, 440, 472, 504 };
+
+	if (code & ~0x7f)
+		return EINVAL;
+	kbd->kb_delay1 = delays[(code >> 5) & 3];
+	kbd->kb_delay2 = rates[code & 0x1f];
+	return 0;
+}
+
+#ifdef UKBD_EMULATE_ATSCANCODE
+Static int
+keycode2scancode(int keycode, int shift, int up)
+{
+	static int scan[] = {
+		0x1c, 0x1d, 0x35,
+		0x37 | SCAN_PREFIX_SHIFT, /* PrintScreen */
+		0x38, 0x47, 0x48, 0x49, 0x4b, 0x4d, 0x4f,
+		0x50, 0x51, 0x52, 0x53,
+		0x46, 	/* XXX Pause/Break */
+		0x5b, 0x5c, 0x5d,
+		/* SUN TYPE 6 USB KEYBOARD */
+		0x68, 0x5e, 0x5f, 0x60,	0x61, 0x62, 0x63,
+		0x64, 0x65, 0x66, 0x67, 0x25, 0x1f, 0x1e,
+		0x20, 
+	};
+	int scancode;
+
+	scancode = keycode;
+	if ((keycode >= 89) && (keycode < 89 + sizeof(scan)/sizeof(scan[0])))
+		scancode = scan[keycode - 89] | SCAN_PREFIX_E0;
+	/* Pause/Break */
+	if ((keycode == 104) && !(shift & (MOD_CONTROL_L | MOD_CONTROL_R)))
+		scancode = 0x45 | SCAN_PREFIX_E1 | SCAN_PREFIX_CTL;
+	if (shift & (MOD_SHIFT_L | MOD_SHIFT_R))
+		scancode &= ~SCAN_PREFIX_SHIFT;
+	return (scancode | (up ? SCAN_RELEASE : SCAN_PRESS));
+}
+#endif /* UKBD_EMULATE_ATSCANCODE */
+
+Static int
+ukbd_driver_load(module_t mod, int what, void *arg)
+{
+	switch (what) {
+		case MOD_LOAD:
+			kbd_add_driver(&ukbd_kbd_driver);
+			break;
+		case MOD_UNLOAD:
+			kbd_delete_driver(&ukbd_kbd_driver);
+			break;
+	}
+	return usbd_driver_load(mod, what, 0);
+}
diff -rubN /usr/src1/src/sys/dev/usb/ukbd.c.rej /usr/src/sys/dev/usb/ukbd.c.rej
--- /usr/src1/src/sys/dev/usb/ukbd.c.rej	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/ukbd.c.rej	Thu Jun  8 21:13:09 2006
@@ -0,0 +1,17 @@
+***************
+*** 684,690 ****
+  	kbd = (keyboard_t *)arg;
+  	state = (ukbd_state_t *)kbd->kb_data;
+  	s = splusb();
+! 	(*kbdsw[kbd->kb_index]->intr)(kbd, (void *)USBD_NORMAL_COMPLETION);
+  	state->ks_timeout_handle = timeout(ukbd_timeout, arg, hz/40);
+  	splx(s);
+  }
+--- 685,691 ----
+  	kbd = (keyboard_t *)arg;
+  	state = (ukbd_state_t *)kbd->kb_data;
+  	s = splusb();
+! 	(*kbdsw[kbd->kb_index]->intr)(kbd, ((u_int8_t *)0) + USBD_NORMAL_COMPLETION);
+  	state->ks_timeout_handle = timeout(ukbd_timeout, arg, hz/40);
+  	splx(s);
+  }
diff -rubN /usr/src1/src/sys/dev/usb/umass.c /usr/src/sys/dev/usb/umass.c
--- /usr/src1/src/sys/dev/usb/umass.c	Fri Mar 24 21:42:02 2006
+++ /usr/src/sys/dev/usb/umass.c	Thu Jun  8 21:15:01 2006
@@ -110,6 +110,7 @@
 #include <sys/systm.h>
 #include <sys/kernel.h>
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/bus.h>
 #include <sys/sysctl.h>
 
@@ -1237,6 +1238,9 @@
 	usbd_status err;
 
 	/* Initialise a USB transfer and then schedule it */
+#ifdef USBD_CUSTOM_CLEARSTALL
+	flags |= USBD_CUSTOM_CLEARSTALL;
+#endif
 
 	(void) usbd_setup_xfer(xfer, pipe, (void *) sc, buffer, buflen, flags,
 			sc->timeout, sc->state);
@@ -1613,6 +1617,8 @@
 			sc->transfer_state = TSTATE_BBB_STATUS2;
 			next_xfer = sc->transfer_xfer[XFER_BBB_CSW2];
 		}
+
+		sc->timeout = 1000;
 
 		/* Read the Command Status Wrapper via bulk-in endpoint. */
 		if (umass_setup_transfer(sc, sc->bulkin_pipe,
diff -rubN /usr/src1/src/sys/dev/usb/umass.c.orig /usr/src/sys/dev/usb/umass.c.orig
--- /usr/src1/src/sys/dev/usb/umass.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/umass.c.orig	Fri Mar 24 21:42:02 2006
@@ -0,0 +1,3204 @@
+/*-
+ * Copyright (c) 1999 MAEKAWA Masahide <bishop@rr.iij4u.or.jp>,
+ *		      Nick Hibma <n_hibma@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	$FreeBSD: src/sys/dev/usb/umass.c,v 1.122.2.8 2006/03/24 21:42:02 iedowse Exp $
+ *	$NetBSD: umass.c,v 1.28 2000/04/02 23:46:53 augustss Exp $
+ */
+
+/* Also already merged from NetBSD:
+ *	$NetBSD: umass.c,v 1.67 2001/11/25 19:05:22 augustss Exp $
+ *	$NetBSD: umass.c,v 1.90 2002/11/04 19:17:33 pooka Exp $
+ *	$NetBSD: umass.c,v 1.108 2003/11/07 17:03:25 wiz Exp $
+ *	$NetBSD: umass.c,v 1.109 2003/12/04 13:57:31 keihan Exp $
+ */
+
+/*
+ * Universal Serial Bus Mass Storage Class specs:
+ * http://www.usb.org/developers/devclass_docs/usb_msc_overview_1.2.pdf
+ * http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf
+ * http://www.usb.org/developers/devclass_docs/usb_msc_cbi_1.1.pdf
+ * http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf
+ */
+
+/*
+ * Ported to NetBSD by Lennart Augustsson <augustss@NetBSD.org>.
+ * Parts of the code written by Jason R. Thorpe <thorpej@shagadelic.org>.
+ */
+
+/*
+ * The driver handles 3 Wire Protocols
+ * - Command/Bulk/Interrupt (CBI)
+ * - Command/Bulk/Interrupt with Command Completion Interrupt (CBI with CCI)
+ * - Mass Storage Bulk-Only (BBB)
+ *   (BBB refers Bulk/Bulk/Bulk for Command/Data/Status phases)
+ *
+ * Over these wire protocols it handles the following command protocols
+ * - SCSI
+ * - UFI (floppy command set)
+ * - 8070i (ATAPI)
+ *
+ * UFI and 8070i (ATAPI) are transformed versions of the SCSI command set. The
+ * sc->transform method is used to convert the commands into the appropriate
+ * format (if at all necessary). For example, UFI requires all commands to be
+ * 12 bytes in length amongst other things.
+ *
+ * The source code below is marked and can be split into a number of pieces
+ * (in this order):
+ *
+ * - probe/attach/detach
+ * - generic transfer routines
+ * - BBB
+ * - CBI
+ * - CBI_I (in addition to functions from CBI)
+ * - CAM (Common Access Method)
+ * - SCSI
+ * - UFI
+ * - 8070i (ATAPI)
+ *
+ * The protocols are implemented using a state machine, for the transfers as
+ * well as for the resets. The state machine is contained in umass_*_state.
+ * The state machine is started through either umass_*_transfer or
+ * umass_*_reset.
+ *
+ * The reason for doing this is a) CAM performs a lot better this way and b) it
+ * avoids using tsleep from interrupt context (for example after a failed
+ * transfer).
+ */
+
+/*
+ * The SCSI related part of this driver has been derived from the
+ * dev/ppbus/vpo.c driver, by Nicolas Souchu (nsouch@freebsd.org).
+ *
+ * The CAM layer uses so called actions which are messages sent to the host
+ * adapter for completion. The actions come in through umass_cam_action. The
+ * appropriate block of routines is called depending on the transport protocol
+ * in use. When the transfer has finished, these routines call
+ * umass_cam_cb again to complete the CAM command.
+ */
+
+/*
+ * XXX Currently CBI with CCI is not supported because it bombs the system
+ *     when the device is detached (low frequency interrupts are detached
+ *     too late.
+ */
+#undef CBI_I
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/sysctl.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include "usbdevs.h"
+
+#include <cam/cam.h>
+#include <cam/cam_ccb.h>
+#include <cam/cam_sim.h>
+#include <cam/cam_xpt_sim.h>
+#include <cam/scsi/scsi_all.h>
+#include <cam/scsi/scsi_da.h>
+
+#include <cam/cam_periph.h>
+
+#ifdef USB_DEBUG
+#define DIF(m, x)	if (umassdebug & (m)) do { x ; } while (0)
+#define	DPRINTF(m, x)	if (umassdebug & (m)) logprintf x
+#define UDMASS_GEN	0x00010000	/* general */
+#define UDMASS_SCSI	0x00020000	/* scsi */
+#define UDMASS_UFI	0x00040000	/* ufi command set */
+#define UDMASS_ATAPI	0x00080000	/* 8070i command set */
+#define UDMASS_CMD	(UDMASS_SCSI|UDMASS_UFI|UDMASS_ATAPI)
+#define UDMASS_USB	0x00100000	/* USB general */
+#define UDMASS_BBB	0x00200000	/* Bulk-Only transfers */
+#define UDMASS_CBI	0x00400000	/* CBI transfers */
+#define UDMASS_WIRE	(UDMASS_BBB|UDMASS_CBI)
+#define UDMASS_ALL	0xffff0000	/* all of the above */
+int umassdebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, umass, CTLFLAG_RW, 0, "USB umass");
+SYSCTL_INT(_hw_usb_umass, OID_AUTO, debug, CTLFLAG_RW,
+	   &umassdebug, 0, "umass debug level");
+#else
+#define DIF(m, x)	/* nop */
+#define	DPRINTF(m, x)	/* nop */
+#endif
+
+
+/* Generic definitions */
+
+/* Direction for umass_*_transfer */
+#define DIR_NONE	0
+#define DIR_IN		1
+#define DIR_OUT		2
+
+/* device name */
+#define DEVNAME		"umass"
+#define DEVNAME_SIM	"umass-sim"
+
+#define UMASS_MAX_TRANSFER_SIZE		65536
+/* Approximate maximum transfer speeds (assumes 33% overhead). */
+#define UMASS_FULL_TRANSFER_SPEED	1000
+#define UMASS_HIGH_TRANSFER_SPEED	40000
+#define UMASS_FLOPPY_TRANSFER_SPEED	20
+
+#define UMASS_TIMEOUT			5000 /* msecs */
+
+/* CAM specific definitions */
+
+#define UMASS_SCSIID_MAX	1	/* maximum number of drives expected */
+#define UMASS_SCSIID_HOST	UMASS_SCSIID_MAX
+
+#define MS_TO_TICKS(ms) ((ms) * hz / 1000)
+
+
+/* Bulk-Only features */
+
+#define UR_BBB_RESET		0xff		/* Bulk-Only reset */
+#define UR_BBB_GET_MAX_LUN	0xfe		/* Get maximum lun */
+
+/* Command Block Wrapper */
+typedef struct {
+	uDWord		dCBWSignature;
+#	define CBWSIGNATURE	0x43425355
+	uDWord		dCBWTag;
+	uDWord		dCBWDataTransferLength;
+	uByte		bCBWFlags;
+#	define CBWFLAGS_OUT	0x00
+#	define CBWFLAGS_IN	0x80
+	uByte		bCBWLUN;
+	uByte		bCDBLength;
+#	define CBWCDBLENGTH	16
+	uByte		CBWCDB[CBWCDBLENGTH];
+} umass_bbb_cbw_t;
+#define	UMASS_BBB_CBW_SIZE	31
+
+/* Command Status Wrapper */
+typedef struct {
+	uDWord		dCSWSignature;
+#	define CSWSIGNATURE	0x53425355
+#	define CSWSIGNATURE_IMAGINATION_DBX1	0x43425355
+#	define CSWSIGNATURE_OLYMPUS_C1	0x55425355
+	uDWord		dCSWTag;
+	uDWord		dCSWDataResidue;
+	uByte		bCSWStatus;
+#	define CSWSTATUS_GOOD	0x0
+#	define CSWSTATUS_FAILED	0x1
+#	define CSWSTATUS_PHASE	0x2
+} umass_bbb_csw_t;
+#define	UMASS_BBB_CSW_SIZE	13
+
+/* CBI features */
+
+#define UR_CBI_ADSC	0x00
+
+typedef unsigned char umass_cbi_cbl_t[16];	/* Command block */
+
+typedef union {
+	struct {
+		unsigned char	type;
+		#define IDB_TYPE_CCI		0x00
+		unsigned char	value;
+		#define IDB_VALUE_PASS		0x00
+		#define IDB_VALUE_FAIL		0x01
+		#define IDB_VALUE_PHASE		0x02
+		#define IDB_VALUE_PERSISTENT	0x03
+		#define IDB_VALUE_STATUS_MASK	0x03
+	} common;
+
+	struct {
+		unsigned char	asc;
+		unsigned char	ascq;
+	} ufi;
+} umass_cbi_sbl_t;
+
+
+
+struct umass_softc;		/* see below */
+
+typedef void (*transfer_cb_f)	(struct umass_softc *sc, void *priv,
+				int residue, int status);
+#define STATUS_CMD_OK		0	/* everything ok */
+#define STATUS_CMD_UNKNOWN	1	/* will have to fetch sense */
+#define STATUS_CMD_FAILED	2	/* transfer was ok, command failed */
+#define STATUS_WIRE_FAILED	3	/* couldn't even get command across */
+
+typedef void (*wire_reset_f)	(struct umass_softc *sc, int status);
+typedef void (*wire_transfer_f)	(struct umass_softc *sc, int lun,
+				void *cmd, int cmdlen, void *data, int datalen,
+				int dir, u_int timeout, transfer_cb_f cb, void *priv);
+typedef void (*wire_state_f)	(usbd_xfer_handle xfer,
+				usbd_private_handle priv, usbd_status err);
+
+typedef int (*command_transform_f)	(struct umass_softc *sc,
+				unsigned char *cmd, int cmdlen,
+				unsigned char **rcmd, int *rcmdlen);
+
+
+struct umass_devdescr_t {
+	u_int32_t	vid;
+#	define VID_WILDCARD	0xffffffff
+#	define VID_EOT		0xfffffffe
+	u_int32_t	pid;
+#	define PID_WILDCARD	0xffffffff
+#	define PID_EOT		0xfffffffe
+	u_int32_t	rid;
+#	define RID_WILDCARD	0xffffffff
+#	define RID_EOT		0xfffffffe
+
+	/* wire and command protocol */
+	u_int16_t	proto;
+#	define UMASS_PROTO_BBB		0x0001	/* USB wire protocol */
+#	define UMASS_PROTO_CBI		0x0002
+#	define UMASS_PROTO_CBI_I	0x0004
+#	define UMASS_PROTO_WIRE		0x00ff	/* USB wire protocol mask */
+#	define UMASS_PROTO_SCSI		0x0100	/* command protocol */
+#	define UMASS_PROTO_ATAPI	0x0200
+#	define UMASS_PROTO_UFI		0x0400
+#	define UMASS_PROTO_RBC		0x0800
+#	define UMASS_PROTO_COMMAND	0xff00	/* command protocol mask */
+
+	/* Device specific quirks */
+	u_int16_t	quirks;
+#	define NO_QUIRKS		0x0000
+	/* The drive does not support Test Unit Ready. Convert to Start Unit
+	 */
+#	define NO_TEST_UNIT_READY	0x0001
+	/* The drive does not reset the Unit Attention state after REQUEST
+	 * SENSE has been sent. The INQUIRY command does not reset the UA
+	 * either, and so CAM runs in circles trying to retrieve the initial
+	 * INQUIRY data.
+	 */
+#	define RS_NO_CLEAR_UA		0x0002
+	/* The drive does not support START STOP.  */
+#	define NO_START_STOP		0x0004
+	/* Don't ask for full inquiry data (255b).  */
+#	define FORCE_SHORT_INQUIRY	0x0008
+	/* Needs to be initialised the Shuttle way */
+#	define SHUTTLE_INIT		0x0010
+	/* Drive needs to be switched to alternate iface 1 */
+#	define ALT_IFACE_1		0x0020
+	/* Drive does not do 1Mb/s, but just floppy speeds (20kb/s) */
+#	define FLOPPY_SPEED		0x0040
+	/* The device can't count and gets the residue of transfers wrong */
+#	define IGNORE_RESIDUE		0x0080
+	/* No GetMaxLun call */
+#	define NO_GETMAXLUN		0x0100
+	/* The device uses a weird CSWSIGNATURE. */
+#	define WRONG_CSWSIG		0x0200
+	/* Device cannot handle INQUIRY so fake a generic response */
+#	define NO_INQUIRY		0x0400
+	/* Device cannot handle INQUIRY EVPD, return CHECK CONDITION */
+#	define NO_INQUIRY_EVPD		0x0800
+	/* Pad all RBC requests to 12 bytes. */
+#	define RBC_PAD_TO_12		0x1000
+};
+
+Static struct umass_devdescr_t umass_devdescrs[] = {
+	{ USB_VENDOR_ASAHIOPTICAL, PID_WILDCARD, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_CBI_I,
+	  RS_NO_CLEAR_UA
+	},
+	{ USB_VENDOR_FUJIPHOTO, USB_PRODUCT_FUJIPHOTO_MASS0100, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_CBI_I,
+	  RS_NO_CLEAR_UA
+	},
+	{ USB_VENDOR_GENESYS,  USB_PRODUCT_GENESYS_GL641USB2IDE, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  FORCE_SHORT_INQUIRY | NO_START_STOP | IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_GENESYS,  USB_PRODUCT_GENESYS_GL641USB2IDE_2, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_BBB,
+	  FORCE_SHORT_INQUIRY | NO_START_STOP | IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_GENESYS,  USB_PRODUCT_GENESYS_GL641USB, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  FORCE_SHORT_INQUIRY | NO_START_STOP | IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_GENESYS,  USB_PRODUCT_GENESYS_GL641USB_2, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  WRONG_CSWSIG
+	},
+	{ USB_VENDOR_HITACHI, USB_PRODUCT_HITACHI_DVDCAM_USB, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_CBI_I,
+	  NO_INQUIRY
+	},
+	{ USB_VENDOR_HP, USB_PRODUCT_HP_CDW8200, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_CBI_I,
+	  NO_TEST_UNIT_READY | NO_START_STOP
+	},
+	{ USB_VENDOR_IMAGINATION, USB_PRODUCT_IMAGINATION_DBX1, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  WRONG_CSWSIG
+	},
+	{ USB_VENDOR_INSYSTEM, USB_PRODUCT_INSYSTEM_USBCABLE, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_CBI,
+	  NO_TEST_UNIT_READY | NO_START_STOP | ALT_IFACE_1
+	},
+	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_IU_CD2, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_DVR_UEH8, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_IOMEGA, USB_PRODUCT_IOMEGA_ZIP100, RID_WILDCARD,
+	  /* XXX This is not correct as there are Zip drives that use ATAPI.
+	   */
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  NO_TEST_UNIT_READY
+	},
+	{ USB_VENDOR_LOGITEC, USB_PRODUCT_LOGITEC_LDR_H443SU2, RID_WILDCARD,
+	  UMASS_PROTO_SCSI,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_LOGITEC, USB_PRODUCT_LOGITEC_LDR_H443U2, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_MELCO,  USB_PRODUCT_MELCO_DUBPXXG, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  FORCE_SHORT_INQUIRY | NO_START_STOP | IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_MICROTECH, USB_PRODUCT_MICROTECH_DPCM, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_CBI,
+	  NO_TEST_UNIT_READY | NO_START_STOP
+	},
+	{ USB_VENDOR_MOTOROLA2, USB_PRODUCT_MOTOROLA2_E398, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  FORCE_SHORT_INQUIRY | NO_INQUIRY_EVPD | NO_GETMAXLUN
+	},
+	{ USB_VENDOR_MSYSTEMS, USB_PRODUCT_MSYSTEMS_DISKONKEY, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE | NO_GETMAXLUN | RS_NO_CLEAR_UA
+	},
+	{ USB_VENDOR_MSYSTEMS, USB_PRODUCT_MSYSTEMS_DISKONKEY2, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_BBB,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_NEODIO, USB_PRODUCT_NEODIO_ND3260, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  FORCE_SHORT_INQUIRY
+	},
+	{ USB_VENDOR_OLYMPUS, USB_PRODUCT_OLYMPUS_C1, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  WRONG_CSWSIG
+	},
+	{ USB_VENDOR_ONSPEC, USB_PRODUCT_ONSPEC_UCF100, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_BBB,
+	  NO_INQUIRY | NO_GETMAXLUN
+	},
+	{ USB_VENDOR_PANASONIC, USB_PRODUCT_PANASONIC_KXLCB20AN, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_PANASONIC, USB_PRODUCT_PANASONIC_KXLCB35AN, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_PLEXTOR, USB_PRODUCT_PLEXTOR_40_12_40U, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  NO_TEST_UNIT_READY
+	},
+	{ USB_VENDOR_PNY, USB_PRODUCT_PNY_ATTACHE, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_PNY, USB_PRODUCT_PNY_A256MB, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_PNY, USB_PRODUCT_PNY_DISKPRO512, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_SANDISK, USB_PRODUCT_SANDISK_SDCZ2_256, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_SANDISK, USB_PRODUCT_SANDISK_SDCZ4_128, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_SANDISK, USB_PRODUCT_SANDISK_SDCZ4_256, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_SCANLOGIC, USB_PRODUCT_SCANLOGIC_SL11R, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_BBB,
+	  NO_INQUIRY
+	},
+	{ USB_VENDOR_SHUTTLE, USB_PRODUCT_SHUTTLE_EUSB, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_CBI_I,
+	  NO_TEST_UNIT_READY | NO_START_STOP | SHUTTLE_INIT
+	},
+	{ USB_VENDOR_SIGMATEL, USB_PRODUCT_SIGMATEL_I_BEAD100, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  SHUTTLE_INIT
+	},
+	{ USB_VENDOR_SIIG, USB_PRODUCT_SIIG_WINTERREADER, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_SONY, USB_PRODUCT_SONY_DSC, 0x0500,
+	  UMASS_PROTO_RBC | UMASS_PROTO_CBI,
+	  RBC_PAD_TO_12
+	},
+	{ USB_VENDOR_SONY, USB_PRODUCT_SONY_DSC, 0x0600,
+	  UMASS_PROTO_RBC | UMASS_PROTO_CBI,
+	  RBC_PAD_TO_12
+	},
+	{ USB_VENDOR_SONY, USB_PRODUCT_SONY_DSC, RID_WILDCARD,
+	  UMASS_PROTO_RBC | UMASS_PROTO_CBI,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_SONY, USB_PRODUCT_SONY_HANDYCAM, RID_WILDCARD,
+	  UMASS_PROTO_RBC | UMASS_PROTO_CBI,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_SONY, USB_PRODUCT_SONY_MSC, RID_WILDCARD,
+	  UMASS_PROTO_RBC | UMASS_PROTO_CBI,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_TREK, USB_PRODUCT_TREK_THUMBDRIVE_8MB, RID_WILDCARD,
+          UMASS_PROTO_ATAPI | UMASS_PROTO_BBB,
+	  IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_TRUMPION, USB_PRODUCT_TRUMPION_C3310, RID_WILDCARD,
+	  UMASS_PROTO_UFI | UMASS_PROTO_CBI,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_TWINMOS, USB_PRODUCT_TWINMOS_MDIV, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  NO_QUIRKS
+	},
+	{ USB_VENDOR_WESTERN,  USB_PRODUCT_WESTERN_EXTHDD, RID_WILDCARD,
+	  UMASS_PROTO_SCSI | UMASS_PROTO_BBB,
+	  FORCE_SHORT_INQUIRY | NO_START_STOP | IGNORE_RESIDUE
+	},
+	{ USB_VENDOR_YANO,  USB_PRODUCT_YANO_U640MO, RID_WILDCARD,
+	  UMASS_PROTO_ATAPI | UMASS_PROTO_CBI_I,
+	  FORCE_SHORT_INQUIRY
+	},
+	{ VID_EOT, PID_EOT, RID_EOT, 0, 0 }
+};
+
+
+/* the per device structure */
+struct umass_softc {
+	USBBASEDEVICE		sc_dev;		/* base device */
+	usbd_device_handle	sc_udev;	/* USB device */
+
+	struct cam_sim		*umass_sim;	/* SCSI Interface Module */
+
+	unsigned char		flags;		/* various device flags */
+#	define UMASS_FLAGS_GONE		0x01	/* devices is no more */
+
+	u_int16_t		proto;		/* wire and cmd protocol */
+	u_int16_t		quirks;		/* they got it almost right */
+
+	usbd_interface_handle	iface;		/* Mass Storage interface */
+	int			ifaceno;	/* MS iface number */
+
+	u_int8_t		bulkin;		/* bulk-in Endpoint Address */
+	u_int8_t		bulkout;	/* bulk-out Endpoint Address */
+	u_int8_t		intrin;		/* intr-in Endp. (CBI) */
+	usbd_pipe_handle	bulkin_pipe;
+	usbd_pipe_handle	bulkout_pipe;
+	usbd_pipe_handle	intrin_pipe;
+
+	/* Reset the device in a wire protocol specific way */
+	wire_reset_f		reset;
+
+	/* The start of a wire transfer. It prepares the whole transfer (cmd,
+	 * data, and status stage) and initiates it. It is up to the state
+	 * machine (below) to handle the various stages and errors in these
+	 */
+	wire_transfer_f		transfer;
+
+	/* The state machine, handling the various states during a transfer */
+	wire_state_f		state;
+
+	/* The command transform function is used to conver the SCSI commands
+	 * into their derivatives, like UFI, ATAPI, and friends.
+	 */
+	command_transform_f	transform;	/* command transform */
+
+	/* Bulk specific variables for transfers in progress */
+	umass_bbb_cbw_t		cbw;	/* command block wrapper */
+	umass_bbb_csw_t		csw;	/* command status wrapper*/
+	/* CBI specific variables for transfers in progress */
+	umass_cbi_cbl_t		cbl;	/* command block */
+	umass_cbi_sbl_t		sbl;	/* status block */
+
+	/* generic variables for transfers in progress */
+	/* ctrl transfer requests */
+	usb_device_request_t	request;
+
+	/* xfer handles
+	 * Most of our operations are initiated from interrupt context, so
+	 * we need to avoid using the one that is in use. We want to avoid
+	 * allocating them in the interrupt context as well.
+	 */
+	/* indices into array below */
+#	define XFER_BBB_CBW		0	/* Bulk-Only */
+#	define XFER_BBB_DATA		1
+#	define XFER_BBB_DCLEAR		2
+#	define XFER_BBB_CSW1		3
+#	define XFER_BBB_CSW2		4
+#	define XFER_BBB_SCLEAR		5
+#	define XFER_BBB_RESET1		6
+#	define XFER_BBB_RESET2		7
+#	define XFER_BBB_RESET3		8
+
+#	define XFER_CBI_CB		0	/* CBI */
+#	define XFER_CBI_DATA		1
+#	define XFER_CBI_STATUS		2
+#	define XFER_CBI_DCLEAR		3
+#	define XFER_CBI_SCLEAR		4
+#	define XFER_CBI_RESET1		5
+#	define XFER_CBI_RESET2		6
+#	define XFER_CBI_RESET3		7
+
+#	define XFER_NR			9	/* maximum number */
+
+	usbd_xfer_handle	transfer_xfer[XFER_NR];	/* for ctrl xfers */
+
+	int			transfer_dir;		/* data direction */
+	void			*transfer_data;		/* data buffer */
+	int			transfer_datalen;	/* (maximum) length */
+	int			transfer_actlen;	/* actual length */
+	transfer_cb_f		transfer_cb;		/* callback */
+	void			*transfer_priv;		/* for callback */
+	int			transfer_status;
+
+	int			transfer_state;
+#	define TSTATE_ATTACH			0	/* in attach */
+#	define TSTATE_IDLE			1
+#	define TSTATE_BBB_COMMAND		2	/* CBW transfer */
+#	define TSTATE_BBB_DATA			3	/* Data transfer */
+#	define TSTATE_BBB_DCLEAR		4	/* clear endpt stall */
+#	define TSTATE_BBB_STATUS1		5	/* clear endpt stall */
+#	define TSTATE_BBB_SCLEAR		6	/* clear endpt stall */
+#	define TSTATE_BBB_STATUS2		7	/* CSW transfer */
+#	define TSTATE_BBB_RESET1		8	/* reset command */
+#	define TSTATE_BBB_RESET2		9	/* in clear stall */
+#	define TSTATE_BBB_RESET3		10	/* out clear stall */
+#	define TSTATE_CBI_COMMAND		11	/* command transfer */
+#	define TSTATE_CBI_DATA			12	/* data transfer */
+#	define TSTATE_CBI_STATUS		13	/* status transfer */
+#	define TSTATE_CBI_DCLEAR		14	/* clear ep stall */
+#	define TSTATE_CBI_SCLEAR		15	/* clear ep stall */
+#	define TSTATE_CBI_RESET1		16	/* reset command */
+#	define TSTATE_CBI_RESET2		17	/* in clear stall */
+#	define TSTATE_CBI_RESET3		18	/* out clear stall */
+#	define TSTATE_STATES			19	/* # of states above */
+
+
+	/* SCSI/CAM specific variables */
+	unsigned char 		cam_scsi_command[CAM_MAX_CDBLEN];
+	unsigned char 		cam_scsi_command2[CAM_MAX_CDBLEN];
+	struct scsi_sense	cam_scsi_sense;
+	struct scsi_sense	cam_scsi_test_unit_ready;
+	usb_callout_t		cam_scsi_rescan_ch;
+
+	int			timeout;		/* in msecs */
+
+	int			maxlun;			/* maximum LUN number */
+};
+
+#ifdef USB_DEBUG
+char *states[TSTATE_STATES+1] = {
+	/* should be kept in sync with the list at transfer_state */
+	"Attach",
+	"Idle",
+	"BBB CBW",
+	"BBB Data",
+	"BBB Data bulk-in/-out clear stall",
+	"BBB CSW, 1st attempt",
+	"BBB CSW bulk-in clear stall",
+	"BBB CSW, 2nd attempt",
+	"BBB Reset",
+	"BBB bulk-in clear stall",
+	"BBB bulk-out clear stall",
+	"CBI Command",
+	"CBI Data",
+	"CBI Status",
+	"CBI Data bulk-in/-out clear stall",
+	"CBI Status intr-in clear stall",
+	"CBI Reset",
+	"CBI bulk-in clear stall",
+	"CBI bulk-out clear stall",
+	NULL
+};
+#endif
+
+/* If device cannot return valid inquiry data, fake it */
+Static uint8_t fake_inq_data[SHORT_INQUIRY_LENGTH] = {
+	0, /*removable*/ 0x80, SCSI_REV_2, SCSI_REV_2,
+	/*additional_length*/ 31, 0, 0, 0
+};
+
+/* USB device probe/attach/detach functions */
+USB_DECLARE_DRIVER(umass);
+Static int umass_match_proto	(struct umass_softc *sc,
+				usbd_interface_handle iface,
+				usbd_device_handle udev);
+
+/* quirk functions */
+Static void umass_init_shuttle	(struct umass_softc *sc);
+
+/* generic transfer functions */
+Static usbd_status umass_setup_transfer	(struct umass_softc *sc,
+				usbd_pipe_handle pipe,
+				void *buffer, int buflen, int flags,
+				usbd_xfer_handle xfer);
+Static usbd_status umass_setup_ctrl_transfer	(struct umass_softc *sc,
+				usbd_device_handle udev,
+				usb_device_request_t *req,
+				void *buffer, int buflen, int flags,
+				usbd_xfer_handle xfer);
+Static void umass_clear_endpoint_stall	(struct umass_softc *sc,
+				u_int8_t endpt, usbd_pipe_handle pipe,
+				int state, usbd_xfer_handle xfer);
+Static void umass_reset		(struct umass_softc *sc,
+				transfer_cb_f cb, void *priv);
+
+/* Bulk-Only related functions */
+Static void umass_bbb_reset	(struct umass_softc *sc, int status);
+Static void umass_bbb_transfer	(struct umass_softc *sc, int lun,
+				void *cmd, int cmdlen,
+		    		void *data, int datalen, int dir, u_int timeout,
+				transfer_cb_f cb, void *priv);
+Static void umass_bbb_state	(usbd_xfer_handle xfer,
+				usbd_private_handle priv,
+				usbd_status err);
+Static int umass_bbb_get_max_lun
+				(struct umass_softc *sc);
+
+/* CBI related functions */
+Static int umass_cbi_adsc	(struct umass_softc *sc,
+				char *buffer, int buflen,
+				usbd_xfer_handle xfer);
+Static void umass_cbi_reset	(struct umass_softc *sc, int status);
+Static void umass_cbi_transfer	(struct umass_softc *sc, int lun,
+				void *cmd, int cmdlen,
+		    		void *data, int datalen, int dir, u_int timeout,
+				transfer_cb_f cb, void *priv);
+Static void umass_cbi_state	(usbd_xfer_handle xfer,
+				usbd_private_handle priv, usbd_status err);
+
+/* CAM related functions */
+Static void umass_cam_action	(struct cam_sim *sim, union ccb *ccb);
+Static void umass_cam_poll	(struct cam_sim *sim);
+
+Static void umass_cam_cb	(struct umass_softc *sc, void *priv,
+				int residue, int status);
+Static void umass_cam_sense_cb	(struct umass_softc *sc, void *priv,
+				int residue, int status);
+Static void umass_cam_quirk_cb	(struct umass_softc *sc, void *priv,
+				int residue, int status);
+
+Static void umass_cam_rescan_callback
+				(struct cam_periph *periph,union ccb *ccb);
+Static void umass_cam_rescan	(void *addr);
+
+Static int umass_cam_attach_sim	(struct umass_softc *sc);
+Static int umass_cam_attach	(struct umass_softc *sc);
+Static int umass_cam_detach_sim	(struct umass_softc *sc);
+
+
+/* SCSI specific functions */
+Static int umass_scsi_transform	(struct umass_softc *sc,
+				unsigned char *cmd, int cmdlen,
+		     		unsigned char **rcmd, int *rcmdlen);
+
+/* UFI specific functions */
+#define UFI_COMMAND_LENGTH	12	/* UFI commands are always 12 bytes */
+Static int umass_ufi_transform	(struct umass_softc *sc,
+				unsigned char *cmd, int cmdlen,
+		    		unsigned char **rcmd, int *rcmdlen);
+
+/* ATAPI (8070i) specific functions */
+#define ATAPI_COMMAND_LENGTH	12	/* ATAPI commands are always 12 bytes */
+Static int umass_atapi_transform	(struct umass_softc *sc,
+				unsigned char *cmd, int cmdlen,
+		     		unsigned char **rcmd, int *rcmdlen);
+
+/* RBC specific functions */
+Static int umass_rbc_transform	(struct umass_softc *sc,
+				unsigned char *cmd, int cmdlen,
+		     		unsigned char **rcmd, int *rcmdlen);
+
+#ifdef USB_DEBUG
+/* General debugging functions */
+Static void umass_bbb_dump_cbw	(struct umass_softc *sc, umass_bbb_cbw_t *cbw);
+Static void umass_bbb_dump_csw	(struct umass_softc *sc, umass_bbb_csw_t *csw);
+Static void umass_cbi_dump_cmd	(struct umass_softc *sc, void *cmd, int cmdlen);
+Static void umass_dump_buffer	(struct umass_softc *sc, u_int8_t *buffer,
+				int buflen, int printlen);
+#endif
+
+#if defined(__FreeBSD__)
+MODULE_DEPEND(umass, cam, 1,1,1);
+#endif
+
+/*
+ * USB device probe/attach/detach
+ */
+
+/*
+ * Match the device we are seeing with the devices supported. Fill in the
+ * description in the softc accordingly. This function is called from both
+ * probe and attach.
+ */
+
+Static int
+umass_match_proto(struct umass_softc *sc, usbd_interface_handle iface,
+		  usbd_device_handle udev)
+{
+	usb_device_descriptor_t *dd;
+	usb_interface_descriptor_t *id;
+	int i;
+	int found = 0;
+
+	sc->sc_udev = udev;
+	sc->proto = 0;
+	sc->quirks = 0;
+
+	dd = usbd_get_device_descriptor(udev);
+
+	/* An entry specifically for Y-E Data devices as they don't fit in the
+	 * device description table.
+	 */
+	if (UGETW(dd->idVendor) == USB_VENDOR_YEDATA
+	    && UGETW(dd->idProduct) == USB_PRODUCT_YEDATA_FLASHBUSTERU) {
+
+		/* Revisions < 1.28 do not handle the interrupt endpoint
+		 * very well.
+		 */
+		if (UGETW(dd->bcdDevice) < 0x128) {
+			sc->proto = UMASS_PROTO_UFI | UMASS_PROTO_CBI;
+		} else {
+			sc->proto = UMASS_PROTO_UFI | UMASS_PROTO_CBI_I;
+		}
+
+		/*
+		 * Revisions < 1.28 do not have the TEST UNIT READY command
+		 * Revisions == 1.28 have a broken TEST UNIT READY
+		 */
+		if (UGETW(dd->bcdDevice) <= 0x128)
+			sc->quirks |= NO_TEST_UNIT_READY;
+
+		sc->quirks |= RS_NO_CLEAR_UA | FLOPPY_SPEED;
+		return(UMATCH_VENDOR_PRODUCT);
+	}
+
+	/* Check the list of supported devices for a match. While looking,
+	 * check for wildcarded and fully matched. First match wins.
+	 */
+	for (i = 0; umass_devdescrs[i].vid != VID_EOT && !found; i++) {
+		if (umass_devdescrs[i].vid == VID_WILDCARD &&
+		    umass_devdescrs[i].pid == PID_WILDCARD &&
+		    umass_devdescrs[i].rid == RID_WILDCARD) {
+			printf("umass: ignoring invalid wildcard quirk\n");
+			continue;
+		}
+		if ((umass_devdescrs[i].vid == UGETW(dd->idVendor) ||
+		     umass_devdescrs[i].vid == VID_WILDCARD)
+		 && (umass_devdescrs[i].pid == UGETW(dd->idProduct) ||
+		     umass_devdescrs[i].pid == PID_WILDCARD)) {
+		    	if (umass_devdescrs[i].rid == RID_WILDCARD) {
+				sc->proto = umass_devdescrs[i].proto;
+				sc->quirks = umass_devdescrs[i].quirks;
+				return (UMATCH_VENDOR_PRODUCT);
+			} else if (umass_devdescrs[i].rid ==
+			    UGETW(dd->bcdDevice)) {
+				sc->proto = umass_devdescrs[i].proto;
+				sc->quirks = umass_devdescrs[i].quirks;
+				return (UMATCH_VENDOR_PRODUCT_REV);
+			} /* else RID does not match */
+		}
+	}
+
+	/* Check for a standards compliant device */
+	id = usbd_get_interface_descriptor(iface);
+	if (id == NULL || id->bInterfaceClass != UICLASS_MASS)
+		return(UMATCH_NONE);
+
+	switch (id->bInterfaceSubClass) {
+	case UISUBCLASS_SCSI:
+		sc->proto |= UMASS_PROTO_SCSI;
+		break;
+	case UISUBCLASS_UFI:
+		sc->proto |= UMASS_PROTO_UFI;
+		break;
+	case UISUBCLASS_RBC:
+		sc->proto |= UMASS_PROTO_RBC;
+		break;
+	case UISUBCLASS_SFF8020I:
+	case UISUBCLASS_SFF8070I:
+		sc->proto |= UMASS_PROTO_ATAPI;
+		break;
+	default:
+		DPRINTF(UDMASS_GEN, ("%s: Unsupported command protocol %d\n",
+			USBDEVNAME(sc->sc_dev), id->bInterfaceSubClass));
+		return(UMATCH_NONE);
+	}
+
+	switch (id->bInterfaceProtocol) {
+	case UIPROTO_MASS_CBI:
+		sc->proto |= UMASS_PROTO_CBI;
+		break;
+	case UIPROTO_MASS_CBI_I:
+		sc->proto |= UMASS_PROTO_CBI_I;
+		break;
+	case UIPROTO_MASS_BBB_OLD:
+	case UIPROTO_MASS_BBB:
+		sc->proto |= UMASS_PROTO_BBB;
+		break;
+	default:
+		DPRINTF(UDMASS_GEN, ("%s: Unsupported wire protocol %d\n",
+			USBDEVNAME(sc->sc_dev), id->bInterfaceProtocol));
+		return(UMATCH_NONE);
+	}
+
+	return(UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO);
+}
+
+USB_MATCH(umass)
+{
+	USB_MATCH_START(umass, uaa);
+	struct umass_softc *sc = device_get_softc(self);
+
+	USB_MATCH_SETUP;
+
+	if (uaa->iface == NULL)
+		return(UMATCH_NONE);
+
+	return(umass_match_proto(sc, uaa->iface, uaa->device));
+}
+
+USB_ATTACH(umass)
+{
+	USB_ATTACH_START(umass, sc, uaa);
+	usb_interface_descriptor_t *id;
+	usb_endpoint_descriptor_t *ed;
+	char devinfo[1024];
+	int i;
+	int err;
+
+	/*
+	 * the softc struct is bzero-ed in device_set_driver. We can safely
+	 * call umass_detach without specifically initialising the struct.
+	 */
+
+	usbd_devinfo(uaa->device, 0, devinfo);
+	USB_ATTACH_SETUP;
+
+	sc->iface = uaa->iface;
+	sc->ifaceno = uaa->ifaceno;
+	usb_callout_init(sc->cam_scsi_rescan_ch);
+
+	/* initialise the proto and drive values in the umass_softc (again) */
+	(void) umass_match_proto(sc, sc->iface, uaa->device);
+
+	id = usbd_get_interface_descriptor(sc->iface);
+#ifdef USB_DEBUG
+	printf("%s: ", USBDEVNAME(sc->sc_dev));
+	switch (sc->proto&UMASS_PROTO_COMMAND) {
+	case UMASS_PROTO_SCSI:
+		printf("SCSI");
+		break;
+	case UMASS_PROTO_ATAPI:
+		printf("8070i (ATAPI)");
+		break;
+	case UMASS_PROTO_UFI:
+		printf("UFI");
+		break;
+	case UMASS_PROTO_RBC:
+		printf("RBC");
+		break;
+	default:
+		printf("(unknown 0x%02x)", sc->proto&UMASS_PROTO_COMMAND);
+		break;
+	}
+	printf(" over ");
+	switch (sc->proto&UMASS_PROTO_WIRE) {
+	case UMASS_PROTO_BBB:
+		printf("Bulk-Only");
+		break;
+	case UMASS_PROTO_CBI:			/* uses Comand/Bulk pipes */
+		printf("CBI");
+		break;
+	case UMASS_PROTO_CBI_I:		/* uses Comand/Bulk/Interrupt pipes */
+		printf("CBI with CCI");
+#ifndef CBI_I
+		printf(" (using CBI)");
+#endif
+		break;
+	default:
+		printf("(unknown 0x%02x)", sc->proto&UMASS_PROTO_WIRE);
+	}
+	printf("; quirks = 0x%04x\n", sc->quirks);
+#endif
+
+#ifndef CBI_I
+	if (sc->proto & UMASS_PROTO_CBI_I) {
+		/* See beginning of file for comment on the use of CBI with CCI */
+		sc->proto = (sc->proto & ~UMASS_PROTO_CBI_I) | UMASS_PROTO_CBI;
+	}
+#endif
+
+	if (sc->quirks & ALT_IFACE_1) {
+		err = usbd_set_interface(uaa->iface, 1);
+		if (err) {
+			DPRINTF(UDMASS_USB, ("%s: could not switch to "
+				"Alt Interface %d\n",
+				USBDEVNAME(sc->sc_dev), 1));
+			umass_detach(self);
+			USB_ATTACH_ERROR_RETURN;
+		}
+	}
+
+	/*
+	 * In addition to the Control endpoint the following endpoints
+	 * are required:
+	 * a) bulk-in endpoint.
+	 * b) bulk-out endpoint.
+	 * and for Control/Bulk/Interrupt with CCI (CBI_I)
+	 * c) intr-in
+	 *
+	 * The endpoint addresses are not fixed, so we have to read them
+	 * from the device descriptors of the current interface.
+	 */
+	for (i = 0 ; i < id->bNumEndpoints ; i++) {
+		ed = usbd_interface2endpoint_descriptor(sc->iface, i);
+		if (!ed) {
+			printf("%s: could not read endpoint descriptor\n",
+			       USBDEVNAME(sc->sc_dev));
+			USB_ATTACH_ERROR_RETURN;
+		}
+		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN
+		    && (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
+			sc->bulkin = ed->bEndpointAddress;
+		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT
+		    && (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
+			sc->bulkout = ed->bEndpointAddress;
+		} else if (sc->proto & UMASS_PROTO_CBI_I
+		    && UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN
+		    && (ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT) {
+			sc->intrin = ed->bEndpointAddress;
+#ifdef USB_DEBUG
+			if (UGETW(ed->wMaxPacketSize) > 2) {
+				DPRINTF(UDMASS_CBI, ("%s: intr size is %d\n",
+					USBDEVNAME(sc->sc_dev),
+					UGETW(ed->wMaxPacketSize)));
+			}
+#endif
+		}
+	}
+
+	/* check whether we found all the endpoints we need */
+	if (!sc->bulkin || !sc->bulkout
+	    || (sc->proto & UMASS_PROTO_CBI_I && !sc->intrin) ) {
+	    	DPRINTF(UDMASS_USB, ("%s: endpoint not found %d/%d/%d\n",
+			USBDEVNAME(sc->sc_dev),
+			sc->bulkin, sc->bulkout, sc->intrin));
+		umass_detach(self);
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	/* Open the bulk-in and -out pipe */
+	err = usbd_open_pipe(sc->iface, sc->bulkout,
+				USBD_EXCLUSIVE_USE, &sc->bulkout_pipe);
+	if (err) {
+		DPRINTF(UDMASS_USB, ("%s: cannot open %d-out pipe (bulk)\n",
+			USBDEVNAME(sc->sc_dev), sc->bulkout));
+		umass_detach(self);
+		USB_ATTACH_ERROR_RETURN;
+	}
+	err = usbd_open_pipe(sc->iface, sc->bulkin,
+				USBD_EXCLUSIVE_USE, &sc->bulkin_pipe);
+	if (err) {
+		DPRINTF(UDMASS_USB, ("%s: could not open %d-in pipe (bulk)\n",
+			USBDEVNAME(sc->sc_dev), sc->bulkin));
+		umass_detach(self);
+		USB_ATTACH_ERROR_RETURN;
+	}
+	/* Open the intr-in pipe if the protocol is CBI with CCI.
+	 * Note: early versions of the Zip drive do have an interrupt pipe, but
+	 * this pipe is unused.
+	 *
+	 * We do not open the interrupt pipe as an interrupt pipe, but as a
+	 * normal bulk endpoint. We send an IN transfer down the wire at the
+	 * appropriate time, because we know exactly when to expect data on
+	 * that endpoint. This saves bandwidth, but more important, makes the
+	 * code for handling the data on that endpoint simpler. No data
+	 * arriving concurrently.
+	 */
+	if (sc->proto & UMASS_PROTO_CBI_I) {
+		err = usbd_open_pipe(sc->iface, sc->intrin,
+				USBD_EXCLUSIVE_USE, &sc->intrin_pipe);
+		if (err) {
+			DPRINTF(UDMASS_USB, ("%s: couldn't open %d-in (intr)\n",
+				USBDEVNAME(sc->sc_dev), sc->intrin));
+			umass_detach(self);
+			USB_ATTACH_ERROR_RETURN;
+		}
+	}
+
+	/* initialisation of generic part */
+	sc->transfer_state = TSTATE_ATTACH;
+
+	/* request a sufficient number of xfer handles */
+	for (i = 0; i < XFER_NR; i++) {
+		sc->transfer_xfer[i] = usbd_alloc_xfer(uaa->device);
+		if (!sc->transfer_xfer[i]) {
+			DPRINTF(UDMASS_USB, ("%s: Out of memory\n",
+				USBDEVNAME(sc->sc_dev)));
+			umass_detach(self);
+			USB_ATTACH_ERROR_RETURN;
+		}
+	}
+
+	/* Initialise the wire protocol specific methods */
+	if (sc->proto & UMASS_PROTO_BBB) {
+		sc->reset = umass_bbb_reset;
+		sc->transfer = umass_bbb_transfer;
+		sc->state = umass_bbb_state;
+	} else if (sc->proto & (UMASS_PROTO_CBI|UMASS_PROTO_CBI_I)) {
+		sc->reset = umass_cbi_reset;
+		sc->transfer = umass_cbi_transfer;
+		sc->state = umass_cbi_state;
+#ifdef USB_DEBUG
+	} else {
+		panic("%s:%d: Unknown proto 0x%02x",
+		      __FILE__, __LINE__, sc->proto);
+#endif
+	}
+
+	if (sc->proto & UMASS_PROTO_SCSI)
+		sc->transform = umass_scsi_transform;
+	else if (sc->proto & UMASS_PROTO_UFI)
+		sc->transform = umass_ufi_transform;
+	else if (sc->proto & UMASS_PROTO_ATAPI)
+		sc->transform = umass_atapi_transform;
+	else if (sc->proto & UMASS_PROTO_RBC)
+		sc->transform = umass_rbc_transform;
+#ifdef USB_DEBUG
+	else
+		panic("No transformation defined for command proto 0x%02x",
+		      sc->proto & UMASS_PROTO_COMMAND);
+#endif
+
+	/* From here onwards the device can be used. */
+
+	if (sc->quirks & SHUTTLE_INIT)
+		umass_init_shuttle(sc);
+
+	/* Get the maximum LUN supported by the device.
+	 */
+	if (((sc->proto & UMASS_PROTO_WIRE) == UMASS_PROTO_BBB) &&
+	    !(sc->quirks & NO_GETMAXLUN))
+		sc->maxlun = umass_bbb_get_max_lun(sc);
+	else
+		sc->maxlun = 0;
+
+	if ((sc->proto & UMASS_PROTO_SCSI) ||
+	    (sc->proto & UMASS_PROTO_ATAPI) ||
+	    (sc->proto & UMASS_PROTO_UFI) ||
+	    (sc->proto & UMASS_PROTO_RBC)) {
+		/* Prepare the SCSI command block */
+		sc->cam_scsi_sense.opcode = REQUEST_SENSE;
+		sc->cam_scsi_test_unit_ready.opcode = TEST_UNIT_READY;
+
+		/* register the SIM */
+		err = umass_cam_attach_sim(sc);
+		if (err) {
+			umass_detach(self);
+			USB_ATTACH_ERROR_RETURN;
+		}
+		/* scan the new sim */
+		err = umass_cam_attach(sc);
+		if (err) {
+			umass_cam_detach_sim(sc);
+			umass_detach(self);
+			USB_ATTACH_ERROR_RETURN;
+		}
+	} else {
+		panic("%s:%d: Unknown proto 0x%02x",
+		      __FILE__, __LINE__, sc->proto);
+	}
+
+	sc->transfer_state = TSTATE_IDLE;
+	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));
+
+	USB_ATTACH_SUCCESS_RETURN;
+}
+
+USB_DETACH(umass)
+{
+	USB_DETACH_START(umass, sc);
+	int err = 0;
+	int i;
+
+	DPRINTF(UDMASS_USB, ("%s: detached\n", USBDEVNAME(sc->sc_dev)));
+
+	sc->flags |= UMASS_FLAGS_GONE;
+
+	/* abort all the pipes in case there are transfers active. */
+	usbd_abort_default_pipe(sc->sc_udev);
+	if (sc->bulkout_pipe)
+		usbd_abort_pipe(sc->bulkout_pipe);
+	if (sc->bulkin_pipe)
+		usbd_abort_pipe(sc->bulkin_pipe);
+	if (sc->intrin_pipe)
+		usbd_abort_pipe(sc->intrin_pipe);
+
+	usb_uncallout_drain(sc->cam_scsi_rescan_ch, umass_cam_rescan, sc);
+	if ((sc->proto & UMASS_PROTO_SCSI) ||
+	    (sc->proto & UMASS_PROTO_ATAPI) ||
+	    (sc->proto & UMASS_PROTO_UFI) ||
+	    (sc->proto & UMASS_PROTO_RBC))
+		/* detach the SCSI host controller (SIM) */
+		err = umass_cam_detach_sim(sc);
+
+	for (i = 0; i < XFER_NR; i++)
+		if (sc->transfer_xfer[i])
+			usbd_free_xfer(sc->transfer_xfer[i]);
+
+	/* remove all the pipes */
+	if (sc->bulkout_pipe)
+		usbd_close_pipe(sc->bulkout_pipe);
+	if (sc->bulkin_pipe)
+		usbd_close_pipe(sc->bulkin_pipe);
+	if (sc->intrin_pipe)
+		usbd_close_pipe(sc->intrin_pipe);
+
+	return(err);
+}
+
+Static void
+umass_init_shuttle(struct umass_softc *sc)
+{
+	usb_device_request_t req;
+	u_char status[2];
+
+	/* The Linux driver does this, but no one can tell us what the
+	 * command does.
+	 */
+	req.bmRequestType = UT_READ_VENDOR_DEVICE;
+	req.bRequest = 1;	/* XXX unknown command */
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, sc->ifaceno);
+	USETW(req.wLength, sizeof status);
+	(void) usbd_do_request(sc->sc_udev, &req, &status);
+
+	DPRINTF(UDMASS_GEN, ("%s: Shuttle init returned 0x%02x%02x\n",
+		USBDEVNAME(sc->sc_dev), status[0], status[1]));
+}
+
+ /*
+ * Generic functions to handle transfers
+ */
+
+Static usbd_status
+umass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,
+			void *buffer, int buflen, int flags,
+			usbd_xfer_handle xfer)
+{
+	usbd_status err;
+
+	/* Initialise a USB transfer and then schedule it */
+
+	(void) usbd_setup_xfer(xfer, pipe, (void *) sc, buffer, buflen, flags,
+			sc->timeout, sc->state);
+
+	err = usbd_transfer(xfer);
+	if (err && err != USBD_IN_PROGRESS) {
+		DPRINTF(UDMASS_BBB, ("%s: failed to setup transfer, %s\n",
+			USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
+		return(err);
+	}
+
+	return (USBD_NORMAL_COMPLETION);
+}
+
+
+Static usbd_status
+umass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle udev,
+	 usb_device_request_t *req,
+	 void *buffer, int buflen, int flags,
+	 usbd_xfer_handle xfer)
+{
+	usbd_status err;
+
+	/* Initialise a USB control transfer and then schedule it */
+
+	(void) usbd_setup_default_xfer(xfer, udev, (void *) sc,
+			sc->timeout, req, buffer, buflen, flags, sc->state);
+
+	err = usbd_transfer(xfer);
+	if (err && err != USBD_IN_PROGRESS) {
+		DPRINTF(UDMASS_BBB, ("%s: failed to setup ctrl transfer, %s\n",
+			 USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
+
+		/* do not reset, as this would make us loop */
+		return(err);
+	}
+
+	return (USBD_NORMAL_COMPLETION);
+}
+
+Static void
+umass_clear_endpoint_stall(struct umass_softc *sc,
+				u_int8_t endpt, usbd_pipe_handle pipe,
+				int state, usbd_xfer_handle xfer)
+{
+	usbd_device_handle udev;
+
+	DPRINTF(UDMASS_BBB, ("%s: Clear endpoint 0x%02x stall\n",
+		USBDEVNAME(sc->sc_dev), endpt));
+
+	usbd_interface2device_handle(sc->iface, &udev);
+
+	sc->transfer_state = state;
+
+	usbd_clear_endpoint_toggle(pipe);
+
+	sc->request.bmRequestType = UT_WRITE_ENDPOINT;
+	sc->request.bRequest = UR_CLEAR_FEATURE;
+	USETW(sc->request.wValue, UF_ENDPOINT_HALT);
+	USETW(sc->request.wIndex, endpt);
+	USETW(sc->request.wLength, 0);
+	umass_setup_ctrl_transfer(sc, udev, &sc->request, NULL, 0, 0, xfer);
+}
+
+Static void
+umass_reset(struct umass_softc *sc, transfer_cb_f cb, void *priv)
+{
+	sc->transfer_cb = cb;
+	sc->transfer_priv = priv;
+
+	/* The reset is a forced reset, so no error (yet) */
+	sc->reset(sc, STATUS_CMD_OK);
+}
+
+/*
+ * Bulk protocol specific functions
+ */
+
+Static void
+umass_bbb_reset(struct umass_softc *sc, int status)
+{
+	usbd_device_handle udev;
+
+	KASSERT(sc->proto & UMASS_PROTO_BBB,
+		("%s: umass_bbb_reset: wrong sc->proto 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), sc->proto));
+
+	/*
+	 * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)
+	 *
+	 * For Reset Recovery the host shall issue in the following order:
+	 * a) a Bulk-Only Mass Storage Reset
+	 * b) a Clear Feature HALT to the Bulk-In endpoint
+	 * c) a Clear Feature HALT to the Bulk-Out endpoint
+	 *
+	 * This is done in 3 steps, states:
+	 * TSTATE_BBB_RESET1
+	 * TSTATE_BBB_RESET2
+	 * TSTATE_BBB_RESET3
+	 *
+	 * If the reset doesn't succeed, the device should be port reset.
+	 */
+
+	DPRINTF(UDMASS_BBB, ("%s: Bulk Reset\n",
+		USBDEVNAME(sc->sc_dev)));
+
+	sc->transfer_state = TSTATE_BBB_RESET1;
+	sc->transfer_status = status;
+
+	usbd_interface2device_handle(sc->iface, &udev);
+
+	/* reset is a class specific interface write */
+	sc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	sc->request.bRequest = UR_BBB_RESET;
+	USETW(sc->request.wValue, 0);
+	USETW(sc->request.wIndex, sc->ifaceno);
+	USETW(sc->request.wLength, 0);
+	umass_setup_ctrl_transfer(sc, udev, &sc->request, NULL, 0, 0,
+				  sc->transfer_xfer[XFER_BBB_RESET1]);
+}
+
+Static void
+umass_bbb_transfer(struct umass_softc *sc, int lun, void *cmd, int cmdlen,
+		    void *data, int datalen, int dir, u_int timeout,
+		    transfer_cb_f cb, void *priv)
+{
+	KASSERT(sc->proto & UMASS_PROTO_BBB,
+		("%s: umass_bbb_transfer: wrong sc->proto 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), sc->proto));
+
+	/* Be a little generous. */
+	sc->timeout = timeout + UMASS_TIMEOUT;
+
+	/*
+	 * Do a Bulk-Only transfer with cmdlen bytes from cmd, possibly
+	 * a data phase of datalen bytes from/to the device and finally a
+	 * csw read phase.
+	 * If the data direction was inbound a maximum of datalen bytes
+	 * is stored in the buffer pointed to by data.
+	 *
+	 * umass_bbb_transfer initialises the transfer and lets the state
+	 * machine in umass_bbb_state handle the completion. It uses the
+	 * following states:
+	 * TSTATE_BBB_COMMAND
+	 *   -> TSTATE_BBB_DATA
+	 *   -> TSTATE_BBB_STATUS
+	 *   -> TSTATE_BBB_STATUS2
+	 *   -> TSTATE_BBB_IDLE
+	 *
+	 * An error in any of those states will invoke
+	 * umass_bbb_reset.
+	 */
+
+	/* check the given arguments */
+	KASSERT(datalen == 0 || data != NULL,
+		("%s: datalen > 0, but no buffer",USBDEVNAME(sc->sc_dev)));
+	KASSERT(cmdlen <= CBWCDBLENGTH,
+		("%s: cmdlen exceeds CDB length in CBW (%d > %d)",
+			USBDEVNAME(sc->sc_dev), cmdlen, CBWCDBLENGTH));
+	KASSERT(dir == DIR_NONE || datalen > 0,
+		("%s: datalen == 0 while direction is not NONE\n",
+			USBDEVNAME(sc->sc_dev)));
+	KASSERT(datalen == 0 || dir != DIR_NONE,
+		("%s: direction is NONE while datalen is not zero\n",
+			USBDEVNAME(sc->sc_dev)));
+	KASSERT(sizeof(umass_bbb_cbw_t) == UMASS_BBB_CBW_SIZE,
+		("%s: CBW struct does not have the right size (%ld vs. %d)\n",
+			USBDEVNAME(sc->sc_dev),
+			(long)sizeof(umass_bbb_cbw_t), UMASS_BBB_CBW_SIZE));
+	KASSERT(sizeof(umass_bbb_csw_t) == UMASS_BBB_CSW_SIZE,
+		("%s: CSW struct does not have the right size (%ld vs. %d)\n",
+			USBDEVNAME(sc->sc_dev),
+			(long)sizeof(umass_bbb_csw_t), UMASS_BBB_CSW_SIZE));
+
+	/*
+	 * Determine the direction of the data transfer and the length.
+	 *
+	 * dCBWDataTransferLength (datalen) :
+	 *   This field indicates the number of bytes of data that the host
+	 *   intends to transfer on the IN or OUT Bulk endpoint(as indicated by
+	 *   the Direction bit) during the execution of this command. If this
+	 *   field is set to 0, the device will expect that no data will be
+	 *   transferred IN or OUT during this command, regardless of the value
+	 *   of the Direction bit defined in dCBWFlags.
+	 *
+	 * dCBWFlags (dir) :
+	 *   The bits of the Flags field are defined as follows:
+	 *     Bits 0-6  reserved
+	 *     Bit  7    Direction - this bit shall be ignored if the
+	 *                           dCBWDataTransferLength field is zero.
+	 *               0 = data Out from host to device
+	 *               1 = data In from device to host
+	 */
+
+	/* Fill in the Command Block Wrapper
+	 * We fill in all the fields, so there is no need to bzero it first.
+	 */
+	USETDW(sc->cbw.dCBWSignature, CBWSIGNATURE);
+	/* We don't care about the initial value, as long as the values are unique */
+	USETDW(sc->cbw.dCBWTag, UGETDW(sc->cbw.dCBWTag) + 1);
+	USETDW(sc->cbw.dCBWDataTransferLength, datalen);
+	/* DIR_NONE is treated as DIR_OUT (0x00) */
+	sc->cbw.bCBWFlags = (dir == DIR_IN? CBWFLAGS_IN:CBWFLAGS_OUT);
+	sc->cbw.bCBWLUN = lun;
+	sc->cbw.bCDBLength = cmdlen;
+	bcopy(cmd, sc->cbw.CBWCDB, cmdlen);
+
+	DIF(UDMASS_BBB, umass_bbb_dump_cbw(sc, &sc->cbw));
+
+	/* store the details for the data transfer phase */
+	sc->transfer_dir = dir;
+	sc->transfer_data = data;
+	sc->transfer_datalen = datalen;
+	sc->transfer_actlen = 0;
+	sc->transfer_cb = cb;
+	sc->transfer_priv = priv;
+	sc->transfer_status = STATUS_CMD_OK;
+
+	/* move from idle to the command state */
+	sc->transfer_state = TSTATE_BBB_COMMAND;
+
+	/* Send the CBW from host to device via bulk-out endpoint. */
+	if (umass_setup_transfer(sc, sc->bulkout_pipe,
+			&sc->cbw, UMASS_BBB_CBW_SIZE, 0,
+			sc->transfer_xfer[XFER_BBB_CBW])) {
+		umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+	}
+}
+
+
+Static void
+umass_bbb_state(usbd_xfer_handle xfer, usbd_private_handle priv,
+		usbd_status err)
+{
+	struct umass_softc *sc = (struct umass_softc *) priv;
+	usbd_xfer_handle next_xfer;
+
+	KASSERT(sc->proto & UMASS_PROTO_BBB,
+		("%s: umass_bbb_state: wrong sc->proto 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), sc->proto));
+
+	/*
+	 * State handling for BBB transfers.
+	 *
+	 * The subroutine is rather long. It steps through the states given in
+	 * Annex A of the Bulk-Only specification.
+	 * Each state first does the error handling of the previous transfer
+	 * and then prepares the next transfer.
+	 * Each transfer is done asynchronously so after the request/transfer
+	 * has been submitted you will find a 'return;'.
+	 */
+
+	DPRINTF(UDMASS_BBB, ("%s: Handling BBB state %d (%s), xfer=%p, %s\n",
+		USBDEVNAME(sc->sc_dev), sc->transfer_state,
+		states[sc->transfer_state], xfer, usbd_errstr(err)));
+
+	/* Give up if the device has detached. */
+	if (sc->flags & UMASS_FLAGS_GONE) {
+		sc->transfer_state = TSTATE_IDLE;
+		sc->transfer_cb(sc, sc->transfer_priv, sc->transfer_datalen,
+		    STATUS_CMD_FAILED);
+		return;
+	}
+
+	switch (sc->transfer_state) {
+
+	/***** Bulk Transfer *****/
+	case TSTATE_BBB_COMMAND:
+		/* Command transport phase, error handling */
+		if (err) {
+			DPRINTF(UDMASS_BBB, ("%s: failed to send CBW\n",
+				USBDEVNAME(sc->sc_dev)));
+			/* If the device detects that the CBW is invalid, then
+			 * the device may STALL both bulk endpoints and require
+			 * a Bulk-Reset
+			 */
+			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+			return;
+		}
+
+		/* Data transport phase, setup transfer */
+		sc->transfer_state = TSTATE_BBB_DATA;
+		if (sc->transfer_dir == DIR_IN) {
+			if (umass_setup_transfer(sc, sc->bulkin_pipe,
+					sc->transfer_data, sc->transfer_datalen,
+					USBD_SHORT_XFER_OK,
+					sc->transfer_xfer[XFER_BBB_DATA]))
+				umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+
+			return;
+		} else if (sc->transfer_dir == DIR_OUT) {
+			if (umass_setup_transfer(sc, sc->bulkout_pipe,
+					sc->transfer_data, sc->transfer_datalen,
+					0,	/* fixed length transfer */
+					sc->transfer_xfer[XFER_BBB_DATA]))
+				umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+
+			return;
+		} else {
+			DPRINTF(UDMASS_BBB, ("%s: no data phase\n",
+				USBDEVNAME(sc->sc_dev)));
+		}
+
+		/* FALLTHROUGH if no data phase, err == 0 */
+	case TSTATE_BBB_DATA:
+		/* Command transport phase, error handling (ignored if no data
+		 * phase (fallthrough from previous state)) */
+		if (sc->transfer_dir != DIR_NONE) {
+			/* retrieve the length of the transfer that was done */
+			usbd_get_xfer_status(xfer, NULL, NULL,
+						&sc->transfer_actlen, NULL);
+
+			if (err) {
+				DPRINTF(UDMASS_BBB, ("%s: Data-%s %db failed, "
+					"%s\n", USBDEVNAME(sc->sc_dev),
+					(sc->transfer_dir == DIR_IN?"in":"out"),
+					sc->transfer_datalen,usbd_errstr(err)));
+
+				if (err == USBD_STALLED) {
+					umass_clear_endpoint_stall(sc,
+					  (sc->transfer_dir == DIR_IN?
+					    sc->bulkin:sc->bulkout),
+					  (sc->transfer_dir == DIR_IN?
+					    sc->bulkin_pipe:sc->bulkout_pipe),
+					  TSTATE_BBB_DCLEAR,
+					  sc->transfer_xfer[XFER_BBB_DCLEAR]);
+					return;
+				} else {
+					/* Unless the error is a pipe stall the
+					 * error is fatal.
+					 */
+					umass_bbb_reset(sc,STATUS_WIRE_FAILED);
+					return;
+				}
+			}
+		}
+
+		DIF(UDMASS_BBB, if (sc->transfer_dir == DIR_IN)
+					umass_dump_buffer(sc, sc->transfer_data,
+						sc->transfer_datalen, 48));
+
+
+
+		/* FALLTHROUGH, err == 0 (no data phase or successfull) */
+	case TSTATE_BBB_DCLEAR:	/* stall clear after data phase */
+	case TSTATE_BBB_SCLEAR:	/* stall clear after status phase */
+		/* Reading of CSW after bulk stall condition in data phase
+		 * (TSTATE_BBB_DATA2) or bulk-in stall condition after
+		 * reading CSW (TSTATE_BBB_SCLEAR).
+		 * In the case of no data phase or successfull data phase,
+		 * err == 0 and the following if block is passed.
+		 */
+		if (err) {	/* should not occur */
+			/* try the transfer below, even if clear stall failed */
+			DPRINTF(UDMASS_BBB, ("%s: bulk-%s stall clear failed"
+				", %s\n", USBDEVNAME(sc->sc_dev),
+				(sc->transfer_dir == DIR_IN? "in":"out"),
+				usbd_errstr(err)));
+			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+			return;
+		}
+
+		/* Status transport phase, setup transfer */
+		if (sc->transfer_state == TSTATE_BBB_COMMAND ||
+		    sc->transfer_state == TSTATE_BBB_DATA ||
+		    sc->transfer_state == TSTATE_BBB_DCLEAR) {
+		    	/* After no data phase, successfull data phase and
+			 * after clearing bulk-in/-out stall condition
+			 */
+			sc->transfer_state = TSTATE_BBB_STATUS1;
+			next_xfer = sc->transfer_xfer[XFER_BBB_CSW1];
+		} else {
+			/* After first attempt of fetching CSW */
+			sc->transfer_state = TSTATE_BBB_STATUS2;
+			next_xfer = sc->transfer_xfer[XFER_BBB_CSW2];
+		}
+
+		/* Read the Command Status Wrapper via bulk-in endpoint. */
+		if (umass_setup_transfer(sc, sc->bulkin_pipe,
+				&sc->csw, UMASS_BBB_CSW_SIZE, 0,
+				next_xfer)) {
+			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+			return;
+		}
+
+		return;
+	case TSTATE_BBB_STATUS1:	/* first attempt */
+	case TSTATE_BBB_STATUS2:	/* second attempt */
+		/* Status transfer, error handling */
+		if (err) {
+			DPRINTF(UDMASS_BBB, ("%s: Failed to read CSW, %s%s\n",
+				USBDEVNAME(sc->sc_dev), usbd_errstr(err),
+				(sc->transfer_state == TSTATE_BBB_STATUS1?
+					", retrying":"")));
+
+			/* If this was the first attempt at fetching the CSW
+			 * retry it, otherwise fail.
+			 */
+			if (sc->transfer_state == TSTATE_BBB_STATUS1) {
+				umass_clear_endpoint_stall(sc,
+					    sc->bulkin, sc->bulkin_pipe,
+					    TSTATE_BBB_SCLEAR,
+					    sc->transfer_xfer[XFER_BBB_SCLEAR]);
+				return;
+			} else {
+				umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+				return;
+			}
+		}
+
+		DIF(UDMASS_BBB, umass_bbb_dump_csw(sc, &sc->csw));
+
+		/* Translate weird command-status signatures. */
+		if (sc->quirks & WRONG_CSWSIG) {
+			u_int32_t dCSWSignature = UGETDW(sc->csw.dCSWSignature);
+			if (dCSWSignature == CSWSIGNATURE_OLYMPUS_C1 ||
+			    dCSWSignature == CSWSIGNATURE_IMAGINATION_DBX1)
+				USETDW(sc->csw.dCSWSignature, CSWSIGNATURE);
+		}
+
+		int Residue;
+		Residue = UGETDW(sc->csw.dCSWDataResidue);
+		if (Residue == 0 &&
+		    sc->transfer_datalen - sc->transfer_actlen != 0)
+			Residue = sc->transfer_datalen - sc->transfer_actlen;
+
+		/* Check CSW and handle any error */
+		if (UGETDW(sc->csw.dCSWSignature) != CSWSIGNATURE) {
+			/* Invalid CSW: Wrong signature or wrong tag might
+			 * indicate that the device is confused -> reset it.
+			 */
+			printf("%s: Invalid CSW: sig 0x%08x should be 0x%08x\n",
+				USBDEVNAME(sc->sc_dev),
+				UGETDW(sc->csw.dCSWSignature),
+				CSWSIGNATURE);
+
+			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+			return;
+		} else if (UGETDW(sc->csw.dCSWTag)
+				!= UGETDW(sc->cbw.dCBWTag)) {
+			printf("%s: Invalid CSW: tag %d should be %d\n",
+				USBDEVNAME(sc->sc_dev),
+				UGETDW(sc->csw.dCSWTag),
+				UGETDW(sc->cbw.dCBWTag));
+
+			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+			return;
+
+		/* CSW is valid here */
+		} else if (sc->csw.bCSWStatus > CSWSTATUS_PHASE) {
+			printf("%s: Invalid CSW: status %d > %d\n",
+				USBDEVNAME(sc->sc_dev),
+				sc->csw.bCSWStatus,
+				CSWSTATUS_PHASE);
+
+			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+			return;
+		} else if (sc->csw.bCSWStatus == CSWSTATUS_PHASE) {
+			printf("%s: Phase Error, residue = %d\n",
+				USBDEVNAME(sc->sc_dev), Residue);
+
+			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
+			return;
+
+		} else if (sc->transfer_actlen > sc->transfer_datalen) {
+			/* Buffer overrun! Don't let this go by unnoticed */
+			panic("%s: transferred %db instead of %db",
+				USBDEVNAME(sc->sc_dev),
+				sc->transfer_actlen, sc->transfer_datalen);
+
+		} else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
+			DPRINTF(UDMASS_BBB, ("%s: Command Failed, res = %d\n",
+				USBDEVNAME(sc->sc_dev), Residue));
+
+			/* SCSI command failed but transfer was succesful */
+			sc->transfer_state = TSTATE_IDLE;
+			sc->transfer_cb(sc, sc->transfer_priv, Residue,
+					STATUS_CMD_FAILED);
+			return;
+
+		} else {	/* success */
+			sc->transfer_state = TSTATE_IDLE;
+			sc->transfer_cb(sc, sc->transfer_priv, Residue,
+					STATUS_CMD_OK);
+
+			return;
+		}
+
+	/***** Bulk Reset *****/
+	case TSTATE_BBB_RESET1:
+		if (err)
+			printf("%s: BBB reset failed, %s\n",
+				USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+
+		umass_clear_endpoint_stall(sc,
+			sc->bulkin, sc->bulkin_pipe, TSTATE_BBB_RESET2,
+			sc->transfer_xfer[XFER_BBB_RESET2]);
+
+		return;
+	case TSTATE_BBB_RESET2:
+		if (err)	/* should not occur */
+			printf("%s: BBB bulk-in clear stall failed, %s\n",
+			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+			/* no error recovery, otherwise we end up in a loop */
+
+		umass_clear_endpoint_stall(sc,
+			sc->bulkout, sc->bulkout_pipe, TSTATE_BBB_RESET3,
+			sc->transfer_xfer[XFER_BBB_RESET3]);
+
+		return;
+	case TSTATE_BBB_RESET3:
+		if (err)	/* should not occur */
+			printf("%s: BBB bulk-out clear stall failed, %s\n",
+			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+			/* no error recovery, otherwise we end up in a loop */
+
+		sc->transfer_state = TSTATE_IDLE;
+		if (sc->transfer_priv) {
+			sc->transfer_cb(sc, sc->transfer_priv,
+					sc->transfer_datalen,
+					sc->transfer_status);
+		}
+
+		return;
+
+	/***** Default *****/
+	default:
+		panic("%s: Unknown state %d",
+		      USBDEVNAME(sc->sc_dev), sc->transfer_state);
+	}
+}
+
+Static int
+umass_bbb_get_max_lun(struct umass_softc *sc)
+{
+	usbd_device_handle udev;
+	usb_device_request_t req;
+	usbd_status err;
+	usb_interface_descriptor_t *id;
+	int maxlun = 0;
+	u_int8_t buf = 0;
+
+	usbd_interface2device_handle(sc->iface, &udev);
+	id = usbd_get_interface_descriptor(sc->iface);
+
+	/* The Get Max Lun command is a class-specific request. */
+	req.bmRequestType = UT_READ_CLASS_INTERFACE;
+	req.bRequest = UR_BBB_GET_MAX_LUN;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, id->bInterfaceNumber);
+	USETW(req.wLength, 1);
+
+	err = usbd_do_request(udev, &req, &buf);
+	switch (err) {
+	case USBD_NORMAL_COMPLETION:
+		maxlun = buf;
+		DPRINTF(UDMASS_BBB, ("%s: Max Lun is %d\n",
+		    USBDEVNAME(sc->sc_dev), maxlun));
+		break;
+	case USBD_STALLED:
+	case USBD_SHORT_XFER:
+	default:
+		/* Device doesn't support Get Max Lun request. */
+		printf("%s: Get Max Lun not supported (%s)\n",
+		    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+		/* XXX Should we port_reset the device? */
+		break;
+	}
+
+	return(maxlun);
+}
+
+/*
+ * Command/Bulk/Interrupt (CBI) specific functions
+ */
+
+Static int
+umass_cbi_adsc(struct umass_softc *sc, char *buffer, int buflen,
+	       usbd_xfer_handle xfer)
+{
+	usbd_device_handle udev;
+
+	KASSERT(sc->proto & (UMASS_PROTO_CBI|UMASS_PROTO_CBI_I),
+		("%s: umass_cbi_adsc: wrong sc->proto 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), sc->proto));
+
+	usbd_interface2device_handle(sc->iface, &udev);
+
+	sc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	sc->request.bRequest = UR_CBI_ADSC;
+	USETW(sc->request.wValue, 0);
+	USETW(sc->request.wIndex, sc->ifaceno);
+	USETW(sc->request.wLength, buflen);
+	return umass_setup_ctrl_transfer(sc, udev, &sc->request, buffer,
+					 buflen, 0, xfer);
+}
+
+
+Static void
+umass_cbi_reset(struct umass_softc *sc, int status)
+{
+	int i;
+#	define SEND_DIAGNOSTIC_CMDLEN	12
+
+	KASSERT(sc->proto & (UMASS_PROTO_CBI|UMASS_PROTO_CBI_I),
+		("%s: umass_cbi_reset: wrong sc->proto 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), sc->proto));
+
+	/*
+	 * Command Block Reset Protocol
+	 *
+	 * First send a reset request to the device. Then clear
+	 * any possibly stalled bulk endpoints.
+	 *
+	 * This is done in 3 steps, states:
+	 * TSTATE_CBI_RESET1
+	 * TSTATE_CBI_RESET2
+	 * TSTATE_CBI_RESET3
+	 *
+	 * If the reset doesn't succeed, the device should be port reset.
+	 */
+
+	DPRINTF(UDMASS_CBI, ("%s: CBI Reset\n",
+		USBDEVNAME(sc->sc_dev)));
+
+	KASSERT(sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN,
+		("%s: CBL struct is too small (%ld < %d)\n",
+			USBDEVNAME(sc->sc_dev),
+			(long)sizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN));
+
+	sc->transfer_state = TSTATE_CBI_RESET1;
+	sc->transfer_status = status;
+
+	/* The 0x1d code is the SEND DIAGNOSTIC command. To distinguish between
+	 * the two the last 10 bytes of the cbl is filled with 0xff (section
+	 * 2.2 of the CBI spec).
+	 */
+	sc->cbl[0] = 0x1d;	/* Command Block Reset */
+	sc->cbl[1] = 0x04;
+	for (i = 2; i < SEND_DIAGNOSTIC_CMDLEN; i++)
+		sc->cbl[i] = 0xff;
+
+	umass_cbi_adsc(sc, sc->cbl, SEND_DIAGNOSTIC_CMDLEN,
+		       sc->transfer_xfer[XFER_CBI_RESET1]);
+	/* XXX if the command fails we should reset the port on the hub */
+}
+
+Static void
+umass_cbi_transfer(struct umass_softc *sc, int lun,
+		void *cmd, int cmdlen, void *data, int datalen, int dir,
+		u_int timeout, transfer_cb_f cb, void *priv)
+{
+	KASSERT(sc->proto & (UMASS_PROTO_CBI|UMASS_PROTO_CBI_I),
+		("%s: umass_cbi_transfer: wrong sc->proto 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), sc->proto));
+
+	/* Be a little generous. */
+	sc->timeout = timeout + UMASS_TIMEOUT;
+
+	/*
+	 * Do a CBI transfer with cmdlen bytes from cmd, possibly
+	 * a data phase of datalen bytes from/to the device and finally a
+	 * csw read phase.
+	 * If the data direction was inbound a maximum of datalen bytes
+	 * is stored in the buffer pointed to by data.
+	 *
+	 * umass_cbi_transfer initialises the transfer and lets the state
+	 * machine in umass_cbi_state handle the completion. It uses the
+	 * following states:
+	 * TSTATE_CBI_COMMAND
+	 *   -> XXX fill in
+	 *
+	 * An error in any of those states will invoke
+	 * umass_cbi_reset.
+	 */
+
+	/* check the given arguments */
+	KASSERT(datalen == 0 || data != NULL,
+		("%s: datalen > 0, but no buffer",USBDEVNAME(sc->sc_dev)));
+	KASSERT(datalen == 0 || dir != DIR_NONE,
+		("%s: direction is NONE while datalen is not zero\n",
+			USBDEVNAME(sc->sc_dev)));
+
+	/* store the details for the data transfer phase */
+	sc->transfer_dir = dir;
+	sc->transfer_data = data;
+	sc->transfer_datalen = datalen;
+	sc->transfer_actlen = 0;
+	sc->transfer_cb = cb;
+	sc->transfer_priv = priv;
+	sc->transfer_status = STATUS_CMD_OK;
+
+	/* move from idle to the command state */
+	sc->transfer_state = TSTATE_CBI_COMMAND;
+
+	DIF(UDMASS_CBI, umass_cbi_dump_cmd(sc, cmd, cmdlen));
+
+	/* Send the Command Block from host to device via control endpoint. */
+	if (umass_cbi_adsc(sc, cmd, cmdlen, sc->transfer_xfer[XFER_CBI_CB]))
+		umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+}
+
+Static void
+umass_cbi_state(usbd_xfer_handle xfer, usbd_private_handle priv,
+		usbd_status err)
+{
+	struct umass_softc *sc = (struct umass_softc *) priv;
+
+	KASSERT(sc->proto & (UMASS_PROTO_CBI|UMASS_PROTO_CBI_I),
+		("%s: umass_cbi_state: wrong sc->proto 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), sc->proto));
+
+	/*
+	 * State handling for CBI transfers.
+	 */
+
+	DPRINTF(UDMASS_CBI, ("%s: Handling CBI state %d (%s), xfer=%p, %s\n",
+		USBDEVNAME(sc->sc_dev), sc->transfer_state,
+		states[sc->transfer_state], xfer, usbd_errstr(err)));
+
+	/* Give up if the device has detached. */
+	if (sc->flags & UMASS_FLAGS_GONE) {
+		sc->transfer_state = TSTATE_IDLE;
+		sc->transfer_cb(sc, sc->transfer_priv, sc->transfer_datalen,
+		    STATUS_CMD_FAILED);
+		return;
+	}
+
+	switch (sc->transfer_state) {
+
+	/***** CBI Transfer *****/
+	case TSTATE_CBI_COMMAND:
+		if (err == USBD_STALLED) {
+			DPRINTF(UDMASS_CBI, ("%s: Command Transport failed\n",
+				USBDEVNAME(sc->sc_dev)));
+			/* Status transport by control pipe (section 2.3.2.1).
+			 * The command contained in the command block failed.
+			 *
+			 * The control pipe has already been unstalled by the
+			 * USB stack.
+			 * Section 2.4.3.1.1 states that the bulk in endpoints
+			 * should not be stalled at this point.
+			 */
+
+			sc->transfer_state = TSTATE_IDLE;
+			sc->transfer_cb(sc, sc->transfer_priv,
+					sc->transfer_datalen,
+					STATUS_CMD_FAILED);
+
+			return;
+		} else if (err) {
+			DPRINTF(UDMASS_CBI, ("%s: failed to send ADSC\n",
+				USBDEVNAME(sc->sc_dev)));
+			umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+
+			return;
+		}
+
+		sc->transfer_state = TSTATE_CBI_DATA;
+		if (sc->transfer_dir == DIR_IN) {
+			if (umass_setup_transfer(sc, sc->bulkin_pipe,
+					sc->transfer_data, sc->transfer_datalen,
+					USBD_SHORT_XFER_OK,
+					sc->transfer_xfer[XFER_CBI_DATA]))
+				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+
+		} else if (sc->transfer_dir == DIR_OUT) {
+			if (umass_setup_transfer(sc, sc->bulkout_pipe,
+					sc->transfer_data, sc->transfer_datalen,
+					0,	/* fixed length transfer */
+					sc->transfer_xfer[XFER_CBI_DATA]))
+				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+
+		} else if (sc->proto & UMASS_PROTO_CBI_I) {
+			DPRINTF(UDMASS_CBI, ("%s: no data phase\n",
+				USBDEVNAME(sc->sc_dev)));
+			sc->transfer_state = TSTATE_CBI_STATUS;
+			if (umass_setup_transfer(sc, sc->intrin_pipe,
+					&sc->sbl, sizeof(sc->sbl),
+					0,	/* fixed length transfer */
+					sc->transfer_xfer[XFER_CBI_STATUS])){
+				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+			}
+		} else {
+			DPRINTF(UDMASS_CBI, ("%s: no data phase\n",
+				USBDEVNAME(sc->sc_dev)));
+			/* No command completion interrupt. Request
+			 * sense data.
+			 */
+			sc->transfer_state = TSTATE_IDLE;
+			sc->transfer_cb(sc, sc->transfer_priv,
+			       0, STATUS_CMD_UNKNOWN);
+		}
+
+		return;
+
+	case TSTATE_CBI_DATA:
+		/* retrieve the length of the transfer that was done */
+		usbd_get_xfer_status(xfer,NULL,NULL,&sc->transfer_actlen,NULL);
+
+		if (err) {
+			DPRINTF(UDMASS_CBI, ("%s: Data-%s %db failed, "
+				"%s\n", USBDEVNAME(sc->sc_dev),
+				(sc->transfer_dir == DIR_IN?"in":"out"),
+				sc->transfer_datalen,usbd_errstr(err)));
+
+			if (err == USBD_STALLED) {
+				umass_clear_endpoint_stall(sc,
+					sc->bulkin, sc->bulkin_pipe,
+					TSTATE_CBI_DCLEAR,
+					sc->transfer_xfer[XFER_CBI_DCLEAR]);
+			} else {
+				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+			}
+			return;
+		}
+
+		DIF(UDMASS_CBI, if (sc->transfer_dir == DIR_IN)
+					umass_dump_buffer(sc, sc->transfer_data,
+						sc->transfer_actlen, 48));
+
+		if (sc->proto & UMASS_PROTO_CBI_I) {
+			sc->transfer_state = TSTATE_CBI_STATUS;
+			if (umass_setup_transfer(sc, sc->intrin_pipe,
+				    &sc->sbl, sizeof(sc->sbl),
+				    0,	/* fixed length transfer */
+				    sc->transfer_xfer[XFER_CBI_STATUS])){
+				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+			}
+		} else {
+			/* No command completion interrupt. Request
+			 * sense to get status of command.
+			 */
+			sc->transfer_state = TSTATE_IDLE;
+			sc->transfer_cb(sc, sc->transfer_priv,
+				sc->transfer_datalen - sc->transfer_actlen,
+				STATUS_CMD_UNKNOWN);
+		}
+		return;
+
+	case TSTATE_CBI_STATUS:
+		if (err) {
+			DPRINTF(UDMASS_CBI, ("%s: Status Transport failed\n",
+				USBDEVNAME(sc->sc_dev)));
+			/* Status transport by interrupt pipe (section 2.3.2.2).
+			 */
+
+			if (err == USBD_STALLED) {
+				umass_clear_endpoint_stall(sc,
+					sc->intrin, sc->intrin_pipe,
+					TSTATE_CBI_SCLEAR,
+					sc->transfer_xfer[XFER_CBI_SCLEAR]);
+			} else {
+				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+			}
+			return;
+		}
+
+		/* Dissect the information in the buffer */
+
+		if (sc->proto & UMASS_PROTO_UFI) {
+			int status;
+
+			/* Section 3.4.3.1.3 specifies that the UFI command
+			 * protocol returns an ASC and ASCQ in the interrupt
+			 * data block.
+			 */
+
+			DPRINTF(UDMASS_CBI, ("%s: UFI CCI, ASC = 0x%02x, "
+				"ASCQ = 0x%02x\n",
+				USBDEVNAME(sc->sc_dev),
+				sc->sbl.ufi.asc, sc->sbl.ufi.ascq));
+
+			if (sc->sbl.ufi.asc == 0 && sc->sbl.ufi.ascq == 0)
+				status = STATUS_CMD_OK;
+			else
+				status = STATUS_CMD_FAILED;
+
+			sc->transfer_state = TSTATE_IDLE;
+			sc->transfer_cb(sc, sc->transfer_priv,
+				sc->transfer_datalen - sc->transfer_actlen,
+				status);
+		} else {
+			/* Command Interrupt Data Block */
+			DPRINTF(UDMASS_CBI, ("%s: type=0x%02x, value=0x%02x\n",
+				USBDEVNAME(sc->sc_dev),
+				sc->sbl.common.type, sc->sbl.common.value));
+
+			if (sc->sbl.common.type == IDB_TYPE_CCI) {
+				int err;
+
+				if ((sc->sbl.common.value&IDB_VALUE_STATUS_MASK)
+							== IDB_VALUE_PASS) {
+					err = STATUS_CMD_OK;
+				} else if ((sc->sbl.common.value & IDB_VALUE_STATUS_MASK)
+							== IDB_VALUE_FAIL ||
+					   (sc->sbl.common.value & IDB_VALUE_STATUS_MASK)
+						== IDB_VALUE_PERSISTENT) {
+					err = STATUS_CMD_FAILED;
+				} else {
+					err = STATUS_WIRE_FAILED;
+				}
+
+				sc->transfer_state = TSTATE_IDLE;
+				sc->transfer_cb(sc, sc->transfer_priv,
+				       sc->transfer_datalen-sc->transfer_actlen,
+				       err);
+			}
+		}
+		return;
+
+	case TSTATE_CBI_DCLEAR:
+		if (err) {	/* should not occur */
+			printf("%s: CBI bulk-in/out stall clear failed, %s\n",
+			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+			umass_cbi_reset(sc, STATUS_WIRE_FAILED);
+		}
+
+		sc->transfer_state = TSTATE_IDLE;
+		sc->transfer_cb(sc, sc->transfer_priv,
+				sc->transfer_datalen,
+				STATUS_CMD_FAILED);
+		return;
+
+	case TSTATE_CBI_SCLEAR:
+		if (err)	/* should not occur */
+			printf("%s: CBI intr-in stall clear failed, %s\n",
+			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+
+		/* Something really bad is going on. Reset the device */
+		umass_cbi_reset(sc, STATUS_CMD_FAILED);
+		return;
+
+	/***** CBI Reset *****/
+	case TSTATE_CBI_RESET1:
+		if (err)
+			printf("%s: CBI reset failed, %s\n",
+				USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+
+		umass_clear_endpoint_stall(sc,
+			sc->bulkin, sc->bulkin_pipe, TSTATE_CBI_RESET2,
+			sc->transfer_xfer[XFER_CBI_RESET2]);
+
+		return;
+	case TSTATE_CBI_RESET2:
+		if (err)	/* should not occur */
+			printf("%s: CBI bulk-in stall clear failed, %s\n",
+			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+			/* no error recovery, otherwise we end up in a loop */
+
+		umass_clear_endpoint_stall(sc,
+			sc->bulkout, sc->bulkout_pipe, TSTATE_CBI_RESET3,
+			sc->transfer_xfer[XFER_CBI_RESET3]);
+
+		return;
+	case TSTATE_CBI_RESET3:
+		if (err)	/* should not occur */
+			printf("%s: CBI bulk-out stall clear failed, %s\n",
+			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+			/* no error recovery, otherwise we end up in a loop */
+
+		sc->transfer_state = TSTATE_IDLE;
+		if (sc->transfer_priv) {
+			sc->transfer_cb(sc, sc->transfer_priv,
+					sc->transfer_datalen,
+					sc->transfer_status);
+		}
+
+		return;
+
+
+	/***** Default *****/
+	default:
+		panic("%s: Unknown state %d",
+		      USBDEVNAME(sc->sc_dev), sc->transfer_state);
+	}
+}
+
+
+
+
+/*
+ * CAM specific functions (used by SCSI, UFI, 8070i (ATAPI))
+ */
+
+Static int
+umass_cam_attach_sim(struct umass_softc *sc)
+{
+	struct cam_devq	*devq;		/* Per device Queue */
+
+	/* A HBA is attached to the CAM layer.
+	 *
+	 * The CAM layer will then after a while start probing for
+	 * devices on the bus. The number of SIMs is limited to one.
+	 */
+
+	devq = cam_simq_alloc(1 /*maximum openings*/);
+	if (devq == NULL)
+		return(ENOMEM);
+
+	sc->umass_sim = cam_sim_alloc(umass_cam_action, umass_cam_poll,
+				DEVNAME_SIM,
+				sc /*priv*/,
+				USBDEVUNIT(sc->sc_dev) /*unit number*/,
+				1 /*maximum device openings*/,
+				0 /*maximum tagged device openings*/,
+				devq);
+	if (sc->umass_sim == NULL) {
+		cam_simq_free(devq);
+		return(ENOMEM);
+	}
+
+	if(xpt_bus_register(sc->umass_sim, USBDEVUNIT(sc->sc_dev)) !=
+	    CAM_SUCCESS)
+		return(ENOMEM);
+
+	return(0);
+}
+
+Static void
+umass_cam_rescan_callback(struct cam_periph *periph, union ccb *ccb)
+{
+#ifdef USB_DEBUG
+	if (ccb->ccb_h.status != CAM_REQ_CMP) {
+		DPRINTF(UDMASS_SCSI, ("%s:%d Rescan failed, 0x%04x\n",
+			periph->periph_name, periph->unit_number,
+			ccb->ccb_h.status));
+	} else {
+		DPRINTF(UDMASS_SCSI, ("%s%d: Rescan succeeded\n",
+			periph->periph_name, periph->unit_number));
+	}
+#endif
+
+	xpt_free_path(ccb->ccb_h.path);
+	free(ccb, M_USBDEV);
+}
+
+Static void
+umass_cam_rescan(void *addr)
+{
+	struct umass_softc *sc = (struct umass_softc *) addr;
+	struct cam_path *path;
+	union ccb *ccb;
+
+	DPRINTF(UDMASS_SCSI, ("scbus%d: scanning for %s:%d:%d:%d\n",
+		cam_sim_path(sc->umass_sim),
+		USBDEVNAME(sc->sc_dev), cam_sim_path(sc->umass_sim),
+		USBDEVUNIT(sc->sc_dev), CAM_LUN_WILDCARD));
+
+	ccb = malloc(sizeof(union ccb), M_USBDEV, M_NOWAIT | M_ZERO);
+	if (ccb == NULL)
+		return;
+	if (xpt_create_path(&path, xpt_periph, cam_sim_path(sc->umass_sim),
+			    CAM_TARGET_WILDCARD, CAM_LUN_WILDCARD)
+	    != CAM_REQ_CMP) {
+		free(ccb, M_USBDEV);
+		return;
+	}
+
+	xpt_setup_ccb(&ccb->ccb_h, path, 5/*priority (low)*/);
+	ccb->ccb_h.func_code = XPT_SCAN_BUS;
+	ccb->ccb_h.cbfcnp = umass_cam_rescan_callback;
+	ccb->crcn.flags = CAM_FLAG_NONE;
+	xpt_action(ccb);
+
+	/* The scan is in progress now. */
+}
+
+Static int
+umass_cam_attach(struct umass_softc *sc)
+{
+#ifndef USB_DEBUG
+	if (bootverbose)
+#endif
+		printf("%s:%d:%d:%d: Attached to scbus%d\n",
+			USBDEVNAME(sc->sc_dev), cam_sim_path(sc->umass_sim),
+			USBDEVUNIT(sc->sc_dev), CAM_LUN_WILDCARD,
+			cam_sim_path(sc->umass_sim));
+
+	if (!cold) {
+		/* Notify CAM of the new device after a short delay. Any
+		 * failure is benign, as the user can still do it by hand
+		 * (camcontrol rescan <busno>). Only do this if we are not
+		 * booting, because CAM does a scan after booting has
+		 * completed, when interrupts have been enabled.
+		 */
+
+		usb_callout(sc->cam_scsi_rescan_ch, MS_TO_TICKS(200),
+		    umass_cam_rescan, sc);
+	}
+
+	return(0);	/* always succesfull */
+}
+
+/* umass_cam_detach
+ *	detach from the CAM layer
+ */
+
+Static int
+umass_cam_detach_sim(struct umass_softc *sc)
+{
+	if (sc->umass_sim) {
+		if (xpt_bus_deregister(cam_sim_path(sc->umass_sim)))
+			cam_sim_free(sc->umass_sim, /*free_devq*/TRUE);
+		else
+			return(EBUSY);
+
+		sc->umass_sim = NULL;
+	}
+
+	return(0);
+}
+
+/* umass_cam_action
+ * 	CAM requests for action come through here
+ */
+
+Static void
+umass_cam_action(struct cam_sim *sim, union ccb *ccb)
+{
+	struct umass_softc *sc = (struct umass_softc *)sim->softc;
+
+	/* The softc is still there, but marked as going away. umass_cam_detach
+	 * has not yet notified CAM of the lost device however.
+	 */
+	if (sc && (sc->flags & UMASS_FLAGS_GONE)) {
+		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
+			"Invalid target (gone)\n",
+			USBDEVNAME(sc->sc_dev), cam_sim_path(sc->umass_sim),
+			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
+			ccb->ccb_h.func_code));
+		ccb->ccb_h.status = CAM_TID_INVALID;
+		xpt_done(ccb);
+		return;
+	}
+
+	/* Verify, depending on the operation to perform, that we either got a
+	 * valid sc, because an existing target was referenced, or otherwise
+	 * the SIM is addressed.
+	 *
+	 * This avoids bombing out at a printf and does give the CAM layer some
+	 * sensible feedback on errors.
+	 */
+	switch (ccb->ccb_h.func_code) {
+	case XPT_SCSI_IO:
+	case XPT_RESET_DEV:
+	case XPT_GET_TRAN_SETTINGS:
+	case XPT_SET_TRAN_SETTINGS:
+	case XPT_CALC_GEOMETRY:
+		/* the opcodes requiring a target. These should never occur. */
+		if (sc == NULL) {
+			printf("%s:%d:%d:%d:func_code 0x%04x: "
+				"Invalid target (target needed)\n",
+				DEVNAME_SIM, cam_sim_path(sc->umass_sim),
+				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
+				ccb->ccb_h.func_code);
+
+			ccb->ccb_h.status = CAM_TID_INVALID;
+			xpt_done(ccb);
+			return;
+		}
+		break;
+	case XPT_PATH_INQ:
+	case XPT_NOOP:
+		/* The opcodes sometimes aimed at a target (sc is valid),
+		 * sometimes aimed at the SIM (sc is invalid and target is
+		 * CAM_TARGET_WILDCARD)
+		 */
+		if (sc == NULL && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
+			DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
+				"Invalid target (no wildcard)\n",
+				DEVNAME_SIM, cam_sim_path(sc->umass_sim),
+				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
+				ccb->ccb_h.func_code));
+
+			ccb->ccb_h.status = CAM_TID_INVALID;
+			xpt_done(ccb);
+			return;
+		}
+		break;
+	default:
+		/* XXX Hm, we should check the input parameters */
+		break;
+	}
+
+	/* Perform the requested action */
+	switch (ccb->ccb_h.func_code) {
+	case XPT_SCSI_IO:
+	{
+		struct ccb_scsiio *csio = &ccb->csio;	/* deref union */
+		int dir;
+		unsigned char *cmd;
+		int cmdlen;
+		unsigned char *rcmd;
+		int rcmdlen;
+
+		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SCSI_IO: "
+			"cmd: 0x%02x, flags: 0x%02x, "
+			"%db cmd/%db data/%db sense\n",
+			USBDEVNAME(sc->sc_dev), cam_sim_path(sc->umass_sim),
+			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
+			csio->cdb_io.cdb_bytes[0],
+			ccb->ccb_h.flags & CAM_DIR_MASK,
+			csio->cdb_len, csio->dxfer_len,
+			csio->sense_len));
+
+		/* clear the end of the buffer to make sure we don't send out
+		 * garbage.
+		 */
+		DIF(UDMASS_SCSI, if ((ccb->ccb_h.flags & CAM_DIR_MASK)
+				     == CAM_DIR_OUT)
+					umass_dump_buffer(sc, csio->data_ptr,
+						csio->dxfer_len, 48));
+
+		if (sc->transfer_state != TSTATE_IDLE) {
+			DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SCSI_IO: "
+				"I/O in progress, deferring (state %d, %s)\n",
+				USBDEVNAME(sc->sc_dev), cam_sim_path(sc->umass_sim),
+				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
+				sc->transfer_state,states[sc->transfer_state]));
+			ccb->ccb_h.status = CAM_SCSI_BUSY;
+			xpt_done(ccb);
+			return;
+		}
+
+		switch(ccb->ccb_h.flags&CAM_DIR_MASK) {
+		case CAM_DIR_IN:
+			dir = DIR_IN;
+			break;
+		case CAM_DIR_OUT:
+			dir = DIR_OUT;
+			break;
+		default:
+			dir = DIR_NONE;
+		}
+
+		ccb->ccb_h.status = CAM_REQ_INPROG | CAM_SIM_QUEUED;
+
+
+		if (csio->ccb_h.flags & CAM_CDB_POINTER) {
+			cmd = (unsigned char *) csio->cdb_io.cdb_ptr;
+		} else {
+			cmd = (unsigned char *) &csio->cdb_io.cdb_bytes;
+		}
+		cmdlen = csio->cdb_len;
+		rcmd = (unsigned char *) &sc->cam_scsi_command;
+		rcmdlen = sizeof(sc->cam_scsi_command);
+
+		/* sc->transform will convert the command to the command
+		 * (format) needed by the specific command set and return
+		 * the converted command in a buffer pointed to be rcmd.
+		 * We pass in a buffer, but if the command does not
+		 * have to be transformed it returns a ptr to the original
+		 * buffer (see umass_scsi_transform).
+		 */
+
+		if (sc->transform(sc, cmd, cmdlen, &rcmd, &rcmdlen)) {
+			/*
+			 * Handle EVPD inquiry for broken devices first
+			 * NO_INQUIRY also implies NO_INQUIRY_EVPD
+			 */
+			if ((sc->quirks & (NO_INQUIRY_EVPD | NO_INQUIRY)) &&
+			    rcmd[0] == INQUIRY && (rcmd[1] & SI_EVPD)) {
+				struct scsi_sense_data *sense;
+
+				sense = &ccb->csio.sense_data;
+				bzero(sense, sizeof(*sense));
+				sense->error_code = SSD_CURRENT_ERROR;
+				sense->flags = SSD_KEY_ILLEGAL_REQUEST;
+				sense->add_sense_code = 0x24;
+				sense->extra_len = 10;
+ 				ccb->csio.scsi_status = SCSI_STATUS_CHECK_COND;
+				ccb->ccb_h.status = CAM_SCSI_STATUS_ERROR |
+				    CAM_AUTOSNS_VALID;
+				xpt_done(ccb);
+				return;
+			}
+			/* Return fake inquiry data for broken devices */
+			if ((sc->quirks & NO_INQUIRY) && rcmd[0] == INQUIRY) {
+				struct ccb_scsiio *csio = &ccb->csio;
+
+				memcpy(csio->data_ptr, &fake_inq_data,
+				    sizeof(fake_inq_data));
+				csio->scsi_status = SCSI_STATUS_OK;
+				ccb->ccb_h.status = CAM_REQ_CMP;
+				xpt_done(ccb);
+				return;
+			}
+			if ((sc->quirks & FORCE_SHORT_INQUIRY) &&
+			    rcmd[0] == INQUIRY) {
+				csio->dxfer_len = SHORT_INQUIRY_LENGTH;
+			}
+			sc->transfer(sc, ccb->ccb_h.target_lun, rcmd, rcmdlen,
+				     csio->data_ptr,
+				     csio->dxfer_len, dir, ccb->ccb_h.timeout,
+				     umass_cam_cb, (void *) ccb);
+		} else {
+			ccb->ccb_h.status = CAM_REQ_INVALID;
+			xpt_done(ccb);
+		}
+
+		break;
+	}
+	case XPT_PATH_INQ:
+	{
+		struct ccb_pathinq *cpi = &ccb->cpi;
+
+		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_PATH_INQ:.\n",
+			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
+			cam_sim_path(sc->umass_sim),
+			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));
+
+		/* host specific information */
+		cpi->version_num = 1;
+		cpi->hba_inquiry = 0;
+		cpi->target_sprt = 0;
+		cpi->hba_misc = PIM_NO_6_BYTE;
+		cpi->hba_eng_cnt = 0;
+		cpi->max_target = UMASS_SCSIID_MAX;	/* one target */
+		cpi->initiator_id = UMASS_SCSIID_HOST;
+		strncpy(cpi->sim_vid, "FreeBSD", SIM_IDLEN);
+		strncpy(cpi->hba_vid, "USB SCSI", HBA_IDLEN);
+		strncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);
+		cpi->unit_number = cam_sim_unit(sim);
+		cpi->bus_id = USBDEVUNIT(sc->sc_dev);
+
+		if (sc == NULL) {
+			cpi->base_transfer_speed = 0;
+			cpi->max_lun = 0;
+		} else {
+			if (sc->quirks & FLOPPY_SPEED) {
+				cpi->base_transfer_speed =
+				    UMASS_FLOPPY_TRANSFER_SPEED;
+			} else if (usbd_get_speed(sc->sc_udev) ==
+			    USB_SPEED_HIGH) {
+				cpi->base_transfer_speed =
+				    UMASS_HIGH_TRANSFER_SPEED;
+			} else {
+				cpi->base_transfer_speed =
+				    UMASS_FULL_TRANSFER_SPEED;
+			}
+			cpi->max_lun = sc->maxlun;
+		}
+
+		cpi->ccb_h.status = CAM_REQ_CMP;
+		xpt_done(ccb);
+		break;
+	}
+	case XPT_RESET_DEV:
+	{
+		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_RESET_DEV:.\n",
+			USBDEVNAME(sc->sc_dev), cam_sim_path(sc->umass_sim),
+			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));
+
+		ccb->ccb_h.status = CAM_REQ_INPROG;
+		umass_reset(sc, umass_cam_cb, (void *) ccb);
+		break;
+	}
+	case XPT_GET_TRAN_SETTINGS:
+	{
+		struct ccb_trans_settings *cts = &ccb->cts;
+
+		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_GET_TRAN_SETTINGS:.\n",
+			USBDEVNAME(sc->sc_dev), cam_sim_path(sc->umass_sim),
+			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));
+
+		cts->valid = 0;
+		cts->flags = 0;		/* no disconnection, tagging */
+
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		xpt_done(ccb);
+		break;
+	}
+	case XPT_SET_TRAN_SETTINGS:
+	{
+		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SET_TRAN_SETTINGS:.\n",
+			USBDEVNAME(sc->sc_dev), cam_sim_path(sc->umass_sim),
+			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));
+
+		ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;
+		xpt_done(ccb);
+		break;
+	}
+	case XPT_CALC_GEOMETRY:
+	{
+		cam_calc_geometry(&ccb->ccg, /*extended*/1);
+		xpt_done(ccb);
+		break;
+	}
+	case XPT_NOOP:
+	{
+		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_NOOP:.\n",
+			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
+			cam_sim_path(sc->umass_sim),
+			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));
+
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		xpt_done(ccb);
+		break;
+	}
+	default:
+		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
+			"Not implemented\n",
+			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
+			cam_sim_path(sc->umass_sim),
+			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
+			ccb->ccb_h.func_code));
+
+		ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;
+		xpt_done(ccb);
+		break;
+	}
+}
+
+/* umass_cam_poll
+ *	all requests are handled through umass_cam_action, requests
+ *	are never pending. So, nothing to do here.
+ */
+Static void
+umass_cam_poll(struct cam_sim *sim)
+{
+#ifdef USB_DEBUG
+	struct umass_softc *sc = (struct umass_softc *) sim->softc;
+
+	DPRINTF(UDMASS_SCSI, ("%s: CAM poll\n",
+		USBDEVNAME(sc->sc_dev)));
+#endif
+
+	/* nop */
+}
+
+
+/* umass_cam_cb
+ *	finalise a completed CAM command
+ */
+
+Static void
+umass_cam_cb(struct umass_softc *sc, void *priv, int residue, int status)
+{
+	union ccb *ccb = (union ccb *) priv;
+	struct ccb_scsiio *csio = &ccb->csio;		/* deref union */
+
+	/* If the device is gone, just fail the request. */
+	if (sc->flags & UMASS_FLAGS_GONE) {
+		ccb->ccb_h.status = CAM_TID_INVALID;
+		xpt_done(ccb);
+		return;
+	}
+
+	csio->resid = residue;
+
+	switch (status) {
+	case STATUS_CMD_OK:
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		xpt_done(ccb);
+		break;
+
+	case STATUS_CMD_UNKNOWN:
+	case STATUS_CMD_FAILED:
+		switch (ccb->ccb_h.func_code) {
+		case XPT_SCSI_IO:
+		{
+			unsigned char *rcmd;
+			int rcmdlen;
+
+			/* fetch sense data */
+			/* the rest of the command was filled in at attach */
+			sc->cam_scsi_sense.length = csio->sense_len;
+
+			DPRINTF(UDMASS_SCSI,("%s: Fetching %db sense data\n",
+				USBDEVNAME(sc->sc_dev), csio->sense_len));
+
+			rcmd = (unsigned char *) &sc->cam_scsi_command;
+			rcmdlen = sizeof(sc->cam_scsi_command);
+
+			if (sc->transform(sc,
+				    (unsigned char *) &sc->cam_scsi_sense,
+				    sizeof(sc->cam_scsi_sense),
+				    &rcmd, &rcmdlen)) {
+				if ((sc->quirks & FORCE_SHORT_INQUIRY) && (rcmd[0] == INQUIRY)) {
+					csio->sense_len = SHORT_INQUIRY_LENGTH;
+				}
+				sc->transfer(sc, ccb->ccb_h.target_lun,
+					     rcmd, rcmdlen,
+					     &csio->sense_data,
+					     csio->sense_len, DIR_IN, ccb->ccb_h.timeout,
+					     umass_cam_sense_cb, (void *) ccb);
+			} else {
+				panic("transform(REQUEST_SENSE) failed");
+			}
+			break;
+		}
+		case XPT_RESET_DEV: /* Reset failed */
+			ccb->ccb_h.status = CAM_REQ_CMP_ERR;
+			xpt_done(ccb);
+			break;
+		default:
+			panic("umass_cam_cb called for func_code %d",
+			      ccb->ccb_h.func_code);
+		}
+		break;
+
+	case STATUS_WIRE_FAILED:
+		/* the wire protocol failed and will have recovered
+		 * (hopefully).  We return an error to CAM and let CAM retry
+		 * the command if necessary.
+		 */
+		ccb->ccb_h.status = CAM_REQ_CMP_ERR;
+		xpt_done(ccb);
+		break;
+	default:
+		panic("%s: Unknown status %d in umass_cam_cb",
+			USBDEVNAME(sc->sc_dev), status);
+	}
+}
+
+/* Finalise a completed autosense operation
+ */
+Static void
+umass_cam_sense_cb(struct umass_softc *sc, void *priv, int residue, int status)
+{
+	union ccb *ccb = (union ccb *) priv;
+	struct ccb_scsiio *csio = &ccb->csio;		/* deref union */
+	unsigned char *rcmd;
+	int rcmdlen;
+
+	if (sc->flags & UMASS_FLAGS_GONE) {
+		ccb->ccb_h.status = CAM_AUTOSENSE_FAIL;
+		xpt_done(ccb);
+		return;
+	}
+
+	switch (status) {
+	case STATUS_CMD_OK:
+	case STATUS_CMD_UNKNOWN:
+	case STATUS_CMD_FAILED:
+		/* Getting sense data always succeeds (apart from wire
+		 * failures).
+		 */
+		if ((sc->quirks & RS_NO_CLEAR_UA)
+		    && csio->cdb_io.cdb_bytes[0] == INQUIRY
+		    && (csio->sense_data.flags & SSD_KEY)
+		    				== SSD_KEY_UNIT_ATTENTION) {
+			/* Ignore unit attention errors in the case where
+			 * the Unit Attention state is not cleared on
+			 * REQUEST SENSE. They will appear again at the next
+			 * command.
+			 */
+			ccb->ccb_h.status = CAM_REQ_CMP;
+		} else if ((csio->sense_data.flags & SSD_KEY)
+						== SSD_KEY_NO_SENSE) {
+			/* No problem after all (in the case of CBI without
+			 * CCI)
+			 */
+			ccb->ccb_h.status = CAM_REQ_CMP;
+		} else if ((sc->quirks & RS_NO_CLEAR_UA) &&
+			   (csio->cdb_io.cdb_bytes[0] == READ_CAPACITY) &&
+			   ((csio->sense_data.flags & SSD_KEY)
+			    == SSD_KEY_UNIT_ATTENTION)) {
+			/*
+			 * Some devices do not clear the unit attention error
+			 * on request sense. We insert a test unit ready
+			 * command to make sure we clear the unit attention
+			 * condition, then allow the retry to proceed as
+			 * usual.
+			 */
+
+			ccb->ccb_h.status = CAM_SCSI_STATUS_ERROR
+					    | CAM_AUTOSNS_VALID;
+			csio->scsi_status = SCSI_STATUS_CHECK_COND;
+
+#if 0
+			DELAY(300000);
+#endif
+
+			DPRINTF(UDMASS_SCSI,("%s: Doing a sneaky"
+					     "TEST_UNIT_READY\n",
+				USBDEVNAME(sc->sc_dev)));
+
+			/* the rest of the command was filled in at attach */
+
+			rcmd = (unsigned char *) &sc->cam_scsi_command2;
+			rcmdlen = sizeof(sc->cam_scsi_command2);
+
+			if (sc->transform(sc,
+					(unsigned char *)
+					&sc->cam_scsi_test_unit_ready,
+					sizeof(sc->cam_scsi_test_unit_ready),
+					&rcmd, &rcmdlen)) {
+				sc->transfer(sc, ccb->ccb_h.target_lun,
+					     rcmd, rcmdlen,
+					     NULL, 0, DIR_NONE, ccb->ccb_h.timeout,
+					     umass_cam_quirk_cb, (void *) ccb);
+			} else {
+				panic("transform(TEST_UNIT_READY) failed");
+			}
+			break;
+		} else {
+			ccb->ccb_h.status = CAM_SCSI_STATUS_ERROR
+					    | CAM_AUTOSNS_VALID;
+			csio->scsi_status = SCSI_STATUS_CHECK_COND;
+		}
+		xpt_done(ccb);
+		break;
+
+	default:
+		DPRINTF(UDMASS_SCSI, ("%s: Autosense failed, status %d\n",
+			USBDEVNAME(sc->sc_dev), status));
+		ccb->ccb_h.status = CAM_AUTOSENSE_FAIL;
+		xpt_done(ccb);
+	}
+}
+
+/*
+ * This completion code just handles the fact that we sent a test-unit-ready
+ * after having previously failed a READ CAPACITY with CHECK_COND.  Even
+ * though this command succeeded, we have to tell CAM to retry.
+ */
+Static void
+umass_cam_quirk_cb(struct umass_softc *sc, void *priv, int residue, int status)
+{
+	union ccb *ccb = (union ccb *) priv;
+
+	DPRINTF(UDMASS_SCSI, ("%s: Test unit ready returned status %d\n",
+	USBDEVNAME(sc->sc_dev), status));
+
+	if (sc->flags & UMASS_FLAGS_GONE) {
+		ccb->ccb_h.status = CAM_TID_INVALID;
+		xpt_done(ccb);
+		return;
+	}
+#if 0
+	ccb->ccb_h.status = CAM_REQ_CMP;
+#endif
+	ccb->ccb_h.status = CAM_SCSI_STATUS_ERROR
+			    | CAM_AUTOSNS_VALID;
+	ccb->csio.scsi_status = SCSI_STATUS_CHECK_COND;
+	xpt_done(ccb);
+}
+
+Static int
+umass_driver_load(module_t mod, int what, void *arg)
+{
+	switch (what) {
+	case MOD_UNLOAD:
+	case MOD_LOAD:
+	default:
+		return(usbd_driver_load(mod, what, arg));
+	}
+}
+
+/*
+ * SCSI specific functions
+ */
+
+Static int
+umass_scsi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
+		     unsigned char **rcmd, int *rcmdlen)
+{
+	switch (cmd[0]) {
+	case TEST_UNIT_READY:
+		if (sc->quirks & NO_TEST_UNIT_READY) {
+			KASSERT(*rcmdlen >= sizeof(struct scsi_start_stop_unit),
+				("rcmdlen = %d < %ld, buffer too small",
+				 *rcmdlen,
+				 (long)sizeof(struct scsi_start_stop_unit)));
+			DPRINTF(UDMASS_SCSI, ("%s: Converted TEST_UNIT_READY "
+				"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
+			memset(*rcmd, 0, *rcmdlen);
+			(*rcmd)[0] = START_STOP_UNIT;
+			(*rcmd)[4] = SSS_START;
+			return 1;
+		}
+		/* fallthrough */
+	case INQUIRY:
+		/* some drives wedge when asked for full inquiry information. */
+		if (sc->quirks & FORCE_SHORT_INQUIRY) {
+			memcpy(*rcmd, cmd, cmdlen);
+			*rcmdlen = cmdlen;
+			(*rcmd)[4] = SHORT_INQUIRY_LENGTH;
+			return 1;
+		}
+		/* fallthrough */
+	default:
+		*rcmd = cmd;		/* We don't need to copy it */
+		*rcmdlen = cmdlen;
+	}
+
+	return 1;
+}
+/* RBC specific functions */
+Static int
+umass_rbc_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
+		     unsigned char **rcmd, int *rcmdlen)
+{
+	switch (cmd[0]) {
+	/* these commands are defined in RBC: */
+	case READ_10:
+	case READ_CAPACITY:
+	case START_STOP_UNIT:
+	case SYNCHRONIZE_CACHE:
+	case WRITE_10:
+	case 0x2f: /* VERIFY_10 is absent from scsi_all.h??? */
+	case INQUIRY:
+	case MODE_SELECT_10:
+	case MODE_SENSE_10:
+	case TEST_UNIT_READY:
+	case WRITE_BUFFER:
+	 /* The following commands are not listed in my copy of the RBC specs.
+	  * CAM however seems to want those, and at least the Sony DSC device
+	  * appears to support those as well */
+	case REQUEST_SENSE:
+	case PREVENT_ALLOW:
+		if ((sc->quirks & RBC_PAD_TO_12) && cmdlen < 12) {
+			*rcmdlen = 12;
+			bcopy(cmd, *rcmd, cmdlen);
+			bzero(*rcmd + cmdlen, 12 - cmdlen);
+		} else {
+			*rcmd = cmd;		/* We don't need to copy it */
+			*rcmdlen = cmdlen;
+		}
+		return 1;
+	/* All other commands are not legal in RBC */
+	default:
+		printf("%s: Unsupported RBC command 0x%02x",
+			USBDEVNAME(sc->sc_dev), cmd[0]);
+		printf("\n");
+		return 0;	/* failure */
+	}
+}
+
+/*
+ * UFI specific functions
+ */
+Static int
+umass_ufi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
+		    unsigned char **rcmd, int *rcmdlen)
+{
+	/* A UFI command is always 12 bytes in length */
+	KASSERT(*rcmdlen >= UFI_COMMAND_LENGTH,
+		("rcmdlen = %d < %d, buffer too small",
+		 *rcmdlen, UFI_COMMAND_LENGTH));
+
+	*rcmdlen = UFI_COMMAND_LENGTH;
+	memset(*rcmd, 0, UFI_COMMAND_LENGTH);
+
+	switch (cmd[0]) {
+	/* Commands of which the format has been verified. They should work.
+	 * Copy the command into the (zeroed out) destination buffer.
+	 */
+	case TEST_UNIT_READY:
+		if (sc->quirks &  NO_TEST_UNIT_READY) {
+			/* Some devices do not support this command.
+			 * Start Stop Unit should give the same results
+			 */
+			DPRINTF(UDMASS_UFI, ("%s: Converted TEST_UNIT_READY "
+				"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
+			(*rcmd)[0] = START_STOP_UNIT;
+			(*rcmd)[4] = SSS_START;
+		} else {
+			memcpy(*rcmd, cmd, cmdlen);
+		}
+		return 1;
+
+	case REZERO_UNIT:
+	case REQUEST_SENSE:
+	case FORMAT_UNIT:
+	case INQUIRY:
+	case START_STOP_UNIT:
+	case SEND_DIAGNOSTIC:
+	case PREVENT_ALLOW:
+	case READ_CAPACITY:
+	case READ_10:
+	case WRITE_10:
+	case POSITION_TO_ELEMENT:	/* SEEK_10 */
+	case WRITE_AND_VERIFY:
+	case VERIFY:
+	case MODE_SELECT_10:
+	case MODE_SENSE_10:
+	case READ_12:
+	case WRITE_12:
+	case READ_FORMAT_CAPACITIES:
+		memcpy(*rcmd, cmd, cmdlen);
+		return 1;
+
+	default:
+		printf("%s: Unsupported UFI command 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), cmd[0]);
+		return 0;	/* failure */
+	}
+}
+
+/*
+ * 8070i (ATAPI) specific functions
+ */
+Static int
+umass_atapi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
+		      unsigned char **rcmd, int *rcmdlen)
+{
+	/* An ATAPI command is always 12 bytes in length. */
+	KASSERT(*rcmdlen >= ATAPI_COMMAND_LENGTH,
+		("rcmdlen = %d < %d, buffer too small",
+		 *rcmdlen, ATAPI_COMMAND_LENGTH));
+
+	*rcmdlen = ATAPI_COMMAND_LENGTH;
+	memset(*rcmd, 0, ATAPI_COMMAND_LENGTH);
+
+	switch (cmd[0]) {
+	/* Commands of which the format has been verified. They should work.
+	 * Copy the command into the (zeroed out) destination buffer.
+	 */
+	case INQUIRY:
+		memcpy(*rcmd, cmd, cmdlen);
+		/* some drives wedge when asked for full inquiry information. */
+		if (sc->quirks & FORCE_SHORT_INQUIRY)
+			(*rcmd)[4] = SHORT_INQUIRY_LENGTH;
+		return 1;
+
+	case TEST_UNIT_READY:
+		if (sc->quirks & NO_TEST_UNIT_READY) {
+			KASSERT(*rcmdlen >= sizeof(struct scsi_start_stop_unit),
+				("rcmdlen = %d < %ld, buffer too small",
+				 *rcmdlen,
+				 (long)sizeof(struct scsi_start_stop_unit)));
+			DPRINTF(UDMASS_SCSI, ("%s: Converted TEST_UNIT_READY "
+				"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
+			memset(*rcmd, 0, *rcmdlen);
+			(*rcmd)[0] = START_STOP_UNIT;
+			(*rcmd)[4] = SSS_START;
+			return 1;
+		}
+		/* fallthrough */
+	case REZERO_UNIT:
+	case REQUEST_SENSE:
+	case START_STOP_UNIT:
+	case SEND_DIAGNOSTIC:
+	case PREVENT_ALLOW:
+	case READ_CAPACITY:
+	case READ_10:
+	case WRITE_10:
+	case POSITION_TO_ELEMENT:	/* SEEK_10 */
+	case SYNCHRONIZE_CACHE:
+	case MODE_SELECT_10:
+	case MODE_SENSE_10:
+	case READ_BUFFER:
+	case 0x42: /* READ_SUBCHANNEL */
+	case 0x43: /* READ_TOC */
+	case 0x44: /* READ_HEADER */
+	case 0x47: /* PLAY_MSF (Play Minute/Second/Frame) */
+	case 0x48: /* PLAY_TRACK */
+	case 0x49: /* PLAY_TRACK_REL */
+	case 0x4b: /* PAUSE */
+	case 0x51: /* READ_DISK_INFO */
+	case 0x52: /* READ_TRACK_INFO */
+	case 0x54: /* SEND_OPC */
+	case 0x59: /* READ_MASTER_CUE */
+	case 0x5b: /* CLOSE_TR_SESSION */
+	case 0x5c: /* READ_BUFFER_CAP */
+	case 0x5d: /* SEND_CUE_SHEET */
+	case 0xa1: /* BLANK */
+	case 0xa5: /* PLAY_12 */
+	case 0xa6: /* EXCHANGE_MEDIUM */
+	case 0xad: /* READ_DVD_STRUCTURE */
+	case 0xbb: /* SET_CD_SPEED */
+	case 0xe5: /* READ_TRACK_INFO_PHILIPS */
+		memcpy(*rcmd, cmd, cmdlen);
+		return 1;
+
+	case READ_12:
+	case WRITE_12:
+	default:
+		printf("%s: Unsupported ATAPI command 0x%02x\n",
+			USBDEVNAME(sc->sc_dev), cmd[0]);
+		return 0;	/* failure */
+	}
+}
+
+
+/* (even the comment is missing) */
+
+DRIVER_MODULE(umass, uhub, umass_driver, umass_devclass, umass_driver_load, 0);
+
+
+
+#ifdef USB_DEBUG
+Static void
+umass_bbb_dump_cbw(struct umass_softc *sc, umass_bbb_cbw_t *cbw)
+{
+	int clen = cbw->bCDBLength;
+	int dlen = UGETDW(cbw->dCBWDataTransferLength);
+	u_int8_t *c = cbw->CBWCDB;
+	int tag = UGETDW(cbw->dCBWTag);
+	int flags = cbw->bCBWFlags;
+
+	DPRINTF(UDMASS_BBB, ("%s: CBW %d: cmd = %db "
+		"(0x%02x%02x%02x%02x%02x%02x%s), "
+		"data = %db, dir = %s\n",
+		USBDEVNAME(sc->sc_dev), tag, clen,
+		c[0], c[1], c[2], c[3], c[4], c[5], (clen > 6? "...":""),
+		dlen, (flags == CBWFLAGS_IN? "in":
+		       (flags == CBWFLAGS_OUT? "out":"<invalid>"))));
+}
+
+Static void
+umass_bbb_dump_csw(struct umass_softc *sc, umass_bbb_csw_t *csw)
+{
+	int sig = UGETDW(csw->dCSWSignature);
+	int tag = UGETW(csw->dCSWTag);
+	int res = UGETDW(csw->dCSWDataResidue);
+	int status = csw->bCSWStatus;
+
+	DPRINTF(UDMASS_BBB, ("%s: CSW %d: sig = 0x%08x (%s), tag = %d, "
+		"res = %d, status = 0x%02x (%s)\n", USBDEVNAME(sc->sc_dev),
+		tag, sig, (sig == CSWSIGNATURE?  "valid":"invalid"),
+		tag, res,
+		status, (status == CSWSTATUS_GOOD? "good":
+			 (status == CSWSTATUS_FAILED? "failed":
+			  (status == CSWSTATUS_PHASE? "phase":"<invalid>")))));
+}
+
+Static void
+umass_cbi_dump_cmd(struct umass_softc *sc, void *cmd, int cmdlen)
+{
+	u_int8_t *c = cmd;
+	int dir = sc->transfer_dir;
+
+	DPRINTF(UDMASS_BBB, ("%s: cmd = %db "
+		"(0x%02x%02x%02x%02x%02x%02x%s), "
+		"data = %db, dir = %s\n",
+		USBDEVNAME(sc->sc_dev), cmdlen,
+		c[0], c[1], c[2], c[3], c[4], c[5], (cmdlen > 6? "...":""),
+		sc->transfer_datalen,
+		(dir == DIR_IN? "in":
+		 (dir == DIR_OUT? "out":
+		  (dir == DIR_NONE? "no data phase": "<invalid>")))));
+}
+
+Static void
+umass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,
+		  int printlen)
+{
+	int i, j;
+	char s1[40];
+	char s2[40];
+	char s3[5];
+
+	s1[0] = '\0';
+	s3[0] = '\0';
+
+	sprintf(s2, " buffer=%p, buflen=%d", buffer, buflen);
+	for (i = 0; i < buflen && i < printlen; i++) {
+		j = i % 16;
+		if (j == 0 && i != 0) {
+			DPRINTF(UDMASS_GEN, ("%s: 0x %s%s\n",
+				USBDEVNAME(sc->sc_dev), s1, s2));
+			s2[0] = '\0';
+		}
+		sprintf(&s1[j*2], "%02x", buffer[i] & 0xff);
+	}
+	if (buflen > printlen)
+		sprintf(s3, " ...");
+	DPRINTF(UDMASS_GEN, ("%s: 0x %s%s%s\n",
+		USBDEVNAME(sc->sc_dev), s1, s2, s3));
+}
+#endif
diff -rubN /usr/src1/src/sys/dev/usb/umass.c.rej /usr/src/sys/dev/usb/umass.c.rej
--- /usr/src1/src/sys/dev/usb/umass.c.rej	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/umass.c.rej	Thu Jun  8 21:13:09 2006
@@ -0,0 +1,17 @@
+***************
+*** 928,934 ****
+  #endif
+  
+  	if (sc->quirks & ALT_IFACE_1) {
+! 		err = usbd_set_interface(0, 1);
+  		if (err) {
+  			DPRINTF(UDMASS_USB, ("%s: could not switch to "
+  				"Alt Interface %d\n",
+--- 929,935 ----
+  #endif
+  
+  	if (sc->quirks & ALT_IFACE_1) {
+! 		err = usbd_set_interface(uaa->iface, 1);
+  		if (err) {
+  			DPRINTF(UDMASS_USB, ("%s: could not switch to "
+  				"Alt Interface %d\n",
diff -rubN /usr/src1/src/sys/dev/usb/umodem.c /usr/src/sys/dev/usb/umodem.c
--- /usr/src1/src/sys/dev/usb/umodem.c	Mon Jan 31 13:58:10 2005
+++ /usr/src/sys/dev/usb/umodem.c	Thu Jun  8 21:13:09 2006
@@ -83,6 +83,7 @@
 #include <sys/systm.h>
 #include <sys/kernel.h>
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/ioccom.h>
 #include <sys/conf.h>
 #include <sys/serial.h>
diff -rubN /usr/src1/src/sys/dev/usb/umodem.c.orig /usr/src/sys/dev/usb/umodem.c.orig
--- /usr/src1/src/sys/dev/usb/umodem.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/umodem.c.orig	Mon Jan 31 13:58:10 2005
@@ -0,0 +1,840 @@
+/*	$NetBSD: umodem.c,v 1.45 2002/09/23 05:51:23 simonb Exp $	*/
+
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/usb/umodem.c,v 1.57 2005/01/31 13:58:10 akiyama Exp $");
+/*-
+ * Copyright (c) 2003, M. Warner Losh <imp@freebsd.org>.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Comm Class spec:  http://www.usb.org/developers/devclass_docs/usbccs10.pdf
+ *                   http://www.usb.org/developers/devclass_docs/usbcdc11.pdf
+ */
+
+/*
+ * TODO:
+ * - Add error recovery in various places; the big problem is what
+ *   to do in a callback if there is an error.
+ * - Implement a Call Device for modems without multiplexed commands.
+ *
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/ioccom.h>
+#include <sys/conf.h>
+#include <sys/serial.h>
+#include <sys/tty.h>
+#include <sys/file.h>
+#include <sys/select.h>
+#include <sys/sysctl.h>
+#include <sys/proc.h>
+#include <sys/bus.h>
+#include <sys/poll.h>
+#include <sys/uio.h>
+#include <sys/taskqueue.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbcdc.h>
+
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include <dev/usb/usb_quirks.h>
+
+#include <dev/usb/ucomvar.h>
+
+#include "usbdevs.h"
+
+#ifdef USB_DEBUG
+int	umodemdebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, umodem, CTLFLAG_RW, 0, "USB umodem");
+SYSCTL_INT(_hw_usb_umodem, OID_AUTO, debug, CTLFLAG_RW,
+	   &umodemdebug, 0, "umodem debug level");
+#define DPRINTFN(n, x)	if (umodemdebug > (n)) logprintf x
+#else
+#define DPRINTFN(n, x)
+#endif
+#define DPRINTF(x) DPRINTFN(0, x)
+
+static const struct umodem_product {
+	u_int16_t	vendor;
+	u_int16_t	product;
+	u_int8_t	interface;
+} umodem_products[] = {
+	/* Kyocera AH-K3001V*/
+	{ USB_VENDOR_KYOCERA, USB_PRODUCT_KYOCERA_AHK3001V, 0 },
+	{ 0, 0, 0 },
+};
+
+/*
+ * These are the maximum number of bytes transferred per frame.
+ * If some really high speed devices should use this driver they
+ * may need to be increased, but this is good enough for normal modems.
+ */
+#define UMODEMIBUFSIZE 64
+#define UMODEMOBUFSIZE 256
+
+#define UMODEM_MODVER			1	/* module version */
+
+struct umodem_softc {
+	struct ucom_softc	sc_ucom;
+
+	USBBASEDEVICE		sc_dev;		/* base device */
+
+	usbd_device_handle	sc_udev;	/* USB device */
+
+	int			sc_ctl_iface_no;
+	usbd_interface_handle	sc_ctl_iface;	/* control interface */
+	int			sc_data_iface_no;
+	usbd_interface_handle	sc_data_iface;	/* data interface */
+
+	int			sc_cm_cap;	/* CM capabilities */
+	int			sc_acm_cap;	/* ACM capabilities */
+
+	int			sc_cm_over_data;
+
+	usb_cdc_line_state_t	sc_line_state;	/* current line state */
+	u_char			sc_dtr;		/* current DTR state */
+	u_char			sc_rts;		/* current RTS state */
+
+	u_char			sc_opening;	/* lock during open */
+
+	int			sc_ctl_notify;	/* Notification endpoint */
+	usbd_pipe_handle	sc_notify_pipe; /* Notification pipe */
+	usb_cdc_notification_t	sc_notify_buf;	/* Notification structure */
+	u_char			sc_lsr;		/* Local status register */
+	u_char			sc_msr;		/* Modem status register */
+
+	struct task		sc_task;
+};
+
+Static void	*umodem_get_desc(usbd_device_handle dev, int type, int subtype);
+Static usbd_status umodem_set_comm_feature(struct umodem_softc *sc,
+					   int feature, int state);
+Static usbd_status umodem_set_line_coding(struct umodem_softc *sc,
+					  usb_cdc_line_state_t *state);
+
+Static void	umodem_get_caps(usbd_device_handle, int *, int *);
+
+Static void	umodem_get_status(void *, int portno, u_char *lsr, u_char *msr);
+Static void	umodem_set(void *, int, int, int);
+Static void	umodem_dtr(struct umodem_softc *, int);
+Static void	umodem_rts(struct umodem_softc *, int);
+Static void	umodem_break(struct umodem_softc *, int);
+Static void	umodem_set_line_state(struct umodem_softc *);
+Static int	umodem_param(void *, int, struct termios *);
+Static int	umodem_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr );
+Static int	umodem_open(void *, int portno);
+Static void	umodem_close(void *, int portno);
+Static void	umodem_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
+Static void	umodem_notify(void *, int);
+
+Static struct ucom_callback umodem_callback = {
+	umodem_get_status,
+	umodem_set,
+	umodem_param,
+	umodem_ioctl,
+	umodem_open,
+	umodem_close,
+	NULL,
+	NULL,
+};
+
+Static device_probe_t umodem_match;
+Static device_attach_t umodem_attach;
+Static device_detach_t umodem_detach;
+
+Static device_method_t umodem_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe, umodem_match),
+	DEVMETHOD(device_attach, umodem_attach),
+	DEVMETHOD(device_detach, umodem_detach),
+	{ 0, 0 }
+};
+
+Static driver_t umodem_driver = {
+	"ucom",
+	umodem_methods,
+	sizeof (struct umodem_softc)
+};
+
+DRIVER_MODULE(umodem, uhub, umodem_driver, ucom_devclass, usbd_driver_load, 0);
+MODULE_DEPEND(umodem, usb, 1, 1, 1);
+MODULE_DEPEND(umodem, ucom, UCOM_MINVER, UCOM_PREFVER, UCOM_MAXVER);
+MODULE_VERSION(umodem, UMODEM_MODVER);
+
+USB_MATCH(umodem)
+{
+	USB_MATCH_START(umodem, uaa);
+	usb_interface_descriptor_t *id;
+	usb_device_descriptor_t *dd;
+	int cm, acm, i, ret;
+
+	if (uaa->iface == NULL)
+		return (UMATCH_NONE);
+
+	id = usbd_get_interface_descriptor(uaa->iface);
+	dd = usbd_get_device_descriptor(uaa->device);
+	if (id == NULL || dd == NULL)
+		return (UMATCH_NONE);
+
+	ret = UMATCH_NONE;
+	for (i = 0; umodem_products[i].vendor != 0; i++) {
+		if (umodem_products[i].vendor == UGETW(dd->idVendor) &&
+		    umodem_products[i].product == UGETW(dd->idProduct) &&
+		    umodem_products[i].interface == id->bInterfaceNumber) {
+			ret = UMATCH_VENDOR_PRODUCT;
+			break;
+		}
+	}
+
+	if (ret == UMATCH_NONE &&
+	    id->bInterfaceClass == UICLASS_CDC &&
+	    id->bInterfaceSubClass == UISUBCLASS_ABSTRACT_CONTROL_MODEL &&
+	    id->bInterfaceProtocol == UIPROTO_CDC_AT)
+		ret = UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO;
+
+	if (ret == UMATCH_NONE)
+		return (ret);
+
+	umodem_get_caps(uaa->device, &cm, &acm);
+	if (!(cm & USB_CDC_CM_DOES_CM) ||
+	    !(cm & USB_CDC_CM_OVER_DATA) ||
+	    !(acm & USB_CDC_ACM_HAS_LINE))
+		return (UMATCH_NONE);
+
+	return ret;
+}
+
+USB_ATTACH(umodem)
+{
+	USB_ATTACH_START(umodem, sc, uaa);
+	usbd_device_handle dev = uaa->device;
+	usb_interface_descriptor_t *id;
+	usb_endpoint_descriptor_t *ed;
+	usb_cdc_cm_descriptor_t *cmd;
+	char *devinfo = NULL;
+	const char *devname;
+	usbd_status err;
+	int data_ifcno;
+	int i;
+	struct ucom_softc *ucom;
+
+	devinfo = malloc(1024, M_USBDEV, M_WAITOK);
+	usbd_devinfo(dev, 0, devinfo);
+	ucom = &sc->sc_ucom;
+	ucom->sc_dev = self;
+	sc->sc_dev = self;
+	device_set_desc_copy(self, devinfo);
+	ucom->sc_udev = dev;
+	ucom->sc_iface = uaa->iface;
+	/*USB_ATTACH_SETUP; */
+
+	sc->sc_udev = dev;
+	sc->sc_ctl_iface = uaa->iface;
+
+	devname = USBDEVNAME(sc->sc_dev);
+	/* XXX ? use something else ? XXX */
+	id = usbd_get_interface_descriptor(sc->sc_ctl_iface);
+	printf("%s: %s, iclass %d/%d\n", devname, devinfo,
+	  id->bInterfaceClass, id->bInterfaceSubClass);
+	sc->sc_ctl_iface_no = id->bInterfaceNumber;
+
+	umodem_get_caps(dev, &sc->sc_cm_cap, &sc->sc_acm_cap);
+
+	/* Get the data interface no. */
+	cmd = umodem_get_desc(dev, UDESC_CS_INTERFACE, UDESCSUB_CDC_CM);
+	if (cmd == NULL) {
+		printf("%s: no CM descriptor\n", devname);
+		goto bad;
+	}
+	sc->sc_data_iface_no = data_ifcno = cmd->bDataInterface;
+
+	printf("%s: data interface %d, has %sCM over data, has %sbreak\n",
+	       devname, data_ifcno,
+	       sc->sc_cm_cap & USB_CDC_CM_OVER_DATA ? "" : "no ",
+	       sc->sc_acm_cap & USB_CDC_ACM_HAS_BREAK ? "" : "no ");
+
+	/* Get the data interface too. */
+	for (i = 0; i < uaa->nifaces; i++) {
+		if (uaa->ifaces[i] != NULL) {
+			id = usbd_get_interface_descriptor(uaa->ifaces[i]);
+			if (id != NULL && id->bInterfaceNumber == data_ifcno) {
+				sc->sc_data_iface = uaa->ifaces[i];
+				uaa->ifaces[i] = NULL;
+			}
+		}
+	}
+	if (sc->sc_data_iface == NULL) {
+		printf("%s: no data interface\n", devname);
+		goto bad;
+	}
+	ucom->sc_iface = sc->sc_data_iface;
+
+	/*
+	 * Find the bulk endpoints.
+	 * Iterate over all endpoints in the data interface and take note.
+	 */
+	ucom->sc_bulkin_no = ucom->sc_bulkout_no = -1;
+
+	id = usbd_get_interface_descriptor(sc->sc_data_iface);
+	for (i = 0; i < id->bNumEndpoints; i++) {
+		ed = usbd_interface2endpoint_descriptor(sc->sc_data_iface, i);
+		if (ed == NULL) {
+			printf("%s: no endpoint descriptor for %d\n", devname,
+			    i);
+			goto bad;
+		}
+		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
+		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
+			ucom->sc_bulkin_no = ed->bEndpointAddress;
+                } else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
+		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
+			ucom->sc_bulkout_no = ed->bEndpointAddress;
+                }
+        }
+
+	if (ucom->sc_bulkin_no == -1) {
+		printf("%s: Could not find data bulk in\n", devname);
+		goto bad;
+	}
+	if (ucom->sc_bulkout_no == -1) {
+		printf("%s: Could not find data bulk out\n", devname);
+		goto bad;
+	}
+
+	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_ASSUME_CM_OVER_DATA) {
+		DPRINTF(("Quirk says to assume CM over data\n"));
+		sc->sc_cm_over_data = 1;
+	} else {
+		if (sc->sc_cm_cap & USB_CDC_CM_OVER_DATA) {
+			if (sc->sc_acm_cap & USB_CDC_ACM_HAS_FEATURE)
+				err = umodem_set_comm_feature(sc,
+				    UCDC_ABSTRACT_STATE, UCDC_DATA_MULTIPLEXED);
+			else
+				err = 0;
+			if (err) {
+				printf("%s: could not set data multiplex mode\n",
+				    devname);
+				goto bad;
+			}
+			sc->sc_cm_over_data = 1;
+		}
+	}
+
+	/*
+	 * The standard allows for notification messages (to indicate things
+	 * like a modem hangup) to come in via an interrupt endpoint
+	 * off of the control interface.  Iterate over the endpoints on
+	 * the control interface and see if there are any interrupt
+	 * endpoints; if there are, then register it.
+	 */
+
+	sc->sc_ctl_notify = -1;
+	sc->sc_notify_pipe = NULL;
+
+	for (i = 0; i < id->bNumEndpoints; i++) {
+		ed = usbd_interface2endpoint_descriptor(sc->sc_ctl_iface, i);
+		if (ed == NULL)
+			continue;
+
+		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
+		    (ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT) {
+			printf("%s: status change notification available\n",
+			    devname);
+			sc->sc_ctl_notify = ed->bEndpointAddress;
+		}
+	}
+
+	sc->sc_dtr = -1;
+
+	ucom->sc_parent = sc;
+	ucom->sc_portno = UCOM_UNK_PORTNO;
+	/* bulkin, bulkout set above */
+	ucom->sc_ibufsize = UMODEMIBUFSIZE;
+	ucom->sc_obufsize = UMODEMOBUFSIZE;
+	ucom->sc_ibufsizepad = UMODEMIBUFSIZE;
+	ucom->sc_opkthdrlen = 0;
+	ucom->sc_callback = &umodem_callback;
+
+	TASK_INIT(&sc->sc_task, 0, umodem_notify, sc);
+	ucom_attach(&sc->sc_ucom);
+
+	free(devinfo, M_USBDEV);
+	USB_ATTACH_SUCCESS_RETURN;
+
+ bad:
+	ucom->sc_dying = 1;
+	free(devinfo, M_USBDEV);
+	USB_ATTACH_ERROR_RETURN;
+}
+
+Static int
+umodem_open(void *addr, int portno)
+{
+	struct umodem_softc *sc = addr;
+	int err;
+
+	DPRINTF(("umodem_open: sc=%p\n", sc));
+
+	if (sc->sc_ctl_notify != -1 && sc->sc_notify_pipe == NULL) {
+		err = usbd_open_pipe_intr(sc->sc_ctl_iface, sc->sc_ctl_notify,
+		    USBD_SHORT_XFER_OK, &sc->sc_notify_pipe, sc,
+		    &sc->sc_notify_buf, sizeof(sc->sc_notify_buf),
+		    umodem_intr, USBD_DEFAULT_INTERVAL);
+
+		if (err) {
+			DPRINTF(("Failed to establish notify pipe: %s\n",
+				usbd_errstr(err)));
+			return EIO;
+		}
+	}
+
+	return 0;
+}
+
+Static void
+umodem_close(void *addr, int portno)
+{
+	struct umodem_softc *sc = addr;
+	int err;
+
+	DPRINTF(("umodem_close: sc=%p\n", sc));
+
+	if (sc->sc_notify_pipe != NULL) {
+		err = usbd_abort_pipe(sc->sc_notify_pipe);
+		if (err)
+			printf("%s: abort notify pipe failed: %s\n",
+			    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+		err = usbd_close_pipe(sc->sc_notify_pipe);
+		if (err)
+			printf("%s: close notify pipe failed: %s\n",
+			    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
+		sc->sc_notify_pipe = NULL;
+	}
+}
+
+Static void
+umodem_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
+{
+	struct umodem_softc *sc = priv;
+	u_char mstatus;
+
+	if (sc->sc_ucom.sc_dying)
+		return;
+
+	if (status != USBD_NORMAL_COMPLETION) {
+		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
+			return;
+		printf("%s: abnormal status: %s\n", USBDEVNAME(sc->sc_dev),
+		       usbd_errstr(status));
+		return;
+	}
+
+	if (sc->sc_notify_buf.bmRequestType != UCDC_NOTIFICATION) {
+		DPRINTF(("%s: unknown message type (%02x) on notify pipe\n",
+			 USBDEVNAME(sc->sc_dev),
+			 sc->sc_notify_buf.bmRequestType));
+		return;
+	}
+
+	switch (sc->sc_notify_buf.bNotification) {
+	case UCDC_N_SERIAL_STATE:
+		/*
+		 * Set the serial state in ucom driver based on
+		 * the bits from the notify message
+		 */
+		if (UGETW(sc->sc_notify_buf.wLength) != 2) {
+			printf("%s: Invalid notification length! (%d)\n",
+			       USBDEVNAME(sc->sc_dev),
+			       UGETW(sc->sc_notify_buf.wLength));
+			break;
+		}
+		DPRINTF(("%s: notify bytes = %02x%02x\n",
+			 USBDEVNAME(sc->sc_dev),
+			 sc->sc_notify_buf.data[0],
+			 sc->sc_notify_buf.data[1]));
+		/* Currently, lsr is always zero. */
+		sc->sc_lsr = sc->sc_msr = 0;
+		mstatus = sc->sc_notify_buf.data[0];
+
+		if (ISSET(mstatus, UCDC_N_SERIAL_RI))
+			sc->sc_msr |= SER_RI;
+		if (ISSET(mstatus, UCDC_N_SERIAL_DSR))
+			sc->sc_msr |= SER_DSR;
+		if (ISSET(mstatus, UCDC_N_SERIAL_DCD))
+			sc->sc_msr |= SER_DCD;
+		/* Deferred notifying to the ucom layer */
+		taskqueue_enqueue(taskqueue_swi_giant, &sc->sc_task);
+		break;
+	default:
+		DPRINTF(("%s: unknown notify message: %02x\n",
+			 USBDEVNAME(sc->sc_dev),
+			 sc->sc_notify_buf.bNotification));
+		break;
+	}
+}
+
+Static void
+umodem_notify(void *arg, int count)
+{
+	struct umodem_softc *sc;
+
+	sc = (struct umodem_softc *)arg;
+	if (sc->sc_ucom.sc_dying)
+		return;
+	ucom_status_change(&sc->sc_ucom);
+}
+
+void
+umodem_get_caps(usbd_device_handle dev, int *cm, int *acm)
+{
+	usb_cdc_cm_descriptor_t *cmd;
+	usb_cdc_acm_descriptor_t *cad;
+
+	*cm = *acm = 0;
+
+	cmd = umodem_get_desc(dev, UDESC_CS_INTERFACE, UDESCSUB_CDC_CM);
+	if (cmd == NULL) {
+		DPRINTF(("umodem_get_desc: no CM desc\n"));
+		return;
+	}
+	*cm = cmd->bmCapabilities;
+
+	cad = umodem_get_desc(dev, UDESC_CS_INTERFACE, UDESCSUB_CDC_ACM);
+	if (cad == NULL) {
+		DPRINTF(("umodem_get_desc: no ACM desc\n"));
+		return;
+	}
+	*acm = cad->bmCapabilities;
+}
+
+void
+umodem_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
+{
+	struct umodem_softc *sc = addr;
+
+	DPRINTF(("umodem_get_status:\n"));
+
+	if (lsr != NULL)
+		*lsr = sc->sc_lsr;
+	if (msr != NULL)
+		*msr = sc->sc_msr;
+}
+
+int
+umodem_param(void *addr, int portno, struct termios *t)
+{
+	struct umodem_softc *sc = addr;
+	usbd_status err;
+	usb_cdc_line_state_t ls;
+
+	DPRINTF(("umodem_param: sc=%p\n", sc));
+
+	USETDW(ls.dwDTERate, t->c_ospeed);
+	if (ISSET(t->c_cflag, CSTOPB))
+		ls.bCharFormat = UCDC_STOP_BIT_2;
+	else
+		ls.bCharFormat = UCDC_STOP_BIT_1;
+	if (ISSET(t->c_cflag, PARENB)) {
+		if (ISSET(t->c_cflag, PARODD))
+			ls.bParityType = UCDC_PARITY_ODD;
+		else
+			ls.bParityType = UCDC_PARITY_EVEN;
+	} else
+		ls.bParityType = UCDC_PARITY_NONE;
+	switch (ISSET(t->c_cflag, CSIZE)) {
+	case CS5:
+		ls.bDataBits = 5;
+		break;
+	case CS6:
+		ls.bDataBits = 6;
+		break;
+	case CS7:
+		ls.bDataBits = 7;
+		break;
+	case CS8:
+		ls.bDataBits = 8;
+		break;
+	}
+
+	err = umodem_set_line_coding(sc, &ls);
+	if (err) {
+		DPRINTF(("umodem_param: err=%s\n", usbd_errstr(err)));
+		return (ENOTTY);
+	}
+	return (0);
+}
+
+int
+umodem_ioctl(void *addr, int portno, u_long cmd, caddr_t data, int flag,
+	     usb_proc_ptr p)
+{
+	struct umodem_softc *sc = addr;
+	int error = 0;
+
+	if (sc->sc_ucom.sc_dying)
+		return (EIO);
+
+	DPRINTF(("umodemioctl: cmd=0x%08lx\n", cmd));
+
+	switch (cmd) {
+	case USB_GET_CM_OVER_DATA:
+		*(int *)data = sc->sc_cm_over_data;
+		break;
+
+	case USB_SET_CM_OVER_DATA:
+		if (*(int *)data != sc->sc_cm_over_data) {
+			/* XXX change it */
+		}
+		break;
+
+	default:
+		DPRINTF(("umodemioctl: unknown\n"));
+		error = ENOTTY;
+		break;
+	}
+
+	return (error);
+}
+
+void
+umodem_dtr(struct umodem_softc *sc, int onoff)
+{
+	DPRINTF(("umodem_modem: onoff=%d\n", onoff));
+
+	if (sc->sc_dtr == onoff)
+		return;
+	sc->sc_dtr = onoff;
+
+	umodem_set_line_state(sc);
+}
+
+void
+umodem_rts(struct umodem_softc *sc, int onoff)
+{
+	DPRINTF(("umodem_modem: onoff=%d\n", onoff));
+
+	if (sc->sc_rts == onoff)
+		return;
+	sc->sc_rts = onoff;
+
+	umodem_set_line_state(sc);
+}
+
+void
+umodem_set_line_state(struct umodem_softc *sc)
+{
+	usb_device_request_t req;
+	int ls;
+
+	ls = (sc->sc_dtr ? UCDC_LINE_DTR : 0) |
+	     (sc->sc_rts ? UCDC_LINE_RTS : 0);
+	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	req.bRequest = UCDC_SET_CONTROL_LINE_STATE;
+	USETW(req.wValue, ls);
+	USETW(req.wIndex, sc->sc_ctl_iface_no);
+	USETW(req.wLength, 0);
+
+	(void)usbd_do_request(sc->sc_udev, &req, 0);
+
+}
+
+void
+umodem_break(struct umodem_softc *sc, int onoff)
+{
+	usb_device_request_t req;
+
+	DPRINTF(("umodem_break: onoff=%d\n", onoff));
+
+	if (!(sc->sc_acm_cap & USB_CDC_ACM_HAS_BREAK))
+		return;
+
+	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	req.bRequest = UCDC_SEND_BREAK;
+	USETW(req.wValue, onoff ? UCDC_BREAK_ON : UCDC_BREAK_OFF);
+	USETW(req.wIndex, sc->sc_ctl_iface_no);
+	USETW(req.wLength, 0);
+
+	(void)usbd_do_request(sc->sc_udev, &req, 0);
+}
+
+void
+umodem_set(void *addr, int portno, int reg, int onoff)
+{
+	struct umodem_softc *sc = addr;
+
+	switch (reg) {
+	case UCOM_SET_DTR:
+		umodem_dtr(sc, onoff);
+		break;
+	case UCOM_SET_RTS:
+		umodem_rts(sc, onoff);
+		break;
+	case UCOM_SET_BREAK:
+		umodem_break(sc, onoff);
+		break;
+	default:
+		break;
+	}
+}
+
+usbd_status
+umodem_set_line_coding(struct umodem_softc *sc, usb_cdc_line_state_t *state)
+{
+	usb_device_request_t req;
+	usbd_status err;
+
+	DPRINTF(("umodem_set_line_coding: rate=%d fmt=%d parity=%d bits=%d\n",
+		 UGETDW(state->dwDTERate), state->bCharFormat,
+		 state->bParityType, state->bDataBits));
+
+	if (memcmp(state, &sc->sc_line_state, UCDC_LINE_STATE_LENGTH) == 0) {
+		DPRINTF(("umodem_set_line_coding: already set\n"));
+		return (USBD_NORMAL_COMPLETION);
+	}
+
+	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	req.bRequest = UCDC_SET_LINE_CODING;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, sc->sc_ctl_iface_no);
+	USETW(req.wLength, UCDC_LINE_STATE_LENGTH);
+
+	err = usbd_do_request(sc->sc_udev, &req, state);
+	if (err) {
+		DPRINTF(("umodem_set_line_coding: failed, err=%s\n",
+			 usbd_errstr(err)));
+		return (err);
+	}
+
+	sc->sc_line_state = *state;
+
+	return (USBD_NORMAL_COMPLETION);
+}
+
+void *
+umodem_get_desc(usbd_device_handle dev, int type, int subtype)
+{
+	usb_descriptor_t *desc;
+	usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);
+        uByte *p = (uByte *)cd;
+        uByte *end = p + UGETW(cd->wTotalLength);
+
+	while (p < end) {
+		desc = (usb_descriptor_t *)p;
+		if (desc->bDescriptorType == type &&
+		    desc->bDescriptorSubtype == subtype)
+			return (desc);
+		p += desc->bLength;
+	}
+
+	return (0);
+}
+
+usbd_status
+umodem_set_comm_feature(struct umodem_softc *sc, int feature, int state)
+{
+	usb_device_request_t req;
+	usbd_status err;
+	usb_cdc_abstract_state_t ast;
+
+	DPRINTF(("umodem_set_comm_feature: feature=%d state=%d\n", feature,
+		 state));
+
+	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	req.bRequest = UCDC_SET_COMM_FEATURE;
+	USETW(req.wValue, feature);
+	USETW(req.wIndex, sc->sc_ctl_iface_no);
+	USETW(req.wLength, UCDC_ABSTRACT_STATE_LENGTH);
+	USETW(ast.wState, state);
+
+	err = usbd_do_request(sc->sc_udev, &req, &ast);
+	if (err) {
+		DPRINTF(("umodem_set_comm_feature: feature=%d, err=%s\n",
+			 feature, usbd_errstr(err)));
+		return (err);
+	}
+
+	return (USBD_NORMAL_COMPLETION);
+}
+
+USB_DETACH(umodem)
+{
+	USB_DETACH_START(umodem, sc);
+	int rv = 0;
+
+	DPRINTF(("umodem_detach: sc=%p\n", sc));
+
+	if (sc->sc_notify_pipe != NULL) {
+		usbd_abort_pipe(sc->sc_notify_pipe);
+		usbd_close_pipe(sc->sc_notify_pipe);
+		sc->sc_notify_pipe = NULL;
+	}
+
+	sc->sc_ucom.sc_dying = 1;
+	rv = ucom_detach(&sc->sc_ucom);
+
+	return (rv);
+}
diff -rubN /usr/src1/src/sys/dev/usb/ums.c /usr/src/sys/dev/usb/ums.c
--- /usr/src1/src/sys/dev/usb/ums.c	Mon Feb  6 20:29:17 2006
+++ /usr/src/sys/dev/usb/ums.c	Thu Jun  8 21:13:09 2006
@@ -596,10 +596,12 @@
 	sc->status.dx = sc->status.dy = sc->status.dz /* = sc->status.dt */ = 0;
 
 	callout_handle_init((struct callout_handle *)&sc->callout_handle);
-
+#ifndef USBD_CUSTOM_CLEARSTALL
+#define USBD_CUSTOM_CLEARSTALL 0
+#endif
 	/* Set up interrupt pipe. */
 	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr,
-				USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
+				USBD_CUSTOM_CLEARSTALL|USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
 				sc->sc_ibuf, sc->sc_isize, ums_intr,
 				USBD_DEFAULT_INTERVAL);
 	if (err) {
diff -rubN /usr/src1/src/sys/dev/usb/ums.c.orig /usr/src/sys/dev/usb/ums.c.orig
--- /usr/src1/src/sys/dev/usb/ums.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/ums.c.orig	Mon Feb  6 20:29:17 2006
@@ -0,0 +1,870 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/usb/ums.c,v 1.77.2.2 2006/02/06 20:29:17 netchild Exp $");
+
+/*
+ * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/ioccom.h>
+#include <sys/conf.h>
+#include <sys/fcntl.h>
+#include <sys/tty.h>
+#include <sys/file.h>
+#if __FreeBSD_version >= 500014
+#include <sys/selinfo.h>
+#else
+#include <sys/select.h>
+#endif
+#include <sys/poll.h>
+#include <sys/sysctl.h>
+#include <sys/uio.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbhid.h>
+
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include "usbdevs.h"
+#include <dev/usb/usb_quirks.h>
+#include <dev/usb/hid.h>
+
+#if __FreeBSD_version >= 500000
+#include <sys/mouse.h>
+#else
+#include <machine/mouse.h>
+#endif
+
+#ifdef USB_DEBUG
+#define DPRINTF(x)	if (umsdebug) logprintf x
+#define DPRINTFN(n,x)	if (umsdebug>(n)) logprintf x
+int	umsdebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, ums, CTLFLAG_RW, 0, "USB ums");
+SYSCTL_INT(_hw_usb_ums, OID_AUTO, debug, CTLFLAG_RW,
+	   &umsdebug, 0, "ums debug level");
+#else
+#define DPRINTF(x)
+#define DPRINTFN(n,x)
+#endif
+
+#define UMSUNIT(s)	(minor(s)&0x1f)
+
+#define MS_TO_TICKS(ms) ((ms) * hz / 1000)
+
+#define QUEUE_BUFSIZE	400	/* MUST be divisible by 5 _and_ 8 */
+
+struct ums_softc {
+	device_t sc_dev;		/* base device */
+	usbd_interface_handle sc_iface;	/* interface */
+	usbd_pipe_handle sc_intrpipe;	/* interrupt pipe */
+	int sc_ep_addr;
+
+	u_char *sc_ibuf;
+	u_int8_t sc_iid;
+	int sc_isize;
+	struct hid_location sc_loc_x, sc_loc_y, sc_loc_z, sc_loc_t;
+	struct hid_location *sc_loc_btn;
+
+	usb_callout_t callout_handle;	/* for spurious button ups */
+
+	int sc_enabled;
+	int sc_disconnected;	/* device is gone */
+
+	int flags;		/* device configuration */
+#define UMS_Z		0x01	/* z direction available */
+#define UMS_SPUR_BUT_UP	0x02	/* spurious button up events */
+#define UMS_T		0x04	/* aa direction available (tilt) */
+	int nbuttons;
+#define MAX_BUTTONS	31	/* chosen because sc_buttons is int */
+
+	u_char		qbuf[QUEUE_BUFSIZE];	/* must be divisable by 3&4 */
+	u_char		dummy[100];	/* XXX just for safety and for now */
+	int		qcount, qhead, qtail;
+	mousehw_t	hw;
+	mousemode_t	mode;
+	mousestatus_t	status;
+
+	int		state;
+#	  define	UMS_ASLEEP	0x01	/* readFromDevice is waiting */
+#	  define	UMS_SELECT	0x02	/* select is waiting */
+	struct selinfo	rsel;		/* process waiting in select */
+
+	struct cdev *dev;		/* specfs */
+};
+
+#define MOUSE_FLAGS_MASK (HIO_CONST|HIO_RELATIVE)
+#define MOUSE_FLAGS (HIO_RELATIVE)
+
+Static void ums_intr(usbd_xfer_handle xfer,
+			  usbd_private_handle priv, usbd_status status);
+
+Static void ums_add_to_queue(struct ums_softc *sc,
+				int dx, int dy, int dz, int dt, int buttons);
+Static void ums_add_to_queue_timeout(void *priv);
+
+Static int  ums_enable(void *);
+Static void ums_disable(void *);
+
+Static d_open_t  ums_open;
+Static d_close_t ums_close;
+Static d_read_t  ums_read;
+Static d_ioctl_t ums_ioctl;
+Static d_poll_t  ums_poll;
+
+
+Static struct cdevsw ums_cdevsw = {
+	.d_version =	D_VERSION,
+	.d_flags =	D_NEEDGIANT,
+	.d_open =	ums_open,
+	.d_close =	ums_close,
+	.d_read =	ums_read,
+	.d_ioctl =	ums_ioctl,
+	.d_poll =	ums_poll,
+	.d_name =	"ums",
+#if __FreeBSD_version < 500014
+	.d_bmaj		-1
+#endif
+};
+
+USB_DECLARE_DRIVER(ums);
+
+USB_MATCH(ums)
+{
+	USB_MATCH_START(ums, uaa);
+	usb_interface_descriptor_t *id;
+	int size, ret;
+	void *desc;
+	usbd_status err;
+
+	if (!uaa->iface)
+		return (UMATCH_NONE);
+	id = usbd_get_interface_descriptor(uaa->iface);
+	if (!id || id->bInterfaceClass != UICLASS_HID)
+		return (UMATCH_NONE);
+
+	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_TEMP);
+	if (err)
+		return (UMATCH_NONE);
+
+	if (hid_is_collection(desc, size,
+			      HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
+		ret = UMATCH_IFACECLASS;
+	else
+		ret = UMATCH_NONE;
+
+	free(desc, M_TEMP);
+	return (ret);
+}
+
+USB_ATTACH(ums)
+{
+	USB_ATTACH_START(ums, sc, uaa);
+	usbd_interface_handle iface = uaa->iface;
+	usb_interface_descriptor_t *id;
+	usb_endpoint_descriptor_t *ed;
+	int size;
+	void *desc;
+	usbd_status err;
+	char devinfo[1024];
+	u_int32_t flags;
+	int i;
+	struct hid_location loc_btn;
+
+	sc->sc_disconnected = 1;
+	sc->sc_iface = iface;
+	id = usbd_get_interface_descriptor(iface);
+	usbd_devinfo(uaa->device, USBD_SHOW_INTERFACE_CLASS, devinfo);
+	USB_ATTACH_SETUP;
+	ed = usbd_interface2endpoint_descriptor(iface, 0);
+	if (!ed) {
+		printf("%s: could not read endpoint descriptor\n",
+		       USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	DPRINTFN(10,("ums_attach: bLength=%d bDescriptorType=%d "
+		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
+		     " bInterval=%d\n",
+		     ed->bLength, ed->bDescriptorType,
+		     UE_GET_ADDR(ed->bEndpointAddress),
+		     UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN ? "in":"out",
+		     UE_GET_XFERTYPE(ed->bmAttributes),
+		     UGETW(ed->wMaxPacketSize), ed->bInterval));
+
+	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
+	    UE_GET_XFERTYPE(ed->bmAttributes) != UE_INTERRUPT) {
+		printf("%s: unexpected endpoint\n",
+		       USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_TEMP);
+	if (err)
+		USB_ATTACH_ERROR_RETURN;
+
+	if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_X),
+		       hid_input, &sc->sc_loc_x, &flags)) {
+		printf("%s: mouse has no X report\n", USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+	if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
+		printf("%s: X report 0x%04x not supported\n",
+		       USBDEVNAME(sc->sc_dev), flags);
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Y),
+		       hid_input, &sc->sc_loc_y, &flags)) {
+		printf("%s: mouse has no Y report\n", USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+	if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
+		printf("%s: Y report 0x%04x not supported\n",
+		       USBDEVNAME(sc->sc_dev), flags);
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	/* try to guess the Z activator: first check Z, then WHEEL */
+	if (hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Z),
+		       hid_input, &sc->sc_loc_z, &flags) ||
+	    hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_WHEEL),
+		       hid_input, &sc->sc_loc_z, &flags) ||
+	    hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_TWHEEL),
+		       hid_input, &sc->sc_loc_z, &flags)) {
+		if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
+			sc->sc_loc_z.size = 0;	/* Bad Z coord, ignore it */
+		} else {
+			sc->flags |= UMS_Z;
+		}
+	}
+
+	/* The Microsoft Wireless Intellimouse 2.0 reports it's wheel
+	 * using 0x0048 (i've called it HUG_TWHEEL) and seems to expect
+	 * you to know that the byte after the wheel is the tilt axis.
+	 * There are no other HID axis descriptors other than X,Y and 
+	 * TWHEEL */
+	if (hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_TWHEEL),
+			hid_input, &sc->sc_loc_t, &flags)) {
+			sc->sc_loc_t.pos = sc->sc_loc_t.pos + 8;
+			sc->flags |= UMS_T;
+	}
+
+	/* figure out the number of buttons */
+	for (i = 1; i <= MAX_BUTTONS; i++)
+		if (!hid_locate(desc, size, HID_USAGE2(HUP_BUTTON, i),
+				hid_input, &loc_btn, 0))
+			break;
+	sc->nbuttons = i - 1;
+	sc->sc_loc_btn = malloc(sizeof(struct hid_location)*sc->nbuttons,
+				M_USBDEV, M_NOWAIT);
+	if (!sc->sc_loc_btn) {
+		printf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	printf("%s: %d buttons%s%s.\n", USBDEVNAME(sc->sc_dev),
+	       sc->nbuttons, sc->flags & UMS_Z? " and Z dir" : "", 
+	       sc->flags & UMS_T?" and a TILT dir": "");
+
+	for (i = 1; i <= sc->nbuttons; i++)
+		hid_locate(desc, size, HID_USAGE2(HUP_BUTTON, i),
+				hid_input, &sc->sc_loc_btn[i-1], 0);
+
+	sc->sc_isize = hid_report_size(desc, size, hid_input, &sc->sc_iid);
+	sc->sc_ibuf = malloc(sc->sc_isize, M_USB, M_NOWAIT);
+	if (!sc->sc_ibuf) {
+		printf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
+		free(sc->sc_loc_btn, M_USB);
+		USB_ATTACH_ERROR_RETURN;
+	}
+
+	sc->sc_ep_addr = ed->bEndpointAddress;
+	sc->sc_disconnected = 0;
+	free(desc, M_TEMP);
+
+#ifdef USB_DEBUG
+	DPRINTF(("ums_attach: sc=%p\n", sc));
+	DPRINTF(("ums_attach: X\t%d/%d\n",
+		 sc->sc_loc_x.pos, sc->sc_loc_x.size));
+	DPRINTF(("ums_attach: Y\t%d/%d\n",
+		 sc->sc_loc_y.pos, sc->sc_loc_y.size));
+	if (sc->flags & UMS_Z)
+		DPRINTF(("ums_attach: Z\t%d/%d\n",
+			 sc->sc_loc_z.pos, sc->sc_loc_z.size));
+	for (i = 1; i <= sc->nbuttons; i++) {
+		DPRINTF(("ums_attach: B%d\t%d/%d\n",
+			 i, sc->sc_loc_btn[i-1].pos,sc->sc_loc_btn[i-1].size));
+	}
+	DPRINTF(("ums_attach: size=%d, id=%d\n", sc->sc_isize, sc->sc_iid));
+#endif
+
+	if (sc->nbuttons > MOUSE_MSC_MAXBUTTON)
+		sc->hw.buttons = MOUSE_MSC_MAXBUTTON;
+	else
+		sc->hw.buttons = sc->nbuttons;
+	sc->hw.iftype = MOUSE_IF_USB;
+	sc->hw.type = MOUSE_MOUSE;
+	sc->hw.model = MOUSE_MODEL_GENERIC;
+	sc->hw.hwid = 0;
+	sc->mode.protocol = MOUSE_PROTO_MSC;
+	sc->mode.rate = -1;
+	sc->mode.resolution = MOUSE_RES_UNKNOWN;
+	sc->mode.accelfactor = 0;
+	sc->mode.level = 0;
+	sc->mode.packetsize = MOUSE_MSC_PACKETSIZE;
+	sc->mode.syncmask[0] = MOUSE_MSC_SYNCMASK;
+	sc->mode.syncmask[1] = MOUSE_MSC_SYNC;
+
+	sc->status.flags = 0;
+	sc->status.button = sc->status.obutton = 0;
+	sc->status.dx = sc->status.dy = sc->status.dz = 0;
+
+#ifndef __FreeBSD__
+	sc->rsel.si_flags = 0;
+	sc->rsel.si_pid = 0;
+#endif
+
+	sc->dev = make_dev(&ums_cdevsw, device_get_unit(self),
+			UID_ROOT, GID_OPERATOR,
+			0644, "ums%d", device_get_unit(self));
+
+	usb_callout_init(sc->callout_handle);
+	if (usbd_get_quirks(uaa->device)->uq_flags & UQ_SPUR_BUT_UP) {
+		DPRINTF(("%s: Spurious button up events\n",
+			USBDEVNAME(sc->sc_dev)));
+		sc->flags |= UMS_SPUR_BUT_UP;
+	}
+
+	USB_ATTACH_SUCCESS_RETURN;
+}
+
+
+Static int
+ums_detach(device_t self)
+{
+	struct ums_softc *sc = device_get_softc(self);
+
+	if (sc->sc_enabled)
+		ums_disable(sc);
+
+	DPRINTF(("%s: disconnected\n", USBDEVNAME(self)));
+
+	free(sc->sc_loc_btn, M_USB);
+	free(sc->sc_ibuf, M_USB);
+
+	/* someone waiting for data */
+	/*
+	 * XXX If we wakeup the process here, the device will be gone by
+	 * the time the process gets a chance to notice. *_close and friends
+	 * should be fixed to handle this case.
+	 * Or we should do a delayed detach for this.
+	 * Does this delay now force tsleep to exit with an error?
+	 */
+	if (sc->state & UMS_ASLEEP) {
+		sc->state &= ~UMS_ASLEEP;
+		wakeup(sc);
+	}
+	if (sc->state & UMS_SELECT) {
+		sc->state &= ~UMS_SELECT;
+		selwakeuppri(&sc->rsel, PZERO);
+	}
+
+	destroy_dev(sc->dev);
+
+	return 0;
+}
+
+void
+ums_intr(xfer, addr, status)
+	usbd_xfer_handle xfer;
+	usbd_private_handle addr;
+	usbd_status status;
+{
+	struct ums_softc *sc = addr;
+	u_char *ibuf;
+	int dx, dy, dz, dt;
+	int buttons = 0;
+	int i;
+
+#define UMS_BUT(i) ((i) < 3 ? (((i) + 2) % 3) : (i))
+
+	DPRINTFN(5, ("ums_intr: sc=%p status=%d\n", sc, status));
+	DPRINTFN(5, ("ums_intr: data = %02x %02x %02x %02x %02x %02x\n",
+		     sc->sc_ibuf[0], sc->sc_ibuf[1], sc->sc_ibuf[2],
+		     sc->sc_ibuf[3], sc->sc_ibuf[4], sc->sc_ibuf[5]));
+
+	if (status == USBD_CANCELLED)
+		return;
+
+	if (status != USBD_NORMAL_COMPLETION) {
+		DPRINTF(("ums_intr: status=%d\n", status));
+		if (status == USBD_STALLED)
+		    usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
+		if(status != USBD_IOERROR)
+			return;
+	}
+
+	ibuf = sc->sc_ibuf;
+	/*
+	 * The M$ Wireless Intellimouse 2.0 sends 1 extra leading byte of
+	 * data compared to most USB mice. This byte frequently switches
+	 * from 0x01 (usual state) to 0x02. I assume it is to allow
+	 * extra, non-standard, reporting (say battery-life). However
+	 * at the same time it generates a left-click message on the button
+	 * byte which causes spurious left-click's where there shouldn't be.
+	 * This should sort that.
+	 * Currently it's the only user of UMS_T so use it as an identifier.
+	 * We probably should switch to some more official quirk.
+	 */
+	if (sc->flags & UMS_T) {
+		if (sc->sc_iid) {
+			if (*ibuf++ == 0x02)
+				return;
+		}
+	} else {
+		if (sc->sc_iid) {
+			if (*ibuf++ != sc->sc_iid)
+				return;
+		}
+	}
+
+	dx =  hid_get_data(ibuf, &sc->sc_loc_x);
+	dy = -hid_get_data(ibuf, &sc->sc_loc_y);
+	dz = -hid_get_data(ibuf, &sc->sc_loc_z);
+	if (sc->flags & UMS_T)
+		dt = -hid_get_data(ibuf, &sc->sc_loc_t);
+	else
+		dt = 0;
+	for (i = 0; i < sc->nbuttons; i++)
+		if (hid_get_data(ibuf, &sc->sc_loc_btn[i]))
+			buttons |= (1 << UMS_BUT(i));
+
+	if (dx || dy || dz || dt || (sc->flags & UMS_Z)
+	    || buttons != sc->status.button) {
+		DPRINTFN(5, ("ums_intr: x:%d y:%d z:%d t:%d buttons:0x%x\n",
+			dx, dy, dz, dt, buttons));
+
+		sc->status.button = buttons;
+		sc->status.dx += dx;
+		sc->status.dy += dy;
+		sc->status.dz += dz;
+		/* sc->status.dt += dt;*/ /* no way to export this yet */
+		
+		/* Discard data in case of full buffer */
+		if (sc->qcount == sizeof(sc->qbuf)) {
+			DPRINTF(("Buffer full, discarded packet"));
+			return;
+		}
+
+		/*
+		 * The Qtronix keyboard has a built in PS/2 port for a mouse.
+		 * The firmware once in a while posts a spurious button up
+		 * event. This event we ignore by doing a timeout for 50 msecs.
+		 * If we receive dx=dy=dz=buttons=0 before we add the event to
+		 * the queue.
+		 * In any other case we delete the timeout event.
+		 */
+		if (sc->flags & UMS_SPUR_BUT_UP &&
+		    dx == 0 && dy == 0 && dz == 0 && dt == 0 && buttons == 0) {
+			usb_callout(sc->callout_handle, MS_TO_TICKS(50 /*msecs*/),
+				    ums_add_to_queue_timeout, (void *) sc);
+		} else {
+			usb_uncallout(sc->callout_handle,
+				      ums_add_to_queue_timeout, (void *) sc);
+			ums_add_to_queue(sc, dx, dy, dz, dt, buttons);
+		}
+	}
+}
+
+Static void
+ums_add_to_queue_timeout(void *priv)
+{
+	struct ums_softc *sc = priv;
+	int s;
+
+	s = splusb();
+	ums_add_to_queue(sc, 0, 0, 0, 0, 0);
+	splx(s);
+}
+
+Static void
+ums_add_to_queue(struct ums_softc *sc, int dx, int dy, int dz, int dt, int buttons)
+{
+	/* Discard data in case of full buffer */
+	if (sc->qhead+sc->mode.packetsize > sizeof(sc->qbuf)) {
+		DPRINTF(("Buffer full, discarded packet"));
+		return;
+	}
+
+	if (dx >  254)		dx =  254;
+	if (dx < -256)		dx = -256;
+	if (dy >  254)		dy =  254;
+	if (dy < -256)		dy = -256;
+	if (dz >  126)		dz =  126;
+	if (dz < -128)		dz = -128;
+	if (dt >  126)		dt =  126;
+        if (dt < -128)		dt = -128;
+
+	sc->qbuf[sc->qhead] = sc->mode.syncmask[1];
+	sc->qbuf[sc->qhead] |= ~buttons & MOUSE_MSC_BUTTONS;
+	sc->qbuf[sc->qhead+1] = dx >> 1;
+	sc->qbuf[sc->qhead+2] = dy >> 1;
+	sc->qbuf[sc->qhead+3] = dx - (dx >> 1);
+	sc->qbuf[sc->qhead+4] = dy - (dy >> 1);
+
+	if (sc->mode.level == 1) {
+		sc->qbuf[sc->qhead+5] = dz >> 1;
+		sc->qbuf[sc->qhead+6] = dz - (dz >> 1);
+		sc->qbuf[sc->qhead+7] = ((~buttons >> 3)
+					 & MOUSE_SYS_EXTBUTTONS);
+	}
+
+	sc->qhead += sc->mode.packetsize;
+	sc->qcount += sc->mode.packetsize;
+	/* wrap round at end of buffer */
+	if (sc->qhead >= sizeof(sc->qbuf))
+		sc->qhead = 0;
+
+	/* someone waiting for data */
+	if (sc->state & UMS_ASLEEP) {
+		sc->state &= ~UMS_ASLEEP;
+		wakeup(sc);
+	}
+	if (sc->state & UMS_SELECT) {
+		sc->state &= ~UMS_SELECT;
+		selwakeuppri(&sc->rsel, PZERO);
+	}
+}
+Static int
+ums_enable(v)
+	void *v;
+{
+	struct ums_softc *sc = v;
+
+	usbd_status err;
+
+	if (sc->sc_enabled)
+		return EBUSY;
+
+	sc->sc_enabled = 1;
+	sc->qcount = 0;
+	sc->qhead = sc->qtail = 0;
+	sc->status.flags = 0;
+	sc->status.button = sc->status.obutton = 0;
+	sc->status.dx = sc->status.dy = sc->status.dz /* = sc->status.dt */ = 0;
+
+	callout_handle_init((struct callout_handle *)&sc->callout_handle);
+
+	/* Set up interrupt pipe. */
+	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr,
+				USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
+				sc->sc_ibuf, sc->sc_isize, ums_intr,
+				USBD_DEFAULT_INTERVAL);
+	if (err) {
+		DPRINTF(("ums_enable: usbd_open_pipe_intr failed, error=%d\n",
+			 err));
+		sc->sc_enabled = 0;
+		return (EIO);
+	}
+	return (0);
+}
+
+Static void
+ums_disable(priv)
+	void *priv;
+{
+	struct ums_softc *sc = priv;
+
+	usb_uncallout(sc->callout_handle, ums_add_to_queue_timeout, sc);
+
+	/* Disable interrupts. */
+	usbd_abort_pipe(sc->sc_intrpipe);
+	usbd_close_pipe(sc->sc_intrpipe);
+
+	sc->sc_enabled = 0;
+
+	if (sc->qcount != 0)
+		DPRINTF(("Discarded %d bytes in queue\n", sc->qcount));
+}
+
+Static int
+ums_open(struct cdev *dev, int flag, int fmt, usb_proc_ptr p)
+{
+	struct ums_softc *sc;
+
+	USB_GET_SC_OPEN(ums, UMSUNIT(dev), sc);
+
+	return ums_enable(sc);
+}
+
+Static int
+ums_close(struct cdev *dev, int flag, int fmt, usb_proc_ptr p)
+{
+	struct ums_softc *sc;
+
+	USB_GET_SC(ums, UMSUNIT(dev), sc);
+
+	if (!sc)
+		return 0;
+
+	if (sc->sc_enabled)
+		ums_disable(sc);
+
+	return 0;
+}
+
+Static int
+ums_read(struct cdev *dev, struct uio *uio, int flag)
+{
+	struct ums_softc *sc;
+	int s;
+	char buf[sizeof(sc->qbuf)];
+	int l = 0;
+	int error;
+
+	USB_GET_SC(ums, UMSUNIT(dev), sc);
+
+	s = splusb();
+	if (!sc) {
+		splx(s);
+		return EIO;
+	}
+
+	while (sc->qcount == 0 )  {
+		if (flag & O_NONBLOCK) {		/* non-blocking I/O */
+			splx(s);
+			return EWOULDBLOCK;
+		}
+
+		sc->state |= UMS_ASLEEP;	/* blocking I/O */
+		error = tsleep(sc, PZERO | PCATCH, "umsrea", 0);
+		if (error) {
+			splx(s);
+			return error;
+		} else if (!sc->sc_enabled) {
+			splx(s);
+			return EINTR;
+		}
+		/* check whether the device is still there */
+
+		sc = devclass_get_softc(ums_devclass, UMSUNIT(dev));
+		if (!sc) {
+			splx(s);
+			return EIO;
+		}
+	}
+
+	/*
+	 * XXX we could optimise the use of splx/splusb somewhat. The writer
+	 * process only extends qcount and qtail. We could copy them and use the copies
+	 * to do the copying out of the queue.
+	 */
+
+	while ((sc->qcount > 0) && (uio->uio_resid > 0)) {
+		l = (sc->qcount < uio->uio_resid? sc->qcount:uio->uio_resid);
+		if (l > sizeof(buf))
+			l = sizeof(buf);
+		if (l > sizeof(sc->qbuf) - sc->qtail)		/* transfer till end of buf */
+			l = sizeof(sc->qbuf) - sc->qtail;
+
+		splx(s);
+		uiomove(&sc->qbuf[sc->qtail], l, uio);
+		s = splusb();
+
+		if ( sc->qcount - l < 0 ) {
+			DPRINTF(("qcount below 0, count=%d l=%d\n", sc->qcount, l));
+			sc->qcount = l;
+		}
+		sc->qcount -= l;	/* remove the bytes from the buffer */
+		sc->qtail = (sc->qtail + l) % sizeof(sc->qbuf);
+	}
+	splx(s);
+
+	return 0;
+}
+
+Static int
+ums_poll(struct cdev *dev, int events, usb_proc_ptr p)
+{
+	struct ums_softc *sc;
+	int revents = 0;
+	int s;
+
+	USB_GET_SC(ums, UMSUNIT(dev), sc);
+
+	if (!sc)
+		return 0;
+
+	s = splusb();
+	if (events & (POLLIN | POLLRDNORM)) {
+		if (sc->qcount) {
+			revents = events & (POLLIN | POLLRDNORM);
+		} else {
+			sc->state |= UMS_SELECT;
+			selrecord(p, &sc->rsel);
+		}
+	}
+	splx(s);
+
+	return revents;
+}
+
+int
+ums_ioctl(struct cdev *dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
+{
+	struct ums_softc *sc;
+	int error = 0;
+	int s;
+	mousemode_t mode;
+
+	USB_GET_SC(ums, UMSUNIT(dev), sc);
+
+	if (!sc)
+		return EIO;
+
+	switch(cmd) {
+	case MOUSE_GETHWINFO:
+		*(mousehw_t *)addr = sc->hw;
+		break;
+	case MOUSE_GETMODE:
+		*(mousemode_t *)addr = sc->mode;
+		break;
+	case MOUSE_SETMODE:
+		mode = *(mousemode_t *)addr;
+
+		if (mode.level == -1)
+			/* don't change the current setting */
+			;
+		else if ((mode.level < 0) || (mode.level > 1))
+			return (EINVAL);
+
+		s = splusb();
+		sc->mode.level = mode.level;
+
+		if (sc->mode.level == 0) {
+			if (sc->nbuttons > MOUSE_MSC_MAXBUTTON)
+				sc->hw.buttons = MOUSE_MSC_MAXBUTTON;
+			else
+				sc->hw.buttons = sc->nbuttons;
+			sc->mode.protocol = MOUSE_PROTO_MSC;
+			sc->mode.packetsize = MOUSE_MSC_PACKETSIZE;
+			sc->mode.syncmask[0] = MOUSE_MSC_SYNCMASK;
+			sc->mode.syncmask[1] = MOUSE_MSC_SYNC;
+		} else if (sc->mode.level == 1) {
+			if (sc->nbuttons > MOUSE_SYS_MAXBUTTON)
+				sc->hw.buttons = MOUSE_SYS_MAXBUTTON;
+			else
+				sc->hw.buttons = sc->nbuttons;
+			sc->mode.protocol = MOUSE_PROTO_SYSMOUSE;
+			sc->mode.packetsize = MOUSE_SYS_PACKETSIZE;
+			sc->mode.syncmask[0] = MOUSE_SYS_SYNCMASK;
+			sc->mode.syncmask[1] = MOUSE_SYS_SYNC;
+		}
+
+		bzero(sc->qbuf, sizeof(sc->qbuf));
+		sc->qhead = sc->qtail = sc->qcount = 0;
+		splx(s);
+
+		break;
+	case MOUSE_GETLEVEL:
+		*(int *)addr = sc->mode.level;
+		break;
+	case MOUSE_SETLEVEL:
+		if (*(int *)addr < 0 || *(int *)addr > 1)
+			return (EINVAL);
+
+		s = splusb();
+		sc->mode.level = *(int *)addr;
+
+		if (sc->mode.level == 0) {
+			if (sc->nbuttons > MOUSE_MSC_MAXBUTTON)
+				sc->hw.buttons = MOUSE_MSC_MAXBUTTON;
+			else
+				sc->hw.buttons = sc->nbuttons;
+			sc->mode.protocol = MOUSE_PROTO_MSC;
+			sc->mode.packetsize = MOUSE_MSC_PACKETSIZE;
+			sc->mode.syncmask[0] = MOUSE_MSC_SYNCMASK;
+			sc->mode.syncmask[1] = MOUSE_MSC_SYNC;
+		} else if (sc->mode.level == 1) {
+			if (sc->nbuttons > MOUSE_SYS_MAXBUTTON)
+				sc->hw.buttons = MOUSE_SYS_MAXBUTTON;
+			else
+				sc->hw.buttons = sc->nbuttons;
+			sc->mode.protocol = MOUSE_PROTO_SYSMOUSE;
+			sc->mode.packetsize = MOUSE_SYS_PACKETSIZE;
+			sc->mode.syncmask[0] = MOUSE_SYS_SYNCMASK;
+			sc->mode.syncmask[1] = MOUSE_SYS_SYNC;
+		}
+
+		bzero(sc->qbuf, sizeof(sc->qbuf));
+		sc->qhead = sc->qtail = sc->qcount = 0;
+		splx(s);
+
+		break;
+	case MOUSE_GETSTATUS: {
+		mousestatus_t *status = (mousestatus_t *) addr;
+
+		s = splusb();
+		*status = sc->status;
+		sc->status.obutton = sc->status.button;
+		sc->status.button = 0;
+		sc->status.dx = sc->status.dy
+		    = sc->status.dz = /* sc->status.dt = */ 0;
+		splx(s);
+
+		if (status->dx || status->dy || status->dz /* || status->dt */)
+			status->flags |= MOUSE_POSCHANGED;
+		if (status->button != status->obutton)
+			status->flags |= MOUSE_BUTTONSCHANGED;
+		break;
+		}
+	default:
+		error = ENOTTY;
+	}
+
+	return error;
+}
+
+DRIVER_MODULE(ums, uhub, ums_driver, ums_devclass, usbd_driver_load, 0);
diff -rubN /usr/src1/src/sys/dev/usb/usb.h /usr/src/sys/dev/usb/usb.h
--- /usr/src1/src/sys/dev/usb/usb.h	Fri Jan 20 22:47:49 2006
+++ /usr/src/sys/dev/usb/usb.h	Thu Jun  8 21:13:08 2006
@@ -1,695 +1 @@
-/*	$NetBSD: usb.h,v 1.69 2002/09/22 23:20:50 augustss Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usb.h,v 1.39.2.1 2006/01/20 22:47:49 mux Exp $    */
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _USB_H_
-#define _USB_H_
-
-#include <sys/types.h>
-#include <sys/time.h>
-
-#if defined(__NetBSD__) || defined(__OpenBSD__)
-#include <sys/ioctl.h>
-#endif
-
-#if defined(_KERNEL)
-#include <dev/usb/usb_port.h>
-#endif /* _KERNEL */
-
-/* These two defines are used by usbd to autoload the usb kld */
-#define USB_KLD		"usb"		/* name of usb module */
-#define USB_UHUB	"usb/uhub"	/* root hub */
-
-#define USB_STACK_VERSION 2
-
-#define USB_MAX_DEVICES 128
-#define USB_START_ADDR 0
-
-#define USB_CONTROL_ENDPOINT 0
-#define USB_MAX_ENDPOINTS 16
-
-#define USB_FRAMES_PER_SECOND 1000
-
-/*
- * The USB records contain some unaligned little-endian word
- * components.  The U[SG]ETW macros take care of both the alignment
- * and endian problem and should always be used to access non-byte
- * values.
- */
-typedef u_int8_t uByte;
-typedef u_int8_t uWord[2];
-typedef u_int8_t uDWord[4];
-
-#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))
-
-#if 1
-#define UGETW(w) ((w)[0] | ((w)[1] << 8))
-#define USETW(w,v) ((w)[0] = (u_int8_t)(v), (w)[1] = (u_int8_t)((v) >> 8))
-#define UGETDW(w) ((w)[0] | ((w)[1] << 8) | ((w)[2] << 16) | ((w)[3] << 24))
-#define USETDW(w,v) ((w)[0] = (u_int8_t)(v), \
-		     (w)[1] = (u_int8_t)((v) >> 8), \
-		     (w)[2] = (u_int8_t)((v) >> 16), \
-		     (w)[3] = (u_int8_t)((v) >> 24))
-#else
-/*
- * On little-endian machines that can handle unanliged accesses
- * (e.g. i386) these macros can be replaced by the following.
- */
-#define UGETW(w) (*(u_int16_t *)(w))
-#define USETW(w,v) (*(u_int16_t *)(w) = (v))
-#define UGETDW(w) (*(u_int32_t *)(w))
-#define USETDW(w,v) (*(u_int32_t *)(w) = (v))
-#endif
-
-#if defined(__FreeBSD__) && (__FreeBSD_version <= 500014)
-#define UPACKED __attribute__ ((packed))
-#else
-#define UPACKED __packed
-#endif
-
-typedef struct {
-	uByte		bmRequestType;
-	uByte		bRequest;
-	uWord		wValue;
-	uWord		wIndex;
-	uWord		wLength;
-} UPACKED usb_device_request_t;
-
-#define UT_WRITE		0x00
-#define UT_READ			0x80
-#define UT_STANDARD		0x00
-#define UT_CLASS		0x20
-#define UT_VENDOR		0x40
-#define UT_DEVICE		0x00
-#define UT_INTERFACE		0x01
-#define UT_ENDPOINT		0x02
-#define UT_OTHER		0x03
-
-#define UT_READ_DEVICE		(UT_READ  | UT_STANDARD | UT_DEVICE)
-#define UT_READ_INTERFACE	(UT_READ  | UT_STANDARD | UT_INTERFACE)
-#define UT_READ_ENDPOINT	(UT_READ  | UT_STANDARD | UT_ENDPOINT)
-#define UT_WRITE_DEVICE		(UT_WRITE | UT_STANDARD | UT_DEVICE)
-#define UT_WRITE_INTERFACE	(UT_WRITE | UT_STANDARD | UT_INTERFACE)
-#define UT_WRITE_ENDPOINT	(UT_WRITE | UT_STANDARD | UT_ENDPOINT)
-#define UT_READ_CLASS_DEVICE	(UT_READ  | UT_CLASS | UT_DEVICE)
-#define UT_READ_CLASS_INTERFACE	(UT_READ  | UT_CLASS | UT_INTERFACE)
-#define UT_READ_CLASS_OTHER	(UT_READ  | UT_CLASS | UT_OTHER)
-#define UT_READ_CLASS_ENDPOINT	(UT_READ  | UT_CLASS | UT_ENDPOINT)
-#define UT_WRITE_CLASS_DEVICE	(UT_WRITE | UT_CLASS | UT_DEVICE)
-#define UT_WRITE_CLASS_INTERFACE (UT_WRITE | UT_CLASS | UT_INTERFACE)
-#define UT_WRITE_CLASS_OTHER	(UT_WRITE | UT_CLASS | UT_OTHER)
-#define UT_WRITE_CLASS_ENDPOINT	(UT_WRITE | UT_CLASS | UT_ENDPOINT)
-#define UT_READ_VENDOR_DEVICE	(UT_READ  | UT_VENDOR | UT_DEVICE)
-#define UT_READ_VENDOR_INTERFACE (UT_READ  | UT_VENDOR | UT_INTERFACE)
-#define UT_READ_VENDOR_OTHER	(UT_READ  | UT_VENDOR | UT_OTHER)
-#define UT_READ_VENDOR_ENDPOINT	(UT_READ  | UT_VENDOR | UT_ENDPOINT)
-#define UT_WRITE_VENDOR_DEVICE	(UT_WRITE | UT_VENDOR | UT_DEVICE)
-#define UT_WRITE_VENDOR_INTERFACE (UT_WRITE | UT_VENDOR | UT_INTERFACE)
-#define UT_WRITE_VENDOR_OTHER	(UT_WRITE | UT_VENDOR | UT_OTHER)
-#define UT_WRITE_VENDOR_ENDPOINT (UT_WRITE | UT_VENDOR | UT_ENDPOINT)
-
-/* Requests */
-#define UR_GET_STATUS		0x00
-#define UR_CLEAR_FEATURE	0x01
-#define UR_SET_FEATURE		0x03
-#define UR_SET_ADDRESS		0x05
-#define UR_GET_DESCRIPTOR	0x06
-#define  UDESC_DEVICE		0x01
-#define  UDESC_CONFIG		0x02
-#define  UDESC_STRING		0x03
-#define  UDESC_INTERFACE	0x04
-#define  UDESC_ENDPOINT		0x05
-#define  UDESC_DEVICE_QUALIFIER	0x06
-#define  UDESC_OTHER_SPEED_CONFIGURATION 0x07
-#define  UDESC_INTERFACE_POWER	0x08
-#define  UDESC_OTG		0x09
-#define  UDESC_CS_DEVICE	0x21	/* class specific */
-#define  UDESC_CS_CONFIG	0x22
-#define  UDESC_CS_STRING	0x23
-#define  UDESC_CS_INTERFACE	0x24
-#define  UDESC_CS_ENDPOINT	0x25
-#define  UDESC_HUB		0x29
-#define UR_SET_DESCRIPTOR	0x07
-#define UR_GET_CONFIG		0x08
-#define UR_SET_CONFIG		0x09
-#define UR_GET_INTERFACE	0x0a
-#define UR_SET_INTERFACE	0x0b
-#define UR_SYNCH_FRAME		0x0c
-
-/* Feature numbers */
-#define UF_ENDPOINT_HALT	0
-#define UF_DEVICE_REMOTE_WAKEUP	1
-#define UF_TEST_MODE		2
-
-#define USB_MAX_IPACKET		8 /* maximum size of the initial packet */
-
-#define USB_2_MAX_CTRL_PACKET	64
-#define USB_2_MAX_BULK_PACKET	512
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uByte		bDescriptorSubtype;
-} UPACKED usb_descriptor_t;
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uWord		bcdUSB;
-#define UD_USB_2_0		0x0200
-#define UD_IS_USB2(d) (UGETW((d)->bcdUSB) >= UD_USB_2_0)
-	uByte		bDeviceClass;
-	uByte		bDeviceSubClass;
-	uByte		bDeviceProtocol;
-	uByte		bMaxPacketSize;
-	/* The fields below are not part of the initial descriptor. */
-	uWord		idVendor;
-	uWord		idProduct;
-	uWord		bcdDevice;
-	uByte		iManufacturer;
-	uByte		iProduct;
-	uByte		iSerialNumber;
-	uByte		bNumConfigurations;
-} UPACKED usb_device_descriptor_t;
-#define USB_DEVICE_DESCRIPTOR_SIZE 18
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uWord		wTotalLength;
-	uByte		bNumInterface;
-	uByte		bConfigurationValue;
-	uByte		iConfiguration;
-	uByte		bmAttributes;
-#define UC_BUS_POWERED		0x80
-#define UC_SELF_POWERED		0x40
-#define UC_REMOTE_WAKEUP	0x20
-	uByte		bMaxPower; /* max current in 2 mA units */
-#define UC_POWER_FACTOR 2
-} UPACKED usb_config_descriptor_t;
-#define USB_CONFIG_DESCRIPTOR_SIZE 9
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uByte		bInterfaceNumber;
-	uByte		bAlternateSetting;
-	uByte		bNumEndpoints;
-	uByte		bInterfaceClass;
-	uByte		bInterfaceSubClass;
-	uByte		bInterfaceProtocol;
-	uByte		iInterface;
-} UPACKED usb_interface_descriptor_t;
-#define USB_INTERFACE_DESCRIPTOR_SIZE 9
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uByte		bEndpointAddress;
-#define UE_GET_DIR(a)	((a) & 0x80)
-#define UE_SET_DIR(a,d)	((a) | (((d)&1) << 7))
-#define UE_DIR_IN	0x80
-#define UE_DIR_OUT	0x00
-#define UE_ADDR		0x0f
-#define UE_GET_ADDR(a)	((a) & UE_ADDR)
-	uByte		bmAttributes;
-#define UE_XFERTYPE	0x03
-#define  UE_CONTROL	0x00
-#define  UE_ISOCHRONOUS	0x01
-#define  UE_BULK	0x02
-#define  UE_INTERRUPT	0x03
-#define UE_GET_XFERTYPE(a)	((a) & UE_XFERTYPE)
-#define UE_ISO_TYPE	0x0c
-#define  UE_ISO_ASYNC	0x04
-#define  UE_ISO_ADAPT	0x08
-#define  UE_ISO_SYNC	0x0c
-#define UE_GET_ISO_TYPE(a)	((a) & UE_ISO_TYPE)
-	uWord		wMaxPacketSize;
-	uByte		bInterval;
-} UPACKED usb_endpoint_descriptor_t;
-#define USB_ENDPOINT_DESCRIPTOR_SIZE 7
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uWord		bString[127];
-} UPACKED usb_string_descriptor_t;
-#define USB_MAX_STRING_LEN 128
-#define USB_LANGUAGE_TABLE 0	/* # of the string language id table */
-
-/* Hub specific request */
-#define UR_GET_BUS_STATE	0x02
-#define UR_CLEAR_TT_BUFFER	0x08
-#define UR_RESET_TT		0x09
-#define UR_GET_TT_STATE		0x0a
-#define UR_STOP_TT		0x0b
-
-/* Hub features */
-#define UHF_C_HUB_LOCAL_POWER	0
-#define UHF_C_HUB_OVER_CURRENT	1
-#define UHF_PORT_CONNECTION	0
-#define UHF_PORT_ENABLE		1
-#define UHF_PORT_SUSPEND	2
-#define UHF_PORT_OVER_CURRENT	3
-#define UHF_PORT_RESET		4
-#define UHF_PORT_POWER		8
-#define UHF_PORT_LOW_SPEED	9
-#define UHF_C_PORT_CONNECTION	16
-#define UHF_C_PORT_ENABLE	17
-#define UHF_C_PORT_SUSPEND	18
-#define UHF_C_PORT_OVER_CURRENT	19
-#define UHF_C_PORT_RESET	20
-#define UHF_PORT_TEST		21
-#define UHF_PORT_INDICATOR	22
-
-typedef struct {
-	uByte		bDescLength;
-	uByte		bDescriptorType;
-	uByte		bNbrPorts;
-	uWord		wHubCharacteristics;
-#define UHD_PWR			0x0003
-#define  UHD_PWR_GANGED		0x0000
-#define  UHD_PWR_INDIVIDUAL	0x0001
-#define  UHD_PWR_NO_SWITCH	0x0002
-#define UHD_COMPOUND		0x0004
-#define UHD_OC			0x0018
-#define  UHD_OC_GLOBAL		0x0000
-#define  UHD_OC_INDIVIDUAL	0x0008
-#define  UHD_OC_NONE		0x0010
-#define UHD_TT_THINK		0x0060
-#define  UHD_TT_THINK_8		0x0000
-#define  UHD_TT_THINK_16	0x0020
-#define  UHD_TT_THINK_24	0x0040
-#define  UHD_TT_THINK_32	0x0060
-#define UHD_PORT_IND		0x0080
-	uByte		bPwrOn2PwrGood;	/* delay in 2 ms units */
-#define UHD_PWRON_FACTOR 2
-	uByte		bHubContrCurrent;
-	uByte		DeviceRemovable[32]; /* max 255 ports */
-#define UHD_NOT_REMOV(desc, i) \
-    (((desc)->DeviceRemovable[(i)/8] >> ((i) % 8)) & 1)
-	/* deprecated */ uByte		PortPowerCtrlMask[1];
-} UPACKED usb_hub_descriptor_t;
-#define USB_HUB_DESCRIPTOR_SIZE 9 /* includes deprecated PortPowerCtrlMask */
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uWord		bcdUSB;
-	uByte		bDeviceClass;
-	uByte		bDeviceSubClass;
-	uByte		bDeviceProtocol;
-	uByte		bMaxPacketSize0;
-	uByte		bNumConfigurations;
-	uByte		bReserved;
-} UPACKED usb_device_qualifier_t;
-#define USB_DEVICE_QUALIFIER_SIZE 10
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uByte		bmAttributes;
-#define UOTG_SRP	0x01
-#define UOTG_HNP	0x02
-} UPACKED usb_otg_descriptor_t;
-
-/* OTG feature selectors */
-#define UOTG_B_HNP_ENABLE	3
-#define UOTG_A_HNP_SUPPORT	4
-#define UOTG_A_ALT_HNP_SUPPORT	5
-
-typedef struct {
-	uWord		wStatus;
-/* Device status flags */
-#define UDS_SELF_POWERED		0x0001
-#define UDS_REMOTE_WAKEUP		0x0002
-/* Endpoint status flags */
-#define UES_HALT			0x0001
-} UPACKED usb_status_t;
-
-typedef struct {
-	uWord		wHubStatus;
-#define UHS_LOCAL_POWER			0x0001
-#define UHS_OVER_CURRENT		0x0002
-	uWord		wHubChange;
-} UPACKED usb_hub_status_t;
-
-typedef struct {
-	uWord		wPortStatus;
-#define UPS_CURRENT_CONNECT_STATUS	0x0001
-#define UPS_PORT_ENABLED		0x0002
-#define UPS_SUSPEND			0x0004
-#define UPS_OVERCURRENT_INDICATOR	0x0008
-#define UPS_RESET			0x0010
-#define UPS_PORT_POWER			0x0100
-#define UPS_LOW_SPEED			0x0200
-#define UPS_HIGH_SPEED			0x0400
-#define UPS_PORT_TEST			0x0800
-#define UPS_PORT_INDICATOR		0x1000
-	uWord		wPortChange;
-#define UPS_C_CONNECT_STATUS		0x0001
-#define UPS_C_PORT_ENABLED		0x0002
-#define UPS_C_SUSPEND			0x0004
-#define UPS_C_OVERCURRENT_INDICATOR	0x0008
-#define UPS_C_PORT_RESET		0x0010
-} UPACKED usb_port_status_t;
-
-/* Device class codes */
-#define UDCLASS_IN_INTERFACE	0x00
-#define UDCLASS_COMM		0x02
-#define UDCLASS_HUB		0x09
-#define  UDSUBCLASS_HUB		0x00
-#define  UDPROTO_FSHUB		0x00
-#define  UDPROTO_HSHUBSTT	0x01
-#define  UDPROTO_HSHUBMTT	0x02
-#define UDCLASS_DIAGNOSTIC	0xdc
-#define UDCLASS_WIRELESS	0xe0
-#define  UDSUBCLASS_RF		0x01
-#define   UDPROTO_BLUETOOTH	0x01
-#define UDCLASS_VENDOR		0xff
-
-/* Interface class codes */
-#define UICLASS_UNSPEC		0x00
-
-#define UICLASS_AUDIO		0x01
-#define  UISUBCLASS_AUDIOCONTROL	1
-#define  UISUBCLASS_AUDIOSTREAM		2
-#define  UISUBCLASS_MIDISTREAM		3
-
-#define UICLASS_CDC		0x02 /* communication */
-#define	 UISUBCLASS_DIRECT_LINE_CONTROL_MODEL	1
-#define  UISUBCLASS_ABSTRACT_CONTROL_MODEL	2
-#define	 UISUBCLASS_TELEPHONE_CONTROL_MODEL	3
-#define	 UISUBCLASS_MULTICHANNEL_CONTROL_MODEL	4
-#define	 UISUBCLASS_CAPI_CONTROLMODEL		5
-#define	 UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL 6
-#define	 UISUBCLASS_ATM_NETWORKING_CONTROL_MODEL 7
-#define   UIPROTO_CDC_AT			1
-
-#define UICLASS_HID		0x03
-#define  UISUBCLASS_BOOT	1
-#define  UIPROTO_BOOT_KEYBOARD	1
-
-#define UICLASS_PHYSICAL	0x05
-
-#define UICLASS_IMAGE		0x06
-
-#define UICLASS_PRINTER		0x07
-#define  UISUBCLASS_PRINTER	1
-#define  UIPROTO_PRINTER_UNI	1
-#define  UIPROTO_PRINTER_BI	2
-#define  UIPROTO_PRINTER_1284	3
-
-#define UICLASS_MASS		0x08
-#define  UISUBCLASS_RBC		1
-#define  UISUBCLASS_SFF8020I	2
-#define  UISUBCLASS_QIC157	3
-#define  UISUBCLASS_UFI		4
-#define  UISUBCLASS_SFF8070I	5
-#define  UISUBCLASS_SCSI	6
-#define  UIPROTO_MASS_CBI_I	0
-#define  UIPROTO_MASS_CBI	1
-#define  UIPROTO_MASS_BBB_OLD	2	/* Not in the spec anymore */
-#define  UIPROTO_MASS_BBB	80	/* 'P' for the Iomega Zip drive */
-
-#define UICLASS_HUB		0x09
-#define  UISUBCLASS_HUB		0
-#define  UIPROTO_FSHUB		0
-#define  UIPROTO_HSHUBSTT	0 /* Yes, same as previous */
-#define  UIPROTO_HSHUBMTT	1
-
-#define UICLASS_CDC_DATA	0x0a
-#define  UISUBCLASS_DATA		0
-#define   UIPROTO_DATA_ISDNBRI		0x30    /* Physical iface */
-#define   UIPROTO_DATA_HDLC		0x31    /* HDLC */
-#define   UIPROTO_DATA_TRANSPARENT	0x32    /* Transparent */
-#define   UIPROTO_DATA_Q921M		0x50    /* Management for Q921 */
-#define   UIPROTO_DATA_Q921		0x51    /* Data for Q921 */
-#define   UIPROTO_DATA_Q921TM		0x52    /* TEI multiplexer for Q921 */
-#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */
-#define   UIPROTO_DATA_Q931		0x91    /* Euro-ISDN */
-#define   UIPROTO_DATA_V120		0x92    /* V.24 rate adaption */
-#define   UIPROTO_DATA_CAPI		0x93    /* CAPI 2.0 commands */
-#define   UIPROTO_DATA_HOST_BASED	0xfd    /* Host based driver */
-#define   UIPROTO_DATA_PUF		0xfe    /* see Prot. Unit Func. Desc.*/
-#define   UIPROTO_DATA_VENDOR		0xff    /* Vendor specific */
-
-#define UICLASS_SMARTCARD	0x0b
-
-/*#define UICLASS_FIRM_UPD	0x0c*/
-
-#define UICLASS_SECURITY	0x0d
-
-#define UICLASS_DIAGNOSTIC	0xdc
-
-#define UICLASS_WIRELESS	0xe0
-#define  UISUBCLASS_RF			0x01
-#define   UIPROTO_BLUETOOTH		0x01
-
-#define UICLASS_APPL_SPEC	0xfe
-#define  UISUBCLASS_FIRMWARE_DOWNLOAD	1
-#define  UISUBCLASS_IRDA		2
-#define  UIPROTO_IRDA			0
-
-#define UICLASS_VENDOR		0xff
-#define  UISUBCLASS_XBOX360_CONTROLLER	0x5d
-#define  UIPROTO_XBOX360_GAMEPAD	0x01
-
-
-#define USB_HUB_MAX_DEPTH 5
-
-/*
- * Minimum time a device needs to be powered down to go through
- * a power cycle.  XXX Are these time in the spec?
- */
-#define USB_POWER_DOWN_TIME	200 /* ms */
-#define USB_PORT_POWER_DOWN_TIME	100 /* ms */
-
-#if 0
-/* These are the values from the spec. */
-#define USB_PORT_RESET_DELAY	10  /* ms */
-#define USB_PORT_ROOT_RESET_DELAY 50  /* ms */
-#define USB_PORT_RESET_RECOVERY	10  /* ms */
-#define USB_PORT_POWERUP_DELAY	100 /* ms */
-#define USB_SET_ADDRESS_SETTLE	2   /* ms */
-#define USB_RESUME_DELAY	(20*5)  /* ms */
-#define USB_RESUME_WAIT		10  /* ms */
-#define USB_RESUME_RECOVERY	10  /* ms */
-#define USB_EXTRA_POWER_UP_TIME	0   /* ms */
-#else
-/* Allow for marginal (i.e. non-conforming) devices. */
-#define USB_PORT_RESET_DELAY	50  /* ms */
-#define USB_PORT_ROOT_RESET_DELAY 250  /* ms */
-#define USB_PORT_RESET_RECOVERY	250  /* ms */
-#define USB_PORT_POWERUP_DELAY	300 /* ms */
-#define USB_SET_ADDRESS_SETTLE	10  /* ms */
-#define USB_RESUME_DELAY	(50*5)  /* ms */
-#define USB_RESUME_WAIT		50  /* ms */
-#define USB_RESUME_RECOVERY	50  /* ms */
-#define USB_EXTRA_POWER_UP_TIME	20  /* ms */
-#endif
-
-#define USB_MIN_POWER		100 /* mA */
-#define USB_MAX_POWER		500 /* mA */
-
-#define USB_BUS_RESET_DELAY	100 /* ms XXX?*/
-
-
-#define USB_UNCONFIG_NO 0
-#define USB_UNCONFIG_INDEX (-1)
-
-/*** ioctl() related stuff ***/
-
-struct usb_ctl_request {
-	int	ucr_addr;
-	usb_device_request_t ucr_request;
-	void	*ucr_data;
-	int	ucr_flags;
-#define USBD_SHORT_XFER_OK	0x04	/* allow short reads */
-	int	ucr_actlen;		/* actual length transferred */
-};
-
-struct usb_alt_interface {
-	int	uai_config_index;
-	int	uai_interface_index;
-	int	uai_alt_no;
-};
-
-#define USB_CURRENT_CONFIG_INDEX (-1)
-#define USB_CURRENT_ALT_INDEX (-1)
-
-struct usb_config_desc {
-	int	ucd_config_index;
-	usb_config_descriptor_t ucd_desc;
-};
-
-struct usb_interface_desc {
-	int	uid_config_index;
-	int	uid_interface_index;
-	int	uid_alt_index;
-	usb_interface_descriptor_t uid_desc;
-};
-
-struct usb_endpoint_desc {
-	int	ued_config_index;
-	int	ued_interface_index;
-	int	ued_alt_index;
-	int	ued_endpoint_index;
-	usb_endpoint_descriptor_t ued_desc;
-};
-
-struct usb_full_desc {
-	int	ufd_config_index;
-	u_int	ufd_size;
-	u_char	*ufd_data;
-};
-
-struct usb_string_desc {
-	int	usd_string_index;
-	int	usd_language_id;
-	usb_string_descriptor_t usd_desc;
-};
-
-struct usb_ctl_report_desc {
-	int	ucrd_size;
-	u_char	ucrd_data[1024];	/* filled data size will vary */
-};
-
-typedef struct { u_int32_t cookie; } usb_event_cookie_t;
-
-#define USB_MAX_DEVNAMES 4
-#define USB_MAX_DEVNAMELEN 16
-struct usb_device_info {
-	u_int8_t	udi_bus;
-	u_int8_t	udi_addr;	/* device address */
-	usb_event_cookie_t udi_cookie;
-	char		udi_product[USB_MAX_STRING_LEN];
-	char		udi_vendor[USB_MAX_STRING_LEN];
-	char		udi_release[8];
-	u_int16_t	udi_productNo;
-	u_int16_t	udi_vendorNo;
-	u_int16_t	udi_releaseNo;
-	u_int8_t	udi_class;
-	u_int8_t	udi_subclass;
-	u_int8_t	udi_protocol;
-	u_int8_t	udi_config;
-	u_int8_t	udi_speed;
-#define USB_SPEED_LOW  1
-#define USB_SPEED_FULL 2
-#define USB_SPEED_HIGH 3
-	int		udi_power;	/* power consumption in mA, 0 if selfpowered */
-	int		udi_nports;
-	char		udi_devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
-	u_int8_t	udi_ports[16];/* hub only: addresses of devices on ports */
-#define USB_PORT_ENABLED 0xff
-#define USB_PORT_SUSPENDED 0xfe
-#define USB_PORT_POWERED 0xfd
-#define USB_PORT_DISABLED 0xfc
-};
-
-struct usb_ctl_report {
-	int	ucr_report;
-	u_char	ucr_data[1024];	/* filled data size will vary */
-};
-
-struct usb_device_stats {
-	u_long	uds_requests[4];	/* indexed by transfer type UE_* */
-};
-
-/* Events that can be read from /dev/usb */
-struct usb_event {
-	int			ue_type;
-#define USB_EVENT_CTRLR_ATTACH 1
-#define USB_EVENT_CTRLR_DETACH 2
-#define USB_EVENT_DEVICE_ATTACH 3
-#define USB_EVENT_DEVICE_DETACH 4
-#define USB_EVENT_DRIVER_ATTACH 5
-#define USB_EVENT_DRIVER_DETACH 6
-#define USB_EVENT_IS_ATTACH(n) ((n) == USB_EVENT_CTRLR_ATTACH || (n) == USB_EVENT_DEVICE_ATTACH || (n) == USB_EVENT_DRIVER_ATTACH)
-#define USB_EVENT_IS_DETACH(n) ((n) == USB_EVENT_CTRLR_DETACH || (n) == USB_EVENT_DEVICE_DETACH || (n) == USB_EVENT_DRIVER_DETACH)
-	struct timespec		ue_time;
-	union {
-		struct {
-			int			ue_bus;
-		} ue_ctrlr;
-		struct usb_device_info		ue_device;
-		struct {
-			usb_event_cookie_t	ue_cookie;
-			char			ue_devname[16];
-		} ue_driver;
-	} u;
-};
-
-/* USB controller */
-#define USB_REQUEST		_IOWR('U', 1, struct usb_ctl_request)
-#define USB_SETDEBUG		_IOW ('U', 2, int)
-#define USB_DISCOVER		_IO  ('U', 3)
-#define USB_DEVICEINFO		_IOWR('U', 4, struct usb_device_info)
-#define USB_DEVICESTATS		_IOR ('U', 5, struct usb_device_stats)
-
-/* Generic HID device */
-#define USB_GET_REPORT_DESC	_IOR ('U', 21, struct usb_ctl_report_desc)
-#define USB_SET_IMMED		_IOW ('U', 22, int)
-#define USB_GET_REPORT		_IOWR('U', 23, struct usb_ctl_report)
-#define USB_SET_REPORT		_IOW ('U', 24, struct usb_ctl_report)
-#define USB_GET_REPORT_ID	_IOR ('U', 25, int)
-
-/* Generic USB device */
-#define USB_GET_CONFIG		_IOR ('U', 100, int)
-#define USB_SET_CONFIG		_IOW ('U', 101, int)
-#define USB_GET_ALTINTERFACE	_IOWR('U', 102, struct usb_alt_interface)
-#define USB_SET_ALTINTERFACE	_IOWR('U', 103, struct usb_alt_interface)
-#define USB_GET_NO_ALT		_IOWR('U', 104, struct usb_alt_interface)
-#define USB_GET_DEVICE_DESC	_IOR ('U', 105, usb_device_descriptor_t)
-#define USB_GET_CONFIG_DESC	_IOWR('U', 106, struct usb_config_desc)
-#define USB_GET_INTERFACE_DESC	_IOWR('U', 107, struct usb_interface_desc)
-#define USB_GET_ENDPOINT_DESC	_IOWR('U', 108, struct usb_endpoint_desc)
-#define USB_GET_FULL_DESC	_IOWR('U', 109, struct usb_full_desc)
-#define USB_GET_STRING_DESC	_IOWR('U', 110, struct usb_string_desc)
-#define USB_DO_REQUEST		_IOWR('U', 111, struct usb_ctl_request)
-#define USB_GET_DEVICEINFO	_IOR ('U', 112, struct usb_device_info)
-#define USB_SET_SHORT_XFER	_IOW ('U', 113, int)
-#define USB_SET_TIMEOUT		_IOW ('U', 114, int)
-
-/* Modem device */
-#define USB_GET_CM_OVER_DATA	_IOR ('U', 130, int)
-#define USB_SET_CM_OVER_DATA	_IOW ('U', 131, int)
-
-#endif /* _USB_H_ */
+#include <dev/usb2/usb.h>
diff -rubN /usr/src1/src/sys/dev/usb/usb_port.h /usr/src/sys/dev/usb/usb_port.h
--- /usr/src1/src/sys/dev/usb/usb_port.h	Thu Jan 20 05:03:28 2005
+++ /usr/src/sys/dev/usb/usb_port.h	Thu Jun  8 21:13:08 2006
@@ -1,529 +1 @@
-/*	$OpenBSD: usb_port.h,v 1.18 2000/09/06 22:42:10 rahnds Exp $ */
-/*	$NetBSD: usb_port.h,v 1.54 2002/03/28 21:49:19 ichiro Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usb_port.h,v 1.74 2005/01/20 05:03:28 imp Exp $       */
-
-/* Also already merged from NetBSD:
- *	$NetBSD: usb_port.h,v 1.57 2002/09/27 20:42:01 thorpej Exp $
- *	$NetBSD: usb_port.h,v 1.58 2002/10/01 01:25:26 thorpej Exp $
- */
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _USB_PORT_H
-#define _USB_PORT_H
-
-/*
- * Macro's to cope with the differences between operating systems.
- */
-
-#if defined(__NetBSD__)
-/*
- * NetBSD
- */
-
-#include "opt_usbverbose.h"
-
-#define USB_USE_SOFTINTR
-
-#ifdef USB_DEBUG
-#define Static
-#else
-#define Static static
-#endif
-
-#define SCSI_MODE_SENSE		MODE_SENSE
-
-typedef struct proc *usb_proc_ptr;
-
-typedef struct device *device_ptr_t;
-#define USBBASEDEVICE struct device
-#define USBDEV(bdev) (&(bdev))
-#define USBDEVNAME(bdev) ((bdev).dv_xname)
-#define USBDEVUNIT(bdev) ((bdev).dv_unit)
-#define USBDEVPTRNAME(bdevptr) ((bdevptr)->dv_xname)
-#define USBGETSOFTC(d) ((void *)(d))
-
-#define DECLARE_USB_DMA_T \
-	struct usb_dma_block; \
-	typedef struct { \
-		struct usb_dma_block *block; \
-		u_int offs; \
-	} usb_dma_t
-
-typedef struct callout usb_callout_t;
-#define usb_callout_init(h)	callout_init(&(h))
-#define	usb_callout(h, t, f, d)	callout_reset(&(h), (t), (f), (d))
-#define	usb_uncallout(h, f, d)	callout_stop(&(h))
-
-#define usb_kthread_create1	kthread_create1
-#define usb_kthread_create	kthread_create
-
-typedef int usb_malloc_type;
-
-#define Ether_ifattach ether_ifattach
-#define IF_INPUT(ifp, m) (*(ifp)->if_input)((ifp), (m))
-
-#define logprintf printf
-
-#define	USB_DNAME(dname)	dname
-#define USB_DECLARE_DRIVER(dname)  \
-int __CONCAT(dname,_match)(struct device *, struct cfdata *, void *); \
-void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
-int __CONCAT(dname,_detach)(struct device *, int); \
-int __CONCAT(dname,_activate)(struct device *, enum devact); \
-\
-extern struct cfdriver __CONCAT(dname,_cd); \
-\
-CFATTACH_DECL(USB_DNAME(dname), \
-    sizeof(struct ___CONCAT(dname,_softc)), \
-    ___CONCAT(dname,_match), \
-    ___CONCAT(dname,_attach), \
-    ___CONCAT(dname,_detach), \
-    ___CONCAT(dname,_activate))
-
-#define USB_MATCH(dname) \
-int __CONCAT(dname,_match)(struct device *parent, struct cfdata *match, void *aux)
-
-#define USB_MATCH_START(dname, uaa) \
-	struct usb_attach_arg *uaa = aux
-
-#define USB_ATTACH(dname) \
-void __CONCAT(dname,_attach)(struct device *parent, struct device *self, void *aux)
-
-#define USB_ATTACH_START(dname, sc, uaa) \
-	struct __CONCAT(dname,_softc) *sc = \
-		(struct __CONCAT(dname,_softc) *)self; \
-	struct usb_attach_arg *uaa = aux
-
-/* Returns from attach */
-#define USB_ATTACH_ERROR_RETURN	return
-#define USB_ATTACH_SUCCESS_RETURN	return
-
-#define USB_ATTACH_SETUP
-	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
-
-#define USB_DETACH(dname) \
-int __CONCAT(dname,_detach)(struct device *self, int flags)
-
-#define USB_DETACH_START(dname, sc) \
-	struct __CONCAT(dname,_softc) *sc = \
-		(struct __CONCAT(dname,_softc) *)self
-
-#define USB_GET_SC_OPEN(dname, unit, sc) \
-	if (unit >= __CONCAT(dname,_cd).cd_ndevs) \
-		return (ENXIO); \
-	sc = __CONCAT(dname,_cd).cd_devs[unit]; \
-	if (sc == NULL) \
-		return (ENXIO)
-
-#define USB_GET_SC(dname, unit, sc) \
-	sc = __CONCAT(dname,_cd).cd_devs[unit]
-
-#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
-	(config_found_sm(parent, args, print, sub))
-
-#elif defined(__OpenBSD__)
-/*
- * OpenBSD
- */
-#define Static
-
-typedef struct proc *usb_proc_ptr;
-
-#define UCOMBUSCF_PORTNO		-1
-#define UCOMBUSCF_PORTNO_DEFAULT	-1
-
-#define SCSI_MODE_SENSE		MODE_SENSE
-#define XS_STS_DONE		ITSDONE
-#define XS_CTL_POLL		SCSI_POLL
-#define XS_CTL_DATA_IN		SCSI_DATA_IN
-#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
-#define scsipi_adapter		scsi_adapter
-#define scsipi_cmd		scsi_cmd
-#define scsipi_device		scsi_device
-#define scsipi_done		scsi_done
-#define scsipi_link		scsi_link
-#define scsipi_minphys		scsi_minphys
-#define scsipi_sense		scsi_sense
-#define scsipi_xfer		scsi_xfer
-#define xs_control		flags
-#define xs_status		status
-
-#define	memcpy(d, s, l)		bcopy((s),(d),(l))
-#define	memset(d, v, l)		bzero((d),(l))
-#define bswap32(x)		swap32(x)
-#define bswap16(x)		swap16(x)
-
-/*
- * The UHCI/OHCI controllers are little endian, so on big endian machines
- * the data strored in memory needs to be swapped.
- */
-
-#if defined(letoh32)
-#define le32toh(x) letoh32(x)
-#define le16toh(x) letoh16(x)
-#endif
-
-#define usb_kthread_create1	kthread_create
-#define usb_kthread_create	kthread_create_deferred
-
-#define	config_pending_incr()
-#define	config_pending_decr()
-
-typedef int usb_malloc_type;
-
-#define Ether_ifattach(ifp, eaddr) ether_ifattach(ifp)
-#define if_deactivate(x)
-#define IF_INPUT(ifp, m) do {						\
-	struct ether_header *eh;					\
-									\
-	eh = mtod(m, struct ether_header *);				\
-	m_adj(m, sizeof(struct ether_header));				\
-	ether_input((ifp), (eh), (m));					\
-} while (0)
-
-#define	usbpoll			usbselect
-#define	uhidpoll		uhidselect
-#define	ugenpoll		ugenselect
-#define	uriopoll		urioselect
-#define uscannerpoll		uscannerselect
-
-#define powerhook_establish(fn, sc) (fn)
-#define powerhook_disestablish(hdl)
-#define PWR_RESUME 0
-
-#define logprintf printf
-
-#define swap_bytes_change_sign16_le swap_bytes_change_sign16
-#define change_sign16_swap_bytes_le change_sign16_swap_bytes
-#define change_sign16_le change_sign16
-
-#define realloc usb_realloc
-void *usb_realloc(void *, u_int, int, int);
-
-extern int cold;
-
-typedef struct device *device_ptr_t;
-#define USBBASEDEVICE struct device
-#define USBDEV(bdev) (&(bdev))
-#define USBDEVNAME(bdev) ((bdev).dv_xname)
-#define USBDEVUNIT(bdev) ((bdev).dv_unit)
-#define USBDEVPTRNAME(bdevptr) ((bdevptr)->dv_xname)
-#define USBGETSOFTC(d) ((void *)(d))
-
-#define DECLARE_USB_DMA_T \
-	struct usb_dma_block; \
-	typedef struct { \
-		struct usb_dma_block *block; \
-		u_int offs; \
-	} usb_dma_t
-
-typedef char usb_callout_t;
-#define usb_callout_init(h)
-#define usb_callout(h, t, f, d) timeout((f), (d), (t))
-#define usb_uncallout(h, f, d) untimeout((f), (d))
-
-#define USB_DECLARE_DRIVER(dname)  \
-int __CONCAT(dname,_match)(struct device *, void *, void *); \
-void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
-int __CONCAT(dname,_detach)(struct device *, int); \
-int __CONCAT(dname,_activate)(struct device *, enum devact); \
-\
-struct cfdriver __CONCAT(dname,_cd) = { \
-	NULL, #dname, DV_DULL \
-}; \
-\
-const struct cfattach __CONCAT(dname,_ca) = { \
-	sizeof(struct __CONCAT(dname,_softc)), \
-	__CONCAT(dname,_match), \
-	__CONCAT(dname,_attach), \
-	__CONCAT(dname,_detach), \
-	__CONCAT(dname,_activate), \
-}
-
-#define USB_MATCH(dname) \
-int \
-__CONCAT(dname,_match)(parent, match, aux) \
-	struct device *parent; \
-	void *match; \
-	void *aux;
-
-#define USB_MATCH_START(dname, uaa) \
-	struct usb_attach_arg *uaa = aux
-
-#define USB_ATTACH(dname) \
-void \
-__CONCAT(dname,_attach)(parent, self, aux) \
-	struct device *parent; \
-	struct device *self; \
-	void *aux;
-
-#define USB_ATTACH_START(dname, sc, uaa) \
-	struct __CONCAT(dname,_softc) *sc = \
-		(struct __CONCAT(dname,_softc) *)self; \
-	struct usb_attach_arg *uaa = aux
-
-/* Returns from attach */
-#define USB_ATTACH_ERROR_RETURN	return
-#define USB_ATTACH_SUCCESS_RETURN	return
-
-#define USB_ATTACH_SETUP
-	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
-
-#define USB_DETACH(dname) \
-int \
-__CONCAT(dname,_detach)(self, flags) \
-	struct device *self; \
-	int flags;
-
-#define USB_DETACH_START(dname, sc) \
-	struct __CONCAT(dname,_softc) *sc = \
-		(struct __CONCAT(dname,_softc) *)self
-
-#define USB_GET_SC_OPEN(dname, unit, sc) \
-	if (unit >= __CONCAT(dname,_cd).cd_ndevs) \
-		return (ENXIO); \
-	sc = __CONCAT(dname,_cd).cd_devs[unit]; \
-	if (sc == NULL) \
-		return (ENXIO)
-
-#define USB_GET_SC(dname, unit, sc) \
-	sc = __CONCAT(dname,_cd).cd_devs[unit]
-
-#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
-	(config_found_sm(parent, args, print, sub))
-
-#elif defined(__FreeBSD__)
-/*
- * FreeBSD
- */
-
-#include "opt_usb.h"
-
-#if defined(_KERNEL)
-#include <sys/malloc.h>
-
-MALLOC_DECLARE(M_USB);
-MALLOC_DECLARE(M_USBDEV);
-MALLOC_DECLARE(M_USBHC);
-
-#endif
-
-/* We don't use the soft interrupt code in FreeBSD. */
-#if 0
-#define USB_USE_SOFTINTR
-#endif
-
-#define Static static
-
-#define device_ptr_t device_t
-#define USBBASEDEVICE device_t
-#define USBDEV(bdev) (bdev)
-#define USBDEVNAME(bdev) device_get_nameunit(bdev)
-#define USBDEVUNIT(bdev) device_get_unit(bdev)
-#define USBDEVPTRNAME(bdev) device_get_nameunit(bdev)
-#define USBDEVUNIT(bdev) device_get_unit(bdev)
-#define USBGETSOFTC(bdev) (device_get_softc(bdev))
-
-#define DECLARE_USB_DMA_T \
-	struct usb_dma_block; \
-	typedef struct { \
-		struct usb_dma_block *block; \
-		u_int offs; \
-		u_int len; \
-	} usb_dma_t
-
-#if __FreeBSD_version >= 500000
-typedef struct thread *usb_proc_ptr;
-
-#define uio_procp uio_td
-
-#define usb_kthread_create1(f, s, p, a0, a1) \
-		kthread_create((f), (s), (p), RFHIGHPID, 0, (a0), (a1))
-#define usb_kthread_create2(f, s, p, a0) \
-		kthread_create((f), (s), (p), RFHIGHPID, 0, (a0))
-#define usb_kthread_create	kthread_create
-
-#define	config_pending_incr()
-#define	config_pending_decr()
-
-typedef struct callout usb_callout_t;
-#define usb_callout_init(h)     callout_init(&(h), 0)
-#define usb_callout(h, t, f, d) callout_reset(&(h), (t), (f), (d))
-#define usb_uncallout(h, f, d)  callout_stop(&(h))
-#define usb_uncallout_drain(h, f, d)  callout_drain(&(h))
-#else
-typedef struct proc *usb_proc_ptr;
-
-#define	PROC_LOCK(p)
-#define	PROC_UNLOCK(p)
-
-#define usb_kthread_create1(f, s, p, a0, a1) \
-		kthread_create((f), (s), (p), (a0), (a1))
-#define usb_kthread_create2(f, s, p, a0) \
-		kthread_create((f), (s), (p), (a0))
-#define usb_kthread_create	kthread_create
-
-#define	config_pending_incr()
-#define	config_pending_decr()
-
-typedef struct callout usb_callout_t;
-#define usb_callout_init(h)     callout_init(&(h))
-#define usb_callout(h, t, f, d) callout_reset(&(h), (t), (f), (d))
-#define usb_uncallout(h, f, d)  callout_stop(&(h))
-
-#define	BUS_DMA_COHERENT	0
-#define	ETHER_ALIGN		2
-#define	BPF_MTAP(ifp, m)	if ((ifp)->if_bpf) bpf_mtap((ifp), (m));
-#endif
-
-#define clalloc(p, s, x) (clist_alloc_cblocks((p), (s), (s)), 0)
-#define clfree(p) clist_free_cblocks((p))
-
-#define PWR_RESUME 0
-#define PWR_SUSPEND 1
-
-#define config_detach(dev, flag) \
-	do { \
-		device_detach(dev); \
-		free(device_get_ivars(dev), M_USB); \
-		device_delete_child(device_get_parent(dev), dev); \
-	} while (0);
-
-typedef struct malloc_type *usb_malloc_type;
-
-#define USB_DECLARE_DRIVER_INIT(dname, init...) \
-Static device_probe_t __CONCAT(dname,_match); \
-Static device_attach_t __CONCAT(dname,_attach); \
-Static device_detach_t __CONCAT(dname,_detach); \
-\
-Static devclass_t __CONCAT(dname,_devclass); \
-\
-Static device_method_t __CONCAT(dname,_methods)[] = { \
-        DEVMETHOD(device_probe, __CONCAT(dname,_match)), \
-        DEVMETHOD(device_attach, __CONCAT(dname,_attach)), \
-        DEVMETHOD(device_detach, __CONCAT(dname,_detach)), \
-	init, \
-        {0,0} \
-}; \
-\
-Static driver_t __CONCAT(dname,_driver) = { \
-        #dname, \
-        __CONCAT(dname,_methods), \
-        sizeof(struct __CONCAT(dname,_softc)) \
-}; \
-MODULE_DEPEND(dname, usb, 1, 1, 1)
-
-
-#define METHODS_NONE			{0,0}
-#define USB_DECLARE_DRIVER(dname)	USB_DECLARE_DRIVER_INIT(dname, METHODS_NONE)
-
-#define USB_MATCH(dname) \
-Static int \
-__CONCAT(dname,_match)(device_t self)
-
-#define USB_MATCH_START(dname, uaa) \
-        struct usb_attach_arg *uaa = device_get_ivars(self)
-
-#define USB_MATCH_SETUP \
-	sc->sc_dev = self
-
-#define USB_ATTACH(dname) \
-Static int \
-__CONCAT(dname,_attach)(device_t self)
-
-#define USB_ATTACH_START(dname, sc, uaa) \
-        struct __CONCAT(dname,_softc) *sc = device_get_softc(self); \
-        struct usb_attach_arg *uaa = device_get_ivars(self)
-
-/* Returns from attach */
-#define USB_ATTACH_ERROR_RETURN	return ENXIO
-#define USB_ATTACH_SUCCESS_RETURN	return 0
-
-#define USB_ATTACH_SETUP \
-	do { \
-		sc->sc_dev = self; \
-		device_set_desc_copy(self, devinfo); \
-		device_printf(self, "%s\n", devinfo); \
-	} while (0);
-
-#define USB_DETACH(dname) \
-Static int \
-__CONCAT(dname,_detach)(device_t self)
-
-#define USB_DETACH_START(dname, sc) \
-	struct __CONCAT(dname,_softc) *sc = device_get_softc(self)
-
-#define USB_GET_SC_OPEN(dname, unit, sc) \
-	sc = devclass_get_softc(__CONCAT(dname,_devclass), unit); \
-	if (sc == NULL) \
-		return (ENXIO)
-
-#define USB_GET_SC(dname, unit, sc) \
-	sc = devclass_get_softc(__CONCAT(dname,_devclass), unit)
-
-#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
-	(device_probe_and_attach((bdev)) == 0 ? (bdev) : 0)
-
-/* conversion from one type of queue to the other */
-#define SIMPLEQ_REMOVE_HEAD	STAILQ_REMOVE_HEAD
-#define SIMPLEQ_INSERT_HEAD	STAILQ_INSERT_HEAD
-#define SIMPLEQ_INSERT_TAIL	STAILQ_INSERT_TAIL
-#define SIMPLEQ_NEXT		STAILQ_NEXT
-#define SIMPLEQ_FIRST		STAILQ_FIRST
-#define SIMPLEQ_HEAD		STAILQ_HEAD
-#define SIMPLEQ_EMPTY		STAILQ_EMPTY
-#define SIMPLEQ_FOREACH		STAILQ_FOREACH
-#define SIMPLEQ_INIT		STAILQ_INIT
-#define SIMPLEQ_HEAD_INITIALIZER	STAILQ_HEAD_INITIALIZER
-#define SIMPLEQ_ENTRY		STAILQ_ENTRY
-
-#include <sys/syslog.h>
-/*
-#define logprintf(args...)	log(LOG_DEBUG, args)
-*/
-#define logprintf		printf
-
-#ifdef SYSCTL_DECL
-SYSCTL_DECL(_hw_usb);
-#endif
-
-#endif /* __FreeBSD__ */
-
-#endif /* _USB_PORT_H */
-
+#include <dev/usb2/usb_port.h>
diff -rubN /usr/src1/src/sys/dev/usb/usb_quirks.c /usr/src/sys/dev/usb/usb_quirks.c
--- /usr/src1/src/sys/dev/usb/usb_quirks.c	Wed Feb 15 22:51:08 2006
+++ /usr/src/sys/dev/usb/usb_quirks.c	Thu Jun  8 21:13:09 2006
@@ -48,10 +48,6 @@
 #include "usbdevs.h"
 #include <dev/usb/usb_quirks.h>
 
-#ifdef USB_DEBUG
-extern int usbdebug;
-#endif
-
 #define ANY 0xffff
 
 Static const struct usbd_quirk_entry {
diff -rubN /usr/src1/src/sys/dev/usb/usb_quirks.c.orig /usr/src/sys/dev/usb/usb_quirks.c.orig
--- /usr/src1/src/sys/dev/usb/usb_quirks.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/usb_quirks.c.orig	Wed Feb 15 22:51:08 2006
@@ -0,0 +1,139 @@
+/*	$NetBSD: usb_quirks.c,v 1.50 2004/06/23 02:30:52 mycroft Exp $	*/
+
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/usb/usb_quirks.c,v 1.41.2.4 2006/02/15 22:51:08 iedowse Exp $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+
+#include <dev/usb/usb.h>
+
+#include "usbdevs.h"
+#include <dev/usb/usb_quirks.h>
+
+#ifdef USB_DEBUG
+extern int usbdebug;
+#endif
+
+#define ANY 0xffff
+
+Static const struct usbd_quirk_entry {
+	u_int16_t idVendor;
+	u_int16_t idProduct;
+	u_int16_t bcdDevice;
+	struct usbd_quirks quirks;
+} usb_quirks[] = {
+ { USB_VENDOR_KYE, USB_PRODUCT_KYE_NICHE,	    0x100, { UQ_NO_SET_PROTO}},
+ { USB_VENDOR_INSIDEOUT, USB_PRODUCT_INSIDEOUT_EDGEPORT4,
+   						    0x094, { UQ_SWAP_UNICODE}},
+ { USB_VENDOR_DALLAS, USB_PRODUCT_DALLAS_J6502,	    0x0a2, { UQ_BAD_ADC }},
+ { USB_VENDOR_DALLAS, USB_PRODUCT_DALLAS_J6502,	    0x0a2, { UQ_AU_NO_XU }},
+ { USB_VENDOR_ALTEC, USB_PRODUCT_ALTEC_ADA70,	    0x103, { UQ_BAD_ADC }},
+ { USB_VENDOR_ALTEC, USB_PRODUCT_ALTEC_ASC495,      0x000, { UQ_BAD_AUDIO }},
+ { USB_VENDOR_QTRONIX, USB_PRODUCT_QTRONIX_980N,    0x110, { UQ_SPUR_BUT_UP }},
+ { USB_VENDOR_ALCOR2, USB_PRODUCT_ALCOR2_KBD_HUB,   0x001, { UQ_SPUR_BUT_UP }},
+ { USB_VENDOR_MCT, USB_PRODUCT_MCT_HUB0100,         0x102, { UQ_BUS_POWERED }},
+ { USB_VENDOR_MCT, USB_PRODUCT_MCT_USB232,          0x102, { UQ_BUS_POWERED }},
+ { USB_VENDOR_METRICOM, USB_PRODUCT_METRICOM_RICOCHET_GS,
+ 	0x100, { UQ_ASSUME_CM_OVER_DATA }},
+ { USB_VENDOR_SANYO, USB_PRODUCT_SANYO_SCP4900,
+ 	0x000, { UQ_ASSUME_CM_OVER_DATA }},
+ { USB_VENDOR_TI, USB_PRODUCT_TI_UTUSB41,	    0x110, { UQ_POWER_CLAIM }},
+ { USB_VENDOR_TELEX, USB_PRODUCT_TELEX_MIC1,	    0x009, { UQ_AU_NO_FRAC }},
+ { USB_VENDOR_SILICONPORTALS, USB_PRODUCT_SILICONPORTALS_YAPPHONE,
+   						    0x100, { UQ_AU_INP_ASYNC }},
+ /* XXX These should have a revision number, but I don't know what they are. */
+ { USB_VENDOR_HP, USB_PRODUCT_HP_895C,		    ANY,   { UQ_BROKEN_BIDIR }},
+ { USB_VENDOR_HP, USB_PRODUCT_HP_880C,		    ANY,   { UQ_BROKEN_BIDIR }},
+ { USB_VENDOR_HP, USB_PRODUCT_HP_815C,		    ANY,   { UQ_BROKEN_BIDIR }},
+ { USB_VENDOR_HP, USB_PRODUCT_HP_810C,		    ANY,   { UQ_BROKEN_BIDIR }},
+ { USB_VENDOR_HP, USB_PRODUCT_HP_830C,		    ANY,   { UQ_BROKEN_BIDIR }},
+ { USB_VENDOR_HP, USB_PRODUCT_HP_1220C,		    ANY,   { UQ_BROKEN_BIDIR }},
+ /* YAMAHA router's ucdDevice is the version of farmware and often changes. */
+ { USB_VENDOR_YAMAHA, USB_PRODUCT_YAMAHA_RTA54I,
+	ANY, { UQ_ASSUME_CM_OVER_DATA }},
+ { USB_VENDOR_YAMAHA, USB_PRODUCT_YAMAHA_RTA55I,
+	ANY, { UQ_ASSUME_CM_OVER_DATA }},
+ { USB_VENDOR_YAMAHA, USB_PRODUCT_YAMAHA_RTW65B,
+	ANY, { UQ_ASSUME_CM_OVER_DATA }},
+ { USB_VENDOR_YAMAHA, USB_PRODUCT_YAMAHA_RTW65I,
+	ANY, { UQ_ASSUME_CM_OVER_DATA }},
+ { USB_VENDOR_QUALCOMM, USB_PRODUCT_QUALCOMM_CDMA_MSM,
+	ANY, { UQ_ASSUME_CM_OVER_DATA }},
+ { USB_VENDOR_QUALCOMM2, USB_PRODUCT_QUALCOMM2_CDMA_MSM,
+	ANY, { UQ_ASSUME_CM_OVER_DATA }},
+ { USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_AS64LX,
+	0x100, { UQ_ASSUME_CM_OVER_DATA }},
+ /* Devices which should be ignored by uhid */
+ { USB_VENDOR_APC, USB_PRODUCT_APC_UPS,
+	ANY, { UQ_HID_IGNORE }},
+ { USB_VENDOR_DELORME, USB_PRODUCT_DELORME_EARTHMATE,
+	ANY, { UQ_HID_IGNORE }},
+ { USB_VENDOR_MGE, USB_PRODUCT_MGE_UPS1,
+	ANY, { UQ_HID_IGNORE }},
+ { USB_VENDOR_MGE, USB_PRODUCT_MGE_UPS2,
+	ANY, { UQ_HID_IGNORE }},
+ { 0, 0, 0, { 0 } }
+};
+
+const struct usbd_quirks usbd_no_quirk = { 0 };
+
+const struct usbd_quirks *
+usbd_find_quirk(usb_device_descriptor_t *d)
+{
+	const struct usbd_quirk_entry *t;
+	u_int16_t vendor = UGETW(d->idVendor);
+	u_int16_t product = UGETW(d->idProduct);
+	u_int16_t revision = UGETW(d->bcdDevice);
+
+	for (t = usb_quirks; t->idVendor != 0; t++) {
+		if (t->idVendor  == vendor &&
+		    t->idProduct == product &&
+		    (t->bcdDevice == ANY || t->bcdDevice == revision))
+			break;
+	}
+#ifdef USB_DEBUG
+	if (usbdebug && t->quirks.uq_flags)
+		logprintf("usbd_find_quirk 0x%04x/0x%04x/%x: %d\n",
+			  UGETW(d->idVendor), UGETW(d->idProduct),
+			  UGETW(d->bcdDevice), t->quirks.uq_flags);
+#endif
+	return (&t->quirks);
+}
diff -rubN /usr/src1/src/sys/dev/usb/usbdi.h /usr/src/sys/dev/usb/usbdi.h
--- /usr/src1/src/sys/dev/usb/usbdi.h	Mon May 16 06:58:43 2005
+++ /usr/src/sys/dev/usb/usbdi.h	Thu Jun  8 21:13:08 2006
@@ -1,308 +1 @@
-/*	$NetBSD: usbdi.h,v 1.64 2004/10/23 13:26:34 augustss Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usbdi.h,v 1.59 2005/05/16 06:58:43 imp Exp $	*/
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _USBDI_H_
-#define _USBDI_H_
-
-typedef struct usbd_bus		*usbd_bus_handle;
-typedef struct usbd_device	*usbd_device_handle;
-typedef struct usbd_interface	*usbd_interface_handle;
-typedef struct usbd_pipe	*usbd_pipe_handle;
-typedef struct usbd_xfer	*usbd_xfer_handle;
-typedef void			*usbd_private_handle;
-
-typedef enum {		/* keep in sync with usbd_status_msgs */
-	USBD_NORMAL_COMPLETION = 0, /* must be 0 */
-	USBD_IN_PROGRESS,	/* 1 */
-	/* errors */
-	USBD_PENDING_REQUESTS,	/* 2 */
-	USBD_NOT_STARTED,	/* 3 */
-	USBD_INVAL,		/* 4 */
-	USBD_NOMEM,		/* 5 */
-	USBD_CANCELLED,		/* 6 */
-	USBD_BAD_ADDRESS,	/* 7 */
-	USBD_IN_USE,		/* 8 */
-	USBD_NO_ADDR,		/* 9 */
-	USBD_SET_ADDR_FAILED,	/* 10 */
-	USBD_NO_POWER,		/* 11 */
-	USBD_TOO_DEEP,		/* 12 */
-	USBD_IOERROR,		/* 13 */
-	USBD_NOT_CONFIGURED,	/* 14 */
-	USBD_TIMEOUT,		/* 15 */
-	USBD_SHORT_XFER,	/* 16 */
-	USBD_STALLED,		/* 17 */
-	USBD_INTERRUPTED,	/* 18 */
-
-	USBD_ERROR_MAX		/* must be last */
-} usbd_status;
-
-typedef void (*usbd_callback)(usbd_xfer_handle, usbd_private_handle,
-			      usbd_status);
-
-/* Open flags */
-#define USBD_EXCLUSIVE_USE	0x01
-
-/* Use default (specified by ep. desc.) interval on interrupt pipe */
-#define USBD_DEFAULT_INTERVAL	(-1)
-
-/* Request flags */
-#define USBD_NO_COPY		0x01	/* do not copy data to DMA buffer */
-#define USBD_SYNCHRONOUS	0x02	/* wait for completion */
-/* in usb.h #define USBD_SHORT_XFER_OK	0x04*/	/* allow short reads */
-#define USBD_FORCE_SHORT_XFER	0x08	/* force last short packet on write */
-
-#define USBD_NO_TIMEOUT 0
-#define USBD_DEFAULT_TIMEOUT 5000 /* ms = 5 s */
-
-usbd_status usbd_open_pipe(usbd_interface_handle, u_int8_t,
-			   u_int8_t, usbd_pipe_handle *);
-usbd_status usbd_close_pipe(usbd_pipe_handle);
-usbd_status usbd_transfer(usbd_xfer_handle);
-usbd_xfer_handle usbd_alloc_xfer(usbd_device_handle);
-usbd_status usbd_free_xfer(usbd_xfer_handle);
-void usbd_setup_xfer(usbd_xfer_handle, usbd_pipe_handle,
-		     usbd_private_handle, void *,
-		     u_int32_t, u_int16_t, u_int32_t,
-		     usbd_callback);
-void usbd_setup_default_xfer(usbd_xfer_handle, usbd_device_handle,
-			     usbd_private_handle, u_int32_t,
-			     usb_device_request_t *, void *,
-			     u_int32_t, u_int16_t, usbd_callback);
-void usbd_setup_isoc_xfer(usbd_xfer_handle, usbd_pipe_handle,
-			  usbd_private_handle, u_int16_t *,
-			  u_int32_t, u_int16_t, usbd_callback);
-void usbd_get_xfer_status(usbd_xfer_handle, usbd_private_handle *,
-			  void **, u_int32_t *, usbd_status *);
-usb_endpoint_descriptor_t *usbd_interface2endpoint_descriptor
-			(usbd_interface_handle, u_int8_t);
-usbd_status usbd_abort_pipe(usbd_pipe_handle);
-usbd_status usbd_abort_default_pipe(usbd_device_handle);
-usbd_status usbd_clear_endpoint_stall(usbd_pipe_handle);
-usbd_status usbd_clear_endpoint_stall_async(usbd_pipe_handle);
-void usbd_clear_endpoint_toggle(usbd_pipe_handle);
-usbd_status usbd_endpoint_count(usbd_interface_handle, u_int8_t *);
-usbd_status usbd_interface_count(usbd_device_handle, u_int8_t *);
-void usbd_interface2device_handle(usbd_interface_handle,
-					 usbd_device_handle *);
-usbd_status usbd_device2interface_handle(usbd_device_handle,
-			      u_int8_t, usbd_interface_handle *);
-
-usbd_device_handle usbd_pipe2device_handle(usbd_pipe_handle);
-void *usbd_alloc_buffer(usbd_xfer_handle, u_int32_t);
-void usbd_free_buffer(usbd_xfer_handle);
-void *usbd_get_buffer(usbd_xfer_handle);
-usbd_status usbd_sync_transfer(usbd_xfer_handle);
-usbd_status usbd_open_pipe_intr(usbd_interface_handle, u_int8_t,
-				u_int8_t, usbd_pipe_handle *,
-				usbd_private_handle, void *,
-				u_int32_t, usbd_callback, int);
-usbd_status usbd_do_request(usbd_device_handle, usb_device_request_t *, void *);
-usbd_status usbd_do_request_async(usbd_device_handle,
-				  usb_device_request_t *, void *);
-usbd_status usbd_do_request_flags(usbd_device_handle, usb_device_request_t *,
-				  void *, u_int16_t, int*, u_int32_t);
-usbd_status usbd_do_request_flags_pipe(usbd_device_handle, usbd_pipe_handle,
-	usb_device_request_t *, void *, u_int16_t, int *, u_int32_t);
-usb_interface_descriptor_t *usbd_get_interface_descriptor
-				(usbd_interface_handle);
-usb_config_descriptor_t *usbd_get_config_descriptor(usbd_device_handle);
-usb_device_descriptor_t *usbd_get_device_descriptor(usbd_device_handle);
-int usbd_get_speed(usbd_device_handle);
-usbd_status usbd_set_interface(usbd_interface_handle, int);
-int usbd_get_no_alts(usb_config_descriptor_t *, int);
-usbd_status  usbd_get_interface(usbd_interface_handle, u_int8_t *);
-void usbd_fill_deviceinfo(usbd_device_handle, struct usb_device_info *, int);
-int usbd_get_interface_altindex(usbd_interface_handle);
-
-usb_interface_descriptor_t *usbd_find_idesc(usb_config_descriptor_t *,
-					    int, int);
-usb_endpoint_descriptor_t *usbd_find_edesc(usb_config_descriptor_t *,
-					   int, int, int);
-
-void usbd_dopoll(usbd_interface_handle);
-void usbd_set_polling(usbd_device_handle, int);
-
-const char *usbd_errstr(usbd_status);
-
-void usbd_add_dev_event(int, usbd_device_handle);
-void usbd_add_drv_event(int, usbd_device_handle, device_ptr_t);
-
-void usbd_devinfo(usbd_device_handle, int, char *);
-const struct usbd_quirks *usbd_get_quirks(usbd_device_handle);
-usb_endpoint_descriptor_t *usbd_get_endpoint_descriptor
-			(usbd_interface_handle, u_int8_t);
-
-usbd_status usbd_reload_device_desc(usbd_device_handle);
-
-int usbd_ratecheck(struct timeval *last);
-
-usbd_status usbd_get_string(usbd_device_handle dev, int si, char *buf);
-
-/* An iterator for descriptors. */
-typedef struct {
-	const uByte *cur;
-	const uByte *end;
-} usbd_desc_iter_t;
-void usb_desc_iter_init(usbd_device_handle dev, usbd_desc_iter_t *iter);
-const usb_descriptor_t *usb_desc_iter_next(usbd_desc_iter_t *iter);
-
-/*
- * The usb_task structs form a queue of things to run in the USB event
- * thread.  Normally this is just device discovery when a connect/disconnect
- * has been detected.  But it may also be used by drivers that need to
- * perform (short) tasks that must have a process context.
- */
-struct usb_task {
-	TAILQ_ENTRY(usb_task) next;
-	void (*fun)(void *);
-	void *arg;
-	char onqueue;
-};
-
-void usb_add_task(usbd_device_handle, struct usb_task *);
-void usb_rem_task(usbd_device_handle, struct usb_task *);
-#define usb_init_task(t, f, a) ((t)->fun = (f), (t)->arg = (a), (t)->onqueue = 0)
-
-struct usb_devno {
-	u_int16_t ud_vendor;
-	u_int16_t ud_product;
-};
-const struct usb_devno *usb_match_device(const struct usb_devno *,
-	u_int, u_int, u_int16_t, u_int16_t);
-#define usb_lookup(tbl, vendor, product) \
-	usb_match_device((const struct usb_devno *)(tbl), sizeof (tbl) / sizeof ((tbl)[0]), sizeof ((tbl)[0]), (vendor), (product))
-#define	USB_PRODUCT_ANY		0xffff
-
-/* NetBSD attachment information */
-
-/* Attach data */
-struct usb_attach_arg {
-	int			port;
-	int			configno;
-	int			ifaceno;
-	int			vendor;
-	int			product;
-	int			release;
-	int			matchlvl;
-	usbd_device_handle	device;	/* current device */
-	usbd_interface_handle	iface; /* current interface */
-	int			usegeneric;
-	usbd_interface_handle  *ifaces;	/* all interfaces */
-	int			nifaces; /* number of interfaces */
-};
-
-#if defined(__NetBSD__) || defined(__OpenBSD__)
-/* Match codes. */
-/* First five codes is for a whole device. */
-#define UMATCH_VENDOR_PRODUCT_REV			14
-#define UMATCH_VENDOR_PRODUCT				13
-#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			12
-#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		11
-#define UMATCH_DEVCLASS_DEVSUBCLASS			10
-/* Next six codes are for interfaces. */
-#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		 9
-#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		 8
-#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		 7
-#define UMATCH_VENDOR_IFACESUBCLASS			 6
-#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	 5
-#define UMATCH_IFACECLASS_IFACESUBCLASS			 4
-#define UMATCH_IFACECLASS				 3
-#define UMATCH_IFACECLASS_GENERIC			 2
-/* Generic driver */
-#define UMATCH_GENERIC					 1
-/* No match */
-#define UMATCH_NONE					 0
-
-#elif defined(__FreeBSD__)
-/* FreeBSD needs values less than zero */
-#define UMATCH_VENDOR_PRODUCT_REV			(-10)
-#define UMATCH_VENDOR_PRODUCT				(-20)
-#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			(-30)
-#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		(-40)
-#define UMATCH_DEVCLASS_DEVSUBCLASS			(-50)
-#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		(-60)
-#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		(-70)
-#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		(-80)
-#define UMATCH_VENDOR_IFACESUBCLASS			(-90)
-#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	(-100)
-#define UMATCH_IFACECLASS_IFACESUBCLASS			(-110)
-#define UMATCH_IFACECLASS				(-120)
-#define UMATCH_IFACECLASS_GENERIC			(-130)
-#define UMATCH_GENERIC					(-140)
-#define UMATCH_NONE					(ENXIO)
-
-#endif
-
-#define USBD_SHOW_DEVICE_CLASS		0x1
-#define USBD_SHOW_INTERFACE_CLASS	0x2
-
-#if defined(__FreeBSD__)
-int usbd_driver_load(module_t mod, int what, void *arg);
-
-static inline int
-usb_get_port(device_t dev)
-{
-	struct usb_attach_arg *uap = device_get_ivars(dev);
-	return (uap->port);
-}
-
-static inline struct usbd_interface *
-usb_get_iface(device_t dev)
-{
-	struct usb_attach_arg *uap = device_get_ivars(dev);
-	return (uap->iface);
-}
-
-#endif
-
-/* XXX Perhaps USB should have its own levels? */
-#ifdef USB_USE_SOFTINTR
-#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
-#define splusb splsoftnet
-#else
-#define	splusb splsoftclock
-#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
-#else
-#define splusb splbio
-#endif /* USB_USE_SOFTINTR */
-#define splhardusb splbio
-#define IPL_USB IPL_BIO
-
-#endif /* _USBDI_H_ */
+#include <dev/usb2/usb_subr.h>
diff -rubN /usr/src1/src/sys/dev/usb/usbdi_util.h /usr/src/sys/dev/usb/usbdi_util.h
--- /usr/src1/src/sys/dev/usb/usbdi_util.h	Tue Mar  1 08:01:22 2005
+++ /usr/src/sys/dev/usb/usbdi_util.h	Thu Jun  8 21:13:08 2006
@@ -1,95 +1 @@
-/*	$NetBSD: usbdi_util.h,v 1.31 2004/12/03 08:53:40 augustss Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usbdi_util.h,v 1.19 2005/03/01 08:01:22 sobomax Exp $	*/
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-usbd_status	usbd_get_desc(usbd_device_handle dev, int type,
-			      int index, int len, void *desc);
-usbd_status	usbd_get_config_desc(usbd_device_handle, int,
-				     usb_config_descriptor_t *);
-usbd_status	usbd_get_config_desc_full(usbd_device_handle, int, void *, int);
-usbd_status	usbd_get_device_desc(usbd_device_handle dev,
-				     usb_device_descriptor_t *d);
-usbd_status	usbd_set_address(usbd_device_handle dev, int addr);
-usbd_status	usbd_get_port_status(usbd_device_handle,
-				     int, usb_port_status_t *);
-usbd_status	usbd_set_hub_feature(usbd_device_handle dev, int);
-usbd_status	usbd_clear_hub_feature(usbd_device_handle, int);
-usbd_status	usbd_set_port_feature(usbd_device_handle dev, int, int);
-usbd_status	usbd_clear_port_feature(usbd_device_handle, int, int);
-usbd_status	usbd_get_device_status(usbd_device_handle, usb_status_t *);
-usbd_status	usbd_get_hub_status(usbd_device_handle, usb_hub_status_t *);
-usbd_status	usbd_get_protocol(usbd_interface_handle dev, u_int8_t *report);
-usbd_status	usbd_set_protocol(usbd_interface_handle dev, int report);
-usbd_status	usbd_get_report_descriptor(usbd_device_handle dev, int ifcno,
-					   int size, void *d);
-struct usb_hid_descriptor *usbd_get_hid_descriptor(usbd_interface_handle ifc);
-usbd_status	usbd_set_report(usbd_interface_handle iface, int type, int id,
-				void *data,int len);
-usbd_status	usbd_set_report_async(usbd_interface_handle iface, int type,
-				      int id, void *data, int len);
-usbd_status	usbd_get_report(usbd_interface_handle iface, int type, int id,
-				void *data, int len);
-usbd_status	usbd_set_idle(usbd_interface_handle iface, int duration, int id);
-usbd_status	usbd_read_report_desc(usbd_interface_handle ifc, void **descp,
-				      int *sizep, usb_malloc_type mem);
-usbd_status	usbd_get_config(usbd_device_handle dev, u_int8_t *conf);
-usbd_status	usbd_get_string_desc(usbd_device_handle dev, int sindex,
-				     int langid,usb_string_descriptor_t *sdesc,
-				     int *sizep);
-void		usbd_delay_ms(usbd_device_handle, u_int);
-
-
-usbd_status usbd_set_config_no(usbd_device_handle dev, int no, int msg);
-usbd_status usbd_set_config_index(usbd_device_handle dev, int index, int msg);
-
-usbd_status usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
-			       u_int16_t flags, u_int32_t timeout, void *buf,
-			       u_int32_t *size, char *lbl);
-
-usbd_status usbd_intr_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
-			       u_int16_t flags, u_int32_t timeout, void *buf,
-			       u_int32_t *size, char *lbl);
-
-void usb_detach_wait(device_ptr_t);
-void usb_detach_wakeup(device_ptr_t);
-
-const usb_descriptor_t *usb_find_desc(usbd_device_handle dev, int type,
-				      int subtype);
-#define USBD_SUBTYPE_ANY (~0)
-
+#include <dev/usb2/usb_subr.h>
diff -rubN /usr/src1/src/sys/dev/usb/usbdivar.h /usr/src/sys/dev/usb/usbdivar.h
--- /usr/src1/src/sys/dev/usb/usbdivar.h	Wed Mar  1 01:59:05 2006
+++ /usr/src/sys/dev/usb/usbdivar.h	Thu Jun  8 21:13:08 2006
@@ -1,321 +1 @@
-/*	$NetBSD: usbdivar.h,v 1.70 2002/07/11 21:14:36 augustss Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usbdivar.h,v 1.43.2.1 2006/03/01 01:59:05 iedowse Exp $	*/
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#if defined(__NetBSD__)
-#include <sys/callout.h>
-#endif
-
-/* From usb_mem.h */
-DECLARE_USB_DMA_T;
-
-struct usbd_xfer;
-struct usbd_pipe;
-
-struct usbd_endpoint {
-	usb_endpoint_descriptor_t *edesc;
-	int			refcnt;
-	int			savedtoggle;
-};
-
-struct usbd_bus_methods {
-	usbd_status	      (*open_pipe)(struct usbd_pipe *pipe);
-	void		      (*soft_intr)(void *);
-	void		      (*do_poll)(struct usbd_bus *);
-	usbd_status	      (*allocm)(struct usbd_bus *, usb_dma_t *,
-					u_int32_t bufsize);
-	void		      (*freem)(struct usbd_bus *, usb_dma_t *);
-	struct usbd_xfer *    (*allocx)(struct usbd_bus *);
-	void		      (*freex)(struct usbd_bus *, struct usbd_xfer *);
-};
-
-struct usbd_pipe_methods {
-	usbd_status	      (*transfer)(usbd_xfer_handle xfer);
-	usbd_status	      (*start)(usbd_xfer_handle xfer);
-	void		      (*abort)(usbd_xfer_handle xfer);
-	void		      (*close)(usbd_pipe_handle pipe);
-	void		      (*cleartoggle)(usbd_pipe_handle pipe);
-	void		      (*done)(usbd_xfer_handle xfer);
-};
-
-struct usbd_tt {
-	struct usbd_hub		*hub;
-};
-
-struct usbd_port {
-	usb_port_status_t	status;
-	u_int16_t		power;	/* mA of current on port */
-	u_int8_t		portno;
-	u_int8_t		restartcnt;
-#define USBD_RESTART_MAX 5
-	struct usbd_device     *device;	/* Connected device */
-	struct usbd_device     *parent;	/* The ports hub */
-	struct usbd_tt	       *tt; /* Transaction translator (if any) */
-};
-
-struct usbd_hub {
-	usbd_status	      (*explore)(usbd_device_handle hub);
-	void		       *hubsoftc;
-	usb_hub_descriptor_t	hubdesc;
-	struct usbd_port        ports[1];
-};
-
-struct usb_softc;
-
-/*****/
-
-struct usbd_bus {
-	/* Filled by HC driver */
-	USBBASEDEVICE		bdev; /* base device, host adapter */
-	struct usbd_bus_methods	*methods;
-	u_int32_t		pipe_size; /* size of a pipe struct */
-	/* Filled by usb driver */
-	struct usbd_device     *root_hub;
-	usbd_device_handle	devices[USB_MAX_DEVICES];
-	char			needs_explore;/* a hub a signalled a change */
-	char			use_polling;
-	struct usb_softc       *usbctl;
-	struct usb_device_stats	stats;
-	int 			intr_context;
-	u_int			no_intrs;
-	int			usbrev;	/* USB revision */
-#define USBREV_UNKNOWN	0
-#define USBREV_PRE_1_0	1
-#define USBREV_1_0	2
-#define USBREV_1_1	3
-#define USBREV_2_0	4
-#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1", "2.0" }
-
-#ifdef USB_USE_SOFTINTR
-#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
-	void		       *soft; /* soft interrupt cookie */
-#else
-	struct callout		softi;
-#endif
-#endif
-
-	bus_dma_tag_t		dmatag;	/* DMA tag */
-};
-
-struct usbd_device {
-	struct usbd_bus	       *bus;           /* our controller */
-	struct usbd_pipe       *default_pipe;  /* pipe 0 */
-	u_int8_t		address;       /* device addess */
-	u_int8_t		config;	       /* current configuration # */
-	u_int8_t		depth;         /* distance from root hub */
-	u_int8_t		speed;         /* low/full/high speed */
-	u_int8_t		self_powered;  /* flag for self powered */
-	u_int16_t		power;         /* mA the device uses */
-	int16_t			langid;	       /* language for strings */
-#define USBD_NOLANG (-1)
-	usb_event_cookie_t	cookie;	       /* unique connection id */
-	struct usbd_port       *powersrc;      /* upstream hub port, or 0 */
-	struct usbd_device     *myhub;	       /* upstream hub */
-	struct usbd_port       *myhsport;      /* closest high speed port */
-	struct usbd_endpoint	def_ep;	       /* for pipe 0 */
-	usb_endpoint_descriptor_t def_ep_desc; /* for pipe 0 */
-	struct usbd_interface  *ifaces;        /* array of all interfaces */
-	usb_device_descriptor_t ddesc;         /* device descriptor */
-	usb_config_descriptor_t *cdesc;	       /* full config descr */
-	const struct usbd_quirks     *quirks;  /* device quirks, always set */
-	struct usbd_hub	       *hub;           /* only if this is a hub */
-	device_ptr_t	       *subdevs;       /* sub-devices, 0 terminated */
-	uint8_t		       *ifacenums;     /* sub-device interfacenumbers */
-};
-
-struct usbd_interface {
-	struct usbd_device     *device;
-	usb_interface_descriptor_t *idesc;
-	int			index;
-	int			altindex;
-	struct usbd_endpoint   *endpoints;
-	void		       *priv;
-	LIST_HEAD(, usbd_pipe)	pipes;
-};
-
-struct usbd_pipe {
-	struct usbd_interface  *iface;
-	struct usbd_device     *device;
-	struct usbd_endpoint   *endpoint;
-	int			refcnt;
-	char			running;
-	char			aborting;
-	SIMPLEQ_HEAD(, usbd_xfer) queue;
-	LIST_ENTRY(usbd_pipe)	next;
-
-	usbd_xfer_handle	intrxfer; /* used for repeating requests */
-	char			repeat;
-	int			interval;
-
-	/* Filled by HC driver. */
-	struct usbd_pipe_methods *methods;
-};
-
-struct usbd_xfer {
-	struct usbd_pipe       *pipe;
-	void		       *priv;
-	void		       *buffer;
-	u_int32_t		length;
-	u_int32_t		actlen;
-	u_int16_t		flags;
-	u_int32_t		timeout;
-	usbd_status		status;
-	usbd_callback		callback;
-	__volatile char		done;
-#ifdef DIAGNOSTIC
-	u_int32_t		busy_free;
-#define XFER_FREE 0x46524545
-#define XFER_BUSY 0x42555359
-#define XFER_ONQU 0x4f4e5155
-#endif
-
-	/* For control pipe */
-	usb_device_request_t	request;
-
-	/* For isoc */
-	u_int16_t		*frlengths;
-	int			nframes;
-
-	/* For memory allocation */
-	struct usbd_device     *device;
-	usb_dma_t		dmabuf;
-
-	int			rqflags;
-#define URQ_REQUEST	0x01
-#define URQ_AUTO_DMABUF	0x10
-#define URQ_DEV_DMABUF	0x20
-
-	SIMPLEQ_ENTRY(usbd_xfer) next;
-
-	void		       *hcpriv; /* private use by the HC driver */
-
-	usb_callout_t		timeout_handle;
-};
-
-void usbd_init(void);
-void usbd_finish(void);
-
-#ifdef USB_DEBUG
-void usbd_dump_iface(struct usbd_interface *iface);
-void usbd_dump_device(struct usbd_device *dev);
-void usbd_dump_endpoint(struct usbd_endpoint *endp);
-void usbd_dump_queue(usbd_pipe_handle pipe);
-void usbd_dump_pipe(usbd_pipe_handle pipe);
-#endif
-
-/* Routines from usb_subr.c */
-int		usbctlprint(void *, const char *);
-void		usb_delay_ms(usbd_bus_handle, u_int);
-usbd_status	usbd_reset_port(usbd_device_handle dev,
-				int port, usb_port_status_t *ps);
-usbd_status	usbd_setup_pipe(usbd_device_handle dev,
-				usbd_interface_handle iface,
-				struct usbd_endpoint *, int,
-				usbd_pipe_handle *pipe);
-usbd_status	usbd_new_device(device_ptr_t parent,
-				usbd_bus_handle bus, int depth,
-				int lowspeed, int port,
-				struct usbd_port *);
-void		usbd_remove_device(usbd_device_handle, struct usbd_port *);
-int		usbd_printBCD(char *cp, int bcd);
-usbd_status	usbd_fill_iface_data(usbd_device_handle dev, int i, int a);
-void		usb_free_device(usbd_device_handle);
-
-usbd_status	usb_insert_transfer(usbd_xfer_handle xfer);
-void		usb_transfer_complete(usbd_xfer_handle xfer);
-void		usb_disconnect_port(struct usbd_port *up, device_ptr_t);
-
-/* Routines from usb.c */
-void		usb_needs_explore(usbd_device_handle);
-void		usb_schedsoftintr(struct usbd_bus *);
-
-/*
- * XXX This check is extremely bogus. Bad Bad Bad.
- */
-#if defined(DIAGNOSTIC) && 0
-#define SPLUSBCHECK \
-	do { int _s = splusb(), _su = splusb(); \
-             if (!cold && _s != _su) printf("SPLUSBCHECK failed 0x%x!=0x%x, %s:%d\n", \
-				   _s, _su, __FILE__, __LINE__); \
-	     splx(_s); \
-        } while (0)
-#else
-#define SPLUSBCHECK
-#endif
-
-/* Locator stuff. */
-
-#if defined(__NetBSD__)
-#include "locators.h"
-#elif defined(__FreeBSD__) || defined(__OpenBSD__)
-/* XXX these values are used to statically bind some elements in the USB tree
- * to specific driver instances. This should be somehow emulated in FreeBSD
- * but can be done later on.
- * The values are copied from the files.usb file in the NetBSD sources.
- */
-#define UHUBCF_PORT_DEFAULT -1
-#define UHUBCF_CONFIGURATION_DEFAULT -1
-#define UHUBCF_INTERFACE_DEFAULT -1
-#define UHUBCF_VENDOR_DEFAULT -1
-#define UHUBCF_PRODUCT_DEFAULT -1
-#define UHUBCF_RELEASE_DEFAULT -1
-#endif
-
-#if defined (__OpenBSD__)
-#define	UHUBCF_PORT		0
-#define	UHUBCF_CONFIGURATION	1
-#define	UHUBCF_INTERFACE	2
-#define	UHUBCF_VENDOR		3
-#define	UHUBCF_PRODUCT		4
-#define	UHUBCF_RELEASE		5
-#endif
-
-#define	uhubcf_port		cf_loc[UHUBCF_PORT]
-#define	uhubcf_configuration	cf_loc[UHUBCF_CONFIGURATION]
-#define	uhubcf_interface	cf_loc[UHUBCF_INTERFACE]
-#define	uhubcf_vendor		cf_loc[UHUBCF_VENDOR]
-#define	uhubcf_product		cf_loc[UHUBCF_PRODUCT]
-#define	uhubcf_release		cf_loc[UHUBCF_RELEASE]
-#define	UHUB_UNK_PORT		UHUBCF_PORT_DEFAULT /* wildcarded 'port' */
-#define	UHUB_UNK_CONFIGURATION	UHUBCF_CONFIGURATION_DEFAULT /* wildcarded 'configuration' */
-#define	UHUB_UNK_INTERFACE	UHUBCF_INTERFACE_DEFAULT /* wildcarded 'interface' */
-#define	UHUB_UNK_VENDOR		UHUBCF_VENDOR_DEFAULT /* wildcarded 'vendor' */
-#define	UHUB_UNK_PRODUCT	UHUBCF_PRODUCT_DEFAULT /* wildcarded 'product' */
-#define	UHUB_UNK_RELEASE	UHUBCF_RELEASE_DEFAULT /* wildcarded 'release' */
-
+#include <dev/usb2/usb_subr.h>
diff -rubN /usr/src1/src/sys/dev/usb/uvisor.c /usr/src/sys/dev/usb/uvisor.c
--- /usr/src1/src/sys/dev/usb/uvisor.c	Mon Dec 12 19:52:52 2005
+++ /usr/src/sys/dev/usb/uvisor.c	Thu Jun  8 21:13:09 2006
@@ -62,6 +62,7 @@
 #include <sys/device.h>
 #elif defined(__FreeBSD__)
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/bus.h>
 #endif
 #include <sys/conf.h>
diff -rubN /usr/src1/src/sys/dev/usb/uvisor.c.orig /usr/src/sys/dev/usb/uvisor.c.orig
--- /usr/src1/src/sys/dev/usb/uvisor.c.orig	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb/uvisor.c.orig	Mon Dec 12 19:52:52 2005
@@ -0,0 +1,648 @@
+/*	$NetBSD: uvisor.c,v 1.9 2001/01/23 14:04:14 augustss Exp $	*/
+/*      $FreeBSD: src/sys/dev/usb/uvisor.c,v 1.24.2.1 2005/12/12 19:52:52 bmah Exp $	*/
+
+/* Also already merged from NetBSD:
+ *	$NetBSD: uvisor.c,v 1.12 2001/11/13 06:24:57 lukem Exp $
+ *	$NetBSD: uvisor.c,v 1.13 2002/02/11 15:11:49 augustss Exp $
+ *	$NetBSD: uvisor.c,v 1.14 2002/02/27 23:00:03 augustss Exp $
+ *	$NetBSD: uvisor.c,v 1.15 2002/06/16 15:01:31 augustss Exp $
+ *	$NetBSD: uvisor.c,v 1.16 2002/07/11 21:14:36 augustss Exp $
+ *	$NetBSD: uvisor.c,v 1.17 2002/08/13 11:38:15 augustss Exp $
+ *	$NetBSD: uvisor.c,v 1.18 2003/02/05 00:50:14 augustss Exp $
+ *	$NetBSD: uvisor.c,v 1.19 2003/02/07 18:12:37 augustss Exp $
+ *	$NetBSD: uvisor.c,v 1.20 2003/04/11 01:30:10 simonb Exp $
+ */
+
+
+/*-
+ * Copyright (c) 2000 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Handspring Visor (Palmpilot compatible PDA) driver
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/device.h>
+#elif defined(__FreeBSD__)
+#include <sys/module.h>
+#include <sys/bus.h>
+#endif
+#include <sys/conf.h>
+#include <sys/tty.h>
+#include <sys/sysctl.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbhid.h>
+
+#include <dev/usb/usbdi.h>
+#include <dev/usb/usbdi_util.h>
+#include "usbdevs.h"
+
+#include <dev/usb/ucomvar.h>
+
+#ifdef USB_DEBUG
+#define DPRINTF(x)	if (uvisordebug) printf x
+#define DPRINTFN(n,x)	if (uvisordebug>(n)) printf x
+int uvisordebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, uvisor, CTLFLAG_RW, 0, "USB uvisor");
+SYSCTL_INT(_hw_usb_uvisor, OID_AUTO, debug, CTLFLAG_RW,
+	   &uvisordebug, 0, "uvisor debug level");
+#else
+#define DPRINTF(x)
+#define DPRINTFN(n,x)
+#endif
+
+#define UVISOR_CONFIG_INDEX	0
+#define UVISOR_IFACE_INDEX	0
+#define UVISOR_MODVER		1
+
+/* From the Linux driver */
+/*
+ * UVISOR_REQUEST_BYTES_AVAILABLE asks the visor for the number of bytes that
+ * are available to be transfered to the host for the specified endpoint.
+ * Currently this is not used, and always returns 0x0001
+ */
+#define UVISOR_REQUEST_BYTES_AVAILABLE		0x01
+
+/*
+ * UVISOR_CLOSE_NOTIFICATION is set to the device to notify it that the host
+ * is now closing the pipe. An empty packet is sent in response.
+ */
+#define UVISOR_CLOSE_NOTIFICATION		0x02
+
+/*
+ * UVISOR_GET_CONNECTION_INFORMATION is sent by the host during enumeration to
+ * get the endpoints used by the connection.
+ */
+#define UVISOR_GET_CONNECTION_INFORMATION	0x03
+
+
+/*
+ * UVISOR_GET_CONNECTION_INFORMATION returns data in the following format
+ */
+#define UVISOR_MAX_CONN 8
+struct uvisor_connection_info {
+	uWord	num_ports;
+	struct {
+		uByte	port_function_id;
+		uByte	port;
+	} connections[UVISOR_MAX_CONN];
+};
+#define UVISOR_CONNECTION_INFO_SIZE 18
+
+/* struct uvisor_connection_info.connection[x].port defines: */
+#define UVISOR_ENDPOINT_1		0x01
+#define UVISOR_ENDPOINT_2		0x02
+
+/* struct uvisor_connection_info.connection[x].port_function_id defines: */
+#define UVISOR_FUNCTION_GENERIC		0x00
+#define UVISOR_FUNCTION_DEBUGGER	0x01
+#define UVISOR_FUNCTION_HOTSYNC		0x02
+#define UVISOR_FUNCTION_CONSOLE		0x03
+#define UVISOR_FUNCTION_REMOTE_FILE_SYS	0x04
+
+/*
+ * Unknown PalmOS stuff.
+ */
+#define UVISOR_GET_PALM_INFORMATION		0x04
+#define UVISOR_GET_PALM_INFORMATION_LEN		0x44
+
+struct uvisor_palm_connection_info {
+        uByte   num_ports;
+        uByte   endpoint_numbers_different;
+        uWord   reserved1;
+  struct {
+                uDWord  port_function_id;
+                uByte   port;
+                uByte   end_point_info;
+                uWord   reserved;
+  } connections[UVISOR_MAX_CONN];
+};
+
+
+/*
+ * Crank down UVISORBUFSIZE from 1024 to 64 to avoid a problem where
+ * the Palm device and the USB host controller deadlock. The USB host
+ * controller is expecting an early-end-of-transmission packet with 0
+ * data, and the Palm doesn't send one because it's already
+ * communicated the amount of data it's going to send in a header
+ * (which ucom/uvisor are oblivious to). This is the problem that has
+ * been known on the pilot-link lists as the "[Free]BSD USB problem",
+ * but not understood.
+ */
+#define UVISORIBUFSIZE 64
+#define UVISOROBUFSIZE 1024
+
+struct uvisor_softc {
+	struct ucom_softc	sc_ucom;
+	u_int16_t		sc_flags;
+};
+
+Static usbd_status uvisor_init(struct uvisor_softc *);
+
+/*Static usbd_status clie_3_5_init(struct uvisor_softc *);*/
+
+Static void uvisor_close(void *, int);
+
+struct ucom_callback uvisor_callback = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	uvisor_close,
+	NULL,
+	NULL,
+};
+
+Static device_probe_t uvisor_match;
+Static device_attach_t uvisor_attach;
+Static device_detach_t uvisor_detach;
+Static device_method_t uvisor_methods[] = {
+       /* Device interface */
+       DEVMETHOD(device_probe, uvisor_match),
+       DEVMETHOD(device_attach, uvisor_attach),
+       DEVMETHOD(device_detach, uvisor_detach),
+       { 0, 0 }
+ };
+
+
+Static driver_t uvisor_driver = {
+       "ucom",
+       uvisor_methods,
+       sizeof (struct uvisor_softc)
+};
+
+DRIVER_MODULE(uvisor, uhub, uvisor_driver, ucom_devclass, usbd_driver_load, 0);
+MODULE_DEPEND(uvisor, usb, 1, 1, 1);
+MODULE_DEPEND(uvisor, ucom, UCOM_MINVER, UCOM_PREFVER, UCOM_MAXVER);
+MODULE_VERSION(uvisor, UVISOR_MODVER);
+
+struct uvisor_type {
+	struct usb_devno	uv_dev;
+	u_int16_t		uv_flags;
+#define PALM4	0x0001
+#define VISOR   0x0002
+#define PALM35  0x0004
+};
+static const struct uvisor_type uvisor_devs[] = {
+	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_VISOR }, VISOR },
+	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_TREO }, PALM4 },
+	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_TREO600 }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M500 }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M505 }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M515 }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_I705 }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M125 }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M130 }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_TUNGSTEN_Z }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_TUNGSTEN_T }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_ZIRE }, PALM4 },
+	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_ZIRE31 }, PALM4 },
+	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_40 }, 0 },
+	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_41 }, PALM4 },
+	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_S360 }, PALM4 },
+	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_NX60 }, PALM4 },
+	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_35 }, PALM35 },
+/*	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_25 }, PALM4 },*/
+	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_TJ37 }, PALM4 },
+};
+#define uvisor_lookup(v, p) ((const struct uvisor_type *)usb_lookup(uvisor_devs, v, p))
+
+
+USB_MATCH(uvisor)
+{
+	USB_MATCH_START(uvisor, uaa);
+
+	if (uaa->iface != NULL)
+		return (UMATCH_NONE);
+
+	DPRINTFN(20,("uvisor: vendor=0x%x, product=0x%x\n",
+		     uaa->vendor, uaa->product));
+
+	return (uvisor_lookup(uaa->vendor, uaa->product) != NULL ?
+		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
+}
+
+USB_ATTACH(uvisor)
+{
+	USB_ATTACH_START(uvisor, sc, uaa);
+	usbd_device_handle dev = uaa->device;
+	usbd_interface_handle iface;
+	usb_interface_descriptor_t *id;
+	usb_endpoint_descriptor_t *ed;
+	char *devinfo;
+	const char *devname;
+	int i;
+	usbd_status err;
+	struct ucom_softc *ucom;
+
+	devinfo = malloc(1024, M_USBDEV, M_WAITOK);
+	ucom = &sc->sc_ucom;
+
+	bzero(sc, sizeof (struct uvisor_softc));
+	usbd_devinfo(dev, 0, devinfo);
+
+	ucom->sc_dev = self;
+	device_set_desc_copy(self, devinfo);
+
+	ucom->sc_udev = dev;
+	ucom->sc_iface = uaa->iface;
+
+	devname = USBDEVNAME(ucom->sc_dev);
+	printf("%s: %s\n", devname, devinfo);
+
+	DPRINTFN(10,("\nuvisor_attach: sc=%p\n", sc));
+
+	/* Move the device into the configured state. */
+	err = usbd_set_config_index(dev, UVISOR_CONFIG_INDEX, 1);
+	if (err) {
+		printf("\n%s: failed to set configuration, err=%s\n",
+		       devname, usbd_errstr(err));
+		goto bad;
+	}
+
+	err = usbd_device2interface_handle(dev, UVISOR_IFACE_INDEX, &iface);
+	if (err) {
+		printf("\n%s: failed to get interface, err=%s\n",
+		       devname, usbd_errstr(err));
+		goto bad;
+	}
+
+	printf("%s: %s\n", devname, devinfo);
+
+	sc->sc_flags = uvisor_lookup(uaa->vendor, uaa->product)->uv_flags;
+
+	id = usbd_get_interface_descriptor(iface);
+
+	ucom->sc_udev = dev;
+	ucom->sc_iface = iface;
+
+	ucom->sc_bulkin_no = ucom->sc_bulkout_no = -1;
+	for (i = 0; i < id->bNumEndpoints; i++) {
+		int addr, dir, attr;
+		ed = usbd_interface2endpoint_descriptor(iface, i);
+		if (ed == NULL) {
+			printf("%s: could not read endpoint descriptor"
+			       ": %s\n", devname, usbd_errstr(err));
+			goto bad;
+		}
+
+		addr = ed->bEndpointAddress;
+		dir = UE_GET_DIR(ed->bEndpointAddress);
+		attr = ed->bmAttributes & UE_XFERTYPE;
+		if (dir == UE_DIR_IN && attr == UE_BULK)
+			ucom->sc_bulkin_no = addr;
+		else if (dir == UE_DIR_OUT && attr == UE_BULK)
+			ucom->sc_bulkout_no = addr;
+		else {
+			printf("%s: unexpected endpoint\n", devname);
+			goto bad;
+		}
+	}
+	if (ucom->sc_bulkin_no == -1) {
+		printf("%s: Could not find data bulk in\n",
+		       USBDEVNAME(ucom->sc_dev));
+		goto bad;
+	}
+	if (ucom->sc_bulkout_no == -1) {
+		printf("%s: Could not find data bulk out\n",
+		       USBDEVNAME(ucom->sc_dev));
+		goto bad;
+	}
+
+	ucom->sc_parent = sc;
+	ucom->sc_portno = UCOM_UNK_PORTNO;
+	/* bulkin, bulkout set above */
+	ucom->sc_ibufsize = UVISORIBUFSIZE;
+	ucom->sc_obufsize = UVISOROBUFSIZE;
+	ucom->sc_ibufsizepad = UVISORIBUFSIZE;
+	ucom->sc_opkthdrlen = 0;
+	ucom->sc_callback = &uvisor_callback;
+
+#if 0
+	if (uaa->vendor == USB_VENDOR_SONY &&
+	    uaa->product == USB_PRODUCT_SONY_CLIE_35)
+		err = clie_3_5_init(sc);
+	else
+#endif
+		err = uvisor_init(sc);
+
+	if (err) {
+		printf("%s: init failed, %s\n", USBDEVNAME(ucom->sc_dev),
+		       usbd_errstr(err));
+		goto bad;
+	}
+
+	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, ucom->sc_udev,
+			   USBDEV(ucom->sc_dev));
+
+	DPRINTF(("uvisor: in=0x%x out=0x%x\n", ucom->sc_bulkin_no, ucom->sc_bulkout_no));
+	ucom_attach(&sc->sc_ucom);
+
+	USB_ATTACH_SUCCESS_RETURN;
+
+bad:
+	DPRINTF(("uvisor_attach: ATTACH ERROR\n"));
+	ucom->sc_dying = 1;
+	USB_ATTACH_ERROR_RETURN;
+}
+
+#if 0
+
+int
+uvisor_activate(device_ptr_t self, enum devact act)
+{
+	struct uvisor_softc *sc = (struct uvisor_softc *)self;
+	int rv = 0;
+
+	switch (act) {
+	case DVACT_ACTIVATE:
+		return (EOPNOTSUPP);
+		break;
+
+	case DVACT_DEACTIVATE:
+		if (sc->sc_subdev != NULL)
+			rv = config_deactivate(sc->sc_subdev);
+		sc->sc_dying = 1;
+		break;
+	}
+	return (rv);
+}
+
+#endif
+
+USB_DETACH(uvisor)
+{
+	USB_DETACH_START(uvisor, sc);
+	int rv = 0;
+
+	DPRINTF(("uvisor_detach: sc=%p\n", sc));
+	sc->sc_ucom.sc_dying = 1;
+	rv = ucom_detach(&sc->sc_ucom);
+
+	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_ucom.sc_udev,
+			   USBDEV(sc->sc_ucom.sc_dev));
+
+	return (rv);
+}
+
+usbd_status
+uvisor_init(struct uvisor_softc *sc)
+{
+	usbd_status err;
+	usb_device_request_t req;
+	struct uvisor_connection_info coninfo;
+	struct uvisor_palm_connection_info pconinfo;
+	int actlen;
+	uWord avail;
+	char buffer[256];
+
+	if (sc->sc_flags & VISOR) {
+	  DPRINTF(("uvisor_init: getting connection info\n"));
+	  req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
+	  req.bRequest = UVISOR_GET_CONNECTION_INFORMATION;
+	  USETW(req.wValue, 0);
+	  USETW(req.wIndex, 0);
+	  USETW(req.wLength, UVISOR_CONNECTION_INFO_SIZE);
+	  err = usbd_do_request_flags(sc->sc_ucom.sc_udev, &req, &coninfo,
+				      USBD_SHORT_XFER_OK, &actlen,
+				      USBD_DEFAULT_TIMEOUT);
+	  if (err)
+	    return (err);
+	}
+#ifdef USB_DEBUG
+	{
+		int i, np;
+		char *string;
+
+		np = UGETW(coninfo.num_ports);
+		printf("%s: Number of ports: %d\n", USBDEVNAME(sc->sc_ucom.sc_dev), np);
+		for (i = 0; i < np; ++i) {
+			switch (coninfo.connections[i].port_function_id) {
+			case UVISOR_FUNCTION_GENERIC:
+				string = "Generic";
+				break;
+			case UVISOR_FUNCTION_DEBUGGER:
+				string = "Debugger";
+				break;
+			case UVISOR_FUNCTION_HOTSYNC:
+				string = "HotSync";
+				break;
+			case UVISOR_FUNCTION_REMOTE_FILE_SYS:
+				string = "Remote File System";
+				break;
+			default:
+				string = "unknown";
+				break;
+			}
+			printf("%s: port %d, is for %s\n",
+			    USBDEVNAME(sc->sc_ucom.sc_dev), coninfo.connections[i].port,
+			    string);
+		}
+	}
+#endif
+
+	if (sc->sc_flags & PALM4) {
+	        int port;
+		/* Palm OS 4.0 Hack */
+		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
+		req.bRequest = UVISOR_GET_PALM_INFORMATION;
+		USETW(req.wValue, 0);
+		USETW(req.wIndex, 0);
+		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
+		err = usbd_do_request_flags(sc->sc_ucom.sc_udev, &req, &pconinfo,
+					    USBD_SHORT_XFER_OK, &actlen,
+					    USBD_DEFAULT_TIMEOUT);
+		if (err)
+			return (err);
+
+		if (pconinfo.endpoint_numbers_different) {
+			port = pconinfo.connections[0].end_point_info;
+			sc->sc_ucom.sc_bulkin_no = (port >> 4) | UE_DIR_IN;
+			sc->sc_ucom.sc_bulkout_no = (port & 0xf) | UE_DIR_OUT;
+		} else {
+			port = pconinfo.connections[0].port;
+			sc->sc_ucom.sc_bulkin_no = port | UE_DIR_IN;
+			sc->sc_ucom.sc_bulkout_no = port | UE_DIR_OUT;
+		}
+#if 0
+		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
+		req.bRequest = UVISOR_GET_PALM_INFORMATION;
+		USETW(req.wValue, 0);
+		USETW(req.wIndex, 0);
+		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
+		err = usbd_do_request(sc->sc_ucom.sc_udev, &req, buffer);
+		if (err)
+			return (err);
+#endif
+	}
+
+	if (sc->sc_flags & PALM35) {
+	  /* get the config number */
+	  DPRINTF(("clie_3_5_init: getting config info\n"));
+	  req.bmRequestType = UT_READ;
+	  req.bRequest = UR_GET_CONFIG;
+	  USETW(req.wValue, 0);
+	  USETW(req.wIndex, 0);
+	  USETW(req.wLength, 1);
+	  err = usbd_do_request(sc->sc_ucom.sc_udev, &req, buffer);
+	  if (err)
+	    return (err);
+  
+	  /* get the interface number */
+	  DPRINTF(("clie_3_5_init: get the interface number\n"));
+	  req.bmRequestType = UT_READ_DEVICE;
+	  req.bRequest = UR_GET_INTERFACE;
+	  USETW(req.wValue, 0);
+	  USETW(req.wIndex, 0);
+	  USETW(req.wLength, 1);
+	  err = usbd_do_request(sc->sc_ucom.sc_udev, &req, buffer);
+	  if (err)
+	    return (err);
+	}
+
+	DPRINTF(("uvisor_init: getting available bytes\n"));
+	req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
+	req.bRequest = UVISOR_REQUEST_BYTES_AVAILABLE;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, 5);
+	USETW(req.wLength, sizeof avail);
+	err = usbd_do_request(sc->sc_ucom.sc_udev, &req, &avail);
+	if (err)
+		return (err);
+	DPRINTF(("uvisor_init: avail=%d\n", UGETW(avail)));
+
+	DPRINTF(("uvisor_init: done\n"));
+	return (err);
+}
+
+#if 0
+usbd_status
+clie_3_5_init(struct uvisor_softc *sc)
+{
+	usbd_status err;
+	usb_device_request_t req;
+	char buffer[256];
+
+	/*
+	 * Note that PEG-300 series devices expect the following two calls.
+	 */
+
+	/* get the config number */
+	DPRINTF(("clie_3_5_init: getting config info\n"));
+	req.bmRequestType = UT_READ;
+	req.bRequest = UR_GET_CONFIG;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, 1);
+	err = usbd_do_request(sc->sc_ucom.sc_udev, &req, buffer);
+	if (err)
+		return (err);
+
+	/* get the interface number */
+	DPRINTF(("clie_3_5_init: get the interface number\n"));
+	req.bmRequestType = UT_READ_DEVICE;
+	req.bRequest = UR_GET_INTERFACE;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, 1);
+	err = usbd_do_request(sc->sc_ucom.sc_udev, &req, buffer);
+	if (err)
+		return (err);
+
+#ifdef USB_DEBUG
+	{
+		struct uvisor_connection_info coninfo;
+		int i, np;
+		char *string;
+
+		np = UGETW(coninfo.num_ports);
+		DPRINTF(("%s: Number of ports: %d\n", USBDEVNAME(sc->sc_ucom.sc_dev), np));
+		for (i = 0; i < np; ++i) {
+			switch (coninfo.connections[i].port_function_id) {
+			case UVISOR_FUNCTION_GENERIC:
+				string = "Generic";
+				break;
+			case UVISOR_FUNCTION_DEBUGGER:
+				string = "Debugger";
+				break;
+			case UVISOR_FUNCTION_HOTSYNC:
+				string = "HotSync";
+				break;
+			case UVISOR_FUNCTION_REMOTE_FILE_SYS:
+				string = "Remote File System";
+				break;
+			default:
+				string = "unknown";
+				break;	
+			}
+			DPRINTF(("%s: port %d, is for %s\n",
+			    USBDEVNAME(sc->sc_ucom.sc_dev), coninfo.connections[i].port,
+			    string));
+		}
+	}
+#endif
+
+	DPRINTF(("clie_3_5_init: done\n"));
+	return (err);
+}
+#endif
+
+void
+uvisor_close(void *addr, int portno)
+{
+	struct uvisor_softc *sc = addr;
+	usb_device_request_t req;
+	struct uvisor_connection_info coninfo; /* XXX ? */
+	int actlen;
+
+	if (sc->sc_ucom.sc_dying)
+		return;
+
+	req.bmRequestType = UT_READ_VENDOR_ENDPOINT; /* XXX read? */
+	req.bRequest = UVISOR_CLOSE_NOTIFICATION;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, UVISOR_CONNECTION_INFO_SIZE);
+	(void)usbd_do_request_flags(sc->sc_ucom.sc_udev, &req, &coninfo,
+				    USBD_SHORT_XFER_OK, &actlen,
+				    USBD_DEFAULT_TIMEOUT);
+}
diff -rubN /usr/src1/src/sys/dev/usb2/CVS/Entries /usr/src/sys/dev/usb2/CVS/Entries
--- /usr/src1/src/sys/dev/usb2/CVS/Entries	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/CVS/Entries	Thu Jun  8 21:18:38 2006
@@ -0,0 +1,23 @@
+/_ehci.c/0/Initial _ehci.c//TRELENG_6_1
+/_ehci_pci.c/0/Initial _ehci_pci.c//TRELENG_6_1
+/_ohci.c/0/Initial _ohci.c//TRELENG_6_1
+/_ohci_pci.c/0/Initial _ohci_pci.c//TRELENG_6_1
+/_ugen.c/0/Initial _ugen.c//TRELENG_6_1
+/_uhci.c/0/Initial _uhci.c//TRELENG_6_1
+/_uhci_pci.c/0/Initial _uhci_pci.c//TRELENG_6_1
+/_uhub.c/0/Initial _uhub.c//TRELENG_6_1
+/_usb.c/0/Initial _usb.c//TRELENG_6_1
+/_usb_requests.c/0/Initial _usb_requests.c//TRELENG_6_1
+/_usb_subr.c/0/Initial _usb_subr.c//TRELENG_6_1
+/_usb_transfer.c/0/Initial _usb_transfer.c//TRELENG_6_1
+/ehci.h/0/Initial ehci.h//TRELENG_6_1
+/hid.h/0/Initial hid.h//TRELENG_6_1
+/ohci.h/0/Initial ohci.h//TRELENG_6_1
+/uhci.h/0/Initial uhci.h//TRELENG_6_1
+/usb.h/0/Initial usb.h//TRELENG_6_1
+/usb_hid.h/0/Initial usb_hid.h//TRELENG_6_1
+/usb_hid_copy.h/0/Initial usb_hid_copy.h//TRELENG_6_1
+/usb_port.h/0/Initial usb_port.h//TRELENG_6_1
+/usb_quirks.h/0/Initial usb_quirks.h//TRELENG_6_1
+/usb_subr.h/0/Initial usb_subr.h//TRELENG_6_1
+D
diff -rubN /usr/src1/src/sys/dev/usb2/CVS/Repository /usr/src/sys/dev/usb2/CVS/Repository
--- /usr/src1/src/sys/dev/usb2/CVS/Repository	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/CVS/Repository	Thu Jun  8 21:16:16 2006
@@ -0,0 +1 @@
+src/sys/dev/usb2
diff -rubN /usr/src1/src/sys/dev/usb2/CVS/Root /usr/src/sys/dev/usb2/CVS/Root
--- /usr/src1/src/sys/dev/usb2/CVS/Root	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/CVS/Root	Thu Jun  8 21:16:16 2006
@@ -0,0 +1 @@
+/home/ncvs
diff -rubN /usr/src1/src/sys/dev/usb2/CVS/Tag /usr/src/sys/dev/usb2/CVS/Tag
--- /usr/src1/src/sys/dev/usb2/CVS/Tag	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/CVS/Tag	Thu Jun  8 21:16:16 2006
@@ -0,0 +1 @@
+TRELENG_6_1
diff -rubN /usr/src1/src/sys/dev/usb2/_ehci.c /usr/src/sys/dev/usb2/_ehci.c
--- /usr/src1/src/sys/dev/usb2/_ehci.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_ehci.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,3736 @@
+/*-
+ * Copyright (c) 2004 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) and by Charles M. Hannum.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * USB Enhanced Host Controller Driver, a.k.a. USB 2.0 controller.
+ *
+ * The EHCI 0.96 spec can be found at
+ * http://developer.intel.com/technology/usb/download/ehci-r096.pdf
+ * The EHCI 1.0 spec can be found at
+ * http://developer.intel.com/technology/usb/download/ehci-r10.pdf
+ * and the USB 2.0 spec at
+ * http://www.usb.org/developers/docs/usb_20.zip
+ *
+ */
+
+/*
+ * TODO:
+ * 1) command failures are not recovered correctly
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/endian.h>
+#include <sys/queue.h> /* LIST_XXX() */
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h> /* bus_space_xxx() */
+
+#define INCLUDE_PCIXXX_H
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/ehci.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb/ehci.c,v 1.18 2004/11/09 20:51:32 iedowse Exp $");
+
+#define MS_TO_TICKS(ms) (((ms) * hz) / 1000)
+#define EHCI_BUS2SC(bus) ((ehci_softc_t *)(((u_int8_t *)(bus)) - \
+   POINTER_TO_UNSIGNED(&(((ehci_softc_t *)0)->sc_bus))))
+
+#ifdef USB_DEBUG
+#define DPRINTF(x)	{ if (ehcidebug) { printf("%s: ", __FUNCTION__); printf x ; } }
+#define DPRINTFN(n,x)	{ if (ehcidebug > (n)) { printf("%s: ", __FUNCTION__); printf x ; } }
+int ehcidebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, ehci, CTLFLAG_RW, 0, "USB ehci");
+SYSCTL_INT(_hw_usb_ehci, OID_AUTO, debug, CTLFLAG_RW,
+	   &ehcidebug, 0, "ehci debug level");
+
+static void
+ehci_dump_regs(ehci_softc_t *sc);
+static void
+ehci_dump_sqh(ehci_qh_t *sqh);
+#else
+#define DPRINTF(x)
+#define DPRINTFN(n,x)
+#endif
+
+#define EHCI_INTR_ENDPT 1
+
+extern struct usbd_bus_methods ehci_bus_methods;
+extern struct usbd_pipe_methods ehci_device_bulk_methods;
+extern struct usbd_pipe_methods ehci_device_ctrl_methods;
+extern struct usbd_pipe_methods ehci_device_intr_methods;
+extern struct usbd_pipe_methods ehci_device_isoc_fs_methods;
+extern struct usbd_pipe_methods ehci_device_isoc_hs_methods;
+extern struct usbd_pipe_methods ehci_root_ctrl_methods;
+extern struct usbd_pipe_methods ehci_root_intr_methods;
+
+#define PHYSADDR(sc,what) \
+  ((sc)->sc_physaddr + POINTER_TO_UNSIGNED(&(((struct ehci_softc *)0)->what)))
+
+usbd_status
+ehci_init(ehci_softc_t *sc)
+{
+	u_int32_t version, sparams, cparams, hcr;
+	u_int i;
+	u_int16_t x;
+	u_int16_t y;
+	u_int16_t bit;
+	usbd_status err = 0;
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	DPRINTF(("start\n"));
+
+	LIST_INIT(&sc->sc_interrupt_list_head);
+
+	__callout_init_mtx(&sc->sc_tmo_pcd, &sc->sc_bus.mtx, 
+			   CALLOUT_RETURNUNLOCKED);
+
+#ifdef USB_DEBUG
+	if(ehcidebug > 2)
+	{
+		ehci_dump_regs(sc);
+	}
+#endif
+
+	sc->sc_offs = EREAD1(sc, EHCI_CAPLENGTH);
+
+	version = EREAD2(sc, EHCI_HCIVERSION);
+	device_printf(sc->sc_bus.bdev, "EHCI version %x.%x\n",
+		      version >> 8, version & 0xff);
+
+	sparams = EREAD4(sc, EHCI_HCSPARAMS);
+	DPRINTF(("sparams=0x%x\n", sparams));
+
+	sc->sc_noport = EHCI_HCS_N_PORTS(sparams);
+	cparams = EREAD4(sc, EHCI_HCCPARAMS);
+	DPRINTF(("cparams=0x%x\n", cparams));
+
+	if(EHCI_HCC_64BIT(cparams))
+	{
+		DPRINTF(("HCC uses 64-bit structures\n"));
+
+		/* MUST clear segment register if 64 bit capable */
+		EWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);
+	}
+
+	sc->sc_bus.usbrev = USBREV_2_0;
+
+	/* Reset the controller */
+	DPRINTF(("%s: resetting\n", device_get_nameunit(sc->sc_bus.bdev)));
+	EOWRITE4(sc, EHCI_USBCMD, 0);	/* Halt controller */
+	DELAY(1000*1);
+	EOWRITE4(sc, EHCI_USBCMD, EHCI_CMD_HCRESET);
+	for(i = 0; i < 100; i++)
+	{
+		DELAY(1000*1);
+		hcr = EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_HCRESET;
+		if(!hcr)
+		{
+			break;
+		}
+	}
+
+	if(hcr)
+	{
+		device_printf(sc->sc_bus.bdev, "reset timeout\n");
+		err = USBD_IOERROR;
+		goto done;
+	}
+
+	/* use current frame-list-size selection
+	 * 0: 1024*4 bytes
+	 * 1:  512*4 bytes
+	 * 2:  256*4 bytes
+	 * 3:      unknown
+	 */
+	if(EHCI_CMD_FLS(EOREAD4(sc, EHCI_USBCMD)) == 3)
+	{
+		device_printf(sc->sc_bus.bdev, "invalid frame-list-size\n");
+		err = USBD_IOERROR;
+		goto done;
+	}
+
+	/* set up the bus struct */
+	sc->sc_bus.methods = &ehci_bus_methods;
+
+	sc->sc_eintrs = EHCI_NORMAL_INTRS;
+
+	for(i = 0; i < EHCI_VIRTUAL_FRAMELIST_COUNT; i++)
+	{
+		sc->sc_hw.intr_start[i].qh_self = 
+		  htole32(PHYSADDR(sc,sc_hw.intr_start[i])|EHCI_LINK_QH);
+
+		sc->sc_hw.intr_start[i].qh_endp = 
+		  htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_HIGH));
+		sc->sc_hw.intr_start[i].qh_endphub = 
+		  htole32(EHCI_QH_SET_MULT(1));
+		sc->sc_hw.intr_start[i].qh_curqtd = 0;
+
+		sc->sc_hw.intr_start[i].qh_qtd.qtd_next = 
+		  htole32(EHCI_LINK_TERMINATE);
+		sc->sc_hw.intr_start[i].qh_qtd.qtd_altnext = 
+		  htole32(EHCI_LINK_TERMINATE);
+		sc->sc_hw.intr_start[i].qh_qtd.qtd_status = 
+		  htole32(EHCI_QTD_HALTED);
+
+		sc->sc_intr_p_last[i] = 
+		  &sc->sc_hw.intr_start[i];
+	}
+
+	/*
+	 * the QHs are arranged to give poll intervals that are
+	 * powers of 2 times 1ms
+	 */
+	bit = EHCI_VIRTUAL_FRAMELIST_COUNT/2;
+	while(bit)
+	{
+		x = bit;
+		while(x & bit)
+		{
+			y = (x ^ bit)|(bit/2);
+
+			/* the next QH has half the
+			 * poll interval
+			 */
+			sc->sc_hw.intr_start[x].qh_link =
+			  sc->sc_hw.intr_start[y].qh_self;
+			x++;
+		}
+		bit >>= 1;
+	}
+
+	/* the last (1ms) QH terminates */
+	sc->sc_hw.intr_start[0].qh_link = htole32(EHCI_LINK_TERMINATE);
+
+	for(i = 0; i < EHCI_VIRTUAL_FRAMELIST_COUNT; i++)
+	{
+		/* initialize full speed isochronous */
+
+		sc->sc_hw.isoc_fs_start[i].sitd_self = 
+		  htole32(PHYSADDR(sc,sc_hw.isoc_fs_start[i])|EHCI_LINK_SITD);
+
+		sc->sc_hw.isoc_fs_start[i].sitd_back = 
+		  htole32(EHCI_LINK_TERMINATE);
+
+		sc->sc_hw.isoc_fs_start[i].sitd_next = 
+		  sc->sc_hw.intr_start[i|(EHCI_VIRTUAL_FRAMELIST_COUNT/2)].qh_self;
+
+		sc->sc_isoc_fs_p_last[i] = 
+		  &sc->sc_hw.isoc_fs_start[i];
+
+
+		/* initialize high speed isochronous */
+
+		sc->sc_hw.isoc_hs_start[i].itd_self = 
+		  htole32(PHYSADDR(sc,sc_hw.isoc_hs_start[i])|EHCI_LINK_ITD);
+
+		sc->sc_hw.isoc_hs_start[i].itd_next = 
+		  sc->sc_hw.isoc_fs_start[i].sitd_self;
+
+		sc->sc_isoc_hs_p_last[i] = 
+		  &sc->sc_hw.isoc_hs_start[i];
+	}
+
+	/*
+	 * execution order:
+	 * pframes -> high speed isochronous -> 
+	 *    full speed isochronous -> interrupt QH's
+	 */
+	for(i = 0; i < EHCI_FRAMELIST_COUNT; i++)
+	{
+		sc->sc_hw.pframes[i] = sc->sc_hw.isoc_hs_start
+		  [i & (EHCI_VIRTUAL_FRAMELIST_COUNT-1)].itd_self;
+	}
+
+	/* setup sync list pointer */
+	EOWRITE4(sc, EHCI_PERIODICLISTBASE, PHYSADDR(sc,sc_hw.pframes[0]));
+
+
+	/* init dummy QH that starts the async list */
+
+	sc->sc_hw.async_start.qh_self = 
+	  htole32(PHYSADDR(sc,sc_hw.async_start)|EHCI_LINK_QH);
+
+	/* fill the QH */
+	sc->sc_hw.async_start.qh_endp =
+	    htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_HIGH) | EHCI_QH_HRECL);
+	sc->sc_hw.async_start.qh_endphub = htole32(EHCI_QH_SET_MULT(1));
+	sc->sc_hw.async_start.qh_link = sc->sc_hw.async_start.qh_self;
+	sc->sc_hw.async_start.qh_curqtd = 0;
+
+	/* fill the overlay qTD */
+	sc->sc_hw.async_start.qh_qtd.qtd_next = htole32(EHCI_LINK_TERMINATE);
+	sc->sc_hw.async_start.qh_qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
+	sc->sc_hw.async_start.qh_qtd.qtd_status = htole32(EHCI_QTD_HALTED);
+
+	sc->sc_async_p_last = 
+	  &sc->sc_hw.async_start;
+
+#ifdef USB_DEBUG
+	if(ehcidebug)
+	{
+		ehci_dump_sqh(&sc->sc_hw.async_start);
+	}
+#endif
+
+	/* setup async list pointer */
+	EOWRITE4(sc, EHCI_ASYNCLISTADDR, PHYSADDR(sc,sc_hw.async_start)|EHCI_LINK_QH);
+
+
+	/* enable interrupts */
+	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
+
+	/* turn on controller */
+	EOWRITE4(sc, EHCI_USBCMD,
+		 EHCI_CMD_ITC_2 | /* 2 microframes interrupt delay */
+		 (EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_FLS_M) |
+		 EHCI_CMD_ASE |
+		 EHCI_CMD_PSE |
+		 EHCI_CMD_RS);
+
+	/* take over port ownership */
+	EOWRITE4(sc, EHCI_CONFIGFLAG, EHCI_CONF_CF);
+
+	for(i = 0; i < 100; i++)
+	{
+		DELAY(1000*1);
+		hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
+		if(!hcr)
+		{
+			break;
+		}
+	}
+	if(hcr)
+	{
+		device_printf(sc->sc_bus.bdev, "run timeout\n");
+		err = USBD_IOERROR;
+		goto done;
+	}
+
+ done:
+	mtx_unlock(&sc->sc_bus.mtx);
+	return (err);
+}
+
+/*
+ * shut down the controller when the system is going down
+ */
+void
+ehci_detach(struct ehci_softc *sc)
+{
+	mtx_lock(&sc->sc_bus.mtx);
+
+	__callout_stop(&sc->sc_tmo_pcd);
+
+	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
+	EOWRITE4(sc, EHCI_USBCMD, 0);
+	EOWRITE4(sc, EHCI_USBCMD, EHCI_CMD_HCRESET);
+
+	DELAY(1000*300); /* XXX let stray task complete */
+
+	mtx_unlock(&sc->sc_bus.mtx);
+	return;
+}
+
+void
+ehci_suspend(struct ehci_softc *sc)
+{
+	u_int32_t cmd;
+	u_int32_t hcr;
+	u_int8_t i;
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	for(i = 1; i <= sc->sc_noport; i++)
+	{
+		cmd = EOREAD4(sc, EHCI_PORTSC(i));
+		if(((cmd & EHCI_PS_PO) == 0) &&
+		   ((cmd & EHCI_PS_PE) == EHCI_PS_PE))
+		{
+			EOWRITE4(sc, EHCI_PORTSC(i),
+				 cmd | EHCI_PS_SUSP);
+		}
+	}
+
+	sc->sc_cmd = EOREAD4(sc, EHCI_USBCMD);
+
+	cmd = sc->sc_cmd & ~(EHCI_CMD_ASE | EHCI_CMD_PSE);
+	EOWRITE4(sc, EHCI_USBCMD, cmd);
+
+	for(i = 0; i < 100; i++)
+	{
+		hcr = EOREAD4(sc, EHCI_USBSTS) &
+		  (EHCI_STS_ASS | EHCI_STS_PSS);
+
+		if(hcr == 0)
+		{
+			break;
+		}
+
+		DELAY(1000*1);
+	}
+
+	if(hcr != 0)
+	{
+		device_printf(sc->sc_bus.bdev, "reset timeout\n");
+	}
+
+	cmd &= ~EHCI_CMD_RS;
+	EOWRITE4(sc, EHCI_USBCMD, cmd);
+
+	for(i = 0; i < 100; i++)
+	{
+		hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
+		if(hcr == EHCI_STS_HCH)
+		{
+			break;
+		}
+
+		DELAY(1000*1);
+	}
+
+	if(hcr != EHCI_STS_HCH)
+	{
+		device_printf(sc->sc_bus.bdev, 
+			      "config timeout\n");
+	}
+
+	mtx_unlock(&sc->sc_bus.mtx);
+ 	return;
+}
+
+void
+ehci_resume(struct ehci_softc *sc)
+{
+	u_int32_t cmd;
+	u_int32_t hcr;
+	u_int8_t i;
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	/* restore things in case the bios doesn't */
+	EOWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);
+	EOWRITE4(sc, EHCI_PERIODICLISTBASE, PHYSADDR(sc,sc_hw.pframes[0]));
+	EOWRITE4(sc, EHCI_ASYNCLISTADDR, PHYSADDR(sc,sc_hw.async_start)|EHCI_LINK_QH);
+
+	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
+
+	hcr = 0;
+	for(i = 1; i <= sc->sc_noport; i++)
+	{
+	    cmd = EOREAD4(sc, EHCI_PORTSC(i));
+	    if(((cmd & EHCI_PS_PO) == 0) &&
+	       ((cmd & EHCI_PS_SUSP) == EHCI_PS_SUSP))
+	    {
+	        EOWRITE4(sc, EHCI_PORTSC(i),
+			 cmd | EHCI_PS_FPR);
+		hcr = 1;
+	    }
+	}
+
+	if(hcr)
+	{
+		DELAY(1000*USB_RESUME_WAIT);
+
+		for(i = 1; i <= sc->sc_noport; i++)
+		{
+			cmd = EOREAD4(sc, EHCI_PORTSC(i));
+			if(((cmd & EHCI_PS_PO) == 0) &&
+			   ((cmd & EHCI_PS_SUSP) == EHCI_PS_SUSP))
+			{
+				EOWRITE4(sc, EHCI_PORTSC(i),
+					 cmd & ~EHCI_PS_FPR);
+			}
+		}
+	}
+
+	EOWRITE4(sc, EHCI_USBCMD, sc->sc_cmd);
+
+	for(i = 0; i < 100; i++)
+	{
+		hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
+		if(hcr != EHCI_STS_HCH)
+		{
+			break;
+		}
+
+		DELAY(1000*1);
+	}
+	if(hcr == EHCI_STS_HCH)
+	{
+		device_printf(sc->sc_bus.bdev, "config timeout\n");
+	}
+
+	mtx_unlock(&sc->sc_bus.mtx);
+
+	DELAY(1000*USB_RESUME_WAIT);
+	return;
+}
+
+void
+ehci_shutdown(ehci_softc_t *sc)
+{
+	DPRINTF(("stopping the HC\n"));
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	EOWRITE4(sc, EHCI_USBCMD, 0);	/* Halt controller */
+	EOWRITE4(sc, EHCI_USBCMD, EHCI_CMD_HCRESET);
+
+	mtx_unlock(&sc->sc_bus.mtx);
+}
+
+#ifdef USB_DEBUG
+static void
+ehci_dump_regs(ehci_softc_t *sc)
+{
+	u_int32_t i;
+
+	i = EOREAD4(sc, EHCI_USBCMD);
+	printf("cmd=0x%08x\n", i);
+
+	if(i &  EHCI_CMD_ITC_1)
+	  printf(" EHCI_CMD_ITC_1\n");
+	if(i &  EHCI_CMD_ITC_2)
+	  printf(" EHCI_CMD_ITC_2\n");
+	if(i &  EHCI_CMD_ITC_4)
+	  printf(" EHCI_CMD_ITC_4\n");
+	if(i &  EHCI_CMD_ITC_8)
+	  printf(" EHCI_CMD_ITC_8\n");
+	if(i &  EHCI_CMD_ITC_16)
+	  printf(" EHCI_CMD_ITC_16\n");
+	if(i &  EHCI_CMD_ITC_32)
+	  printf(" EHCI_CMD_ITC_32\n");
+	if(i &  EHCI_CMD_ITC_64)
+	  printf(" EHCI_CMD_ITC_64\n");
+	if(i & EHCI_CMD_ASPME)
+	  printf(" EHCI_CMD_ASPME\n");
+	if(i & EHCI_CMD_ASPMC)
+	  printf(" EHCI_CMD_ASPMC\n");
+	if(i & EHCI_CMD_LHCR)
+	  printf(" EHCI_CMD_LHCR\n");
+	if(i & EHCI_CMD_IAAD)
+	  printf(" EHCI_CMD_IAAD\n");
+	if(i & EHCI_CMD_ASE)
+	  printf(" EHCI_CMD_ASE\n");
+	if(i & EHCI_CMD_PSE)
+	  printf(" EHCI_CMD_PSE\n");
+	if(i & EHCI_CMD_FLS_M)
+	  printf(" EHCI_CMD_FLS_M\n");
+	if(i & EHCI_CMD_HCRESET)
+	  printf(" EHCI_CMD_HCRESET\n");
+	if(i & EHCI_CMD_RS)
+	  printf(" EHCI_CMD_RS\n");
+
+	i = EOREAD4(sc, EHCI_USBSTS);
+
+	printf("sts=0x%08x\n", i);
+
+	if(i & EHCI_STS_ASS)
+	  printf(" EHCI_STS_ASS\n");
+	if(i & EHCI_STS_PSS)
+	  printf(" EHCI_STS_PSS\n");
+	if(i & EHCI_STS_REC)
+	  printf(" EHCI_STS_REC\n");
+	if(i & EHCI_STS_HCH)
+	  printf(" EHCI_STS_HCH\n");
+	if(i & EHCI_STS_IAA)
+	  printf(" EHCI_STS_IAA\n");
+	if(i & EHCI_STS_HSE)
+	  printf(" EHCI_STS_HSE\n");
+	if(i & EHCI_STS_FLR)
+	  printf(" EHCI_STS_FLR\n");
+	if(i & EHCI_STS_PCD)
+	  printf(" EHCI_STS_PCD\n");
+	if(i & EHCI_STS_ERRINT)
+	  printf(" EHCI_STS_ERRINT\n");
+	if(i & EHCI_STS_INT)
+	  printf(" EHCI_STS_INT\n");
+
+	printf("ien=0x%08x\n",
+	       EOREAD4(sc, EHCI_USBINTR));
+	printf("frindex=0x%08x ctrdsegm=0x%08x periodic=0x%08x async=0x%08x\n",
+	       EOREAD4(sc, EHCI_FRINDEX),
+	       EOREAD4(sc, EHCI_CTRLDSSEGMENT),
+	       EOREAD4(sc, EHCI_PERIODICLISTBASE),
+	       EOREAD4(sc, EHCI_ASYNCLISTADDR));
+	for(i = 1; i <= sc->sc_noport; i++)
+	{
+		printf("port %d status=0x%08x\n", i,
+		       EOREAD4(sc, EHCI_PORTSC(i)));
+	}
+	return;
+}
+
+static void
+ehci_dump_link(u_int32_t link, int type)
+{
+	link = le32toh(link);
+	printf("0x%08x", link);
+	if(link & EHCI_LINK_TERMINATE)
+		printf("<T>");
+	else {
+		printf("<");
+		if(type) {
+			switch (EHCI_LINK_TYPE(link)) {
+			case EHCI_LINK_ITD: printf("ITD"); break;
+			case EHCI_LINK_QH: printf("QH"); break;
+			case EHCI_LINK_SITD: printf("SITD"); break;
+			case EHCI_LINK_FSTN: printf("FSTN"); break;
+			}
+		}
+		printf(">");
+	}
+	return;
+}
+
+static void
+ehci_dump_qtd(ehci_qtd_t *qtd)
+{
+	u_int32_t s;
+
+	printf("  next="); ehci_dump_link(qtd->qtd_next, 0);
+	printf(" altnext="); ehci_dump_link(qtd->qtd_altnext, 0);
+	printf("\n");
+	s = le32toh(qtd->qtd_status);
+	printf("  status=0x%08x: toggle=%d bytes=0x%x ioc=%d c_page=0x%x\n",
+	       s, EHCI_QTD_GET_TOGGLE(s), EHCI_QTD_GET_BYTES(s),
+	       EHCI_QTD_GET_IOC(s), EHCI_QTD_GET_C_PAGE(s));
+	printf("    cerr=%d pid=%d stat=%s%s%s%s%s%s%s%s\n", 
+	       EHCI_QTD_GET_CERR(s), EHCI_QTD_GET_PID(s), 
+	       (s & EHCI_QTD_ACTIVE) ? "ACTIVE" : "NOT_ACTIVE",
+	       (s & EHCI_QTD_HALTED) ? "-HALTED" : "",
+	       (s & EHCI_QTD_BUFERR) ? "-BUFERR" : "",
+	       (s & EHCI_QTD_BABBLE) ? "-BABBLE" : "",
+	       (s & EHCI_QTD_XACTERR) ? "-XACTERR" : "",
+	       (s & EHCI_QTD_MISSEDMICRO) ? "-MISSED" : "",
+	       (s & EHCI_QTD_SPLITXSTATE) ? "-SPLIT" : "",
+	       (s & EHCI_QTD_PINGSTATE) ? "-PING" : "");
+
+	for(s = 0; s < 5; s++)
+	{
+		printf("  buffer[%d]=0x%08x\n", s, 
+		       le32toh(qtd->qtd_buffer[s]));
+	}
+	for(s = 0; s < 5; s++)
+	{
+		printf("  buffer_hi[%d]=0x%08x\n", s, 
+		       le32toh(qtd->qtd_buffer_hi[s]));
+	}
+	return;
+}
+
+static void
+ehci_dump_sqtd(ehci_qtd_t *sqtd)
+{
+	printf("QTD(%p) at 0x%08x:\n", sqtd, le32toh(sqtd->qtd_self));
+	ehci_dump_qtd(sqtd);
+	return;
+}
+
+static void
+ehci_dump_sqtds(ehci_qtd_t *sqtd)
+{
+	int i;
+	u_int32_t stop;
+
+	stop = 0;
+	for(i = 0; sqtd && (i < 20) && !stop; sqtd = sqtd->next, i++)
+	{
+		ehci_dump_sqtd(sqtd);
+		stop = sqtd->qtd_next & htole32(EHCI_LINK_TERMINATE);
+	}
+	if(sqtd)
+	{
+		printf("dump aborted, too many TDs\n");
+	}
+	return;
+}
+
+static void
+ehci_dump_sqh(ehci_qh_t *qh)
+{
+	u_int32_t endp, endphub;
+
+	printf("QH(%p) at 0x%08x:\n", qh, le32toh(qh->qh_self) & ~0x1F);
+	printf("  link="); ehci_dump_link(qh->qh_link, 1); printf("\n");
+	endp = le32toh(qh->qh_endp);
+	printf("  endp=0x%08x\n", endp);
+	printf("    addr=0x%02x inact=%d endpt=%d eps=%d dtc=%d hrecl=%d\n",
+	       EHCI_QH_GET_ADDR(endp), EHCI_QH_GET_INACT(endp),
+	       EHCI_QH_GET_ENDPT(endp),  EHCI_QH_GET_EPS(endp),
+	       EHCI_QH_GET_DTC(endp), EHCI_QH_GET_HRECL(endp));
+	printf("    mpl=0x%x ctl=%d nrl=%d\n",
+	       EHCI_QH_GET_MPL(endp), EHCI_QH_GET_CTL(endp),
+	       EHCI_QH_GET_NRL(endp));
+	endphub = le32toh(qh->qh_endphub);
+	printf("  endphub=0x%08x\n", endphub);
+	printf("    smask=0x%02x cmask=0x%02x huba=0x%02x port=%d mult=%d\n",
+	       EHCI_QH_GET_SMASK(endphub), EHCI_QH_GET_CMASK(endphub),
+	       EHCI_QH_GET_HUBA(endphub), EHCI_QH_GET_PORT(endphub),
+	       EHCI_QH_GET_MULT(endphub));
+	printf("  curqtd="); ehci_dump_link(qh->qh_curqtd, 0); printf("\n");
+	printf("Overlay qTD:\n");
+	ehci_dump_qtd((void *)&qh->qh_qtd);
+	return;
+}
+
+static void
+ehci_dump_sitd(ehci_sitd_t *sitd)
+{
+	printf("SITD(%p) at 0x%08x\n", sitd, le32toh(sitd->sitd_self) & ~0x1F);
+	printf(" next=0x%08x\n", le32toh(sitd->sitd_next));
+	printf(" portaddr=0x%08x dir=%s addr=%d endpt=0x%x port=0x%x huba=0x%x\n", 
+	       le32toh(sitd->sitd_portaddr),
+	       (sitd->sitd_portaddr & htole32(EHCI_SITD_SET_DIR_IN)) 
+	       ? "in" : "out" , 
+	       EHCI_SITD_GET_ADDR(le32toh(sitd->sitd_portaddr)),
+	       EHCI_SITD_GET_ENDPT(le32toh(sitd->sitd_portaddr)), 
+	       EHCI_SITD_GET_PORT(le32toh(sitd->sitd_portaddr)), 
+	       EHCI_SITD_GET_HUBA(le32toh(sitd->sitd_portaddr)));
+	printf(" mask=0x%08x\n", le32toh(sitd->sitd_mask));
+	printf(" status=0x%08x <%s> len=0x%x\n", le32toh(sitd->sitd_status),
+	       (sitd->sitd_status & htole32(EHCI_SITD_ACTIVE)) ? "ACTIVE" : "",
+	       EHCI_SITD_GET_LEN(le32toh(sitd->sitd_status)));
+	printf(" back=0x%08x, bp=0x%08x,0x%08x,0x%08x,0x%08x\n",
+		le32toh(sitd->sitd_back),
+		le32toh(sitd->sitd_bp[0]),
+		le32toh(sitd->sitd_bp[1]),
+		le32toh(sitd->sitd_bp_hi[0]),
+		le32toh(sitd->sitd_bp_hi[1]));
+	return;
+}
+
+static void
+ehci_dump_itd(ehci_itd_t *itd)
+{
+	printf("ITD(%p) at 0x%08x\n", itd, le32toh(itd->itd_self) & ~0x1F);
+	printf(" next=0x%08x\n", le32toh(itd->itd_next));
+	printf(" status[0]=0x%08x; <%s>\n", le32toh(itd->itd_status[0]),
+	       (itd->itd_status[0] & htole32(EHCI_ITD_ACTIVE)) ? "ACTIVE" : "");
+	printf(" status[1]=0x%08x; <%s>\n", le32toh(itd->itd_status[1]),
+	       (itd->itd_status[1] & htole32(EHCI_ITD_ACTIVE)) ? "ACTIVE" : "");
+	printf(" status[2]=0x%08x; <%s>\n", le32toh(itd->itd_status[2]),
+	       (itd->itd_status[2] & htole32(EHCI_ITD_ACTIVE)) ? "ACTIVE" : "");
+	printf(" status[3]=0x%08x; <%s>\n", le32toh(itd->itd_status[3]),
+	       (itd->itd_status[3] & htole32(EHCI_ITD_ACTIVE)) ? "ACTIVE" : "");
+	printf(" status[4]=0x%08x; <%s>\n", le32toh(itd->itd_status[4]),
+	       (itd->itd_status[4] & htole32(EHCI_ITD_ACTIVE)) ? "ACTIVE" : "");
+	printf(" status[5]=0x%08x; <%s>\n", le32toh(itd->itd_status[5]),
+	       (itd->itd_status[5] & htole32(EHCI_ITD_ACTIVE)) ? "ACTIVE" : "");
+	printf(" status[6]=0x%08x; <%s>\n", le32toh(itd->itd_status[6]),
+	       (itd->itd_status[6] & htole32(EHCI_ITD_ACTIVE)) ? "ACTIVE" : "");
+	printf(" status[7]=0x%08x; <%s>\n", le32toh(itd->itd_status[7]),
+	       (itd->itd_status[7] & htole32(EHCI_ITD_ACTIVE)) ? "ACTIVE" : "");
+	printf(" bp[0]=0x%08x\n", le32toh(itd->itd_bp[0]));
+	printf("  addr=0x%02x; endpt=0x%01x\n",
+	       EHCI_ITD_GET_ADDR(le32toh(itd->itd_bp[0])),
+	       EHCI_ITD_GET_ENDPT(le32toh(itd->itd_bp[0])));
+	printf(" bp[1]=0x%08x\n", le32toh(itd->itd_bp[1]));
+	printf(" dir=%s; mpl=0x%02x\n",
+	       (le32toh(itd->itd_bp[1]) & EHCI_ITD_SET_DIR_IN) ? "in" : "out",
+	       EHCI_ITD_GET_MPL(le32toh(itd->itd_bp[1])));
+	printf(" bp[2..6]=0x%08x,0x%08x,0x%08x,0x%08x,0x%08x\n",
+		le32toh(itd->itd_bp[2]),
+		le32toh(itd->itd_bp[3]),
+		le32toh(itd->itd_bp[4]),
+		le32toh(itd->itd_bp[5]),
+		le32toh(itd->itd_bp[6]));
+	printf(" bp_hi=0x%08x,0x%08x,0x%08x,0x%08x,\n"
+	       "       0x%08x,0x%08x,0x%08x\n",
+		le32toh(itd->itd_bp_hi[0]),
+		le32toh(itd->itd_bp_hi[1]),
+		le32toh(itd->itd_bp_hi[2]),
+		le32toh(itd->itd_bp_hi[3]),
+		le32toh(itd->itd_bp_hi[4]),
+		le32toh(itd->itd_bp_hi[5]),
+		le32toh(itd->itd_bp_hi[6]));
+	return;
+}
+
+static void
+ehci_dump_isoc(ehci_softc_t *sc)
+{
+	ehci_itd_t *itd;
+	ehci_sitd_t *sitd;
+	u_int16_t max = 1000;
+	u_int16_t pos;
+
+	pos = (EOREAD4(sc, EHCI_FRINDEX) / 8) & 
+	  (EHCI_VIRTUAL_FRAMELIST_COUNT-1);
+
+	printf("%s: isochronous dump from frame 0x%03x:\n",
+	       __FUNCTION__, pos);
+
+	itd = sc->sc_isoc_hs_p_last[pos];
+	sitd = sc->sc_isoc_fs_p_last[pos];
+
+	while(itd && max && max--)
+	{
+		ehci_dump_itd(itd);
+		itd = itd->prev;
+	}
+
+	while(sitd && max && max--)
+	{
+		ehci_dump_sitd(sitd);
+		sitd = sitd->prev;
+	}
+	return;
+}
+#endif
+
+#define EHCI_APPEND_FS_TD(std,last) (last) = _ehci_append_fs_td(std,last)
+static ehci_sitd_t *
+_ehci_append_fs_td(ehci_sitd_t *std, ehci_sitd_t *last)
+{
+	DPRINTFN(10, ("%p to %p\n", std, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	std->next = last->next;
+	std->sitd_next = last->sitd_next;
+
+	std->prev = last;
+
+	/* the last->next->prev is never followed:
+	 * std->next->prev = std;
+	 */
+	last->next = std;
+	last->sitd_next = std->sitd_self;
+
+	return(std);
+}
+
+#define EHCI_APPEND_HS_TD(std,last) (last) = _ehci_append_hs_td(std,last)
+static ehci_itd_t *
+_ehci_append_hs_td(ehci_itd_t *std, ehci_itd_t *last)
+{
+	DPRINTFN(10, ("%p to %p\n", std, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	std->next = last->next;
+	std->itd_next = last->itd_next;
+
+	std->prev = last;
+
+	/* the last->next->prev is never followed:
+	 * std->next->prev = std;
+	 */
+	last->next = std;
+	last->itd_next = std->itd_self;
+	return(std);
+}
+
+#define EHCI_APPEND_QH(sqh,last) (last) = _ehci_append_qh(sqh,last)
+static ehci_qh_t *
+_ehci_append_qh(ehci_qh_t *sqh, ehci_qh_t *last)
+{
+	DPRINTFN(10, ("%p to %p\n", sqh, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	sqh->next = last->next;
+	sqh->qh_link = last->qh_link;
+
+	sqh->prev = last;
+	
+	/* the last->next->prev is never followed:
+	 * sqh->next->prev = sqh;
+	 */
+
+	last->next = sqh;
+	last->qh_link = sqh->qh_self;
+
+#ifdef USB_DEBUG
+	if(ehcidebug > 5)
+	{
+		printf("%s:\n", __FUNCTION__);
+		ehci_dump_sqh(sqh);
+	}
+#endif
+	return(sqh);
+}
+/**/
+
+#define EHCI_REMOVE_FS_TD(std,last) (last) = _ehci_remove_fs_td(std,last)
+static ehci_sitd_t *
+_ehci_remove_fs_td(ehci_sitd_t *std, ehci_sitd_t *last)
+{
+	DPRINTFN(10, ("%p from %p\n", std, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	std->prev->next = std->next;
+	std->prev->sitd_next = std->sitd_next;
+
+	if(std->next)
+	{
+		std->next->prev = std->prev;
+	}
+	return((last == std) ? std->prev : last);
+}
+
+#define EHCI_REMOVE_HS_TD(std,last) (last) = _ehci_remove_hs_td(std,last)
+static ehci_itd_t *
+_ehci_remove_hs_td(ehci_itd_t *std, ehci_itd_t *last)
+{
+	DPRINTFN(10, ("%p from %p\n", std, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	std->prev->next = std->next;
+	std->prev->itd_next = std->itd_next;
+
+	if(std->next)
+	{
+		std->next->prev = std->prev;
+	}
+	return((last == std) ? std->prev : last);
+}
+
+#define EHCI_REMOVE_QH(sqh,last) (last) = _ehci_remove_qh(sqh,last)
+static ehci_qh_t *
+_ehci_remove_qh(ehci_qh_t *sqh, ehci_qh_t *last)
+{
+	DPRINTFN(10, ("%p from %p\n", sqh, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	/* only remove if not removed from a queue */
+	if(sqh->prev)
+	{
+		sqh->prev->next = sqh->next;
+		sqh->prev->qh_link = sqh->qh_link;
+
+		if(sqh->next)
+		{
+			sqh->next->prev = sqh->prev;
+		}
+
+		/* set the Terminate-bit in the e_next of the QH,
+		 * in case the transferred packet was short so
+		 * that the QH still points at the last used TD
+		 */
+
+		sqh->qh_qtd.qtd_next = htole32(EHCI_LINK_TERMINATE);
+
+		last = ((last == sqh) ? sqh->prev : last);
+
+		sqh->prev = 0;
+	}
+	return(last);
+}
+
+static void
+ehci_device_done(struct usbd_xfer *xfer, usbd_status error);
+
+static void
+ehci_non_isoc_done(struct usbd_xfer *xfer)
+{
+	u_int32_t status = 0;
+	u_int32_t actlen = 0;
+	u_int16_t len;
+	ehci_qtd_t *td = xfer->td_transfer_first;
+
+	DPRINTFN(12, ("xfer=%p pipe=%p transfer done\n",
+		      xfer, xfer->pipe));
+
+#ifdef USB_DEBUG
+	if(ehcidebug > 10)
+	{
+		ehci_dump_sqtds(td);
+	}
+#endif
+
+	/* the transfer is done, compute actual length and status */
+	for (;
+	     td != NULL;
+	     td = td->next)
+	{
+		if(td->qtd_status & htole32(EHCI_QTD_ACTIVE))
+		{
+			break;
+		}
+
+		status = le32toh(td->qtd_status);
+
+		/* halt is ok if descriptor is last, and complete */
+		if((td->qtd_next == htole32(EHCI_LINK_TERMINATE)) &&
+		   (EHCI_QTD_GET_BYTES(status) == 0))
+		{
+			status &= ~EHCI_QTD_HALTED;
+		}
+
+		len = EHCI_QTD_GET_BYTES(status);
+
+		if(len <= td->len)
+		{
+			actlen += td->len - len;
+		}
+	}
+
+	/* if there are left over TDs 
+	 * the toggle needs to be updated
+	 */
+	if(td != NULL)
+	{
+		xfer->pipe->toggle_next =
+		  (td->qtd_status & htole32(EHCI_QTD_SET_TOGGLE(1))) ? 1 : 0;
+	}
+
+	/* update toggle in case of
+	 * a short transfer
+	 */
+	xfer->pipe->toggle_next ^= (EHCI_QTD_GET_BYTES(status) / 
+				    xfer->max_packet_size) & 1;
+
+	DPRINTFN(10, ("actlen=%d\n", actlen));
+
+	xfer->actlen = actlen;
+
+	status &= EHCI_QTD_STATERRS;
+
+#ifdef USB_DEBUG
+	if(status == EHCI_QTD_HALTED)
+	{
+		DPRINTFN(10,
+			 ("error, addr=%d, endpt=0x%02x, "
+			  "status=%s%s%s%s%s%s%s%s\n",
+			  xfer->address,
+			  xfer->endpoint,
+			  (status & EHCI_QTD_ACTIVE) ? "ACTIVE" : "NOT_ACTIVE",
+			  (status & EHCI_QTD_HALTED) ? "-HALTED" : "",
+			  (status & EHCI_QTD_BUFERR) ? "-BUFERR" : "",
+			  (status & EHCI_QTD_BABBLE) ? "-BABBLE" : "",
+			  (status & EHCI_QTD_XACTERR) ? "-XACTERR" : "",
+			  (status & EHCI_QTD_MISSEDMICRO) ? "-MISSED" : "",
+			  (status & EHCI_QTD_SPLITXSTATE) ? "-SPLIT" : "",
+			  (status & EHCI_QTD_PINGSTATE) ? "-PING" : ""));
+	}
+#endif
+
+	ehci_device_done(xfer, 
+			 (status == 0) ? USBD_NORMAL_COMPLETION :
+			 (status == EHCI_QTD_HALTED) ? USBD_STALLED : USBD_IOERROR);
+	return;
+}
+
+/* returns one when transfer is finished 
+ * and callback must be called else zero
+ */
+static u_int8_t
+ehci_check_transfer(struct usbd_xfer *xfer)
+{
+	DPRINTFN(15, ("xfer=%p\n", xfer));
+
+	if(xfer->usb_thread)
+	{
+	    if(xfer->usb_thread != curthread)
+	    {
+	        /* cannot call this transfer 
+		 * back due to locking !
+		 */
+	        goto done;
+	    }
+	}
+
+	if(xfer->pipe->methods == &ehci_device_isoc_fs_methods)
+	{
+		ehci_sitd_t *td = xfer->td_transfer_last;
+
+		/* isochronous full speed transfer */
+		if(!(td->sitd_status & htole32(EHCI_SITD_ACTIVE)))
+		{
+			ehci_device_done(xfer, USBD_NORMAL_COMPLETION);
+			goto transferred;
+		}
+	}
+	else if(xfer->pipe->methods == &ehci_device_isoc_hs_methods)
+	{
+		ehci_itd_t *td = xfer->td_transfer_last;
+
+		/* isochronous high speed transfer */
+		if((!(td->itd_status[0] & htole32(EHCI_ITD_ACTIVE))) &&
+		   (!(td->itd_status[1] & htole32(EHCI_ITD_ACTIVE))) &&
+		   (!(td->itd_status[2] & htole32(EHCI_ITD_ACTIVE))) &&
+		   (!(td->itd_status[3] & htole32(EHCI_ITD_ACTIVE))) &&
+		   (!(td->itd_status[4] & htole32(EHCI_ITD_ACTIVE))) &&
+		   (!(td->itd_status[5] & htole32(EHCI_ITD_ACTIVE))) &&
+		   (!(td->itd_status[6] & htole32(EHCI_ITD_ACTIVE))) &&
+		   (!(td->itd_status[7] & htole32(EHCI_ITD_ACTIVE))))
+		{
+			ehci_device_done(xfer, USBD_NORMAL_COMPLETION);
+			goto transferred;
+		}
+	}
+	else
+	{
+		ehci_qtd_t *td = xfer->td_transfer_last;
+
+		/* non-isochronous transfer */
+		if(td->qtd_status & htole32(EHCI_QTD_ACTIVE))
+		{
+			/*
+			 * if the last TD is still active we need to
+			 * check whether there is an error somewhere
+			 * in the middle, or whether there was a short
+			 * packet (SPD and not ACTIVE)
+			 */
+
+			DPRINTFN(12, ("xfer=%p active\n", xfer));
+
+			for(td = xfer->td_transfer_first;
+			    td != NULL;
+			    td = td->next)
+			{
+				u_int32_t status;
+
+				status = le32toh(td->qtd_status);
+
+				/* if there's an active TD 
+				 * the transfer isn't done
+				 */
+				if(status & EHCI_QTD_ACTIVE)
+				{
+					DPRINTFN(12, ("xfer=%p is still "
+						      "active\n", xfer));
+					goto done;
+				}
+
+				/* any kind of error makes
+				 * the transfer done 
+				 */
+				if(status & EHCI_QTD_HALTED)
+				{
+					break;
+				}
+
+				/* we want short packets, 
+				 * and if it is short: it's done 
+				 */
+				if(EHCI_QTD_GET_BYTES(status) != 0)
+				{
+					break;
+				}
+			}
+		}
+		ehci_non_isoc_done(xfer);
+		goto transferred;
+	}
+
+ done:
+	return 0;
+
+ transferred:
+	return 1;
+}
+
+static void
+ehci_pcd_enable(ehci_softc_t *sc)
+{
+	struct usbd_callback_info info[1];
+	struct usbd_xfer *xfer;
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	sc->sc_eintrs |= EHCI_STS_PCD;
+	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
+
+	/* acknowledge any PCD interrupt */
+	EOWRITE4(sc, EHCI_USBSTS, EHCI_STS_PCD);
+
+	xfer = sc->sc_intrxfer;
+
+ 	if(xfer)
+	{
+	    /* transfer is transferred */
+	    ehci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+	    /* queue callback */
+	    info[0].xfer = xfer;
+	    info[0].refcount = xfer->usb_refcount;
+
+	    xfer->usb_root->memory_refcount++;
+
+	    mtx_unlock(&sc->sc_bus.mtx);
+
+	    usbd_do_callback(&info[0],&info[1]);
+	}
+	else
+	{
+	    mtx_unlock(&sc->sc_bus.mtx);
+	}
+	return;
+}
+
+void
+ehci_interrupt(ehci_softc_t *sc)
+{
+	enum { FINISH_LIST_MAX = 16 };
+
+	struct usbd_callback_info info[FINISH_LIST_MAX];
+	struct usbd_callback_info *ptr = &info[0];
+	struct usbd_xfer *xfer;
+	u_int32_t status;
+	u_int8_t need_repeat = 0;
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	/*
+	 * It can happen that an interrupt will be delivered to
+	 * us before the device has been fully attached and the
+	 * softc struct has been configured. Usually this happens
+	 * when kldloading the USB support as a module after the
+	 * system has been booted. If we detect this condition,
+	 * we need to squelch the unwanted interrupts until we're
+	 * ready for them.
+	 */
+	if(sc->sc_bus.bdev == NULL)
+	{
+		goto done;
+	}
+
+	sc->sc_bus.no_intrs++;
+
+	DPRINTFN(15,("%s: real interrupt\n",
+		     device_get_nameunit(sc->sc_bus.bdev)));
+
+#ifdef USB_DEBUG
+	if(ehcidebug > 15)
+	{
+		DPRINTF(("%s\n", device_get_nameunit(sc->sc_bus.bdev)));
+		ehci_dump_regs(sc);
+	}
+#endif
+
+	status = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));
+	if(status == 0)
+	{
+		/* the interrupt was not for us */
+		goto done;
+	}
+
+	if(!(status & sc->sc_eintrs))
+	{
+		goto done;
+	}
+
+	EOWRITE4(sc, EHCI_USBSTS, status); /* acknowledge */
+
+	status &= sc->sc_eintrs;
+
+	if(status & EHCI_STS_IAA)
+	{
+		DPRINTF(("door bell\n"));
+		wakeup(&sc->sc_async_p_last);
+	}
+
+	if(status & EHCI_STS_HSE)
+	{
+		device_printf(sc->sc_bus.bdev, "unrecoverable error, "
+			      "controller halted\n");
+#ifdef USB_DEBUG
+		ehci_dump_regs(sc);
+		ehci_dump_isoc(sc);
+#endif
+	}
+
+	if(status & EHCI_STS_PCD)
+	{
+		xfer = sc->sc_intrxfer;
+
+		if(xfer)
+		{
+		    ehci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+		    /* queue callback */
+		    ptr->xfer = xfer;
+		    ptr->refcount = xfer->usb_refcount;
+		    ptr++;
+
+		    xfer->usb_root->memory_refcount++;
+		}
+
+		/*
+		 * Disable PCD interrupt for now, because it will be
+		 * on until the port has been reset.
+		 */
+		sc->sc_eintrs &= ~EHCI_STS_PCD;
+		EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
+
+		/* do not allow RHSC interrupts > 1 per second */
+		__callout_reset(&sc->sc_tmo_pcd, hz,
+				(void *)(void *)ehci_pcd_enable, sc);
+	}
+
+	status &= ~(EHCI_STS_INT | EHCI_STS_ERRINT | EHCI_STS_PCD | EHCI_STS_IAA);
+
+	if(status != 0)
+	{
+		/* block unprocessed interrupts */
+		sc->sc_eintrs &= ~status;
+		EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
+		device_printf(sc->sc_bus.bdev, "blocking intrs 0x%x\n",
+			      status);
+	}
+
+ repeat:
+	LIST_FOREACH(xfer, &sc->sc_interrupt_list_head, interrupt_list)
+	{
+		/* check if transfer is
+		 * transferred 
+		 */
+		if(ehci_check_transfer(xfer))
+		{
+		    /* queue callback */
+		    ptr->xfer = xfer;
+		    ptr->refcount = xfer->usb_refcount;
+		    ptr++;
+
+		    xfer->usb_root->memory_refcount++;
+
+		    /* check queue length */
+		    if(ptr >= &info[FINISH_LIST_MAX])
+		    {
+		        need_repeat = 1;
+			break;
+		    }
+		}
+	}
+
+ done:
+	mtx_unlock(&sc->sc_bus.mtx);
+
+	usbd_do_callback(&info[0],ptr);
+
+	if(need_repeat)
+	{
+		ptr = &info[0];
+
+		need_repeat = 0;
+
+		mtx_lock(&sc->sc_bus.mtx);
+
+		goto repeat;
+	}
+	return;
+}
+
+/*
+ * called when a request does not complete
+ */
+static void
+ehci_timeout(struct usbd_xfer *xfer)
+{
+	struct usbd_callback_info info[1];
+	ehci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTF(("xfer=%p\n", xfer));
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	/* transfer is transferred */
+	ehci_device_done(xfer, USBD_TIMEOUT);
+
+	/* queue callback */
+	info[0].xfer = xfer;
+	info[0].refcount = xfer->usb_refcount;
+
+	xfer->usb_root->memory_refcount++;
+
+	mtx_unlock(&sc->sc_bus.mtx);
+
+	usbd_do_callback(&info[0],&info[1]);
+
+	return;
+}
+
+static void
+ehci_do_poll(struct usbd_bus *bus)
+{
+	ehci_interrupt(EHCI_BUS2SC(bus));
+	return;
+}
+
+#define ehci_add_interrupt_info(sc, xfer) \
+	LIST_INSERT_HEAD(&(sc)->sc_interrupt_list_head, (xfer), interrupt_list)
+
+static void
+ehci_remove_interrupt_info(struct usbd_xfer *xfer)
+{
+	if((xfer)->interrupt_list.le_prev)
+	{
+		LIST_REMOVE((xfer), interrupt_list);
+		(xfer)->interrupt_list.le_prev = 0;
+	}
+	return;
+}
+
+static void
+ehci_setup_standard_chain(struct usbd_xfer *xfer, ehci_qh_t **qh_last)
+{
+	/* the EHCI hardware can handle at most five 4k crossing per TD */
+	u_int32_t average = ((unsigned)(EHCI_PAGE_SIZE / xfer->max_packet_size))
+	  * xfer->max_packet_size;
+	u_int32_t qtd_status;
+	u_int32_t physbuffer = xfer->physbuffer;
+	u_int32_t len = xfer->length;
+	u_int32_t c_error = 
+	  (xfer->udev->speed == USB_SPEED_HIGH) ? 0 : 
+	  htole32(EHCI_QTD_SET_CERR(3));
+	u_int8_t isread;
+	u_int8_t shortpkt = 0;
+
+	ehci_qtd_t *td;
+	ehci_qh_t *qh;
+
+	DPRINTFN(8, ("addr=%d endpt=%d len=%d speed=%d\n", 
+		     xfer->address, UE_GET_ADDR(xfer->endpoint),
+		     xfer->length, xfer->udev->speed));
+
+	td = (xfer->td_transfer_first = xfer->td_start);
+
+	if(xfer->pipe->methods == &ehci_device_ctrl_methods)
+	{
+		isread = ((usb_device_request_t *)(xfer->buffer))->
+		  bmRequestType & UT_READ;
+
+		/* xfer->length = sizeof(usb_device_request_t) + 
+		 *                UGETW(req->wLength)
+		 * check length ??
+		 */
+		xfer->pipe->toggle_next = 1;
+
+		/* SETUP message */
+
+		td->next = (td+1);
+		td->qtd_next = (td+1)->qtd_self;
+		td->qtd_altnext = htole32(EHCI_LINK_TERMINATE);
+
+		td->qtd_status = c_error | htole32
+		  (EHCI_QTD_ACTIVE |
+		   EHCI_QTD_SET_PID(EHCI_QTD_PID_SETUP) |
+		   EHCI_QTD_SET_TOGGLE(0) |
+		   EHCI_QTD_SET_BYTES(sizeof(usb_device_request_t)));
+
+		td->qtd_buffer[0] = htole32(physbuffer);
+		td->qtd_buffer_hi[0] = 0;
+		td->qtd_buffer[1] = 
+		  htole32(physbuffer + sizeof(usb_device_request_t)) & 
+		  htole32(~0xfff);
+		td->qtd_buffer_hi[1] = 0;
+
+		td->len = sizeof(usb_device_request_t);
+
+		physbuffer += sizeof(usb_device_request_t);
+		len -= sizeof(usb_device_request_t);
+		td++;
+	}
+	else
+	{
+		isread = (UE_GET_DIR(xfer->endpoint) == UE_DIR_IN);
+
+		if(xfer->length == 0)
+		{
+			/* must allow access to (td-1),
+			 * so xfer->length cannot be zero
+			 */
+			printf("%s: setting USBD_FORCE_SHORT_XFER!\n",
+			       __FUNCTION__);
+			xfer->flags |= USBD_FORCE_SHORT_XFER;
+		}
+	}
+
+	qtd_status = c_error | (isread ?
+	  htole32
+	  (EHCI_QTD_ACTIVE |
+	   EHCI_QTD_SET_PID(EHCI_QTD_PID_IN)) :
+	  htole32
+	  (EHCI_QTD_ACTIVE |
+	   EHCI_QTD_SET_PID(EHCI_QTD_PID_OUT)));
+
+	if(xfer->pipe->toggle_next)
+	{
+		qtd_status |= htole32(EHCI_QTD_SET_TOGGLE(1));
+	}
+
+	while(1)
+	{
+		if(len == 0)
+		{
+			if(xfer->flags & USBD_FORCE_SHORT_XFER)
+			{
+				if(shortpkt)
+				{
+					break;
+				}
+			}
+			else
+			{
+				break;
+			}
+		}
+
+		if(len < average)
+		{
+			if((len % xfer->max_packet_size) || 
+			   (len == 0))
+			{
+				shortpkt = 1;
+			}
+
+			average = len;
+		}
+
+		if(((void *)td) >= xfer->td_end)
+		{
+			panic("%s: software wants to write more data "
+			      "than there is in the buffer!", __FUNCTION__);
+		}
+
+		/* fill out TD */
+
+		td->next = (td+1);
+		td->qtd_next = (td+1)->qtd_self;
+
+		/* short transfers should terminate the transfer: */
+		td->qtd_altnext = htole32(EHCI_LINK_TERMINATE);
+
+		td->qtd_status = 
+		  qtd_status | htole32(EHCI_QTD_SET_BYTES(average));
+
+		td->qtd_buffer[0] = htole32(physbuffer);
+		td->qtd_buffer_hi[0] = 0;
+		td->qtd_buffer[1] = 
+		  htole32(physbuffer + average) & htole32(~0xfff);
+		td->qtd_buffer_hi[1] = 0;
+
+		td->len = average;
+
+		/* adjust the toggle based on the 
+		 * number of packets in this qtd
+		 */
+		if((((average + xfer->max_packet_size - 1) / 
+		     xfer->max_packet_size) & 1) ||
+		   (!average))
+		{
+		    xfer->pipe->toggle_next =
+		      xfer->pipe->toggle_next ? 0 : 1;
+
+		    qtd_status ^= htole32(EHCI_QTD_TOGGLE_MASK);
+		}
+
+		physbuffer += average;
+		len -= average;
+		td++;
+	}
+
+	if(xfer->pipe->methods == &ehci_device_ctrl_methods)
+	{
+		/* STATUS message */
+
+		td->qtd_status = c_error | (isread ?
+		  htole32
+		  (EHCI_QTD_ACTIVE |
+		   EHCI_QTD_SET_PID(EHCI_QTD_PID_OUT) |
+		   EHCI_QTD_SET_TOGGLE(1) |
+		   EHCI_QTD_IOC) :
+		  htole32
+		  (EHCI_QTD_ACTIVE |
+		   EHCI_QTD_SET_PID(EHCI_QTD_PID_IN) |
+		   EHCI_QTD_SET_TOGGLE(1) |
+		   EHCI_QTD_IOC));
+
+		td->qtd_buffer[0] = 0; 
+		td->qtd_buffer_hi[0] = 0;
+
+		td->next = NULL;
+		td->qtd_next = htole32(EHCI_LINK_TERMINATE);
+		td->qtd_altnext = htole32(EHCI_LINK_TERMINATE);
+		td->len = 0;
+
+		physbuffer += 0;
+		len -= 0;
+		td++;
+	}
+	else
+	{
+		(td-1)->next = NULL;
+		(td-1)->qtd_next = htole32(EHCI_LINK_TERMINATE);
+		(td-1)->qtd_altnext = htole32(EHCI_LINK_TERMINATE);
+		(td-1)->qtd_status |= htole32(EHCI_QTD_IOC);
+	}
+
+	/* must have at least one frame! */
+
+	xfer->td_transfer_last = (td-1);
+
+#ifdef USB_DEBUG
+	if(ehcidebug > 8)
+	{
+		DPRINTF(("nexttog=%d; data before transfer:\n",
+			 xfer->pipe->toggle_next));
+		ehci_dump_sqtds(xfer->td_start);
+	}
+#endif
+	qh = xfer->qh_start;
+
+	/* qh_link filled when the QH is added */
+	qh->qh_endp = htole32
+	  (EHCI_QH_SET_ADDR(xfer->address) |
+	   EHCI_QH_SET_ENDPT(UE_GET_ADDR(xfer->endpoint)) |
+	   EHCI_QH_DTC |
+	   EHCI_QH_SET_MPL(xfer->max_packet_size) |
+	   EHCI_QH_SET_NRL(8) /* XXX */ 
+	   );
+
+	/* XXX have data toogle in qh */
+
+	switch (xfer->udev->speed) {
+	case USB_SPEED_LOW:  
+	  qh->qh_endp |= htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_LOW)|
+				 EHCI_QH_CTL);  
+	  break;
+	case USB_SPEED_FULL: 
+	  qh->qh_endp |= htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_FULL)|
+				 EHCI_QH_CTL); break;
+	case USB_SPEED_HIGH: 
+	  qh->qh_endp |= htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_HIGH)); 
+	  break;
+	default:
+	  panic("%s: bad device speed %d!", __FUNCTION__, xfer->udev->speed);
+	  break;
+	}
+
+	if(xfer->pipe->methods != &ehci_device_ctrl_methods)
+	{
+		qh->qh_endp &= htole32(~EHCI_QH_CTL);
+	}
+
+	qh->qh_endphub = htole32
+	  (EHCI_QH_SET_MULT(1)|
+	   EHCI_QH_SET_CMASK(0xf0));
+
+	if(xfer->udev->myhsport)
+	{
+		qh->qh_endphub |= htole32
+		  (EHCI_QH_SET_HUBA(xfer->udev->myhsport->parent->address)|
+		   EHCI_QH_SET_PORT(xfer->udev->myhsport->portno));
+	}
+
+	if(xfer->pipe->methods == &ehci_device_intr_methods)
+	{
+		/* execute the transfer one time per 1ms */
+		qh->qh_endphub |= htole32(EHCI_QH_SET_SMASK(0x04));
+	}
+
+	qh->qh_curqtd = htole32(0);
+
+	/* fill the overlay qTD */
+	qh->qh_qtd.qtd_status = htole32(0);
+
+	td = xfer->td_transfer_first;
+
+	qh->qh_qtd.qtd_next = td->qtd_self;
+	qh->qh_qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
+
+	EHCI_APPEND_QH(qh, *qh_last);
+	return;
+}
+
+static void
+ehci_root_intr_done(ehci_softc_t *sc, struct usbd_xfer *xfer)
+{
+	u_int8_t *p;
+	int i, m;
+
+	if(sc->sc_intrxfer)
+	{
+		/* disable further interrupts */
+		sc->sc_intrxfer = NULL;
+
+		p = xfer->buffer;
+		m = min(sc->sc_noport, (xfer->length * 8) - 1);
+		memset(p, 0, xfer->length);
+		for(i = 1; i <= m; i++)
+		{
+			/* pick out CHANGE bits from the status register */
+			if(EOREAD4(sc, EHCI_PORTSC(i)) & EHCI_PS_CLEAR)
+			{
+				p[i/8] |= 1 << (i%8);
+			}
+		}
+		DPRINTF(("change=0x%02x\n", *p));
+		xfer->actlen = xfer->length;
+	}
+	return;
+}
+
+static u_int8_t
+ehci_isoc_fs_done(ehci_softc_t *sc, struct usbd_xfer *xfer)
+{
+	u_int32_t nframes = xfer->nframes;
+	u_int32_t actlen = 0;
+	u_int16_t *plen = xfer->frlengths;
+	u_int16_t len = 0;
+	u_int8_t need_delay = 0;
+	ehci_sitd_t *td = xfer->td_transfer_first;
+	ehci_sitd_t **pp_last = &sc->sc_isoc_fs_p_last[xfer->qh_pos];
+
+	DPRINTFN(12, ("xfer=%p pipe=%p transfer done\n",
+		      xfer, xfer->pipe));
+
+	while(nframes--)
+	{
+	  if(((void *)td) >= xfer->td_end)
+	  {
+		td = xfer->td_start;
+	  }
+
+	  if(pp_last >= &sc->sc_isoc_fs_p_last[EHCI_VIRTUAL_FRAMELIST_COUNT])
+	  {
+		pp_last = &sc->sc_isoc_fs_p_last[0];
+	  }
+
+#ifdef USB_DEBUG
+	  if(ehcidebug > 15)
+	  {
+		DPRINTFN(15,("isoc FS-TD\n"));
+		ehci_dump_sitd(td);
+	  }
+#endif
+	  /* check for active transfers */
+	  if(td->sitd_status & htole32(EHCI_SITD_ACTIVE))
+	  {
+		need_delay = 1;
+	  }
+
+	  len = EHCI_SITD_GET_LEN(le32toh(td->sitd_status));
+
+	  if(*plen >= len)
+	  {
+		len = *plen - len;
+	  }
+	  else
+	  {
+		len = 0;
+	  }
+
+	  *plen = len;
+	  actlen += len;
+
+	  /* remove FS-TD from schedule */
+	  EHCI_REMOVE_FS_TD(td, *pp_last);
+
+	  pp_last++;
+	  plen++;
+	  td++;
+	}
+	xfer->actlen = actlen;
+
+	return need_delay;
+}
+
+static u_int8_t
+ehci_isoc_hs_done(ehci_softc_t *sc, struct usbd_xfer *xfer)
+{
+	u_int32_t nframes = xfer->nframes;
+	u_int32_t actlen = 0;
+	u_int16_t *plen = xfer->frlengths;
+	u_int16_t len = 0;
+	u_int8_t td_no = 0;
+	u_int8_t need_delay = 0;
+	ehci_itd_t *td = xfer->td_transfer_first;
+	ehci_itd_t **pp_last = &sc->sc_isoc_hs_p_last[xfer->qh_pos];
+
+	DPRINTFN(12, ("xfer=%p pipe=%p transfer done\n",
+		      xfer, xfer->pipe));
+
+	while(nframes--)
+	{
+	  if(((void *)td) >= xfer->td_end)
+	  {
+		td = xfer->td_start;
+	  }
+
+	  if(pp_last >= &sc->sc_isoc_hs_p_last[EHCI_VIRTUAL_FRAMELIST_COUNT])
+	  {
+		pp_last = &sc->sc_isoc_hs_p_last[0];
+	  }
+
+#ifdef USB_DEBUG
+	  if(ehcidebug > 15)
+	  {
+		DPRINTFN(15,("isoc HS-TD\n"));
+		ehci_dump_itd(td);
+	  }
+#endif
+	  if(td->itd_status[td_no] & htole32(EHCI_ITD_ACTIVE))
+	  {
+		need_delay = 1;
+	  }
+
+	  len = EHCI_ITD_GET_LEN(le32toh(td->itd_status[td_no]));
+
+	  if(*plen >= len)
+	  {
+		len = *plen - len;
+	  }
+	  else
+	  {
+		len = 0;
+	  }
+
+	  *plen = len;
+	  actlen += len;
+
+	  plen++;
+	  td_no++;
+
+	  if((td_no == 8) || (nframes == 0))
+	  {
+		/* remove HS-TD from schedule */
+		EHCI_REMOVE_HS_TD(td, *pp_last);
+		pp_last++;
+
+		td_no = 0;
+		td++;
+	  }
+	}
+	xfer->actlen = actlen;
+
+	return need_delay;
+}
+
+/* NOTE: "done" can be run two times in a row,
+ * from close and from interrupt
+ */
+static void
+ehci_device_done(struct usbd_xfer *xfer, usbd_status error)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+	u_int8_t need_delay;
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	need_delay = 0;
+
+	DPRINTFN(1,("xfer=%p, pipe=%p length=%d error=%d\n",
+		    xfer, xfer->pipe, xfer->actlen, error));
+
+	/* ... could check for not-completed transfers, 
+	 * instead of setting need_delay ...
+	 */
+	if((error == USBD_CANCELLED) ||
+	   (error == USBD_TIMEOUT))
+	{
+		if(xfer->flags & USBD_DEV_TRANSFERRING)
+		{
+			need_delay = 1;
+		}
+	}
+
+	if((xfer->pipe->methods == &ehci_device_bulk_methods) ||
+	   (xfer->pipe->methods == &ehci_device_ctrl_methods))
+	{
+#ifdef USB_DEBUG
+		if(ehcidebug > 8)
+		{
+			DPRINTF(("nexttog=%d; data after transfer:\n",
+				 xfer->pipe->toggle_next));
+			ehci_dump_sqtds(xfer->td_start);
+		}
+#endif
+
+		EHCI_REMOVE_QH(xfer->qh_start, sc->sc_async_p_last);
+	}
+
+	if(xfer->pipe->methods == &ehci_device_intr_methods)
+	{
+		EHCI_REMOVE_QH(xfer->qh_start, sc->sc_intr_p_last[xfer->qh_pos]);
+	}
+
+	/* finish isochronous transfers 
+	 * (will update xfer->actlen and xfer->frlengths;
+	 *  should only be called once)
+	 */
+	if(xfer->td_transfer_first &&
+	   xfer->td_transfer_last)
+	{
+		if(xfer->pipe->methods == &ehci_device_isoc_fs_methods)
+		{
+			if(ehci_isoc_fs_done(sc, xfer))
+			{
+				need_delay = 1;
+			}
+		}
+
+		if(xfer->pipe->methods == &ehci_device_isoc_hs_methods)
+		{
+			if(ehci_isoc_hs_done(sc, xfer))
+			{
+				need_delay = 1;
+			}
+		}
+
+		xfer->td_transfer_first = 0;
+		xfer->td_transfer_last = 0;
+	}
+
+	/* finish root interrupt transfer
+	 * (will update xfer->buffer and xfer->actlen)
+	 */
+	if(xfer->pipe->methods == &ehci_root_intr_methods)
+	{
+		ehci_root_intr_done(sc, xfer);
+	}
+
+	/* stop timeout */
+	__callout_stop(&xfer->timeout_handle);
+
+	/* remove interrupt info (if any) */
+	ehci_remove_interrupt_info(xfer);
+
+	if(((xfer->pipe->methods == &ehci_device_ctrl_methods) ||
+	    (xfer->pipe->methods == &ehci_device_bulk_methods)) &&
+	   (sc->sc_doorbell_disable == 0))
+	{
+		u_int32_t to = 100*1000;
+
+		/* wait for doorbell ~32us */
+		EOWRITE4(sc, EHCI_USBCMD, 
+			 EOREAD4(sc, EHCI_USBCMD) | EHCI_CMD_IAAD);
+
+		while(EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_IAAD)
+		{
+		    if(!to--)
+		    {
+		        printf("%s: doorbell timeout "
+			       "(disabling)\n", __FUNCTION__);
+			sc->sc_doorbell_disable = 1;
+			break;
+		    }
+		    DELAY(1);
+		}
+		need_delay = 0;
+	}
+	else
+	{
+		/* wait until the hardware has finished any possible
+		 * use of the transfer descriptor and QH
+		 *
+		 * in case "need_delay" is set, 
+		 * wait until the next isochronous 
+		 * frame is started
+		 */
+		DELAY(need_delay ? ((3*1000)/(2*8)) : (5));
+	}
+
+	/* acknowledge any doorbell interrupt 
+	 * (SiS chipsets require this)
+	 */
+	EOWRITE4(sc, EHCI_USBSTS, EHCI_STS_IAA);
+
+	if(error)
+	{
+		/* next transfer needs to clear stall */
+		xfer->pipe->clearstall = 1;
+	}
+
+	/* transfer transferred (no callback!) */
+	usbd_transfer_done(xfer,error);
+
+	/* dequeue transfer (and start next transfer)
+	 *
+	 * if two transfers are queued, the second
+	 * transfer must be started before the
+	 * first is called back!
+	 */
+	usbd_transfer_dequeue(xfer);
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ * ehci bulk support
+ *---------------------------------------------------------------------------*/
+static void
+ehci_device_bulk_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ehci_device_bulk_close(struct usbd_xfer *xfer)
+{
+	ehci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ehci_device_bulk_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ehci_device_bulk_start(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTFN(3, ("xfer=%p len=%d\n",
+		     xfer, xfer->length));
+
+	/* setup TD's and QH */
+	ehci_setup_standard_chain(xfer, &sc->sc_async_p_last);
+
+	/**/
+	ehci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ehci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods ehci_device_bulk_methods = 
+{
+  .open = ehci_device_bulk_open,
+  .close = ehci_device_bulk_close,
+  .enter = ehci_device_bulk_enter,
+  .start = ehci_device_bulk_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ehci control support
+ *---------------------------------------------------------------------------*/
+static void
+ehci_device_ctrl_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ehci_device_ctrl_close(struct usbd_xfer *xfer)
+{
+	ehci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ehci_device_ctrl_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ehci_device_ctrl_start(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTFN(3,("type=0x%02x, request=0x%02x, "
+		    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
+		    ((usb_device_request_t *)(xfer->buffer))->bmRequestType,
+		    ((usb_device_request_t *)(xfer->buffer))->bRequest,
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wValue),
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wIndex), 
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wLength),
+		    xfer->address, xfer->endpoint));
+
+	/* setup TD's and QH */
+	ehci_setup_standard_chain(xfer, &sc->sc_async_p_last);
+
+	/**/
+	ehci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ehci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods ehci_device_ctrl_methods = 
+{
+  .open = ehci_device_ctrl_open,
+  .close = ehci_device_ctrl_close,
+  .enter = ehci_device_ctrl_enter,
+  .start = ehci_device_ctrl_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ehci interrupt support
+ *---------------------------------------------------------------------------*/
+static void
+ehci_device_intr_open(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+	u_int16_t best;
+	u_int16_t bit;
+	u_int16_t x;
+
+	best = 0;
+	bit = EHCI_VIRTUAL_FRAMELIST_COUNT/2;
+	while(bit)
+	{
+		if(xfer->interval >= bit)
+		{
+			x = bit;
+			best = bit;
+			while(x & bit)
+			{
+				if(sc->sc_intr_stat[x] < 
+				   sc->sc_intr_stat[best])
+				{
+					best = x;
+				}
+				x++;
+			}
+			break;
+		}
+		bit >>= 1;
+	}
+
+	sc->sc_intr_stat[best]++;
+	xfer->qh_pos = best;
+
+	DPRINTFN(2, ("best=%d interval=%d\n",
+		     best, xfer->interval));
+	return;
+}
+
+static void
+ehci_device_intr_close(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+
+	sc->sc_intr_stat[xfer->qh_pos]--;
+
+	ehci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ehci_device_intr_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ehci_device_intr_start(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTFN(3,("xfer=%p len=%d\n",
+		    xfer, xfer->length));
+
+	/* setup TD's and QH */
+	ehci_setup_standard_chain(xfer, &sc->sc_intr_p_last[xfer->qh_pos]);
+
+	/**/
+	ehci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ehci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods ehci_device_intr_methods = 
+{
+  .open = ehci_device_intr_open,
+  .close = ehci_device_intr_close,
+  .enter = ehci_device_intr_enter,
+  .start = ehci_device_intr_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ehci full speed isochronous support
+ *---------------------------------------------------------------------------*/
+static void
+ehci_device_isoc_fs_open(struct usbd_xfer *xfer)
+{
+	ehci_sitd_t *td;
+	u_int32_t sitd_portaddr;
+
+	sitd_portaddr = 
+	  EHCI_SITD_SET_ADDR(xfer->address)|
+	  EHCI_SITD_SET_ENDPT(UE_GET_ADDR(xfer->endpoint));
+
+	if(UE_GET_DIR(xfer->endpoint) == UE_DIR_IN)
+	{
+		sitd_portaddr |= EHCI_SITD_SET_DIR_IN;
+	}
+
+	if(xfer->udev->myhsport)
+	{
+		sitd_portaddr |= 
+			EHCI_SITD_SET_HUBA(xfer->udev->myhsport->parent->address)|
+			EHCI_SITD_SET_PORT(xfer->udev->myhsport->portno);
+	}
+
+	sitd_portaddr = htole32(sitd_portaddr);
+
+	/* initialize all TD's */
+
+	for(td = xfer->td_start;
+	    ((void *)td) < xfer->td_end;
+	    td++)
+	{
+		td->sitd_portaddr = sitd_portaddr;
+
+		/* TODO: make some kind of automatic SMASK/CMASK selection
+		 * based on micro-frame usage
+		 *
+		 * micro-frame usage 
+		 * (8 microframes per 1ms)
+		 *
+		 * 0: isoc-IN
+		 * 1: isoc-OUT
+		 * 2: interrupt transfers
+		 * .
+		 * .
+		 * 7:
+		 */
+		if(UE_GET_DIR(xfer->endpoint) == UE_DIR_IN)
+		{
+			td->sitd_mask = htole32(EHCI_SITD_SET_SMASK(0x01)|
+						EHCI_SITD_SET_CMASK(0xFC));
+		}
+		else
+		{
+			td->sitd_mask = htole32(EHCI_SITD_SET_SMASK(0x02)|
+						EHCI_SITD_SET_CMASK(0xF8));
+		}
+		td->sitd_back = htole32(EHCI_LINK_TERMINATE);
+	}
+	return;
+}
+
+static void
+ehci_device_isoc_fs_close(struct usbd_xfer *xfer)
+{
+	ehci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ehci_device_isoc_fs_enter(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+	u_int32_t physbuffer;
+	u_int32_t nframes;
+	u_int16_t *plen;
+#ifdef USB_DEBUG
+	u_int8_t once = 1;
+#endif
+	ehci_sitd_t *td;
+	ehci_sitd_t **pp_last;
+
+	DPRINTFN(5,("xfer=%p next=%d nframes=%d\n",
+		    xfer, xfer->pipe->isoc_next, xfer->nframes));
+
+	nframes = EOREAD4(sc, EHCI_FRINDEX) / 8;
+
+	if(((nframes - xfer->pipe->isoc_next) & 
+	    (EHCI_VIRTUAL_FRAMELIST_COUNT-1)) < xfer->nframes)
+	{
+		/* not in use yet, schedule it a few frames ahead */
+		/* data underflow */
+		xfer->pipe->isoc_next = (nframes + 3) & 
+		  (EHCI_VIRTUAL_FRAMELIST_COUNT-1);
+		DPRINTFN(2,("start next=%d\n", xfer->pipe->isoc_next));
+	}
+
+	nframes = xfer->nframes;
+
+	if(nframes == 0)
+	{
+		/* transfer transferred */
+		ehci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+		/* call callback recursively */
+		__usbd_callback(xfer);
+
+		return;
+	}
+
+	physbuffer = xfer->physbuffer;
+
+	plen = xfer->frlengths;
+
+	td = (xfer->td_transfer_first = xfer->td_start);
+
+	pp_last = &sc->sc_isoc_fs_p_last[xfer->pipe->isoc_next];
+
+	/* store starting position */
+
+	xfer->qh_pos = xfer->pipe->isoc_next;
+
+	while(nframes--)
+	{
+		if(((void *)td) >= xfer->td_end)
+		{
+			td = xfer->td_start;
+		}
+
+		if(pp_last >= &sc->sc_isoc_fs_p_last[EHCI_VIRTUAL_FRAMELIST_COUNT])
+		{
+			pp_last = &sc->sc_isoc_fs_p_last[0];
+		}
+
+		/* reuse sitd_portaddr and sitd_back from last transfer */
+
+		/* TODO: implement support for multiple transactions */
+		if(*plen > 188)
+		{
+#ifdef USB_DEBUG
+			if(once)
+			{
+				once = 0;
+				printf("%s: frame length(%d) exceeds %d bytes "
+				       "(frame truncated)\n", 
+				       __FUNCTION__, *plen, 188);
+			}
+#endif
+
+			/* set new frame length, so that
+			 * a valid transfer can be setup,
+			 * even if synchronization with
+			 * physbuffer is lost
+			 */
+			*plen = 188;
+		}
+
+		td->sitd_bp[0] = htole32(physbuffer);
+		td->sitd_bp[1] = htole32((physbuffer + *plen) & ~0xFFF);
+
+		if(UE_GET_DIR(xfer->endpoint) == UE_DIR_OUT)
+		{
+			td->sitd_bp[1] |= htole32(1); /* T-count == 1 */
+		}
+
+		if(nframes == 0)
+		{
+			td->sitd_status = htole32
+			  (EHCI_SITD_IOC|
+			   EHCI_SITD_ACTIVE|
+			   EHCI_SITD_SET_LEN(*plen));
+		}
+		else
+		{
+			td->sitd_status = htole32
+			  (EHCI_SITD_ACTIVE|
+			   EHCI_SITD_SET_LEN(*plen));
+		}
+#ifdef USB_DEBUG
+		if(ehcidebug > 15)
+		{
+			DPRINTFN(15,("FS-TD %d\n", nframes));
+			ehci_dump_sitd(td);
+		}
+#endif
+		/* insert TD into schedule */
+		EHCI_APPEND_FS_TD(td, *pp_last);
+		pp_last++;
+
+		physbuffer += *plen;
+		plen++;
+		td++;
+	}
+
+	xfer->td_transfer_last = (td-1);
+
+	/* update isoc_next */
+	xfer->pipe->isoc_next = (pp_last - &sc->sc_isoc_fs_p_last[0]) &
+	  (EHCI_VIRTUAL_FRAMELIST_COUNT-1);
+
+	/**/
+	ehci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ehci_timeout, xfer);
+	}
+
+	/* enqueue transfer 
+	 * (so that it can be aborted through pipe abort)
+	 */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ehci_device_isoc_fs_start(struct usbd_xfer *xfer)
+{
+	/* already started, nothing to do */
+	return;
+}
+
+struct usbd_pipe_methods ehci_device_isoc_fs_methods = 
+{
+  .open = ehci_device_isoc_fs_open,
+  .close = ehci_device_isoc_fs_close,
+  .enter = ehci_device_isoc_fs_enter,
+  .start = ehci_device_isoc_fs_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ehci high speed isochronous support
+ *---------------------------------------------------------------------------*/
+static void
+ehci_device_isoc_hs_open(struct usbd_xfer *xfer)
+{
+	ehci_itd_t *td;
+
+	/* initialize all TD's */
+
+	for(td = xfer->td_start;
+	    ((void *)td) < xfer->td_end;
+	    td++)
+	{
+		/* set TD inactive */
+		td->itd_status[0] = 0;
+		td->itd_status[1] = 0;
+		td->itd_status[2] = 0;
+		td->itd_status[3] = 0;
+		td->itd_status[4] = 0;
+		td->itd_status[5] = 0;
+		td->itd_status[6] = 0;
+		td->itd_status[7] = 0;
+
+		/* set endpoint and address */
+		td->itd_bp[0] = htole32
+		  (EHCI_ITD_SET_ADDR(xfer->address)|
+		   EHCI_ITD_SET_ENDPT(UE_GET_ADDR(xfer->endpoint)));
+
+		/* set maximum packet size */
+		td->itd_bp[1] = htole32
+		  (EHCI_ITD_SET_MPL(xfer->max_packet_size & 0x7FF));
+
+		/* set direction */
+		if(UE_GET_DIR(xfer->endpoint) == UE_DIR_IN)
+		{
+			td->itd_bp[1] |= htole32(EHCI_ITD_SET_DIR_IN);
+		}
+
+		/* set transfer multiplier */
+		td->itd_bp[2] = htole32(1);
+	}
+	return;
+}
+
+static void
+ehci_device_isoc_hs_close(struct usbd_xfer *xfer)
+{
+	ehci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ehci_device_isoc_hs_enter(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+	u_int32_t status;
+	u_int32_t page_addr;
+	u_int32_t physbuffer;
+	u_int32_t nframes;
+	u_int16_t *plen;
+	u_int8_t page_no;
+	u_int8_t td_no;
+#ifdef USB_DEBUG
+	u_int8_t once = 1;
+#endif
+	ehci_itd_t *td;
+	ehci_itd_t **pp_last;
+
+	DPRINTFN(5,("xfer=%p next=%d nframes=%d\n",
+		    xfer, xfer->pipe->isoc_next, xfer->nframes));
+
+	nframes = EOREAD4(sc, EHCI_FRINDEX) / 8;
+
+	if(((nframes - xfer->pipe->isoc_next) & 
+	    (EHCI_VIRTUAL_FRAMELIST_COUNT-1)) < xfer->nframes)
+	{
+		/* not in use yet, schedule it a few frames ahead */
+		/* data underflow */
+		xfer->pipe->isoc_next = (nframes + 3) & 
+		  (EHCI_VIRTUAL_FRAMELIST_COUNT-1);
+		DPRINTFN(2,("start next=%d\n", xfer->pipe->isoc_next));
+	}
+
+	nframes = xfer->nframes;
+
+	if(nframes == 0)
+	{
+		/* transfer transferred */
+		ehci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+		/* call callback recursively */
+		__usbd_callback(xfer);
+
+		return;
+	}
+
+	physbuffer = xfer->physbuffer;
+
+	page_addr = physbuffer & ~0xFFF;
+	page_no = 0;
+	td_no = 0;
+
+	plen = xfer->frlengths;
+
+	td = (xfer->td_transfer_first = xfer->td_start);
+
+	pp_last = &sc->sc_isoc_hs_p_last[xfer->pipe->isoc_next];
+
+	/* store starting position */
+
+	xfer->qh_pos = xfer->pipe->isoc_next;
+
+	while(nframes--)
+	{
+		if(((void *)td) >= xfer->td_end)
+		{
+			td = xfer->td_start;
+		}
+
+		if(pp_last >= &sc->sc_isoc_hs_p_last[EHCI_VIRTUAL_FRAMELIST_COUNT])
+		{
+			pp_last = &sc->sc_isoc_hs_p_last[0];
+		}
+
+		/* range check */
+		if(*plen > 0xC00)
+		{
+#ifdef USB_DEBUG
+			if(once)
+			{
+				once = 0;
+				printf("%s: frame length(%d) exceeds %d bytes "
+				       "(frame truncated)\n", 
+				       __FUNCTION__, *plen, 0xC00);
+			}
+#endif
+			/* set new frame length, so that
+			 * a valid transfer can be setup,
+			 * even if synchronization with
+			 * physbuffer is lost
+			 */
+			*plen = 0xC00;
+		}
+
+		if(td_no == 0)
+		{
+			/* update page address */
+			td->itd_bp[page_no] &= htole32(0xFFF);
+			td->itd_bp[page_no] |= htole32(page_addr);
+
+			if(nframes < 7)
+			{
+				/* clear all status in case
+				 * some are not initialized
+				 */
+				td->itd_status[0] = 0;
+				td->itd_status[1] = 0;
+				td->itd_status[2] = 0;
+				td->itd_status[3] = 0;
+				td->itd_status[4] = 0;
+				td->itd_status[5] = 0;
+				td->itd_status[6] = 0;
+				td->itd_status[7] = 0;
+			}
+		}
+
+		/* compute status */
+		if(nframes == 0)
+		{
+			status = 
+			  (EHCI_ITD_SET_LEN(*plen)|
+			   EHCI_ITD_ACTIVE|
+			   EHCI_ITD_IOC|
+			   EHCI_ITD_SET_PG(page_no)|
+			   (physbuffer & 0xFFF));
+		}
+		else
+		{
+			status = 
+			  (EHCI_ITD_SET_LEN(*plen)|
+			   EHCI_ITD_ACTIVE|
+			   EHCI_ITD_SET_PG(page_no)|
+			   (physbuffer & 0xFFF));
+		}
+
+		physbuffer += *plen;
+
+		if((physbuffer ^ page_addr) & ~0xFFF)
+		{
+			/* new page needed */
+			page_addr = physbuffer & ~0xFFF;
+			page_no++;
+
+			if(page_no < 7)
+			{
+				/* update page address */
+				td->itd_bp[page_no] &= htole32(0xFFF);
+				td->itd_bp[page_no] |= htole32(page_addr);
+			}
+		}
+
+		if(page_no < 7)
+		{
+			/* activate the transfer */
+			td->itd_status[td_no] = htole32(status);
+		}
+		else
+		{
+			/* pretend that the transfer has finished */
+			td->itd_status[td_no] = (nframes == 0) ? 
+			  htole32(EHCI_ITD_IOC) : 0;
+#ifdef USB_DEBUG
+			if(once)
+			{
+				once = 0;
+				printf("%s: isoc limit reached! "
+				       "Max %d bytes per 8 frames. Frame skipped.\n",
+				       __FUNCTION__, (6 << 12));
+			}
+#endif
+		}
+
+		plen++;
+		td_no++;
+
+		if((td_no == 8) || (nframes == 0))
+		{
+#ifdef USB_DEBUG
+			if(ehcidebug > 15)
+			{
+				DPRINTFN(15,("HS-TD %d\n", nframes));
+				ehci_dump_itd(td);
+			}
+#endif
+			/* insert TD into schedule */
+			EHCI_APPEND_HS_TD(td, *pp_last);
+			pp_last++;
+
+			page_no = 0;
+			td_no = 0;
+			td++;
+		}
+	}
+
+	xfer->td_transfer_last = (td-1);
+
+	/* update isoc_next */
+	xfer->pipe->isoc_next = (pp_last - &sc->sc_isoc_hs_p_last[0]) &
+	  (EHCI_VIRTUAL_FRAMELIST_COUNT-1);
+
+	/**/
+	ehci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ehci_timeout, xfer);
+	}
+
+	/* enqueue transfer 
+	 * (so that it can be aborted through pipe abort)
+	 */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ehci_device_isoc_hs_start(struct usbd_xfer *xfer)
+{
+	/* already started, nothing to do */
+	return;
+}
+
+struct usbd_pipe_methods ehci_device_isoc_hs_methods = 
+{
+  .open = ehci_device_isoc_hs_open,
+  .close = ehci_device_isoc_hs_close,
+  .enter = ehci_device_isoc_hs_enter,
+  .start = ehci_device_isoc_hs_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ehci root control support
+ *---------------------------------------------------------------------------*
+ * simulate a hardware hub by handling
+ * all the necessary requests
+ *---------------------------------------------------------------------------*/
+
+static void
+ehci_root_ctrl_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ehci_root_ctrl_close(struct usbd_xfer *xfer)
+{
+	ehci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+/* data structures and routines
+ * to emulate the root hub:
+ */
+
+static const
+usb_device_descriptor_t ehci_devd = 
+{
+	USB_DEVICE_DESCRIPTOR_SIZE,
+	UDESC_DEVICE,		/* type */
+	{0x00, 0x02},		/* USB version */
+	UDCLASS_HUB,		/* class */
+	UDSUBCLASS_HUB,		/* subclass */
+	UDPROTO_HSHUBSTT,	/* protocol */
+	64,			/* max packet */
+	{0},{0},{0x00,0x01},	/* device id */
+	1,2,0,			/* string indicies */
+	1			/* # of configurations */
+};
+
+static const
+usb_device_qualifier_t ehci_odevd = 
+{
+	USB_DEVICE_DESCRIPTOR_SIZE,
+	UDESC_DEVICE_QUALIFIER,	/* type */
+	{0x00, 0x02},		/* USB version */
+	UDCLASS_HUB,		/* class */
+	UDSUBCLASS_HUB,		/* subclass */
+	UDPROTO_FSHUB,		/* protocol */
+	64,			/* max packet */
+	1,			/* # of configurations */
+	0
+};
+
+static const
+usb_config_descriptor_t ehci_confd = 
+{
+	USB_CONFIG_DESCRIPTOR_SIZE,
+	UDESC_CONFIG,
+	{USB_CONFIG_DESCRIPTOR_SIZE +
+	 USB_INTERFACE_DESCRIPTOR_SIZE +
+	 USB_ENDPOINT_DESCRIPTOR_SIZE},
+	1,
+	1,
+	0,
+	UC_SELF_POWERED,
+	0			/* max power */
+};
+
+static const
+usb_interface_descriptor_t ehci_ifcd = 
+{
+	USB_INTERFACE_DESCRIPTOR_SIZE,
+	UDESC_INTERFACE,
+	0,
+	0,
+	1,
+	UICLASS_HUB,
+	UISUBCLASS_HUB,
+	UIPROTO_HSHUBSTT,
+	0
+};
+
+static const
+usb_endpoint_descriptor_t ehci_endpd =
+{
+	USB_ENDPOINT_DESCRIPTOR_SIZE,
+	UDESC_ENDPOINT,
+	UE_DIR_IN | EHCI_INTR_ENDPT,
+	UE_INTERRUPT,
+	{8, 0},			/* max packet */
+	255
+};
+
+static const
+usb_hub_descriptor_t ehci_hubd =
+{
+	USB_HUB_DESCRIPTOR_SIZE,
+	UDESC_HUB,
+	0,
+	{0,0},
+	0,
+	0,
+	{0},
+};
+
+static int
+ehci_str(usb_string_descriptor_t *p, int l, char *s)
+{
+	int i;
+
+	if(l == 0)
+	{
+		return (0);
+	}
+	p->bLength = (2 * strlen(s)) + 2;
+	if(l == 1)
+	{
+		return (1);
+	}
+	p->bDescriptorType = UDESC_STRING;
+	l -= 2;
+	for(i = 0; s[i] && (l > 1); i++, l -= 2)
+	{
+		USETW2(p->bString[i], 0, s[i]);
+	}
+	return ((2 * i) + 2);
+}
+
+static void
+ehci_disown(ehci_softc_t *sc, int index, int lowspeed)
+{
+	u_int32_t port;
+	u_int32_t v;
+
+	DPRINTF(("index=%d lowspeed=%d\n", index, lowspeed));
+
+	port = EHCI_PORTSC(index);
+	v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
+	EOWRITE4(sc, port, v | EHCI_PS_PO);
+}
+
+static void
+ehci_root_ctrl_enter(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+	usb_device_request_t *req = xfer->buffer;
+	void *buf;
+	int port, i;
+	int len, value, index, l, totlen = 0;
+	usb_port_status_t ps;
+	usb_hub_descriptor_t hubd;
+	usbd_status err;
+	u_int32_t v;
+
+	DPRINTFN(2,("type=0x%02x request=0x%02x\n",
+		    req->bmRequestType, req->bRequest));
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	/* set default actual length */
+	xfer->actlen = sizeof(*req);
+
+	len = UGETW(req->wLength);
+	value = UGETW(req->wValue);
+	index = UGETW(req->wIndex);
+
+	if(len != 0)
+	{
+		buf = (req+1);
+	}
+	else
+	{
+		buf = NULL;
+	}
+
+#define C(x,y) ((x) | ((y) << 8))
+	switch(C(req->bRequest, req->bmRequestType)) {
+	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
+	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
+	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
+		/*
+		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
+		 * for the integrated root hub.
+		 */
+		break;
+	case C(UR_GET_CONFIG, UT_READ_DEVICE):
+		if(len > 0)
+		{
+			*(u_int8_t *)buf = sc->sc_conf;
+			totlen = 1;
+		}
+		break;
+	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
+		DPRINTFN(8,("wValue=0x%04x\n", value));
+		switch(value >> 8) {
+		case UDESC_DEVICE:
+			if((value & 0xff) != 0)
+			{
+				err = USBD_IOERROR;
+				goto done;
+			}
+			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
+			memcpy(buf, &ehci_devd, l);
+#if 0
+			if(len >= 12)
+			{
+			  USETW(((usb_device_descriptor_t *)buf)->idVendor,
+				sc->sc_id_vendor);
+			}
+#endif
+			break;
+		/*
+		 * We can't really operate at another speed, but the spec says
+		 * we need this descriptor.
+		 */
+		case UDESC_DEVICE_QUALIFIER:
+			if((value & 0xff) != 0)
+			{
+				err = USBD_IOERROR;
+				goto done;
+			}
+			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
+			memcpy(buf, &ehci_odevd, l);
+			break;
+		/*
+		 * We can't really operate at another speed, but the spec says
+		 * we need this descriptor.
+		 */
+		case UDESC_OTHER_SPEED_CONFIGURATION:
+		case UDESC_CONFIG:
+			if((value & 0xff) != 0)
+			{
+				err = USBD_IOERROR;
+				goto done;
+			}
+			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
+			memcpy(buf, &ehci_confd, l);
+			((usb_config_descriptor_t *)buf)->bDescriptorType =
+				value >> 8;
+			buf = ((u_int8_t *)buf) + l;
+			len -= l;
+			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
+			totlen += l;
+			memcpy(buf, &ehci_ifcd, l);
+			buf = ((u_int8_t *)buf) + l;
+			len -= l;
+			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
+			totlen += l;
+			memcpy(buf, &ehci_endpd, l);
+			break;
+		case UDESC_STRING:
+			if(len == 0)
+			{
+				break;
+			}
+			*(u_int8_t *)buf = 0;
+			totlen = 1;
+			switch (value & 0xff) {
+			case 0: /* Language table */
+				totlen = ehci_str(buf, len, "\001");
+				break;
+			case 1: /* Vendor */
+				totlen = ehci_str(buf, len, sc->sc_vendor);
+				break;
+			case 2: /* Product */
+				totlen = ehci_str(buf, len, "EHCI root hub");
+				break;
+
+			}
+			break;
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+		break;
+	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
+		if(len > 0)
+		{
+			*(u_int8_t *)buf = 0;
+			totlen = 1;
+		}
+		break;
+	case C(UR_GET_STATUS, UT_READ_DEVICE):
+		if(len > 1)
+		{
+			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
+			totlen = 2;
+		}
+		break;
+	case C(UR_GET_STATUS, UT_READ_INTERFACE):
+	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
+		if(len > 1)
+		{
+			USETW(((usb_status_t *)buf)->wStatus, 0);
+			totlen = 2;
+		}
+		break;
+	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
+		if(value >= USB_MAX_DEVICES)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		sc->sc_addr = value;
+		break;
+	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
+		if((value != 0) && (value != 1))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		sc->sc_conf = value;
+		break;
+	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
+		break;
+	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
+	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
+	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
+		err = USBD_IOERROR;
+		goto done;
+	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
+		break;
+	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
+		break;
+	/* Hub requests */
+	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
+		break;
+	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
+		DPRINTFN(8, ("UR_CLEAR_PORT_FEATURE "
+			     "port=%d feature=%d\n",
+			     index, value));
+		if((index < 1) ||
+		   (index > sc->sc_noport))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		port = EHCI_PORTSC(index);
+		v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
+		switch(value) {
+		case UHF_PORT_ENABLE:
+			EOWRITE4(sc, port, v &~ EHCI_PS_PE);
+			break;
+		case UHF_PORT_SUSPEND:
+			EOWRITE4(sc, port, v &~ EHCI_PS_SUSP);
+			break;
+		case UHF_PORT_POWER:
+			EOWRITE4(sc, port, v &~ EHCI_PS_PP);
+			break;
+		case UHF_PORT_TEST:
+			DPRINTFN(2,("clear port test "
+				    "%d\n", index));
+			break;
+		case UHF_PORT_INDICATOR:
+			DPRINTFN(2,("clear port ind "
+				    "%d\n", index));
+			EOWRITE4(sc, port, v &~ EHCI_PS_PIC);
+			break;
+		case UHF_C_PORT_CONNECTION:
+			EOWRITE4(sc, port, v | EHCI_PS_CSC);
+			break;
+		case UHF_C_PORT_ENABLE:
+			EOWRITE4(sc, port, v | EHCI_PS_PEC);
+			break;
+		case UHF_C_PORT_SUSPEND:
+			/* how? */
+			break;
+		case UHF_C_PORT_OVER_CURRENT:
+			EOWRITE4(sc, port, v | EHCI_PS_OCC);
+			break;
+		case UHF_C_PORT_RESET:
+			sc->sc_isreset = 0;
+			break;
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+#if 0
+		switch(value) {
+		case UHF_C_PORT_CONNECTION:
+		case UHF_C_PORT_ENABLE:
+		case UHF_C_PORT_SUSPEND:
+		case UHF_C_PORT_OVER_CURRENT:
+		case UHF_C_PORT_RESET:
+			/* Enable RHSC interrupt if condition is cleared. */
+			if((OREAD4(sc, port) >> 16) == 0)
+			{
+				mtx_lock(&sc->sc_bus.mtx);
+				ehci_pcd_enable(sc);
+			}
+			break;
+		default:
+			break;
+		}
+#endif
+		break;
+	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
+		if((value & 0xff) != 0)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		hubd = ehci_hubd;
+		hubd.bNbrPorts = sc->sc_noport;
+		v = EOREAD4(sc, EHCI_HCSPARAMS);
+		USETW(hubd.wHubCharacteristics,
+		    (EHCI_HCS_PPC(v) ? UHD_PWR_INDIVIDUAL : UHD_PWR_NO_SWITCH) |
+		      (EHCI_HCS_P_INDICATOR(EREAD4(sc, EHCI_HCSPARAMS)) ?
+		       UHD_PORT_IND : 0));
+		hubd.bPwrOn2PwrGood = 200; /* XXX can't find out? */
+		for(i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
+		{
+			hubd.DeviceRemovable[i++] = 0; /* XXX can't find out? */
+		}
+		hubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;
+		l = min(len, hubd.bDescLength);
+		totlen = l;
+		memcpy(buf, &hubd, l);
+		break;
+	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
+		if(len != 4)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		memset(buf, 0, len);
+		totlen = len;
+		break;
+	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
+		DPRINTFN(8,("get port status i=%d\n",
+			    index));
+		if((index < 1) || (index > sc->sc_noport))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		if(len != 4)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		v = EOREAD4(sc, EHCI_PORTSC(index));
+		DPRINTFN(8,("port status=0x%04x\n",
+			    v));
+		i = UPS_HIGH_SPEED;
+		if(v & EHCI_PS_CS)	i |= UPS_CURRENT_CONNECT_STATUS;
+		if(v & EHCI_PS_PE)	i |= UPS_PORT_ENABLED;
+		if(v & EHCI_PS_SUSP)	i |= UPS_SUSPEND;
+		if(v & EHCI_PS_OCA)	i |= UPS_OVERCURRENT_INDICATOR;
+		if(v & EHCI_PS_PR)	i |= UPS_RESET;
+		if(v & EHCI_PS_PP)	i |= UPS_PORT_POWER;
+		USETW(ps.wPortStatus, i);
+		i = 0;
+		if(v & EHCI_PS_CSC)	i |= UPS_C_CONNECT_STATUS;
+		if(v & EHCI_PS_PEC)	i |= UPS_C_PORT_ENABLED;
+		if(v & EHCI_PS_OCC)	i |= UPS_C_OVERCURRENT_INDICATOR;
+		if(sc->sc_isreset)	i |= UPS_C_PORT_RESET;
+		USETW(ps.wPortChange, i);
+		l = min(len, sizeof ps);
+		memcpy(buf, &ps, l);
+		totlen = l;
+		break;
+	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
+		err = USBD_IOERROR;
+		goto done;
+	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
+		break;
+	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
+		if((index < 1) || 
+		   (index > sc->sc_noport))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		port = EHCI_PORTSC(index);
+		v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
+		switch(value) {
+		case UHF_PORT_ENABLE:
+			EOWRITE4(sc, port, v | EHCI_PS_PE);
+			break;
+		case UHF_PORT_SUSPEND:
+			EOWRITE4(sc, port, v | EHCI_PS_SUSP);
+			break;
+		case UHF_PORT_RESET:
+			DPRINTFN(5,("reset port %d\n",
+				    index));
+			if(EHCI_PS_IS_LOWSPEED(v))
+			{
+				/* Low speed device, give up ownership. */
+				ehci_disown(sc, index, 1);
+				break;
+			}
+			/* Start reset sequence. */
+			v &= ~ (EHCI_PS_PE | EHCI_PS_PR);
+			EOWRITE4(sc, port, v | EHCI_PS_PR);
+			/* Wait for reset to complete. */
+			DELAY(1000*USB_PORT_ROOT_RESET_DELAY);
+
+			/* Terminate reset sequence. */
+			EOWRITE4(sc, port, v);
+			/* Wait for HC to complete reset. */
+			DELAY(1000*EHCI_PORT_RESET_COMPLETE);
+			v = EOREAD4(sc, port);
+			DPRINTF(("ehci after reset, status=0x%08x\n", v));
+			if(v & EHCI_PS_PR)
+			{
+				device_printf(sc->sc_bus.bdev,
+					      "port reset timeout\n");
+				err = USBD_TIMEOUT;
+				goto done;
+			}
+			if(!(v & EHCI_PS_PE))
+			{
+				/* Not a high speed device, 
+				 * give up ownership.
+				 */
+				ehci_disown(sc, index, 0);
+				break;
+			}
+			sc->sc_isreset = 1;
+			DPRINTF(("ehci port %d reset, status = 0x%08x\n",
+				 index, v));
+			break;
+		case UHF_PORT_POWER:
+			DPRINTFN(2,("set port power %d\n", index));
+			EOWRITE4(sc, port, v | EHCI_PS_PP);
+			break;
+		case UHF_PORT_TEST:
+			DPRINTFN(2,("set port test %d\n", index));
+			break;
+		case UHF_PORT_INDICATOR:
+			DPRINTFN(2,("set port ind %d\n", index));
+			EOWRITE4(sc, port, v | EHCI_PS_PIC);
+			break;
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+		break;
+	case C(UR_CLEAR_TT_BUFFER, UT_WRITE_CLASS_OTHER):
+	case C(UR_RESET_TT, UT_WRITE_CLASS_OTHER):
+	case C(UR_GET_TT_STATE, UT_READ_CLASS_OTHER):
+	case C(UR_STOP_TT, UT_WRITE_CLASS_OTHER):
+		break;
+	default:
+		err = USBD_IOERROR;
+		goto done;
+	}
+	xfer->actlen = totlen + sizeof(*req);
+	err = USBD_NORMAL_COMPLETION;
+
+ done:
+	/* transfer transferred */
+	ehci_device_done(xfer, err);
+
+	/* call callback recursively */
+	__usbd_callback(xfer);
+
+	return;
+}
+
+static void
+ehci_root_ctrl_start(struct usbd_xfer *xfer)
+{
+	/* not used */
+	return;
+}
+
+struct usbd_pipe_methods ehci_root_ctrl_methods = 
+{
+  .open = ehci_root_ctrl_open,
+  .close = ehci_root_ctrl_close,
+  .enter = ehci_root_ctrl_enter,
+  .start = ehci_root_ctrl_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ehci root interrupt support
+ *---------------------------------------------------------------------------*/
+static void
+ehci_root_intr_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ehci_root_intr_close(struct usbd_xfer *xfer)
+{
+	ehci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ehci_root_intr_enter(struct usbd_xfer *xfer)
+{
+	DPRINTFN(3, ("xfer=%p len=%d\n",
+		     xfer, xfer->length));
+
+	/* enqueue transfer
+	 * (so that it can be aborted through pipe abort)  
+	 */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ehci_root_intr_start(struct usbd_xfer *xfer)
+{
+	ehci_softc_t *sc = xfer->usb_sc;
+
+	/* only one transfer at at time 
+	 * (sc_intrxfer is cleared by ehci_root_intr_done())
+	 */
+	sc->sc_intrxfer = xfer;
+	return;
+}
+
+struct usbd_pipe_methods ehci_root_intr_methods = 
+{
+  .open = ehci_root_intr_open,
+  .close = ehci_root_intr_close,
+  .enter = ehci_root_intr_enter,
+  .start = ehci_root_intr_start,
+};
+
+#define ADD_BYTES(ptr,size) ((void *)(((u_int8_t *)(ptr)) + (size)))
+
+static usbd_status
+ehci_xfer_setup(struct usbd_device *udev,
+		u_int8_t iface_index,
+		struct usbd_xfer **pxfer,
+		const struct usbd_config *setup_start,
+		const struct usbd_config *setup_end)
+{
+	ehci_softc_t *sc = EHCI_BUS2SC(udev->bus);
+	const struct usbd_config *setup;
+	struct usbd_memory_info *info;
+	struct usbd_xfer dummy;
+	struct usbd_xfer *xfer;
+	u_int32_t physbuffer;
+	u_int32_t size;
+	u_int32_t total_size;
+	u_int32_t nqtd;
+	u_int32_t nqh;
+	u_int32_t nsitd;
+	u_int32_t nitd;
+	u_int32_t n;
+	void *buf;
+	usbd_status error = 0;
+
+	buf = 0;
+	physbuffer = 0;
+	total_size = 0;
+
+ repeat:
+	size = 0;
+
+	/* align data to 8 byte boundary */
+	size += ((-size) & (USB_HOST_ALIGN-1));
+
+	if(buf)
+	{
+	    info = ADD_BYTES(buf,size);
+
+	    info->memory_base = buf;
+	    info->memory_size = total_size;
+	    info->usb_mtx = &sc->sc_bus.mtx;
+	}
+	else
+	{
+	    info = NULL;
+	}
+
+	size += sizeof(info[0]);
+
+	for(setup = setup_start;
+	    setup < setup_end;
+	    setup++)
+	{
+	  nqtd = 0;
+	  nqh = 0;
+	  nsitd = 0;
+	  nitd = 0;
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		*pxfer++ = (xfer = ADD_BYTES(buf,size));
+	  }
+	  else
+	  {
+		/* need dummy xfer to 
+		 * calculate nqtd and nqh !
+		 */
+		xfer = &dummy;
+		bzero(&dummy, sizeof(dummy));
+	  }
+
+	  /*
+	   * setup xfer
+	   */
+	  xfer->usb_sc = sc;
+	  xfer->usb_mtx = &sc->sc_bus.mtx;
+	  xfer->usb_root = info;
+	  xfer->flags = setup->flags;
+	  xfer->length = setup->bufsize;
+	  xfer->nframes = setup->frames;
+	  xfer->timeout = setup->timeout;
+	  xfer->callback = setup->callback;
+
+	  __callout_init_mtx(&xfer->timeout_handle, &sc->sc_bus.mtx, 
+			     CALLOUT_RETURNUNLOCKED);
+
+	  xfer->pipe = usbd_get_pipe(udev, iface_index, setup);
+
+	  if(!xfer->pipe)
+	  {
+		/* continue though this error is critical */
+		error = USBD_NO_PIPE;
+		DPRINTF(("no pipe for endpoint %d\n",
+			 setup->endpoint));
+	  }
+	  else
+	  {
+		xfer->interval = setup->interval;
+
+		if(xfer->interval == 0)
+		{
+			xfer->interval = xfer->pipe->edesc->bInterval;
+		}
+
+		if(xfer->interval == 0)
+		{
+			/* one is the smallest interval */
+			xfer->interval = 1;
+		}
+
+		xfer->address = udev->address;
+		xfer->endpoint = xfer->pipe->edesc->bEndpointAddress;
+		xfer->max_packet_size = UGETW(xfer->pipe->edesc->wMaxPacketSize);
+
+		/* wMaxPacketSize is validated by "usbd_fill_iface_data()" */
+
+		/*
+		 * compute maximum number of some structures
+		 */
+		if((xfer->pipe->methods == &ehci_device_ctrl_methods) ||
+		   (xfer->pipe->methods == &ehci_device_bulk_methods) ||
+		   (xfer->pipe->methods == &ehci_device_intr_methods))
+		{
+			nqh = 1;
+			nqtd = (1+ /* SETUP */ 1+ /* STATUS */
+			       1  /* SHORTPKT */) +
+			  (xfer->length / (EHCI_PAGE_SIZE/2)); /* DATA */
+		}
+
+		if(xfer->pipe->methods == &ehci_device_isoc_fs_methods)
+		{
+			if(xfer->nframes == 0)
+			{
+				/* continue, though this error is critical */
+				error = USBD_ZERO_FRAMES_IN_ISOC_MODE;
+				DPRINTF(("frames == 0 in isochronous mode; "
+					 "endpoint 0x%02x\n", setup->endpoint));
+			}
+			if(xfer->nframes >= EHCI_VIRTUAL_FRAMELIST_COUNT)
+			{
+				/* continue, though this error is critical */
+				error = USBD_INVAL;
+				DPRINTF(("isochronous frame-limit "
+					 "exceeded by 0x%x frames; "
+					 "endpoint 0x%02x\n",
+					 setup->frames - 
+					 EHCI_VIRTUAL_FRAMELIST_COUNT,
+					 setup->endpoint));
+			}
+			nsitd = xfer->nframes;
+		}
+
+		if(xfer->pipe->methods == &ehci_device_isoc_hs_methods)
+		{
+			if(xfer->nframes == 0)
+			{
+				/* continue, though this error is critical */
+				error = USBD_ZERO_FRAMES_IN_ISOC_MODE;
+				DPRINTF(("frames == 0 in isochronous mode; "
+					 "endpoint 0x%02x\n", setup->endpoint));
+			}
+			if(xfer->nframes >= (8*EHCI_VIRTUAL_FRAMELIST_COUNT))
+			{
+				/* continue, though this error is critical */
+				error = USBD_INVAL;
+				DPRINTF(("isochronous frame-limit "
+					 "exceeded by 0x%x frames; "
+					 "endpoint 0x%02x\n",
+					 setup->frames - 
+					 (8*EHCI_VIRTUAL_FRAMELIST_COUNT),
+					 setup->endpoint));
+			}
+			nitd = (xfer->nframes + 7) / 8;
+		}
+	  }
+
+	  size += sizeof(xfer[0]);
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		xfer->frlengths = ADD_BYTES(buf,size);
+	  }
+
+	  if(nsitd)
+	  {
+		size += 1 * EHCI_VIRTUAL_FRAMELIST_COUNT * sizeof(xfer->frlengths[0]);
+	  }
+
+	  if(nitd)
+	  {
+		size += 8 * EHCI_VIRTUAL_FRAMELIST_COUNT * sizeof(xfer->frlengths[0]);
+	  }
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		xfer->buffer = ADD_BYTES(buf,size);
+		xfer->physbuffer = (physbuffer + size);
+	  }
+
+	  size += setup->bufsize;
+
+	  /* memory is allocated at 
+	   * highest alignment 
+	   * which is first
+	   */
+	  if(nitd)
+	  {
+		/* align data */
+		size += ((-size) & (EHCI_ITD_ALIGN-1));
+	  }
+
+	  if(nsitd)
+	  {
+		/* align data */
+		size += ((-size) & (EHCI_SITD_ALIGN-1));
+	  }
+
+	  if(nqtd)
+	  {
+		/* align data */
+		size += ((-size) & (EHCI_QTD_ALIGN-1));
+	  }
+
+	  if(buf)
+	  {
+		xfer->td_start = ADD_BYTES(buf,size);
+	  }
+
+	  for(n = 0;
+	      n < nitd;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init TD */
+		((ehci_itd_t *)ADD_BYTES(buf,size))->itd_self = 
+		  htole32((physbuffer + size)|EHCI_LINK_ITD);
+	    }
+	    size += sizeof(ehci_itd_t);
+	  }
+
+	  for(n = 0;
+	      n < nsitd;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init TD */
+		((ehci_sitd_t *)ADD_BYTES(buf,size))->sitd_self = 
+		  htole32((physbuffer + size)|EHCI_LINK_SITD);
+	    }
+	    size += sizeof(ehci_sitd_t);
+	  }
+
+	  for(n = 0;
+	      n < nqtd;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init TD */
+		((ehci_qtd_t *)ADD_BYTES(buf,size))->qtd_self = 
+		  htole32(physbuffer + size);
+	    }
+	    size += sizeof(ehci_qtd_t);
+	  }
+
+	  if(buf)
+	  {
+		xfer->td_end = ADD_BYTES(buf,size);
+	  }
+
+	  if(nqh)
+	  {
+		/* align data */
+		size += ((-size) & (EHCI_QH_ALIGN-1));
+	  }
+
+	  if(buf)
+	  {
+		xfer->qh_start = ADD_BYTES(buf,size);
+	  }
+
+	  for(n = 0;
+	      n < nqh;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init QH */
+		((ehci_qh_t *)ADD_BYTES(buf,size))->qh_self = 
+		  htole32((physbuffer + size)|EHCI_LINK_QH);
+	    }
+	    size += sizeof(ehci_qh_t);
+	  }
+
+	  if(buf)
+	  {
+		xfer->qh_end = ADD_BYTES(buf,size);
+	  }
+	}
+
+	if(!buf && !error)
+	{
+		/* store total buffer size */
+		total_size = size;
+
+		/* allocate zeroed memory */
+		buf = usb_alloc_mem(device_get_dma_tag(sc->sc_dev),
+				    size, LOG2(EHCI_ITD_ALIGN));
+
+		if(!buf)
+		{
+			error = USBD_NOMEM;
+			DPRINTF(("cannot allocate memory block for "
+				 "configuration (%d bytes)\n", size));
+		}
+		else
+		{
+#if 1
+			bzero(buf, size);
+#endif
+			physbuffer = usb_vtophys(buf, size);
+			goto repeat;
+		}
+	}
+	return error;
+}
+
+static void
+ehci_pipe_init(struct usbd_device *udev, usb_endpoint_descriptor_t *edesc, 
+               struct usbd_pipe *pipe)
+{
+	ehci_softc_t *sc = EHCI_BUS2SC(udev->bus);
+
+	DPRINTFN(1, ("pipe=%p, addr=%d, endpt=%d (%d)\n",
+		     pipe, udev->address,
+		     edesc->bEndpointAddress, sc->sc_addr));
+
+	if(udev->address == sc->sc_addr)
+	{
+		switch (edesc->bEndpointAddress)
+		{
+		case USB_CONTROL_ENDPOINT:
+			pipe->methods = &ehci_root_ctrl_methods;
+			break;
+		case UE_DIR_IN | EHCI_INTR_ENDPT:
+			pipe->methods = &ehci_root_intr_methods;
+			break;
+		default:
+			panic("invalid endpoint address: 0x%02x",
+			      edesc->bEndpointAddress);
+			break;
+		}
+	}
+	else
+        {
+		switch (edesc->bmAttributes & UE_XFERTYPE)
+		{
+		case UE_CONTROL:
+			pipe->methods = &ehci_device_ctrl_methods;
+			break;
+		case UE_INTERRUPT:
+			pipe->methods = &ehci_device_intr_methods;
+			break;
+		case UE_ISOCHRONOUS:
+			if(udev->speed == USB_SPEED_HIGH)
+			{
+				pipe->methods = &ehci_device_isoc_hs_methods;
+			}
+			else
+			{
+				pipe->methods = &ehci_device_isoc_fs_methods;
+			}
+			break;
+		case UE_BULK:
+			pipe->methods = &ehci_device_bulk_methods;
+			break;
+		}
+	}
+	return;
+}
+
+struct usbd_bus_methods ehci_bus_methods = 
+{
+	.pipe_init  = ehci_pipe_init,
+	.xfer_setup = ehci_xfer_setup,
+	.do_poll    = ehci_do_poll,
+};
diff -rubN /usr/src1/src/sys/dev/usb2/_ehci_pci.c /usr/src/sys/dev/usb2/_ehci_pci.c
--- /usr/src1/src/sys/dev/usb2/_ehci_pci.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_ehci_pci.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,461 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (augustss@carlstedt.se) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * USB Enhanced Host Controller Driver, a.k.a. USB 2.0 controller.
+ *
+ * The EHCI 1.0 spec can be found at
+ * http://developer.intel.com/technology/usb/download/ehci-r10.pdf
+ * and the USB 2.0 spec at
+ * http://www.usb.org/developers/docs/usb_20.zip
+ */
+
+/* The low level controller code for EHCI has been split into
+ * PCI probes and EHCI specific code. This was done to facilitate the
+ * sharing of code between *BSD's
+ */
+
+#include "opt_bus.h"
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/endian.h>
+#include <sys/queue.h> /* LIST_XXX() */
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h> /* bus_space_xxx() */
+
+#define INCLUDE_PCIXXX_H
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/ehci.h> 
+
+__FBSDID("$FreeBSD: src/sys/dev/usb2/ehci_pci.c,v 1.14 2004/08/02 15:37:34 iedowse Exp $");
+
+#define PCI_EHCI_VENDORID_ACERLABS	0x10b9
+#define PCI_EHCI_VENDORID_AMD		0x1022
+#define PCI_EHCI_VENDORID_APPLE		0x106b
+#define PCI_EHCI_VENDORID_CMDTECH	0x1095
+#define PCI_EHCI_VENDORID_INTEL		0x8086
+#define PCI_EHCI_VENDORID_NEC		0x1033
+#define PCI_EHCI_VENDORID_OPTI		0x1045
+#define PCI_EHCI_VENDORID_SIS		0x1039
+#define PCI_EHCI_VENDORID_NVIDIA	0x12D2
+#define PCI_EHCI_VENDORID_NVIDIA2	0x10DE
+#define PCI_EHCI_VENDORID_VIA		0x1106
+
+#define PCI_EHCI_BASE_REG	0x10
+
+static void ehci_pci_givecontroller(device_t self);
+static void ehci_pci_takecontroller(device_t self);
+
+static int
+ehci_pci_suspend(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+	int err;
+
+	err = bus_generic_suspend(self);
+	if(err)
+	{
+		return (err);
+	}
+	ehci_suspend(sc);
+	return 0;
+}
+
+static int
+ehci_pci_resume(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+
+	ehci_pci_takecontroller(self);
+	ehci_resume(sc);
+
+	bus_generic_resume(self);
+	return 0;
+}
+
+static int
+ehci_pci_shutdown(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+	int err;
+
+	err = bus_generic_shutdown(self);
+	if(err)
+	{
+		return (err);
+	}
+	ehci_shutdown(sc);
+	ehci_pci_givecontroller(self);
+
+	return 0;
+}
+
+static const char *
+ehci_pci_match(device_t self)
+{
+	u_int32_t device_id = pci_get_devid(self);
+
+	if(device_id == 0x00e01033)
+	  { return ("NEC uPD 720100 USB 2.0 controller"); }
+	if(device_id == 0x31041106)
+	  { return ("VIA VT6202 USB 2.0 controller"); }
+
+	if((pci_get_class(self) == PCIC_SERIALBUS)
+	   && (pci_get_subclass(self) == PCIS_SERIALBUS_USB)
+	   && (pci_get_progif(self) == PCI_INTERFACE_EHCI))
+	{
+		return ("EHCI (generic) USB 2.0 controller");
+	}
+	return NULL;
+}
+
+static int
+ehci_pci_probe(device_t self)
+{
+	const char *desc = ehci_pci_match(self);
+
+	if(desc)
+	{
+		device_set_desc(self, desc);
+		return 0;
+	}
+	else
+	{
+		return ENXIO;
+	}
+}
+
+static int
+ehci_pci_detach(device_t self);
+
+static int
+ehci_pci_attach(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+	int err;
+	int rid;
+
+	sc = usb_alloc_mem(device_get_dma_tag(self),
+			   sizeof(*sc), LOG2(EHCI_FRAMELIST_ALIGN));
+
+	if(sc == NULL)
+	{
+		device_printf(self, "Could not allocate sc\n");
+		return ENXIO;
+	}
+
+#if 1
+	bzero(sc, sizeof(*sc));
+#endif
+	sc->sc_physaddr = usb_vtophys(sc, sizeof(*sc)); /* physical address of sc */
+
+	mtx_init(&sc->sc_bus.mtx, "usb lock",
+		 NULL, MTX_DEF|MTX_RECURSE);
+
+	device_set_softc(self, sc);
+	sc->sc_dev = self;
+
+	pci_enable_busmaster(self);
+
+	switch(pci_read_config(self, PCI_USBREV, 1) & PCI_USBREV_MASK) {
+	case PCI_USBREV_PRE_1_0:
+	case PCI_USBREV_1_0:
+	case PCI_USBREV_1_1:
+		sc->sc_bus.usbrev = USBREV_UNKNOWN;
+		printf("pre-2.0 USB rev\n");
+		return ENXIO;
+	case PCI_USBREV_2_0:
+		sc->sc_bus.usbrev = USBREV_2_0;
+		break;
+	default:
+		sc->sc_bus.usbrev = USBREV_UNKNOWN;
+		break;
+	}
+
+	rid = PCI_CBMEM;
+	sc->io_res = bus_alloc_resource_any(self, SYS_RES_MEMORY, &rid,
+					    RF_ACTIVE);
+	if(!sc->io_res)
+	{
+		device_printf(self, "Could not map memory\n");
+		goto error;
+	}
+	sc->iot = rman_get_bustag(sc->io_res);
+	sc->ioh = rman_get_bushandle(sc->io_res);
+
+	rid = 0;
+	sc->irq_res = bus_alloc_resource_any(self, SYS_RES_IRQ, &rid,
+					     RF_SHAREABLE | RF_ACTIVE);
+	if (sc->irq_res == NULL)
+	{
+		device_printf(self, "Could not allocate irq\n");
+		goto error;
+	}
+
+	sc->sc_bus.bdev = device_add_child(self, "usb", -1);
+	if(!sc->sc_bus.bdev)
+	{
+		device_printf(self, "Could not add USB device\n");
+		goto error;
+	}
+
+	device_set_ivars(sc->sc_bus.bdev, &sc->sc_bus);
+	device_set_softc(sc->sc_bus.bdev, &sc->sc_bus);
+
+	/* ehci_pci_match will never return NULL if ehci_pci_probe succeeded */
+	device_set_desc(sc->sc_bus.bdev, ehci_pci_match(self));
+	switch (pci_get_vendor(self)) {
+	case PCI_EHCI_VENDORID_ACERLABS:
+		sprintf(sc->sc_vendor, "AcerLabs");
+		break;
+	case PCI_EHCI_VENDORID_AMD:
+		sprintf(sc->sc_vendor, "AMD");
+		break;
+	case PCI_EHCI_VENDORID_APPLE:
+		sprintf(sc->sc_vendor, "Apple");
+		break;
+	case PCI_EHCI_VENDORID_CMDTECH:
+		sprintf(sc->sc_vendor, "CMDTECH");
+		break;
+	case PCI_EHCI_VENDORID_INTEL:
+		sprintf(sc->sc_vendor, "Intel");
+		break;
+	case PCI_EHCI_VENDORID_NEC:
+		sprintf(sc->sc_vendor, "NEC");
+		break;
+	case PCI_EHCI_VENDORID_OPTI:
+		sprintf(sc->sc_vendor, "OPTi");
+		break;
+	case PCI_EHCI_VENDORID_SIS:
+		sprintf(sc->sc_vendor, "SiS");
+		break;
+	case PCI_EHCI_VENDORID_NVIDIA:
+	case PCI_EHCI_VENDORID_NVIDIA2:
+		sprintf(sc->sc_vendor, "nVidia");
+		break;
+	case PCI_EHCI_VENDORID_VIA:
+		sprintf(sc->sc_vendor, "VIA");
+		break;
+	default:
+		if(bootverbose)
+		{
+			device_printf(self, "(New EHCI DeviceId=0x%08x)\n",
+				      pci_get_devid(self));
+		}
+		sprintf(sc->sc_vendor, "(0x%04x)", pci_get_vendor(self));
+	}
+
+	err = bus_setup_intr(self, sc->irq_res, INTR_TYPE_BIO|INTR_MPSAFE,
+			     (void *)(void *)ehci_interrupt, sc, &sc->ih);
+	if(err)
+	{
+		device_printf(self, "Could not setup irq, %d\n", err);
+		sc->ih = NULL;
+		goto error;
+	}
+
+	ehci_pci_takecontroller(self);
+	err = ehci_init(sc);
+	if(!err)
+	{
+		err = device_probe_and_attach(sc->sc_bus.bdev);
+	}
+
+	if(err)
+	{
+		device_printf(self, "USB init failed err=%d\n", err);
+		goto error;
+	}
+	return 0;
+
+ error:
+	ehci_pci_detach(self);
+	return ENXIO;
+}
+
+static int
+ehci_pci_detach(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+
+	if(sc->sc_bus.bdev)
+	{
+		device_delete_child(self, sc->sc_bus.bdev);
+		sc->sc_bus.bdev = NULL;
+	}
+
+	pci_disable_busmaster(self);
+
+	/*
+	 * disable interrupts that might have been switched on in ehci_init
+	 */
+	if(sc->io_res)
+	{
+		bus_space_write_4(sc->iot, sc->ioh, EHCI_USBINTR, 0);
+	}
+
+	if(sc->irq_res && sc->ih)
+	{
+		/* only call ehci_detach()
+		 * after ehci_init()
+		 */
+		ehci_detach(sc);
+
+		int err = bus_teardown_intr(self, sc->irq_res, sc->ih);
+
+		if(err)
+		{
+			/* XXX or should we panic? */
+			device_printf(self, "Could not tear down irq, %d\n",
+				      err);
+		}
+		sc->ih = NULL;
+	}
+	if(sc->irq_res)
+	{
+		bus_release_resource(self, SYS_RES_IRQ, 0, sc->irq_res);
+		sc->irq_res = NULL;
+	}
+	if(sc->io_res)
+	{
+		bus_release_resource(self, SYS_RES_MEMORY, PCI_CBMEM, 
+				     sc->io_res);
+		sc->io_res = NULL;
+	}
+
+	usb_free_mem(sc, sizeof(*sc));
+
+	device_set_softc(self, NULL);
+	return 0;
+}
+
+static void
+ehci_pci_takecontroller(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+	u_int32_t cparams, eec, legsup;
+	int eecp, i;
+
+	cparams = EREAD4(sc, EHCI_HCCPARAMS);
+
+	/* Synchronize with the BIOS if it owns the controller. */
+	for (eecp = EHCI_HCC_EECP(cparams); eecp != 0;
+	     eecp = EHCI_EECP_NEXT(eec))
+	{
+		eec = pci_read_config(self, eecp, 4);
+		if(EHCI_EECP_ID(eec) != EHCI_EC_LEGSUP)
+		{
+			continue;
+		}
+		legsup = eec;
+		pci_write_config(self, eecp, legsup | EHCI_LEGSUP_OSOWNED, 4);
+		if(legsup & EHCI_LEGSUP_BIOSOWNED)
+		{
+			device_printf(sc->sc_bus.bdev, "waiting for BIOS "
+				      "to give up control\n");
+
+			for (i = 0; i < 5000; i++)
+			{
+				legsup = pci_read_config(self, eecp, 4);
+				if((legsup & EHCI_LEGSUP_BIOSOWNED) == 0)
+				{
+					break;
+				}
+				DELAY(1000);
+			}
+			if(legsup & EHCI_LEGSUP_BIOSOWNED)
+			{
+				device_printf(sc->sc_bus.bdev, "timed out waiting for BIOS\n");
+			}
+		}
+	}
+}
+
+static void
+ehci_pci_givecontroller(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+	u_int32_t cparams, eec, legsup;
+	int eecp;
+
+	cparams = EREAD4(sc, EHCI_HCCPARAMS);
+	for (eecp = EHCI_HCC_EECP(cparams); eecp != 0;
+	     eecp = EHCI_EECP_NEXT(eec))
+	{
+		eec = pci_read_config(self, eecp, 4);
+		if(EHCI_EECP_ID(eec) != EHCI_EC_LEGSUP)
+		{
+			continue;
+		}
+		legsup = eec;
+		pci_write_config(self, eecp, legsup & ~EHCI_LEGSUP_OSOWNED, 4);
+	}
+}
+
+static driver_t ehci_driver =
+{
+	.name = "ehci",
+	.methods = (device_method_t [])
+	{
+	  /* device interface */
+	  DEVMETHOD(device_probe, ehci_pci_probe),
+	  DEVMETHOD(device_attach, ehci_pci_attach),
+	  DEVMETHOD(device_detach, ehci_pci_detach),
+	  DEVMETHOD(device_suspend, ehci_pci_suspend),
+	  DEVMETHOD(device_resume, ehci_pci_resume),
+	  DEVMETHOD(device_shutdown, ehci_pci_shutdown),
+
+	  /* bus interface */
+	  DEVMETHOD(bus_print_child, bus_generic_print_child),
+
+	  {0, 0}
+	},
+	.size = 0,
+};
+
+static devclass_t ehci_devclass;
+
+DRIVER_MODULE(ehci, pci, ehci_driver, ehci_devclass, 0, 0);
+DRIVER_MODULE(ehci, cardbus, ehci_driver, ehci_devclass, 0, 0);
diff -rubN /usr/src1/src/sys/dev/usb2/_ohci.c /usr/src/sys/dev/usb2/_ohci.c
--- /usr/src1/src/sys/dev/usb2/_ohci.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_ohci.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,2684 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * USB Open Host Controller driver.
+ *
+ * OHCI spec: http://www.compaq.com/productinfo/development/openhci.html
+ * USB spec: http://www.usb.org/developers/docs/usbspec.zip
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/endian.h>
+#include <sys/queue.h> /* LIST_XXX() */
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h> /* bus_space_xxx() */
+
+#define INCLUDE_PCIXXX_H
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/ohci.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb/ohci.c,v 1.145 2004/11/09 20:51:32 iedowse Exp $");
+
+#define MS_TO_TICKS(ms) (((ms) * hz) / 1000)
+#define OHCI_BUS2SC(bus) ((ohci_softc_t *)(((u_int8_t *)(bus)) - \
+   POINTER_TO_UNSIGNED(&(((ohci_softc_t *)0)->sc_bus))))
+
+#ifdef USB_DEBUG
+#undef DPRINTF
+#undef DPRINTFN
+#define DPRINTF(x)	{ if (ohcidebug) { printf("%s: ", __FUNCTION__); printf x ; } }
+#define DPRINTFN(n,x)	{ if (ohcidebug > (n)) { printf("%s: ", __FUNCTION__); printf x ; } }
+int ohcidebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, ohci, CTLFLAG_RW, 0, "USB ohci");
+SYSCTL_INT(_hw_usb_ohci, OID_AUTO, debug, CTLFLAG_RW,
+	   &ohcidebug, 0, "ohci debug level");
+static void		ohci_dumpregs(ohci_softc_t *);
+static void		ohci_dump_tds(ohci_td_t *);
+static void		ohci_dump_td(ohci_td_t *);
+static void		ohci_dump_ed(ohci_ed_t *);
+static void		ohci_dump_itd(ohci_itd_t *);
+static void		ohci_dump_itds(ohci_itd_t *);
+#endif
+
+#define OBARR(sc) bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->sc_size, \
+			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
+#define OWRITE1(sc, r, x) \
+ do { OBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
+#define OWRITE2(sc, r, x) \
+ do { OBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
+#define OWRITE4(sc, r, x) \
+ do { OBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
+#define OREAD1(sc, r) (OBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
+#define OREAD2(sc, r) (OBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
+#define OREAD4(sc, r) (OBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))
+
+#define OHCI_INTR_ENDPT 1
+
+extern struct usbd_bus_methods ohci_bus_methods;
+extern struct usbd_pipe_methods ohci_device_bulk_methods;
+extern struct usbd_pipe_methods ohci_device_ctrl_methods;
+extern struct usbd_pipe_methods ohci_device_intr_methods;
+extern struct usbd_pipe_methods ohci_device_isoc_methods;
+extern struct usbd_pipe_methods ohci_root_ctrl_methods;
+extern struct usbd_pipe_methods ohci_root_intr_methods;
+
+#define PHYSADDR(sc,what) \
+  ((sc)->sc_physaddr + POINTER_TO_UNSIGNED(&(((struct ohci_softc *)0)->what)))
+
+static usbd_status
+ohci_controller_init(ohci_softc_t *sc)
+{
+	int i;
+	u_int32_t s, ctl, ival, hcr, fm, per, desca;
+
+	/* Determine in what context we are running. */
+	ctl = OREAD4(sc, OHCI_CONTROL);
+	if(ctl & OHCI_IR)
+	{
+		/* SMM active, request change */
+		DPRINTF(("SMM active, request owner change\n"));
+		s = OREAD4(sc, OHCI_COMMAND_STATUS);
+		OWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);
+		for(i = 0; (i < 100) && (ctl & OHCI_IR); i++)
+		{
+			DELAY(1000*1);
+			ctl = OREAD4(sc, OHCI_CONTROL);
+		}
+		if((ctl & OHCI_IR) == 0)
+		{
+			device_printf(sc->sc_bus.bdev, "SMM does not respond, resetting\n");
+			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
+			goto reset;
+		}
+#if 0
+/* Don't bother trying to reuse the BIOS init, we'll reset it anyway. */
+	} else if((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_RESET) {
+		/* BIOS started controller. */
+		DPRINTF(("BIOS active\n"));
+		if((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_OPERATIONAL) {
+			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL);
+			DELAY(1000*USB_RESUME_DELAY);
+		}
+#endif
+	} else {
+		DPRINTF(("cold started\n"));
+	reset:
+		/* controller was cold started */
+		DELAY(1000*USB_BUS_RESET_DELAY);
+	}
+
+	/*
+	 * This reset should not be necessary according to the OHCI spec, but
+	 * without it some controllers do not start.
+	 */
+	DPRINTF(("%s: resetting\n", device_get_nameunit(sc->sc_bus.bdev)));
+	OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
+	DELAY(1000*USB_BUS_RESET_DELAY);
+
+	/* we now own the host controller and the bus has been reset */
+	ival = OHCI_GET_IVAL(OREAD4(sc, OHCI_FM_INTERVAL));
+
+	OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_HCR); /* Reset HC */
+	/* nominal time for a reset is 10 us */
+	for(i = 0; i < 10; i++)
+	{
+		DELAY(10);
+		hcr = OREAD4(sc, OHCI_COMMAND_STATUS) & OHCI_HCR;
+		if(!hcr)
+		{
+			break;
+		}
+	}
+	if(hcr)
+	{
+		device_printf(sc->sc_bus.bdev, "reset timeout\n");
+		return (USBD_IOERROR);
+	}
+#ifdef USB_DEBUG
+	if(ohcidebug > 15)
+	{
+		ohci_dumpregs(sc);
+	}
+#endif
+
+	/* The controller is now in SUSPEND state, we have 2ms to finish. */
+
+	/* set up HC registers */
+	OWRITE4(sc, OHCI_HCCA, PHYSADDR(sc, sc_hw.hcca));
+	OWRITE4(sc, OHCI_CONTROL_HEAD_ED, PHYSADDR(sc, sc_hw.ctrl_start));
+	OWRITE4(sc, OHCI_BULK_HEAD_ED, PHYSADDR(sc, sc_hw.bulk_start));
+	/* disable all interrupts and then switch on all desired interrupts */
+	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
+	OWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);
+	/* switch on desired functional features */
+	ctl = OREAD4(sc, OHCI_CONTROL);
+	ctl &= ~(OHCI_CBSR_MASK | OHCI_LES | OHCI_HCFS_MASK | OHCI_IR);
+	ctl |= OHCI_PLE | OHCI_IE | OHCI_CLE | OHCI_BLE |
+		OHCI_RATIO_1_4 | OHCI_HCFS_OPERATIONAL;
+	/* And finally start it! */
+	OWRITE4(sc, OHCI_CONTROL, ctl);
+
+	/*
+	 * The controller is now OPERATIONAL.  Set a some final
+	 * registers that should be set earlier, but that the
+	 * controller ignores when in the SUSPEND state.
+	 */
+	fm = (OREAD4(sc, OHCI_FM_INTERVAL) & OHCI_FIT) ^ OHCI_FIT;
+	fm |= OHCI_FSMPS(ival) | ival;
+	OWRITE4(sc, OHCI_FM_INTERVAL, fm);
+	per = OHCI_PERIODIC(ival); /* 90% periodic */
+	OWRITE4(sc, OHCI_PERIODIC_START, per);
+
+	/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */
+	desca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
+	OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca | OHCI_NOCP);
+	OWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */
+	DELAY(1000*OHCI_ENABLE_POWER_DELAY);
+	OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca);
+
+	/*
+	 * The AMD756 requires a delay before re-reading the register,
+	 * otherwise it will occasionally report 0 ports.
+	 */
+  	sc->sc_noport = 0;
+ 	for(i = 0; (i < 10) && (sc->sc_noport == 0); i++)
+	{
+ 		DELAY(1000*OHCI_READ_DESC_DELAY);
+ 		sc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));
+ 	}
+
+#ifdef USB_DEBUG
+	if(ohcidebug > 5)
+	{
+		ohci_dumpregs(sc);
+	}
+#endif
+	return (USBD_NORMAL_COMPLETION);
+}
+
+usbd_status
+ohci_init(ohci_softc_t *sc)
+{
+	u_int i;
+	u_int32_t rev;
+	u_int16_t bit;
+	u_int16_t x;
+	u_int16_t y;
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	DPRINTF(("start\n"));
+
+	sc->sc_eintrs = OHCI_NORMAL_INTRS;
+
+	/*
+	 * setup self pointers
+	 */
+	sc->sc_hw.ctrl_start.ed_self = htole32(PHYSADDR(sc,sc_hw.ctrl_start));
+	sc->sc_hw.ctrl_start.ed_flags = htole32(OHCI_ED_SKIP);
+	sc->sc_ctrl_p_last = &sc->sc_hw.ctrl_start;
+
+	sc->sc_hw.bulk_start.ed_self = htole32(PHYSADDR(sc,sc_hw.bulk_start));
+	sc->sc_hw.bulk_start.ed_flags = htole32(OHCI_ED_SKIP);
+	sc->sc_bulk_p_last = &sc->sc_hw.bulk_start;
+
+	sc->sc_hw.isoc_start.ed_self = htole32(PHYSADDR(sc,sc_hw.isoc_start));
+	sc->sc_hw.isoc_start.ed_flags = htole32(OHCI_ED_SKIP);
+	sc->sc_isoc_p_last = &sc->sc_hw.isoc_start;
+
+	for(i = 0;
+	    i < OHCI_NO_EDS;
+	    i++)
+	{
+		sc->sc_hw.intr_start[i].ed_self = htole32(PHYSADDR(sc,sc_hw.intr_start[i]));
+		sc->sc_hw.intr_start[i].ed_flags = htole32(OHCI_ED_SKIP);
+		sc->sc_intr_p_last[i] = &sc->sc_hw.intr_start[i];
+	}
+
+	/*
+	 * the QHs are arranged to give poll intervals that are
+	 * powers of 2 times 1ms
+	 */
+	bit = OHCI_NO_EDS/2;
+	while(bit)
+	{
+		x = bit;
+		while(x & bit)
+		{
+			y = (x ^ bit)|(bit/2);
+			/* the next QH has half the
+			 * poll interval
+			 */
+			sc->sc_hw.intr_start[x].next = NULL;
+			sc->sc_hw.intr_start[x].ed_next =
+			  sc->sc_hw.intr_start[y].ed_self;
+			x++;
+		}
+		bit >>= 1;
+	}
+
+	/* the last (1ms) QH */
+	sc->sc_hw.intr_start[0].next = &sc->sc_hw.isoc_start;
+	sc->sc_hw.intr_start[0].ed_next = sc->sc_hw.isoc_start.ed_self;
+
+	/*
+	 * Fill HCCA interrupt table.  The bit reversal is to get
+	 * the tree set up properly to spread the interrupts.
+	 */
+	for(i = 0;
+	    i < OHCI_NO_INTRS;
+	    i++)
+	{
+		sc->sc_hw.hcca.hcca_interrupt_table[i] =
+		  sc->sc_hw.intr_start[i|(OHCI_NO_EDS/2)].ed_self;
+	}
+
+	LIST_INIT(&sc->sc_interrupt_list_head);
+
+	/* set up the bus struct */
+	sc->sc_bus.methods = &ohci_bus_methods;
+
+	__callout_init_mtx(&sc->sc_tmo_rhsc,  &sc->sc_bus.mtx, 
+			   CALLOUT_RETURNUNLOCKED);
+
+#ifdef USB_DEBUG
+	if(ohcidebug > 15)
+	{
+		for(i = 0; 
+		    i < OHCI_NO_EDS; 
+		    i++)
+		{
+			printf("ed#%d ", i);
+			ohci_dump_ed(&sc->sc_hw.intr_start[i]);
+		}
+		printf("iso ");
+		ohci_dump_ed(&sc->sc_hw.isoc_start);
+	}
+#endif
+
+	sc->sc_control = sc->sc_intre = 0;
+
+#if defined(__OpenBSD__)
+	printf(",");
+#else
+	device_printf(sc->sc_bus.bdev, " ");
+#endif
+	rev = OREAD4(sc, OHCI_REVISION);
+	printf("OHCI version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
+	       OHCI_REV_LEGACY(rev) ? ", legacy support" : "");
+
+	if((OHCI_REV_HI(rev) != 1) ||
+	   (OHCI_REV_LO(rev) != 0))
+	{
+		device_printf(sc->sc_bus.bdev, "unsupported OHCI revision\n");
+		sc->sc_bus.usbrev = USBREV_UNKNOWN;
+		goto error;
+	}
+	sc->sc_bus.usbrev = USBREV_1_0;
+
+	if(ohci_controller_init(sc))
+	{
+	error:
+		mtx_unlock(&sc->sc_bus.mtx);
+		return (USBD_INVAL);
+	}
+	else
+	{
+		mtx_unlock(&sc->sc_bus.mtx);
+		return (USBD_NORMAL_COMPLETION);
+	}
+}
+
+/*
+ * shut down the controller when the system is going down
+ */
+void
+ohci_detach(struct ohci_softc *sc)
+{
+	mtx_lock(&sc->sc_bus.mtx);
+
+	__callout_stop(&sc->sc_tmo_rhsc);
+
+	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
+	OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
+
+	DELAY(1000*300); /* XXX let stray task complete */
+
+	mtx_unlock(&sc->sc_bus.mtx);
+	return;
+}
+
+/* NOTE: suspend/resume is called from
+ * interrupt context and cannot sleep!
+ */
+void
+ohci_suspend(ohci_softc_t *sc)
+{
+	u_int32_t ctl;
+	mtx_lock(&sc->sc_bus.mtx);
+
+#ifdef USB_DEBUG
+	DPRINTF(("\n"));
+	if(ohcidebug > 2)
+	{
+		ohci_dumpregs(sc);
+	}
+#endif
+
+	ctl = OREAD4(sc, OHCI_CONTROL) & ~OHCI_HCFS_MASK;
+	if(sc->sc_control == 0)
+	{
+		/*
+		 * Preserve register values, in case that APM BIOS
+		 * does not recover them.
+		 */
+		sc->sc_control = ctl;
+		sc->sc_intre = OREAD4(sc, OHCI_INTERRUPT_ENABLE);
+	}
+	ctl |= OHCI_HCFS_SUSPEND;
+	OWRITE4(sc, OHCI_CONTROL, ctl);
+	DELAY(1000*USB_RESUME_WAIT);
+
+	mtx_unlock(&sc->sc_bus.mtx);
+	return;
+}
+
+void
+ohci_resume(ohci_softc_t *sc)
+{
+	u_int32_t ctl;
+	mtx_lock(&sc->sc_bus.mtx);
+
+#ifdef USB_DEBUG
+	DPRINTF(("\n"));
+	if(ohcidebug > 2)
+	{
+		ohci_dumpregs(sc);
+	}
+#endif
+	/* some broken BIOSes never initialize the Controller chip */
+	ohci_controller_init(sc);
+
+	if(sc->sc_intre)
+	{
+		OWRITE4(sc, OHCI_INTERRUPT_ENABLE,
+			sc->sc_intre & (OHCI_ALL_INTRS | OHCI_MIE));
+	}
+
+	if(sc->sc_control)
+		ctl = sc->sc_control;
+	else
+		ctl = OREAD4(sc, OHCI_CONTROL);
+	ctl |= OHCI_HCFS_RESUME;
+	OWRITE4(sc, OHCI_CONTROL, ctl);
+	DELAY(1000*USB_RESUME_DELAY);
+	ctl = (ctl & ~OHCI_HCFS_MASK) | OHCI_HCFS_OPERATIONAL;
+	OWRITE4(sc, OHCI_CONTROL, ctl);
+	DELAY(1000*USB_RESUME_RECOVERY);
+	sc->sc_control = sc->sc_intre = 0;
+
+	mtx_unlock(&sc->sc_bus.mtx);
+	return;
+}
+
+#ifdef USB_DEBUG
+static void
+ohci_dumpregs(ohci_softc_t *sc)
+{
+	DPRINTF(("ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\n",
+		 OREAD4(sc, OHCI_REVISION),
+		 OREAD4(sc, OHCI_CONTROL),
+		 OREAD4(sc, OHCI_COMMAND_STATUS)));
+	DPRINTF(("               intrstat=0x%08x intre=0x%08x intrd=0x%08x\n",
+		 OREAD4(sc, OHCI_INTERRUPT_STATUS),
+		 OREAD4(sc, OHCI_INTERRUPT_ENABLE),
+		 OREAD4(sc, OHCI_INTERRUPT_DISABLE)));
+	DPRINTF(("               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\n",
+		 OREAD4(sc, OHCI_HCCA),
+		 OREAD4(sc, OHCI_PERIOD_CURRENT_ED),
+		 OREAD4(sc, OHCI_CONTROL_HEAD_ED)));
+	DPRINTF(("               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\n",
+		 OREAD4(sc, OHCI_CONTROL_CURRENT_ED),
+		 OREAD4(sc, OHCI_BULK_HEAD_ED),
+		 OREAD4(sc, OHCI_BULK_CURRENT_ED)));
+	DPRINTF(("               done=0x%08x fmival=0x%08x fmrem=0x%08x\n",
+		 OREAD4(sc, OHCI_DONE_HEAD),
+		 OREAD4(sc, OHCI_FM_INTERVAL),
+		 OREAD4(sc, OHCI_FM_REMAINING)));
+	DPRINTF(("               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\n",
+		 OREAD4(sc, OHCI_FM_NUMBER),
+		 OREAD4(sc, OHCI_PERIODIC_START),
+		 OREAD4(sc, OHCI_LS_THRESHOLD)));
+	DPRINTF(("               desca=0x%08x descb=0x%08x stat=0x%08x\n",
+		 OREAD4(sc, OHCI_RH_DESCRIPTOR_A),
+		 OREAD4(sc, OHCI_RH_DESCRIPTOR_B),
+		 OREAD4(sc, OHCI_RH_STATUS)));
+	DPRINTF(("               port1=0x%08x port2=0x%08x\n",
+		 OREAD4(sc, OHCI_RH_PORT_STATUS(1)),
+		 OREAD4(sc, OHCI_RH_PORT_STATUS(2))));
+	DPRINTF(("         HCCA: frame_number=0x%04x done_head=0x%08x\n",
+		 le32toh(sc->sc_hw.hcca.hcca_frame_number),
+		 le32toh(sc->sc_hw.hcca.hcca_done_head)));
+}
+static void
+ohci_dump_tds(ohci_td_t *std)
+{
+	for(; std; std = std->next)
+	{
+		ohci_dump_td(std);
+	}
+}
+
+static void
+ohci_dump_td(ohci_td_t *std)
+{
+	u_int32_t td_flags = le32toh(std->td_flags);
+
+	printf("TD(%p) at %08lx: %s%s%s%s%s delay=%d ec=%d "
+	       "cc=%d\ncbp=0x%08lx next=0x%08lx be=0x%08lx\n",
+	       std, (long)le32toh(std->td_self),
+	       (td_flags & OHCI_TD_R) ? "-R" : "",
+	       (td_flags & OHCI_TD_OUT) ? "-OUT" : "",
+	       (td_flags & OHCI_TD_IN) ? "-IN" : "",
+	       ((td_flags & OHCI_TD_TOGGLE_MASK) == OHCI_TD_TOGGLE_1) ? "-TOG1" : "",
+	       ((td_flags & OHCI_TD_TOGGLE_MASK) == OHCI_TD_TOGGLE_0) ? "-TOG0" : "",
+	       OHCI_TD_GET_DI(le32toh(std->td_flags)),
+	       OHCI_TD_GET_EC(le32toh(std->td_flags)),
+	       OHCI_TD_GET_CC(le32toh(std->td_flags)),
+	       (long)le32toh(std->td_cbp),
+	       (long)le32toh(std->td_next),
+	       (long)le32toh(std->td_be));
+}
+
+static void
+ohci_dump_itd(ohci_itd_t *sitd)
+{
+	int i;
+
+	printf("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
+	       "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
+	       sitd, (long)le32toh(sitd->itd_self),
+	       OHCI_ITD_GET_SF(le32toh(sitd->itd_flags)),
+	       OHCI_ITD_GET_DI(le32toh(sitd->itd_flags)),
+	       OHCI_ITD_GET_FC(le32toh(sitd->itd_flags)),
+	       OHCI_ITD_GET_CC(le32toh(sitd->itd_flags)),
+	       (long)le32toh(sitd->itd_bp0),
+	       (long)le32toh(sitd->itd_next),
+	       (long)le32toh(sitd->itd_be));
+	for(i = 0; i < OHCI_ITD_NOFFSET; i++)
+	{
+		printf("offs[%d]=0x%04x ", i,
+		       (u_int)le16toh(sitd->itd_offset[i]));
+	}
+	printf("\n");
+}
+
+static void
+ohci_dump_itds(ohci_itd_t *sitd)
+{
+	for(; sitd; sitd = sitd->next)
+	{
+		ohci_dump_itd(sitd);
+	}
+}
+
+static void
+ohci_dump_ed(ohci_ed_t *sed)
+{
+	u_int32_t ed_flags = le32toh(sed->ed_flags);
+	u_int32_t ed_headp = le32toh(sed->ed_headp);
+
+	printf("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d flags=%s%s%s%s%s\n"
+	       "tailp=0x%08lx headflags=%s%s headp=0x%08lx nexted=0x%08lx\n",
+	       sed, (long)le32toh(sed->ed_self),
+	       OHCI_ED_GET_FA(le32toh(sed->ed_flags)),
+	       OHCI_ED_GET_EN(le32toh(sed->ed_flags)),
+	       OHCI_ED_GET_MAXP(le32toh(sed->ed_flags)),
+	       (ed_flags & OHCI_ED_DIR_OUT) ? "-OUT" : "",
+	       (ed_flags & OHCI_ED_DIR_IN) ? "-IN" : "",
+	       (ed_flags & OHCI_ED_SPEED) ? "-LOWSPEED" : "",
+	       (ed_flags & OHCI_ED_SKIP) ? "-SKIP" : "",
+	       (ed_flags & OHCI_ED_FORMAT_ISO) ? "-ISO" : "",
+	       (long)le32toh(sed->ed_tailp), 
+	       (ed_headp & OHCI_HALTED) ? "-HALTED" : "",
+	       (ed_headp & OHCI_TOGGLECARRY) ? "-CARRY" : "",
+	       (long)le32toh(sed->ed_headp),
+	       (long)le32toh(sed->ed_next));
+}
+#endif
+
+
+#define OHCI_APPEND_QH(sed,last) (last) = _ohci_append_qh(sed,last)
+static ohci_ed_t *
+_ohci_append_qh(ohci_ed_t *sed, ohci_ed_t *last)
+{
+	DPRINTFN(10, ("%p to %p\n", sed, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	sed->next = last->next;
+	sed->ed_next = last->ed_next;
+
+	sed->prev = last;
+	
+	/* the last->next->prev is never followed:
+	 * sed->next->prev = sed;
+	 */
+
+	last->next = sed;
+	last->ed_next = sed->ed_self;
+	return(sed);
+}
+/**/
+
+#define OHCI_REMOVE_QH(sed,last) (last) = _ohci_remove_qh(sed,last)
+static ohci_ed_t *
+_ohci_remove_qh(ohci_ed_t *sed, ohci_ed_t *last)
+{
+	DPRINTFN(10, ("%p from %p\n", sed, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	/* only remove if not removed from a queue */
+	if(sed->prev)
+	{
+		sed->prev->next = sed->next;
+		sed->prev->ed_next = sed->ed_next;
+
+		if(sed->next)
+		{
+			sed->next->prev = sed->prev;
+		}
+
+		/* terminate transfer in case the
+		 * transferred packet was short so
+		 * that the ED still points at the
+		 * last used TD
+		 */
+		sed->ed_flags |= htole32(OHCI_ED_SKIP);
+		sed->ed_headp = sed->ed_tailp;
+
+		last = ((last == sed) ? sed->prev : last);
+
+		sed->prev = 0;
+	}
+	return(last);
+}
+
+static void
+ohci_device_done(struct usbd_xfer *xfer, usbd_status error);
+
+static void
+ohci_isoc_done(struct usbd_xfer *xfer)
+{
+	u_int8_t nframes;
+	u_int32_t actlen = 0;
+	u_int16_t *plen = xfer->frlengths;
+	__volatile__ u_int16_t *olen;
+	u_int16_t len = 0;
+	ohci_itd_t *td = xfer->td_transfer_first;
+
+	while(((void *)td) <= xfer->td_transfer_last)
+	{
+#ifdef USB_DEBUG
+		if(ohcidebug > 5)
+		{
+			DPRINTFN(-1,("isoc TD\n"));
+			ohci_dump_itd(td);
+		}
+#endif
+		nframes = td->frames;
+		olen = &td->itd_offset[0];
+
+		while(nframes--)
+		{
+			len = le16toh(*olen);
+
+			if((len >> 12) == OHCI_CC_NOT_ACCESSED)
+			{
+				len = 0;
+			}
+			else
+			{
+				len &= ((1<<12)-1);
+			}
+
+			*plen = len;
+			actlen += len;
+			plen++;
+			olen++;
+		}
+		td++;
+	}
+	xfer->actlen = actlen;
+	ohci_device_done(xfer,USBD_NORMAL_COMPLETION);
+	return;
+}
+
+#ifdef USB_DEBUG
+static const char * const
+ohci_cc_strs[] =
+{
+	"NO_ERROR",
+	"CRC",
+	"BIT_STUFFING",
+	"DATA_TOGGLE_MISMATCH",
+	"STALL",
+	"DEVICE_NOT_RESPONDING",
+	"PID_CHECK_FAILURE",
+	"UNEXPECTED_PID",
+	"DATA_OVERRUN",
+	"DATA_UNDERRUN",
+	"BUFFER_OVERRUN",
+	"BUFFER_UNDERRUN",
+	"reserved",
+	"reserved",
+	"NOT_ACCESSED",
+	"NOT_ACCESSED"
+};
+#endif
+
+static void
+ohci_non_isoc_done(struct usbd_xfer *xfer)
+{
+	u_int16_t cc = 0;
+	u_int32_t actlen = 0;
+	u_int32_t len;
+	ohci_td_t *td = xfer->td_transfer_first;
+
+	DPRINTFN(12, ("xfer=%p pipe=%p transfer done\n",
+		      xfer, xfer->pipe));
+
+#ifdef USB_DEBUG
+	if(ohcidebug > 10)
+	{
+		ohci_dump_tds(td);
+	}
+#endif
+
+	while(((void *)td) <= xfer->td_transfer_last)
+	{
+		len = td->len;
+		if(td->td_cbp != 0)
+		{
+			len -= le32toh(td->td_be) -
+			       le32toh(td->td_cbp) + 1;
+		}
+		DPRINTFN(10, ("len=%d\n", len));
+
+		actlen += len;
+
+		cc = OHCI_TD_GET_CC(le32toh(td->td_flags));
+		if(cc)
+		{
+			DPRINTFN(15,("error cc=%d (%s)\n",
+				     cc, ohci_cc_strs[cc]));
+			break;
+		}
+
+		if(td->td_cbp != 0)
+		{
+			/* short transfer */
+			break;
+		}
+		td++;
+	}
+
+	DPRINTFN(10, ("actlen=%d\n", actlen));
+
+	xfer->actlen = actlen;
+
+	ohci_device_done(xfer, 
+			 (cc == 0) ? USBD_NORMAL_COMPLETION :
+			 (cc == OHCI_CC_STALL) ? USBD_STALLED : USBD_IOERROR);
+	return;
+}
+
+/* returns one when transfer is finished 
+ * and callback must be called; else zero
+ */
+static u_int8_t
+ohci_check_transfer(struct usbd_xfer *xfer)
+{
+	ohci_ed_t *ed = xfer->qh_start;
+
+	DPRINTFN(15, ("xfer=%p\n", xfer));
+
+	if(xfer->usb_thread)
+	{
+	    if(xfer->usb_thread != curthread)
+	    {
+	        /* cannot call this transfer 
+		 * back due to locking !
+		 */
+	        return 0;
+	    }
+	}
+
+	if((ed->ed_flags & htole32(OHCI_ED_SKIP)) ||
+	   (ed->ed_headp & htole32(OHCI_HALTED)) ||
+	   (((ed->ed_headp ^ ed->ed_tailp) & htole32(-0x10)) == 0))
+	{
+		if(xfer->pipe->methods == &ohci_device_isoc_methods)
+		{
+			/* isochronous transfer */
+			ohci_isoc_done(xfer);
+		}
+		else
+		{
+			/* store data-toggle */
+			if(ed->ed_headp & htole32(OHCI_TOGGLECARRY))
+			{
+				xfer->pipe->toggle_next = 1;
+			}
+			else
+			{
+				xfer->pipe->toggle_next = 0;
+			}
+
+			/* non-isochronous transfer */
+			ohci_non_isoc_done(xfer);
+		}
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+static void
+ohci_rhsc_enable(ohci_softc_t *sc)
+{
+	struct usbd_callback_info info[1];
+	struct usbd_xfer *xfer;
+
+	DPRINTFN(4, ("\n"));
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	sc->sc_eintrs |= OHCI_RHSC;
+	OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);
+
+	/* acknowledge any RHSC interrupt */
+	OWRITE4(sc, OHCI_INTERRUPT_STATUS, OHCI_RHSC);
+
+	xfer = sc->sc_intrxfer;
+
+ 	if(xfer)
+	{
+	    /* transfer is transferred */
+	    ohci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+	    /* queue callback */
+	    info[0].xfer = xfer;
+	    info[0].refcount = xfer->usb_refcount;
+
+	    xfer->usb_root->memory_refcount++;
+
+	    mtx_unlock(&sc->sc_bus.mtx);
+
+	    usbd_do_callback(&info[0],&info[1]);
+	}
+	else
+	{
+	    mtx_unlock(&sc->sc_bus.mtx);
+	}
+	return;
+}
+
+void
+ohci_interrupt(ohci_softc_t *sc)
+{
+	enum { FINISH_LIST_MAX = 16 };
+
+	struct usbd_callback_info info[FINISH_LIST_MAX];
+	struct usbd_callback_info *ptr = &info[0];
+	struct usbd_xfer *xfer;
+	u_int32_t status;
+	u_int32_t done;
+	u_int8_t need_repeat = 0;
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	if(sc->sc_bus.bdev == NULL)
+	{
+		/* too early interrupt */
+		goto done;
+	}
+
+	sc->sc_bus.no_intrs++;
+
+	DPRINTFN(15,("%s: real interrupt\n",
+		     device_get_nameunit(sc->sc_bus.bdev)));
+
+#ifdef USB_DEBUG
+	if(ohcidebug > 15)
+	{
+		DPRINTF(("%s:\n", device_get_nameunit(sc->sc_bus.bdev)));
+		ohci_dumpregs(sc);
+	}
+#endif
+
+	status = 0;
+	done = le32toh(sc->sc_hw.hcca.hcca_done_head);
+
+	/* The LSb of done is used to inform the HC Driver that an interrupt
+	 * condition exists for both the Done list and for another event
+	 * recorded in HcInterruptStatus. On an interrupt from the HC, the HC
+	 * Driver checks the HccaDoneHead Value. If this value is 0, then the
+	 * interrupt was caused by other than the HccaDoneHead update and the
+	 * HcInterruptStatus register needs to be accessed to determine that
+	 * exact interrupt cause. If HccaDoneHead is nonzero, then a Done list
+	 * update interrupt is indicated and if the LSb of done is nonzero,
+	 * then an additional interrupt event is indicated and
+	 * HcInterruptStatus should be checked to determine its cause.
+	 */
+	if(done != 0)
+	{
+		if(done & ~OHCI_DONE_INTRS)
+		{
+			status |= OHCI_WDH;
+		}
+		if(done & OHCI_DONE_INTRS)
+		{
+			status |= OREAD4(sc, OHCI_INTERRUPT_STATUS);
+			done &= ~OHCI_DONE_INTRS;
+		}
+		sc->sc_hw.hcca.hcca_done_head = 0;
+	}
+	else
+	{
+		status = OREAD4(sc, OHCI_INTERRUPT_STATUS) & ~OHCI_WDH;
+	}
+
+	if(status == 0)		/* nothing to be done (PCI shared interrupt) */
+	{
+		goto done;
+	}
+
+	status &= ~OHCI_MIE;
+	OWRITE4(sc, OHCI_INTERRUPT_STATUS, status); /* Acknowledge */
+
+	status &= sc->sc_eintrs;
+	if(status == 0)
+	{
+		goto done;
+	}
+
+#if 0
+	if(status & OHCI_SO)
+	{
+		/* XXX do what */
+	}
+#endif
+	if(status & OHCI_RD)
+	{
+		device_printf(sc->sc_bus.bdev, "resume detect\n");
+		/* XXX process resume detect */
+	}
+	if(status & OHCI_UE)
+	{
+		device_printf(sc->sc_bus.bdev, "unrecoverable error, "
+			      "controller halted\n");
+		OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
+		/* XXX what else */
+	}
+	if(status & OHCI_RHSC)
+	{
+		xfer = sc->sc_intrxfer;
+
+		if(xfer)
+		{
+		    ohci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+		    /* queue callback */
+		    ptr->xfer = xfer;
+		    ptr->refcount = xfer->usb_refcount;
+		    ptr++;
+
+		    xfer->usb_root->memory_refcount++;
+		}
+
+		/*
+		 * Disable RHSC interrupt for now, because it will be
+		 * on until the port has been reset.
+		 */
+		sc->sc_eintrs &= ~OHCI_RHSC;
+		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);
+
+		/* do not allow RHSC interrupts > 1 per second */
+		__callout_reset(&sc->sc_tmo_rhsc, hz,
+				(void *)(void *)ohci_rhsc_enable, sc);
+	}
+
+	status &= ~(OHCI_RHSC|OHCI_WDH|OHCI_SO);
+	if(status != 0)
+	{
+		/* Block unprocessed interrupts. XXX */
+		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, status);
+		sc->sc_eintrs &= ~status;
+		device_printf(sc->sc_bus.bdev, 
+			      "blocking intrs 0x%x\n", status);
+	}
+
+	/*
+	 * when the host controller interrupts because a transfer
+	 * is completed, all active transfers are checked!
+	 */
+
+ repeat:
+	LIST_FOREACH(xfer, &sc->sc_interrupt_list_head, interrupt_list)
+	{
+		/* check if transfer is
+		 * transferred 
+		 */
+		if(ohci_check_transfer(xfer))
+		{
+		    /* queue callback */
+		    ptr->xfer = xfer;
+		    ptr->refcount = xfer->usb_refcount;
+		    ptr++;
+
+		    xfer->usb_root->memory_refcount++;
+
+		    /* check queue length */
+		    if(ptr >= &info[FINISH_LIST_MAX])
+		    {
+		        need_repeat = 1;
+			break;
+		    }
+		}
+	}
+
+ done:
+	mtx_unlock(&sc->sc_bus.mtx);
+
+	usbd_do_callback(&info[0],ptr);
+
+	if(need_repeat)
+	{
+		ptr = &info[0];
+
+		need_repeat = 0;
+
+		mtx_lock(&sc->sc_bus.mtx);
+
+		goto repeat;
+	}
+	return;
+}
+
+/*
+ * called when a request does not complete
+ */
+static void
+ohci_timeout(struct usbd_xfer *xfer)
+{
+	struct usbd_callback_info info[1];
+	ohci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTF(("xfer=%p\n", xfer));
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	/* transfer is transferred */
+	ohci_device_done(xfer, USBD_TIMEOUT);
+
+	/* queue callback */
+	info[0].xfer = xfer;
+	info[0].refcount = xfer->usb_refcount;
+
+	xfer->usb_root->memory_refcount++;
+
+	mtx_unlock(&sc->sc_bus.mtx);
+
+	usbd_do_callback(&info[0],&info[1]);
+
+	return;
+}
+
+static void
+ohci_do_poll(struct usbd_bus *bus)
+{
+	ohci_interrupt(OHCI_BUS2SC(bus));
+	return;
+}
+
+#define ohci_add_interrupt_info(sc, xfer) \
+	LIST_INSERT_HEAD(&(sc)->sc_interrupt_list_head, (xfer), interrupt_list)
+
+static void
+ohci_remove_interrupt_info(struct usbd_xfer *xfer)
+{
+	if((xfer)->interrupt_list.le_prev)
+	{
+		LIST_REMOVE((xfer), interrupt_list);
+		(xfer)->interrupt_list.le_prev = 0;
+	}
+	return;
+}
+
+static void
+ohci_setup_standard_chain(struct usbd_xfer *xfer, ohci_ed_t **ed_last)
+{
+	/* the OHCI hardware can handle at most one 4k crossing per TD */
+	u_int32_t average = ((unsigned)(OHCI_PAGE_SIZE / xfer->max_packet_size))
+	  * xfer->max_packet_size;
+	u_int32_t td_flags;
+	u_int32_t physbuffer = xfer->physbuffer;
+	u_int32_t len = xfer->length;
+	u_int8_t isread;
+	u_int8_t shortpkt = 0;
+	ohci_td_t *td;
+	ohci_ed_t *ed;
+
+	DPRINTFN(8, ("addr=%d endpt=%d len=%d speed=%d\n", 
+		     xfer->address, UE_GET_ADDR(xfer->endpoint),
+		     xfer->length, xfer->udev->speed));
+
+	td = (xfer->td_transfer_first = xfer->td_start);
+
+	if(xfer->pipe->methods == &ohci_device_ctrl_methods)
+	{
+		isread = ((usb_device_request_t *)xfer->buffer)->bmRequestType & UT_READ;
+
+		/* xfer->length = sizeof(usb_device_request_t) + UGETW(req->wLength)
+		 * check length ??
+		 */
+
+		xfer->pipe->toggle_next = 1;
+
+		/* SETUP message */
+
+		td->next = (td+1);
+		td->td_next = (td+1)->td_self;
+
+		td->td_flags = htole32(OHCI_TD_SETUP | OHCI_TD_NOCC |
+				       OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);
+
+		td->td_cbp = htole32(physbuffer);
+		td->td_be = htole32(physbuffer + (sizeof(usb_device_request_t) - 1));
+		td->len = sizeof(usb_device_request_t);
+
+		physbuffer += sizeof(usb_device_request_t);
+		len -= sizeof(usb_device_request_t);
+		td++;
+	}
+	else
+	{
+		isread = (UE_GET_DIR(xfer->endpoint) == UE_DIR_IN);
+
+		if(xfer->length == 0)
+		{
+			/* must allow access to (td-1),
+			 * so xfer->length cannot be zero
+			 */
+			printf("%s: setting USBD_FORCE_SHORT_XFER!\n", __FUNCTION__);
+			xfer->flags |= USBD_FORCE_SHORT_XFER;
+		}
+	}
+
+	td_flags = htole32(OHCI_TD_NOCC | OHCI_TD_NOINTR);
+
+ 	if(xfer->flags & USBD_SHORT_XFER_OK)
+	{
+		td_flags |= htole32(OHCI_TD_R);
+	}
+	if(xfer->pipe->toggle_next)
+	{
+		td_flags |= htole32(OHCI_TD_TOGGLE_1);
+	}
+	else
+	{
+		td_flags |= htole32(OHCI_TD_TOGGLE_0);
+	}
+	if(isread)
+        {
+		td_flags |= htole32(OHCI_TD_IN);
+	}
+	else
+	{
+		td_flags |= htole32(OHCI_TD_OUT);
+	}
+
+	while(1)
+	{
+		if(len == 0)
+		{
+			if(xfer->flags & USBD_FORCE_SHORT_XFER)
+			{
+				if(shortpkt)
+				{
+					break;
+				}
+			}
+			else
+			{
+				break;
+			}
+		}
+
+		if(len < average)
+		{
+			if((len % xfer->max_packet_size) || 
+			   (len == 0))
+			{
+				shortpkt = 1;
+			}
+
+			average = len;
+		}
+
+		 if(((void *)td) >= xfer->td_end)
+		 {
+			panic("%s: software wants to write more data "
+			      "than there is in the buffer!", __FUNCTION__);
+		 }
+
+		 /* fill out TD */
+
+		 td->next = (td+1);
+		 td->td_next = (td+1)->td_self;
+		 td->td_flags = td_flags;
+
+		 /* the next td uses TOGGLE_CARRY */
+		 td_flags &= htole32(~OHCI_TD_TOGGLE_MASK);
+
+		 if(average == 0)
+		 {
+			td->td_cbp = 0;
+			td->td_be = ~0;
+		 }
+		 else
+		 {
+			td->td_cbp = htole32(physbuffer);
+			td->td_be = htole32(physbuffer + average - 1);
+		 }
+		 td->len = average;
+
+		 physbuffer += average;
+		 len -= average;
+		 td++;
+	}
+
+	if(xfer->pipe->methods == &ohci_device_ctrl_methods)
+	{
+		/* STATUS message */
+
+		td->next = NULL;
+		td->td_next = 0;
+		td->td_flags = htole32(OHCI_TD_NOCC | OHCI_TD_TOGGLE_1 |
+				       OHCI_TD_SET_DI(1));
+		if(isread)
+		{
+			td->td_flags |= htole32(OHCI_TD_OUT);
+		}
+		else
+		{
+			td->td_flags |= htole32(OHCI_TD_IN);
+		}
+		td->td_cbp = 0;
+		td->td_be = ~0;
+		td->len = 0;
+
+		physbuffer += 0;
+		len -= 0;
+		td++;
+	}
+	else
+	{
+		(td-1)->next = NULL;
+		(td-1)->td_next = 0;
+		(td-1)->td_flags &= htole32(~OHCI_TD_INTR_MASK);
+		(td-1)->td_flags |= htole32(OHCI_TD_SET_DI(1));
+	}
+
+	/* must have at least one frame! */
+
+	xfer->td_transfer_last = (td-1);
+
+#ifdef USB_DEBUG
+	if(ohcidebug > 8)
+	{
+		DPRINTF(("nexttog=%d; data before transfer:\n",
+			 xfer->pipe->toggle_next));
+		ohci_dump_tds(xfer->td_start);
+	}
+#endif
+
+	ed = xfer->qh_start;
+
+	ed->ed_flags = htole32(OHCI_ED_FORMAT_GEN | OHCI_ED_DIR_TD);
+	ed->ed_flags |= htole32(OHCI_ED_SET_FA(xfer->address)|
+				OHCI_ED_SET_EN(UE_GET_ADDR(xfer->endpoint))|
+				OHCI_ED_SET_MAXP(xfer->max_packet_size));
+
+	if(xfer->udev->speed == USB_SPEED_LOW)
+	{
+		ed->ed_flags |= htole32(OHCI_ED_SPEED);
+	}
+
+	td = xfer->td_transfer_first;
+
+	ed->ed_tailp = 0;
+	ed->ed_headp = td->td_self;
+
+	OHCI_APPEND_QH(ed, *ed_last);
+
+	if(xfer->pipe->methods == &ohci_device_bulk_methods)
+	{
+		ohci_softc_t *sc = xfer->usb_sc;
+		OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_BLF);
+	}
+
+	if(xfer->pipe->methods == &ohci_device_ctrl_methods)
+	{
+		ohci_softc_t *sc = xfer->usb_sc;
+		OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);
+	}
+	return;
+}
+
+static void
+ohci_root_intr_done(ohci_softc_t *sc, struct usbd_xfer *xfer)
+{
+	u_int8_t *p;
+	u_int i, m;
+	u_int32_t hstatus;
+
+	if(sc->sc_intrxfer)
+	{
+		/* disable further interrupts */
+		sc->sc_intrxfer = NULL;
+
+		hstatus = OREAD4(sc, OHCI_RH_STATUS);
+		DPRINTF(("sc=%p xfer=%p hstatus=0x%08x\n",
+			 sc, xfer, hstatus));
+
+		p = xfer->buffer;
+		m = min(sc->sc_noport, (xfer->length * 8) - 1);
+		memset(p, 0, xfer->length);
+		for(i = 1; i <= m; i++)
+		{
+			/* pick out CHANGE bits from the status register */
+			if(OREAD4(sc, OHCI_RH_PORT_STATUS(i)) >> 16)
+			{
+				p[i/8] |= 1 << (i%8);
+			}
+		}
+		DPRINTF(("change=0x%02x\n", *p));
+		xfer->actlen = xfer->length;
+	}
+	return;
+}
+
+/* NOTE: "done" can be run two times in a row,
+ * from close and from interrupt
+ */
+static void
+ohci_device_done(struct usbd_xfer *xfer, usbd_status error)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+	ohci_ed_t *ed;
+	u_int8_t need_delay;
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	need_delay = 0;
+
+	DPRINTFN(1,("xfer=%p, pipe=%p length=%d error=%d\n",
+		    xfer, xfer->pipe, xfer->actlen, error));
+
+	for(ed = xfer->qh_start;
+	    ((void *)ed) < xfer->qh_end;
+	    ed++)
+	{
+		if((!(ed->ed_flags & htole32(OHCI_ED_SKIP))) &&
+		   (!(ed->ed_headp & htole32(OHCI_HALTED))) &&
+		   ((ed->ed_headp ^ ed->ed_tailp) & htole32(-0x10)))
+		{
+			need_delay = 1;
+		}
+	}
+
+	if(xfer->pipe->methods == &ohci_device_bulk_methods)
+	{
+		OHCI_REMOVE_QH(xfer->qh_start, sc->sc_bulk_p_last);
+	}
+
+	if(xfer->pipe->methods == &ohci_device_ctrl_methods)
+	{
+		OHCI_REMOVE_QH(xfer->qh_start, sc->sc_ctrl_p_last);
+	}
+
+	if(xfer->pipe->methods == &ohci_device_intr_methods)
+	{
+		OHCI_REMOVE_QH(xfer->qh_start, sc->sc_intr_p_last[xfer->qh_pos]);
+	}
+
+	if(xfer->pipe->methods == &ohci_device_isoc_methods)
+	{
+		OHCI_REMOVE_QH(xfer->qh_start, sc->sc_isoc_p_last);
+	}
+
+	xfer->td_transfer_first = 0;
+	xfer->td_transfer_last = 0;
+
+	/* finish root interrupt transfer
+	 * (will update xfer->buffer and xfer->actlen)
+	 */
+	if(xfer->pipe->methods == &ohci_root_intr_methods)
+	{
+		ohci_root_intr_done(sc, xfer);
+	}
+
+	/* stop timeout */
+	__callout_stop(&xfer->timeout_handle);
+
+	/* remove interrupt info */
+	ohci_remove_interrupt_info(xfer);
+
+	/* wait until hardware has finished any possible
+	 * use of the transfer and QH
+	 *
+	 * hardware finishes in 1 millisecond
+	 */
+	DELAY(need_delay ? (2*1000) : (5));
+
+	if(error)
+	{
+		/* next transfer needs to clear stall */
+		xfer->pipe->clearstall = 1;
+	}
+
+	/* transfer is transferred ! */
+	usbd_transfer_done(xfer,error);
+
+	/* dequeue transfer (and start next transfer)
+	 *
+	 * if two transfers are queued, the second
+	 * transfer must be started before the
+	 * first is called back!
+	 */
+	usbd_transfer_dequeue(xfer);
+
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ * ohci bulk support
+ *---------------------------------------------------------------------------*/
+static void
+ohci_device_bulk_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ohci_device_bulk_close(struct usbd_xfer *xfer)
+{
+	ohci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ohci_device_bulk_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ohci_device_bulk_start(struct usbd_xfer *xfer)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTFN(3, ("xfer=%p len=%d\n",
+		     xfer, xfer->length));
+
+	/* setup TD's and QH */
+	ohci_setup_standard_chain(xfer, &sc->sc_bulk_p_last);
+
+	/**/
+	ohci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ohci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods ohci_device_bulk_methods = 
+{
+  .open = ohci_device_bulk_open,
+  .close = ohci_device_bulk_close,
+  .enter = ohci_device_bulk_enter,
+  .start = ohci_device_bulk_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ohci control support
+ *---------------------------------------------------------------------------*/
+static void
+ohci_device_ctrl_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ohci_device_ctrl_close(struct usbd_xfer *xfer)
+{
+	ohci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ohci_device_ctrl_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ohci_device_ctrl_start(struct usbd_xfer *xfer)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTFN(3,("type=0x%02x, request=0x%02x, "
+		    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
+		    ((usb_device_request_t *)(xfer->buffer))->bmRequestType,
+		    ((usb_device_request_t *)(xfer->buffer))->bRequest,
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wValue),
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wIndex), 
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wLength),
+		    xfer->address, xfer->endpoint));
+
+	/* setup TD's and QH */
+	ohci_setup_standard_chain(xfer, &sc->sc_ctrl_p_last);
+
+	/**/
+	ohci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ohci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods ohci_device_ctrl_methods = 
+{
+  .open = ohci_device_ctrl_open,
+  .close = ohci_device_ctrl_close,
+  .enter = ohci_device_ctrl_enter,
+  .start = ohci_device_ctrl_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ohci interrupt support
+ *---------------------------------------------------------------------------*/
+static void
+ohci_device_intr_open(struct usbd_xfer *xfer)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+	u_int16_t best;
+	u_int16_t bit;
+	u_int16_t x;
+
+	best = 0;
+	bit = OHCI_NO_EDS/2;
+	while(bit)
+	{
+		if(xfer->interval >= bit)
+		{
+			x = bit;
+			best = bit;
+			while(x & bit)
+			{
+				if(sc->sc_intr_stat[x] < 
+				   sc->sc_intr_stat[best])
+				{
+					best = x;
+				}
+				x++;
+			}
+			break;
+		}
+		bit >>= 1;
+	}
+
+	sc->sc_intr_stat[best]++;
+	xfer->qh_pos = best;
+
+	DPRINTFN(2, ("best=%d interval=%d\n",
+		     best, xfer->interval));
+	return;
+}
+
+static void
+ohci_device_intr_close(struct usbd_xfer *xfer)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+
+	sc->sc_intr_stat[xfer->qh_pos]--;
+
+	ohci_device_done(xfer,USBD_CANCELLED);
+	return;
+}
+
+static void
+ohci_device_intr_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ohci_device_intr_start(struct usbd_xfer *xfer)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTFN(3,("xfer=%p len=%d\n",
+		    xfer, xfer->length));
+
+	/* setup TD's and QH */
+	ohci_setup_standard_chain(xfer, &sc->sc_intr_p_last[xfer->qh_pos]);
+
+	/**/
+	ohci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ohci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods ohci_device_intr_methods = 
+{
+  .open = ohci_device_intr_open,
+  .close = ohci_device_intr_close,
+  .enter = ohci_device_intr_enter,
+  .start = ohci_device_intr_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ohci isochronous support
+ *---------------------------------------------------------------------------*/
+static void
+ohci_device_isoc_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ohci_device_isoc_close(struct usbd_xfer *xfer)
+{
+	/**/
+	ohci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ohci_device_isoc_enter(struct usbd_xfer *xfer)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+	u_int32_t physbuffer;
+	u_int32_t nframes;
+	u_int32_t bp0;
+	u_int16_t *plen;
+	u_int8_t ncur;
+	ohci_itd_t *td;
+	ohci_ed_t *ed;
+
+	DPRINTFN(5,("xfer=%p next=%d nframes=%d\n",
+		    xfer, xfer->pipe->isoc_next, xfer->nframes));
+
+	nframes = le32toh(sc->sc_hw.hcca.hcca_frame_number);
+
+	if((((nframes - xfer->pipe->isoc_next) & ((1<<16)-1)) < xfer->nframes) ||
+	   (((xfer->pipe->isoc_next - nframes) & ((1<<16)-1)) >= 256))
+	{
+		/* not in use yet, schedule it a few frames ahead */
+		/* data underflow */
+		xfer->pipe->isoc_next = (nframes + 5) & ((1<<16)-1);
+		DPRINTFN(2,("start next=%d\n", xfer->pipe->isoc_next));
+	}
+
+	nframes = xfer->nframes;
+
+	if(nframes == 0)
+	{
+		/* transfer transferred */
+		ohci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+		/* call callback recursively */
+		__usbd_callback(xfer);
+
+		return;
+	}
+
+	physbuffer = xfer->physbuffer;
+
+	plen = xfer->frlengths;
+
+	td = xfer->td_start;
+
+	xfer->td_transfer_first = td;
+
+	ncur = 0;
+
+	bp0 = OHCI_PAGE(physbuffer);
+
+	while(nframes--)
+	{
+		td->itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(physbuffer-bp0));
+
+		ncur++;
+		physbuffer += *plen;
+		plen++;
+
+		if((ncur == OHCI_ITD_NOFFSET) ||
+		   (OHCI_PAGE(physbuffer) != bp0) ||
+		   (nframes == 0))
+		{
+			/* fill current ITD */
+			td->next = (td+1);
+			td->itd_next = (td+1)->itd_self;
+			td->itd_flags = htole32(
+				OHCI_ITD_NOCC |
+				OHCI_ITD_SET_SF(xfer->pipe->isoc_next) |
+				OHCI_ITD_NOINTR |
+				OHCI_ITD_SET_FC(ncur));
+			td->itd_bp0 = htole32(bp0);
+			td->itd_be = htole32(physbuffer - 1);
+			td->frames = ncur;
+
+			xfer->pipe->isoc_next += ncur;
+			bp0 = OHCI_PAGE(physbuffer);
+			ncur = 0;
+			td++;
+		}
+	}
+
+	/* fixup last used ITD */
+	(td-1)->itd_flags &= htole32(~OHCI_ITD_NOINTR);
+	(td-1)->itd_flags |= htole32(OHCI_ITD_SET_DI(0));
+	(td-1)->next = 0;
+	(td-1)->itd_next = 0;
+
+	xfer->td_transfer_last = (td-1);
+
+#ifdef USB_DEBUG
+	if(ohcidebug > 8)
+	{
+		DPRINTF(("data before transfer:\n"));
+		ohci_dump_itds(xfer->td_start);
+	}
+#endif
+	ed = xfer->qh_start;
+
+	if(UE_GET_DIR(xfer->endpoint) == UE_DIR_IN)
+		ed->ed_flags = htole32(OHCI_ED_DIR_IN|OHCI_ED_FORMAT_ISO);
+	else
+		ed->ed_flags = htole32(OHCI_ED_DIR_OUT|OHCI_ED_FORMAT_ISO);
+
+	ed->ed_flags |= htole32(OHCI_ED_SET_FA(xfer->address)|
+				OHCI_ED_SET_EN(UE_GET_ADDR(xfer->endpoint))|
+				OHCI_ED_SET_MAXP(xfer->max_packet_size));
+	if(xfer->udev->speed == USB_SPEED_LOW)
+	{
+		ed->ed_flags |= htole32(OHCI_ED_SPEED);
+	}
+
+	ed->ed_tailp = 0;
+	td = xfer->td_transfer_first;
+	ed->ed_headp = td->itd_self;
+
+	OHCI_APPEND_QH(ed, sc->sc_isoc_p_last);
+
+	/**/
+	ohci_add_interrupt_info(sc, xfer);
+
+	if(!xfer->timeout)
+	{
+		/* in case the frame start number is wrong */
+		xfer->timeout = 1000/4;
+	}
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)ohci_timeout, xfer);
+	}
+
+	/* enqueue transfer 
+	 * (so that it can be aborted through pipe abort)
+	 */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ohci_device_isoc_start(struct usbd_xfer *xfer)
+{
+	/* already started, nothing to do */
+	return;
+}
+
+struct usbd_pipe_methods ohci_device_isoc_methods = 
+{
+  .open = ohci_device_isoc_open,
+  .close = ohci_device_isoc_close,
+  .enter = ohci_device_isoc_enter,
+  .start = ohci_device_isoc_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ohci root control support
+ *---------------------------------------------------------------------------*
+ * simulate a hardware hub by handling
+ * all the necessary requests
+ *---------------------------------------------------------------------------*/
+
+static void
+ohci_root_ctrl_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ohci_root_ctrl_close(struct usbd_xfer *xfer)
+{
+	ohci_device_done(xfer,USBD_CANCELLED);
+	return;
+}
+
+/* data structures and routines
+ * to emulate the root hub:
+ */
+static const
+usb_device_descriptor_t ohci_devd =
+{
+	USB_DEVICE_DESCRIPTOR_SIZE,
+	UDESC_DEVICE,		/* type */
+	{0x00, 0x01},		/* USB version */
+	UDCLASS_HUB,		/* class */
+	UDSUBCLASS_HUB,		/* subclass */
+	UDPROTO_FSHUB,		/* protocol */
+	64,			/* max packet */
+	{0},{0},{0x00,0x01},	/* device id */
+	1,2,0,			/* string indicies */
+	1			/* # of configurations */
+};
+
+static const
+usb_config_descriptor_t ohci_confd =
+{
+	USB_CONFIG_DESCRIPTOR_SIZE,
+	UDESC_CONFIG,
+	{USB_CONFIG_DESCRIPTOR_SIZE +
+	 USB_INTERFACE_DESCRIPTOR_SIZE +
+	 USB_ENDPOINT_DESCRIPTOR_SIZE},
+	1,
+	1,
+	0,
+	UC_SELF_POWERED,
+	0			/* max power */
+};
+
+static const
+usb_interface_descriptor_t ohci_ifcd =
+{
+	USB_INTERFACE_DESCRIPTOR_SIZE,
+	UDESC_INTERFACE,
+	0,
+	0,
+	1,
+	UICLASS_HUB,
+	UISUBCLASS_HUB,
+	UIPROTO_FSHUB,
+	0
+};
+
+static const
+usb_endpoint_descriptor_t ohci_endpd =
+{
+	USB_ENDPOINT_DESCRIPTOR_SIZE,
+	UDESC_ENDPOINT,
+	UE_DIR_IN | OHCI_INTR_ENDPT,
+	UE_INTERRUPT,
+	{8, 0},			/* max packet */
+	255
+};
+
+static const
+usb_hub_descriptor_t ohci_hubd =
+{
+	USB_HUB_DESCRIPTOR_SIZE,
+	UDESC_HUB,
+	0,
+	{0,0},
+	0,
+	0,
+	{0},
+};
+
+static int
+ohci_str(usb_string_descriptor_t *p, int l, const char *s)
+{
+	int i;
+
+	if(l == 0)
+	{
+		return (0);
+	}
+	p->bLength = (2 * strlen(s)) + 2;
+	if(l == 1)
+	{
+		return (1);
+	}
+	p->bDescriptorType = UDESC_STRING;
+	l -= 2;
+	for(i = 0; s[i] && (l > 1); i++, l -= 2)
+	{
+		USETW2(p->bString[i], 0, s[i]);
+	}
+	return ((2 * i) + 2);
+}
+
+static void
+ohci_root_ctrl_enter(struct usbd_xfer *xfer)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+	usb_device_request_t *req = xfer->buffer;
+	void *buf;
+	int port, i;
+	int len, value, index, l, totlen = 0;
+	usb_port_status_t ps;
+	usb_hub_descriptor_t hubd;
+	usbd_status err;
+	u_int32_t v;
+
+	DPRINTFN(2,("type=0x%02x request=0x%02x\n",
+		    req->bmRequestType, req->bRequest));
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	/* set default actual length */
+	xfer->actlen = sizeof(*req);
+
+	len = UGETW(req->wLength);
+	value = UGETW(req->wValue);
+	index = UGETW(req->wIndex);
+
+	if(len != 0)
+	{
+		buf = (req+1);
+	}
+	else
+	{
+		buf = NULL;
+	}
+
+#define C(x,y) ((x) | ((y) << 8))
+	switch(C(req->bRequest, req->bmRequestType)) {
+	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
+	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
+	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
+		/*
+		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
+		 * for the integrated root hub.
+		 */
+		break;
+	case C(UR_GET_CONFIG, UT_READ_DEVICE):
+		if(len > 0)
+		{
+			*(u_int8_t *)buf = sc->sc_conf;
+			totlen = 1;
+		}
+		break;
+	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
+		DPRINTFN(8,("wValue=0x%04x\n", value));
+		switch(value >> 8) {
+		case UDESC_DEVICE:
+			if((value & 0xff) != 0)
+			{
+				err = USBD_IOERROR;
+				goto done;
+			}
+			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
+			memcpy(buf, &ohci_devd, l);
+#if 0
+			if(len >= 12)
+			{
+			  USETW(((usb_device_descriptor_t *)buf)->idVendor,
+				sc->sc_id_vendor);
+			}
+#endif
+			break;
+		case UDESC_CONFIG:
+			if((value & 0xff) != 0)
+			{
+				err = USBD_IOERROR;
+				goto done;
+			}
+			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
+			memcpy(buf, &ohci_confd, l);
+			buf = ((u_int8_t *)buf) + l;
+			len -= l;
+			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
+			totlen += l;
+			memcpy(buf, &ohci_ifcd, l);
+			buf = ((u_int8_t *)buf) + l;
+			len -= l;
+			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
+			totlen += l;
+			memcpy(buf, &ohci_endpd, l);
+			break;
+		case UDESC_STRING:
+			if(len == 0)
+			{
+				break;
+			}
+			*(u_int8_t *)buf = 0;
+			totlen = 1;
+			switch (value & 0xff) {
+			case 1: /* Vendor */
+				totlen = ohci_str(buf, len, sc->sc_vendor);
+				break;
+			case 2: /* Product */
+				totlen = ohci_str(buf, len, "OHCI root hub");
+				break;
+			}
+			break;
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+		break;
+	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
+		if(len > 0)
+		{
+			*(u_int8_t *)buf = 0;
+			totlen = 1;
+		}
+		break;
+	case C(UR_GET_STATUS, UT_READ_DEVICE):
+		if(len > 1)
+		{
+			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
+			totlen = 2;
+		}
+		break;
+	case C(UR_GET_STATUS, UT_READ_INTERFACE):
+	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
+		if(len > 1)
+		{
+			USETW(((usb_status_t *)buf)->wStatus, 0);
+			totlen = 2;
+		}
+		break;
+	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
+		if(value >= USB_MAX_DEVICES)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		sc->sc_addr = value;
+		break;
+	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
+		if((value != 0) && (value != 1))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		sc->sc_conf = value;
+		break;
+	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
+		break;
+	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
+	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
+	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
+		err = USBD_IOERROR;
+		goto done;
+	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
+		break;
+	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
+		break;
+	/* Hub requests */
+	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
+		break;
+	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
+		DPRINTFN(8, ("UR_CLEAR_PORT_FEATURE "
+			     "port=%d feature=%d\n",
+			     index, value));
+		if((index < 1) ||
+		   (index > sc->sc_noport))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		port = OHCI_RH_PORT_STATUS(index);
+		switch(value) {
+		case UHF_PORT_ENABLE:
+			OWRITE4(sc, port, UPS_CURRENT_CONNECT_STATUS);
+			break;
+		case UHF_PORT_SUSPEND:
+			OWRITE4(sc, port, UPS_OVERCURRENT_INDICATOR);
+			break;
+		case UHF_PORT_POWER:
+			/* Yes, writing to the LOW_SPEED bit clears power. */
+			OWRITE4(sc, port, UPS_LOW_SPEED);
+			break;
+		case UHF_C_PORT_CONNECTION:
+			OWRITE4(sc, port, UPS_C_CONNECT_STATUS << 16);
+			break;
+		case UHF_C_PORT_ENABLE:
+			OWRITE4(sc, port, UPS_C_PORT_ENABLED << 16);
+			break;
+		case UHF_C_PORT_SUSPEND:
+			OWRITE4(sc, port, UPS_C_SUSPEND << 16);
+			break;
+		case UHF_C_PORT_OVER_CURRENT:
+			OWRITE4(sc, port, UPS_C_OVERCURRENT_INDICATOR << 16);
+			break;
+		case UHF_C_PORT_RESET:
+			OWRITE4(sc, port, UPS_C_PORT_RESET << 16);
+			break;
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+		switch(value) {
+		case UHF_C_PORT_CONNECTION:
+		case UHF_C_PORT_ENABLE:
+		case UHF_C_PORT_SUSPEND:
+		case UHF_C_PORT_OVER_CURRENT:
+		case UHF_C_PORT_RESET:
+			/* enable RHSC interrupt if condition is cleared. */
+			if((OREAD4(sc, port) >> 16) == 0)
+			{
+				mtx_lock(&sc->sc_bus.mtx);
+				ohci_rhsc_enable(sc);
+			}
+			break;
+		default:
+			break;
+		}
+		break;
+	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
+		if((value & 0xff) != 0)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		v = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
+		hubd = ohci_hubd;
+		hubd.bNbrPorts = sc->sc_noport;
+		USETW(hubd.wHubCharacteristics,
+		      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH :
+		       v & OHCI_PSM ? UHD_PWR_GANGED : UHD_PWR_INDIVIDUAL)
+		      /* XXX overcurrent */
+		      );
+		hubd.bPwrOn2PwrGood = OHCI_GET_POTPGT(v);
+		v = OREAD4(sc, OHCI_RH_DESCRIPTOR_B);
+		for(i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
+		{
+			hubd.DeviceRemovable[i++] = (u_int8_t)v;
+		}
+		hubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;
+		l = min(len, hubd.bDescLength);
+		totlen = l;
+		memcpy(buf, &hubd, l);
+		break;
+	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
+		if(len != 4)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		memset(buf, 0, len); /* ? XXX */
+		totlen = len;
+		break;
+	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
+		DPRINTFN(8,("get port status i=%d\n",
+			    index));
+		if((index < 1) ||
+		   (index > sc->sc_noport))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		if(len != 4)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		v = OREAD4(sc, OHCI_RH_PORT_STATUS(index));
+		DPRINTFN(8,("port status=0x%04x\n",
+			    v));
+		USETW(ps.wPortStatus, v);
+		USETW(ps.wPortChange, v >> 16);
+		l = min(len, sizeof ps);
+		memcpy(buf, &ps, l);
+		totlen = l;
+		break;
+	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
+		err = USBD_IOERROR;
+		goto done;
+	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
+		break;
+	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
+		if((index < 1) || (index > sc->sc_noport))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		port = OHCI_RH_PORT_STATUS(index);
+		switch(value) {
+		case UHF_PORT_ENABLE:
+			OWRITE4(sc, port, UPS_PORT_ENABLED);
+			break;
+		case UHF_PORT_SUSPEND:
+			OWRITE4(sc, port, UPS_SUSPEND);
+			break;
+		case UHF_PORT_RESET:
+			DPRINTFN(5,("reset port %d\n",
+				    index));
+			OWRITE4(sc, port, UPS_RESET);
+			for(i = 0; i < 5; i++)
+			{
+				DELAY(1000*USB_PORT_ROOT_RESET_DELAY);
+
+				if((OREAD4(sc, port) & UPS_RESET) == 0)
+				{
+					break;
+				}
+			}
+			DPRINTFN(8,("ohci port %d reset, status = 0x%04x\n",
+				    index, OREAD4(sc, port)));
+			break;
+		case UHF_PORT_POWER:
+			DPRINTFN(2,("set port power %d\n", index));
+			OWRITE4(sc, port, UPS_PORT_POWER);
+			break;
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+		break;
+	default:
+		err = USBD_IOERROR;
+		goto done;
+	}
+	xfer->actlen = totlen + sizeof(*req);
+	err = USBD_NORMAL_COMPLETION;
+
+ done:
+	/* transfer transferred */
+	ohci_device_done(xfer,err);
+
+	/* call callback recursively */
+	__usbd_callback(xfer);
+
+	return;
+}
+
+static void
+ohci_root_ctrl_start(struct usbd_xfer *xfer)
+{
+	/* not used */
+	return;
+}
+
+struct usbd_pipe_methods ohci_root_ctrl_methods = 
+{
+  .open = ohci_root_ctrl_open,
+  .close = ohci_root_ctrl_close,
+  .enter = ohci_root_ctrl_enter,
+  .start = ohci_root_ctrl_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * ohci root interrupt support
+ *---------------------------------------------------------------------------*/
+static void
+ohci_root_intr_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+ohci_root_intr_close(struct usbd_xfer *xfer)
+{
+	ohci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+ohci_root_intr_enter(struct usbd_xfer *xfer)
+{
+	DPRINTFN(3, ("xfer=%p len=%d\n",
+		     xfer, xfer->length));
+
+	/* enqueue transfer 
+	 * (so that it can be aborted through pipe abort)
+	 */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+ohci_root_intr_start(struct usbd_xfer *xfer)
+{
+	ohci_softc_t *sc = xfer->usb_sc;
+
+	/* only one transfer at a time 
+	 * (sc_intrxfer is cleared by ohci_root_intr_done())
+	 */
+	sc->sc_intrxfer = xfer;
+	return;
+}
+
+struct usbd_pipe_methods ohci_root_intr_methods = 
+{
+  .open = ohci_root_intr_open,
+  .close = ohci_root_intr_close,
+  .enter = ohci_root_intr_enter,
+  .start = ohci_root_intr_start,
+};
+
+#define ADD_BYTES(ptr,size) ((void *)(((u_int8_t *)(ptr)) + (size)))
+
+static usbd_status
+ohci_xfer_setup(struct usbd_device *udev,
+		u_int8_t iface_index,
+		struct usbd_xfer **pxfer,
+		const struct usbd_config *setup_start,
+		const struct usbd_config *setup_end)
+{
+	enum { max_frames = 128 };
+	ohci_softc_t *sc = OHCI_BUS2SC(udev->bus);
+	const struct usbd_config *setup;
+	struct usbd_memory_info *info;
+	struct usbd_xfer dummy;
+	struct usbd_xfer *xfer;
+	u_int32_t physbuffer;
+	u_int32_t size;
+	u_int32_t total_size;
+	u_int32_t ntd;
+	u_int32_t nitd;
+	u_int32_t nqh;
+	u_int32_t n;
+	void *buf;
+	usbd_status error = 0;
+
+	buf = 0;
+	physbuffer = 0;
+	total_size = 0;
+
+ repeat:
+	size = 0;
+
+	/* align data to 8 byte boundary */
+	size += ((-size) & (USB_HOST_ALIGN-1));
+
+	if(buf)
+	{
+	    info = ADD_BYTES(buf,size);
+
+	    info->memory_base = buf;
+	    info->memory_size = total_size;
+	    info->usb_mtx = &sc->sc_bus.mtx;
+	}
+	else
+	{
+	    info = NULL;
+	}
+
+	size += sizeof(info[0]);
+
+	for(setup = setup_start;
+	    setup < setup_end;
+	    setup++)
+	{
+	  ntd = 0;
+	  nitd = 0;
+	  nqh = 0;
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		*pxfer++ = (xfer = ADD_BYTES(buf,size));
+	  }
+	  else
+	  {
+		/* need dummy xfer to 
+		 * calculate ntd and nqh !
+		 */
+		xfer = &dummy;
+		bzero(&dummy, sizeof(dummy));
+	  }
+
+	  /*
+	   * setup xfer
+	   */
+	  xfer->usb_sc = sc;
+	  xfer->usb_mtx = &sc->sc_bus.mtx;
+	  xfer->usb_root = info;
+	  xfer->flags = setup->flags;
+	  xfer->length = setup->bufsize;
+	  xfer->nframes = setup->frames;
+	  xfer->timeout = setup->timeout;
+	  xfer->callback = setup->callback;
+
+	  __callout_init_mtx(&xfer->timeout_handle, &sc->sc_bus.mtx, 
+			     CALLOUT_RETURNUNLOCKED);
+
+	  xfer->pipe = usbd_get_pipe(udev, iface_index, setup);
+
+	  if(!xfer->pipe)
+	  {
+		/* continue though this error is critical */
+		error = USBD_NO_PIPE;
+		DPRINTF(("no pipe for endpoint %d\n",
+			 setup->endpoint));
+	  }
+	  else
+	  {
+		if(xfer->nframes >= max_frames)
+		{
+			/* continue, though this error is critical */
+			error = USBD_INVAL;
+			DPRINTF(("isochronous frame-limit "
+				 "exceeded by 0x%x frames; endpoint 0x%02x\n",
+				 setup->frames - max_frames,
+				 setup->endpoint));
+		}
+
+		if((xfer->nframes == 0) &&
+		   (xfer->pipe->methods == &ohci_device_isoc_methods))
+		{
+			/* continue, though this error is critical */
+			error = USBD_ZERO_FRAMES_IN_ISOC_MODE;
+			DPRINTF(("frames == 0 in isochronous mode; "
+				 "endpoint 0x%02x\n", setup->endpoint));
+		}
+
+		xfer->interval = setup->interval;
+
+		if(xfer->interval == 0)
+		{
+			xfer->interval = xfer->pipe->edesc->bInterval;
+		}
+
+		if(xfer->interval == 0)
+		{
+			/* one is the smallest interval */
+			xfer->interval = 1;
+		}
+
+		xfer->address = udev->address;
+		xfer->endpoint = xfer->pipe->edesc->bEndpointAddress;
+		xfer->max_packet_size = UGETW(xfer->pipe->edesc->wMaxPacketSize);
+
+		/* wMaxPacketSize is validated by "usbd_fill_iface_data()" */
+
+		/*
+		 * calculate ntd and nqh
+		 */
+		if((xfer->pipe->methods == &ohci_device_ctrl_methods) ||
+		   (xfer->pipe->methods == &ohci_device_bulk_methods) ||
+		   (xfer->pipe->methods == &ohci_device_intr_methods))
+		{
+			nitd = 0;
+			ntd = (1+ /* SETUP */ 1+ /* STATUS */
+			       1+  /* SHORTPKT */ 1 /* EXTRA */) +
+			  (xfer->length / (OHCI_PAGE_SIZE/2)) /* DATA */;
+		}
+		else if(xfer->pipe->methods == &ohci_device_isoc_methods)
+		{
+			nitd = (setup->bufsize / OHCI_PAGE_SIZE) +
+			  (max_frames / OHCI_ITD_NOFFSET) + 1 /* EXTRA */;
+			ntd = 0;
+		}
+		else
+		{
+			nitd = 0;
+			ntd = 0;
+		}
+
+		if((xfer->pipe->methods == &ohci_device_ctrl_methods) ||
+		   (xfer->pipe->methods == &ohci_device_bulk_methods) ||
+		   (xfer->pipe->methods == &ohci_device_intr_methods) ||
+		   (xfer->pipe->methods == &ohci_device_isoc_methods))
+		{
+			nqh = 1;
+		}
+		else
+		{
+			nqh = 0;
+		}
+	  }
+
+	  size += sizeof(xfer[0]);
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		xfer->frlengths = ADD_BYTES(buf,size);
+	  }
+
+	  size += max_frames * sizeof(xfer->frlengths[0]);
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		xfer->buffer = ADD_BYTES(buf,size);
+		xfer->physbuffer = (physbuffer + size);
+	  }
+
+	  size += setup->bufsize;
+
+	  size += ((-size) & (OHCI_ITD_ALIGN-1)); /* align data */
+
+	  if(buf)
+	  {
+		xfer->td_start = ADD_BYTES(buf,size);
+	  }
+
+	  for(n = 0;
+	      n < ntd;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init TD */
+		((ohci_td_t *)ADD_BYTES(buf,size))->td_self = 
+		  htole32(physbuffer + size);
+	    }
+	    size += sizeof(ohci_td_t);
+	  }
+
+	  for(n = 0;
+	      n < nitd;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init TD */
+		((ohci_itd_t *)ADD_BYTES(buf,size))->itd_self = 
+		  htole32(physbuffer + size);
+	    }
+	    size += sizeof(ohci_itd_t);
+	  }
+
+	  if(buf)
+	  {
+		xfer->td_end = ADD_BYTES(buf,size);
+	  }
+
+	  size += ((-size) & (OHCI_ED_ALIGN-1)); /* align data */
+
+	  if(buf)
+	  {
+		xfer->qh_start = ADD_BYTES(buf,size);
+	  }
+
+	  for(n = 0;
+	      n < nqh;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init QH */
+		((ohci_ed_t *)ADD_BYTES(buf,size))->ed_self = 
+		  htole32(physbuffer + size);
+	    }
+	    size += sizeof(ohci_ed_t);
+	  }
+
+	  if(buf)
+	  {
+		xfer->qh_end = ADD_BYTES(buf,size);
+	  }
+	}
+
+	if(!buf && !error)
+	{
+		/* store total buffer size */
+		total_size = size;
+
+		/* allocate zeroed memory */
+		buf = usb_alloc_mem(device_get_dma_tag(sc->sc_dev),
+				    size, LOG2(OHCI_TD_ALIGN));
+
+		if(!buf)
+		{
+			error = USBD_NOMEM;
+			DPRINTF(("cannot allocate memory block for "
+				 "configuration (%d bytes)\n", size));
+		}
+		else
+		{
+#if 1
+			bzero(buf, size);
+#endif
+			physbuffer = usb_vtophys(buf, size);
+			goto repeat;
+		}
+	}
+	return error;
+}
+
+static void
+ohci_pipe_init(struct usbd_device *udev, usb_endpoint_descriptor_t *edesc, 
+               struct usbd_pipe *pipe)
+{
+	ohci_softc_t *sc = OHCI_BUS2SC(udev->bus);
+
+	DPRINTFN(1, ("pipe=%p, addr=%d, endpt=%d (%d)\n",
+		     pipe, udev->address,
+		     edesc->bEndpointAddress, sc->sc_addr));
+
+	if(udev->address == sc->sc_addr)
+	{
+		switch (edesc->bEndpointAddress)
+		{
+		case USB_CONTROL_ENDPOINT:
+			pipe->methods = &ohci_root_ctrl_methods;
+			break;
+		case UE_DIR_IN | OHCI_INTR_ENDPT:
+			pipe->methods = &ohci_root_intr_methods;
+			break;
+		default:
+			panic("invalid endpoint address: 0x%02x",
+			      edesc->bEndpointAddress);
+			break;
+		}
+	}
+	else
+        {
+		switch (edesc->bmAttributes & UE_XFERTYPE)
+		{
+		case UE_CONTROL:
+			pipe->methods = &ohci_device_ctrl_methods;
+			break;
+		case UE_INTERRUPT:
+			pipe->methods = &ohci_device_intr_methods;
+			break;
+		case UE_ISOCHRONOUS:
+			pipe->methods = &ohci_device_isoc_methods;
+			break;
+		case UE_BULK:
+			pipe->methods = &ohci_device_bulk_methods;
+			break;
+		}
+	}
+	return;
+}
+
+struct usbd_bus_methods ohci_bus_methods = 
+{
+	.pipe_init  = ohci_pipe_init,
+	.xfer_setup = ohci_xfer_setup,
+	.do_poll    = ohci_do_poll,
+};
diff -rubN /usr/src1/src/sys/dev/usb2/_ohci_pci.c /usr/src/sys/dev/usb2/_ohci_pci.c
--- /usr/src1/src/sys/dev/usb2/_ohci_pci.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_ohci_pci.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (augustss@carlstedt.se) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * USB Open Host Controller driver.
+ *
+ * OHCI spec: http://www.intel.com/design/usb/ohci11d.pdf
+ */
+
+/* The low level controller code for OHCI has been split into
+ * PCI probes and OHCI specific code. This was done to facilitate the
+ * sharing of code between *BSD's
+ */
+
+#include "opt_bus.h"
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/endian.h>
+#include <sys/queue.h> /* LIST_XXX() */
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h> /* bus_space_xxx() */
+
+#define INCLUDE_PCIXXX_H
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/ohci.h> 
+
+__FBSDID("$FreeBSD: src/sys/dev/usb/ohci_pci.c,v 1.40 2004/08/02 15:37:35 iedowse Exp $");
+
+#define PCI_OHCI_VENDORID_ACERLABS	0x10b9
+#define PCI_OHCI_VENDORID_AMD		0x1022
+#define PCI_OHCI_VENDORID_APPLE		0x106b
+#define PCI_OHCI_VENDORID_CMDTECH	0x1095
+#define PCI_OHCI_VENDORID_NEC		0x1033
+#define PCI_OHCI_VENDORID_NVIDIA	0x12D2
+#define PCI_OHCI_VENDORID_NVIDIA2	0x10DE
+#define PCI_OHCI_VENDORID_OPTI		0x1045
+#define PCI_OHCI_VENDORID_SIS		0x1039
+
+#define PCI_OHCI_BASE_REG	0x10
+
+static int ohci_pci_attach(device_t self);
+static int ohci_pci_detach(device_t self);
+static int ohci_pci_suspend(device_t self);
+static int ohci_pci_resume(device_t self);
+
+static int
+ohci_pci_suspend(device_t self)
+{
+	ohci_softc_t *sc = device_get_softc(self);
+	int err;
+
+	err = bus_generic_suspend(self);
+	if(err)
+	{
+		return err;
+	}
+	ohci_suspend(sc);
+	return 0;
+}
+
+static int
+ohci_pci_resume(device_t self)
+{
+	ohci_softc_t *sc = device_get_softc(self);
+	u_int32_t reg, int_line;
+
+	if(pci_get_powerstate(self) != PCI_POWERSTATE_D0)
+	{
+                device_printf(self, "chip is in D%d mode "
+                        "-- setting to D0\n", pci_get_powerstate(self));
+                reg = pci_read_config(self, PCI_CBMEM, 4);
+                int_line = pci_read_config(self, PCIR_INTLINE, 4);
+                pci_set_powerstate(self, PCI_POWERSTATE_D0);
+                pci_write_config(self, PCI_CBMEM, reg, 4);
+                pci_write_config(self, PCIR_INTLINE, int_line, 4);
+	}
+
+	ohci_resume(sc);
+
+	bus_generic_resume(self);
+	return 0;
+}
+
+static const char *
+ohci_pci_match(device_t self)
+{
+	u_int32_t device_id = pci_get_devid(self);
+
+	if(device_id == 0x523710b9)
+	  { return ("AcerLabs M5237 (Aladdin-V) USB controller"); }
+        if(device_id == 0x740c1022)
+	  { return ("AMD-756 USB Controller"); }
+        if(device_id == 0x74141022)
+	  { return ("AMD-766 USB Controller"); }
+        if(device_id == 0x06701095)
+	  { return ("CMD Tech 670 (USB0670) USB controller"); }
+        if(device_id == 0x06731095)
+	  { return ("CMD Tech 673 (USB0673) USB controller"); }
+        if(device_id == 0xc8611045)
+	  { return ("OPTi 82C861 (FireLink) USB controller"); }
+        if(device_id == 0x00351033)
+	  { return ("NEC uPD 9210 USB controller"); }
+        if(device_id == 0x00d710de)
+	  { return ("nVidia nForce3 USB Controller"); }
+        if(device_id == 0x70011039)
+	  { return ("SiS 5571 USB controller"); }
+        if(device_id == 0x0019106b)
+	  { return ("Apple KeyLargo USB controller"); }
+
+	if ((pci_get_class(self) == PCIC_SERIALBUS) &&
+	    (pci_get_subclass(self) == PCIS_SERIALBUS_USB) &&
+	    (pci_get_progif(self) == PCI_INTERFACE_OHCI))
+	{
+		return ("OHCI (generic) USB controller");
+	}
+	return NULL;
+}
+
+static int
+ohci_pci_probe(device_t self)
+{
+	const char *desc = ohci_pci_match(self);
+
+	if (desc)
+	{
+		device_set_desc(self, desc);
+		return 0;
+	}
+	else
+	{
+		return ENXIO;
+	}
+}
+
+static int
+ohci_pci_attach(device_t self)
+{
+	ohci_softc_t *sc;
+	int rid;
+	int err;
+
+	sc = usb_alloc_mem(device_get_dma_tag(self),
+			   sizeof(*sc), LOG2(OHCI_HCCA_ALIGN));
+
+	if(sc == NULL)
+	{
+		device_printf(self, "Could not allocate sc\n");
+		return ENXIO;
+	}
+
+#if 1
+	bzero(sc, sizeof(*sc));
+#endif
+
+	sc->sc_physaddr = usb_vtophys(sc, sizeof(*sc)); /* physical address of sc */
+
+	mtx_init(&sc->sc_bus.mtx, "usb lock",
+		 NULL, MTX_DEF|MTX_RECURSE);
+
+	device_set_softc(self, sc);
+	sc->sc_dev = self;
+
+	pci_enable_busmaster(self);
+
+	rid = PCI_CBMEM;
+	sc->io_res = bus_alloc_resource_any(self, SYS_RES_MEMORY, &rid,
+					    RF_ACTIVE);
+	if(!sc->io_res)
+	{
+		device_printf(self, "Could not map memory\n");
+		goto error;
+	}
+	sc->iot = rman_get_bustag(sc->io_res);
+	sc->ioh = rman_get_bushandle(sc->io_res);
+
+	rid = 0;
+	sc->irq_res = bus_alloc_resource_any(self, SYS_RES_IRQ, &rid,
+					     RF_SHAREABLE | RF_ACTIVE);
+	if(sc->irq_res == NULL)
+	{
+		device_printf(self, "Could not allocate irq\n");
+		goto error;
+	}
+
+	sc->sc_bus.bdev = device_add_child(self, "usb", -1);
+	if(!sc->sc_bus.bdev)
+	{
+		device_printf(self, "Could not add USB device\n");
+		goto error;
+	}
+
+	device_set_ivars(sc->sc_bus.bdev, &sc->sc_bus);
+	device_set_softc(sc->sc_bus.bdev, &sc->sc_bus);
+
+	/* ohci_pci_match will never return NULL if ohci_pci_probe succeeded */
+	device_set_desc(sc->sc_bus.bdev, ohci_pci_match(self));
+	switch (pci_get_vendor(self)) {
+	case PCI_OHCI_VENDORID_ACERLABS:
+		sprintf(sc->sc_vendor, "AcerLabs");
+		break;
+	case PCI_OHCI_VENDORID_AMD:
+		sprintf(sc->sc_vendor, "AMD");
+		break;
+	case PCI_OHCI_VENDORID_APPLE:
+		sprintf(sc->sc_vendor, "Apple");
+		break;
+	case PCI_OHCI_VENDORID_CMDTECH:
+		sprintf(sc->sc_vendor, "CMDTECH");
+		break;
+	case PCI_OHCI_VENDORID_NEC:
+		sprintf(sc->sc_vendor, "NEC");
+		break;
+	case PCI_OHCI_VENDORID_NVIDIA:
+	case PCI_OHCI_VENDORID_NVIDIA2:
+		sprintf(sc->sc_vendor, "nVidia");
+		break;
+	case PCI_OHCI_VENDORID_OPTI:
+		sprintf(sc->sc_vendor, "OPTi");
+		break;
+	case PCI_OHCI_VENDORID_SIS:
+		sprintf(sc->sc_vendor, "SiS");
+		break;
+	default:
+		if(bootverbose)
+		{
+			device_printf(self, "(New OHCI DeviceId=0x%08x)\n",
+				      pci_get_devid(self));
+		}
+		sprintf(sc->sc_vendor, "(0x%04x)", pci_get_vendor(self));
+	}
+
+	/* sc->sc_bus.usbrev; set by ohci_init() */
+
+	err = bus_setup_intr(self, sc->irq_res, INTR_TYPE_BIO|INTR_MPSAFE,
+			     (void *)(void *)ohci_interrupt, sc, &sc->ih);
+	if(err)
+	{
+		device_printf(self, "Could not setup irq, %d\n", err);
+		sc->ih = NULL;
+		goto error;
+	}
+
+	err = ohci_init(sc);
+	if(!err)
+	{
+		err = device_probe_and_attach(sc->sc_bus.bdev);
+	}
+
+	if(err)
+	{
+		device_printf(self, "USB init failed\n");
+		goto error;
+	}
+	return 0;
+
+ error:
+	ohci_pci_detach(self);
+	return ENXIO;
+}
+
+static int
+ohci_pci_detach(device_t self)
+{
+	ohci_softc_t *sc = device_get_softc(self);
+
+	if(sc->sc_bus.bdev)
+	{
+		device_delete_child(self, sc->sc_bus.bdev);
+		sc->sc_bus.bdev = NULL;
+	}
+
+	pci_disable_busmaster(self);
+
+	if(sc->irq_res && sc->ih)
+	{
+		/* only call ohci_detach()
+		 * after ohci_init()
+		 */
+		ohci_detach(sc);
+
+		int err = bus_teardown_intr(self, sc->irq_res, sc->ih);
+
+		if(err)
+		{
+			/* XXX or should we panic? */
+			device_printf(self, "Could not tear down irq, %d\n",
+				      err);
+		}
+		sc->ih = NULL;
+	}
+	if(sc->irq_res)
+	{
+		bus_release_resource(self, SYS_RES_IRQ, 0, sc->irq_res);
+		sc->irq_res = NULL;
+	}
+	if(sc->io_res)
+	{
+		bus_release_resource(self, SYS_RES_MEMORY, PCI_CBMEM,
+				     sc->io_res);
+		sc->io_res = NULL;
+	}
+
+	usb_free_mem(sc, sizeof(*sc));
+
+	device_set_softc(self, NULL);
+	return 0;
+}
+
+static driver_t ohci_driver =
+{
+	.name    = "ohci",
+	.methods = (device_method_t [])
+	{
+	  /* device interface */
+	  DEVMETHOD(device_probe, ohci_pci_probe),
+	  DEVMETHOD(device_attach, ohci_pci_attach),
+	  DEVMETHOD(device_detach, ohci_pci_detach),
+	  DEVMETHOD(device_suspend, ohci_pci_suspend),
+	  DEVMETHOD(device_resume, ohci_pci_resume),
+	  DEVMETHOD(device_shutdown, bus_generic_shutdown),
+
+	  /* bus interface */
+	  DEVMETHOD(bus_print_child, bus_generic_print_child),
+
+	  {0, 0}
+	},
+	.size = 0,
+};
+
+static devclass_t ohci_devclass;
+
+DRIVER_MODULE(ohci, pci, ohci_driver, ohci_devclass, 0, 0);
+DRIVER_MODULE(ohci, cardbus, ohci_driver, ohci_devclass, 0, 0);
diff -rubN /usr/src1/src/sys/dev/usb2/_ugen.c /usr/src/sys/dev/usb2/_ugen.c
--- /usr/src1/src/sys/dev/usb2/_ugen.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_ugen.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,2093 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/ioccom.h>
+#include <sys/filio.h>
+#include <sys/tty.h>
+#include <sys/file.h>
+#include <sys/vnode.h>
+#include <sys/poll.h>
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb2/ugen.c $");
+
+#define	UGEN_BULK_BUFFER_SIZE	(1024*64) /* bytes */
+
+#define UGEN_HW_FRAMES	50 /* number of milliseconds per transfer */
+
+#define ADD_BYTES(ptr,size) ((void *)(((u_int8_t *)(ptr)) + (size)))
+
+struct ugen_frame_ring {
+  u_int16_t input_index;
+  u_int16_t output_index;
+  u_int16_t end_index; /* exclusive */
+  u_int16_t frame_size;
+  u_int16_t *frlengths;
+  void *buf;
+};
+
+struct ugen_endpoint {
+  struct ugen_softc *	  sc;
+  struct cdev *		  dev;
+  struct usbd_pipe *	  pipe_in; /* pipe for reading data from USB */
+  struct usbd_pipe *	  pipe_out; /* pipe for writing data to USB */
+  struct usbd_xfer *	  xfer_in[2];
+  struct usbd_xfer *	  xfer_out[2];
+
+  struct ugen_frame_ring  in_queue; /* (isoc/interrupt) */
+  struct ugen_frame_ring  out_queue; /* (isoc) */
+  u_int32_t		  in_timeout; /* (bulk/interrupt) */
+  u_int32_t		  in_frames; /* number of frames to use (isoc) */
+  u_int32_t		  out_frames; /* number of frames to use (isoc) */
+  u_int16_t		  out_frame_size; /* maximum frame size (isoc) */
+
+  u_int32_t		  io_buffer_size; /* (bulk) */
+
+  struct selinfo	  selinfo;
+
+  u_int16_t		  state;
+#define UGEN_OPEN_IN      0x0001
+#define UGEN_OPEN_OUT     0x0002
+#define UGEN_OPEN_DEV     0x0004
+#define UGEN_CLOSING      0x0008
+#define UGEN_GONE         0x0010
+#define UGEN_SHORT_OK     0x0020 /* short xfers are OK */
+
+  /* context bits */
+#define UGEN_RD_CFG	  0x0040
+#define UGEN_RD_SLP	  0x0080 /* sleep entered */
+#define UGEN_RD_WUP	  0x0100 /* need wakeup */
+#define UGEN_RD_UIO	  0x0200
+
+  /* context bits */
+#define UGEN_WR_CFG	  0x0400
+#define UGEN_WR_SLP	  0x0800
+#define UGEN_WR_WUP	  0x1000
+#define UGEN_WR_UIO	  0x2000
+
+  /* context bit */
+#define UGEN_IOCTL	  0x4000
+};
+
+struct ugen_softc {
+  device_t       	  sc_dev;
+  struct usbd_device *	  sc_udev;
+  struct ugen_endpoint	  sc_endpoints[USB_MAX_ENDPOINTS];
+  struct ugen_endpoint	  sc_endpoints_end[0];
+  struct mtx		  sc_mtx;
+};
+
+extern cdevsw_t ugen_cdevsw;
+
+static void
+ugen_make_devnodes(struct ugen_softc *sc);
+
+static void
+ugen_destroy_devnodes(struct ugen_softc *sc, int skip_first);
+
+static void
+ugen_interrupt_callback(struct usbd_xfer *xfer);
+
+static void
+ugenisoc_read_callback(struct usbd_xfer *xfer);
+
+static void
+ugenisoc_write_callback(struct usbd_xfer *xfer);
+
+static int
+ugen_set_config(struct ugen_softc *sc, int configno);
+
+static int
+ugen_set_interface(struct ugen_softc *sc, int ifaceidx, int altno);
+
+static usb_config_descriptor_t *
+ugen_get_cdesc(struct usbd_device *udev, int index, int *lenp);
+
+static int
+ugen_get_alt_index(struct usbd_device *udev, int ifaceidx);
+
+#define UGENMINOR(unit, endpoint) (((unit) << 4) | (endpoint))
+
+#define DEV2SC(dev) ((dev)->si_drv1)
+#define DEV2SCE(dev) ((dev)->si_drv2)
+
+static int 
+ugen_probe(device_t dev)
+{
+	struct usb_attach_arg *uaa = device_get_ivars(dev);
+
+	if(uaa->usegeneric)
+		return (UMATCH_GENERIC);
+	else
+		return (UMATCH_NONE);
+}
+
+static int
+ugen_attach(device_t dev)
+{
+	struct usb_attach_arg *uaa = device_get_ivars(dev);
+	struct ugen_softc *sc = device_get_softc(dev);
+	struct ugen_endpoint *sce;
+	int conf;
+
+	sc->sc_dev = dev;
+	sc->sc_udev = uaa->device;
+
+        mtx_init(&sc->sc_mtx, "ugen lock",
+                 NULL, MTX_DEF|MTX_RECURSE);
+
+	/**/
+	usbd_set_desc(dev, sc->sc_udev);
+
+	/* first set configuration index 0, the default one for ugen */
+	if(usbd_set_config_index(sc->sc_udev, 0, 0))
+	{
+		device_printf(dev, "setting configuration index 0 failed\n");
+		return ENXIO;
+	}
+	conf = usbd_get_config_descriptor(sc->sc_udev)->bConfigurationValue;
+
+	/* set up all the local state for this configuration */
+	if(ugen_set_config(sc, conf))
+	{
+		device_printf(dev, "setting configuration "
+			      "%d failed\n", conf);
+		return ENXIO;
+	}
+
+	sce = &sc->sc_endpoints[0];
+
+	/* make control endpoint */
+	sce->dev = make_dev(&ugen_cdevsw, UGENMINOR(device_get_unit(sc->sc_dev), 0),
+			    UID_ROOT, GID_OPERATOR, 0644, "%s", 
+			    device_get_nameunit(sc->sc_dev));
+	if(sce->dev)
+	{
+		DEV2SC(sce->dev) = sc;
+		DEV2SCE(sce->dev) = sce;
+	}
+	return 0; /* success */
+}
+
+static int
+ugen_detach(device_t dev)
+{
+	struct ugen_softc *sc = device_get_softc(dev);
+	struct ugen_endpoint *sce = &sc->sc_endpoints[0];
+	struct ugen_endpoint *sce_end = &sc->sc_endpoints_end[0];
+
+	mtx_lock(&sc->sc_mtx);
+	while(sce < sce_end)
+	{
+		sce->state |= UGEN_GONE;
+		sce++;
+	}
+	mtx_unlock(&sc->sc_mtx);
+
+	/* destroy all devices */
+	ugen_destroy_devnodes(sc, 0);
+	return 0;
+}
+
+#define ugen_inc_input_index(ufr) \
+{\
+  (ufr)->input_index++;\
+  if((ufr)->input_index >= (ufr)->end_index)\
+	(ufr)->input_index = 0;\
+}
+
+#define ugen_inc_output_index(ufr) \
+{\
+  (ufr)->output_index++;\
+  if((ufr)->output_index >= (ufr)->end_index)\
+	(ufr)->output_index = 0;\
+}
+
+#define ugen_half_empty(ufr) \
+((ufr)->end_index ? \
+((((ufr)->end_index + \
+   (ufr)->input_index - \
+   (ufr)->output_index) % (ufr)->end_index) \
+ < ((ufr)->end_index / 2)) : 0)
+
+#define ugen_not_empty(ufr) \
+((ufr)->output_index != \
+ (ufr)->input_index)
+
+static void
+ugen_get_input_block(struct ugen_frame_ring *ufr, void **ptr, u_int16_t **len)
+{
+	u_int16_t next;
+
+	next = ufr->input_index +1;
+	if(next >= ufr->end_index)
+	{
+		next = 0;
+	}
+	if(next == ufr->output_index)
+	{
+		/* buffer full */
+		*ptr = 0;
+		*len = 0;
+	}
+	else
+	{
+		*ptr = ADD_BYTES
+		  (ufr->buf, 
+		   ufr->frame_size*ufr->input_index);
+
+		*len = &ufr->frlengths[ufr->input_index];
+
+		/* set default block length */
+		ufr->frlengths[ufr->input_index] = ufr->frame_size; 
+	}
+	return;
+}
+
+static void
+ugen_get_output_block(struct ugen_frame_ring *ufr, void **ptr, u_int16_t *len)
+{
+	if(ufr->output_index == ufr->input_index)
+	{
+		/* buffer empty */
+		*ptr = 0;
+		*len = 0;
+	}
+	else
+	{
+		*ptr = ADD_BYTES
+		  (ufr->buf,
+		   ufr->frame_size*ufr->output_index);
+
+		*len = ufr->frlengths[ufr->output_index];
+	}
+	return;
+}
+
+static int
+ugen_allocate_blocks(struct ugen_softc *sc,
+		     struct ugen_endpoint *sce,
+		     u_int16_t context_bit,
+		     struct ugen_frame_ring *ufr, 
+		     u_int16_t frames, 
+		     u_int16_t frame_size)
+{
+	void *ptr;
+
+	bzero(ufr, sizeof(*ufr));
+
+	if(frames == 0) 
+	{
+		return 0;
+	}
+
+	/* one frame will always be unused
+	 * to make things simple, so allocate
+	 * one extra frame:
+	 */
+	frames++;
+
+	sce->state |= context_bit;
+
+	mtx_unlock(&sc->sc_mtx);
+
+	ptr = malloc(frames*(frame_size + sizeof(u_int16_t)), 
+		     M_USBDEV, M_WAITOK);
+
+	mtx_lock(&sc->sc_mtx);
+
+	sce->state &= ~context_bit;
+
+	if(sce->state & UGEN_CLOSING)
+	{
+		wakeup(sce);
+		if(ptr)
+		{
+			free(ptr, M_USBDEV);
+			ptr = NULL;
+		}
+	}
+
+	if(ptr == NULL)
+	{
+		return 0;
+	}
+
+	ufr->end_index = frames;
+	ufr->frame_size = frame_size;
+	ufr->frlengths = ADD_BYTES(ptr, frames*frame_size);
+	ufr->buf = ADD_BYTES(ptr, 0);
+	return 1;
+}
+
+static void
+ugen_free_blocks(struct ugen_frame_ring *ufr)
+{
+	if(ufr->buf)
+	{
+		free(ufr->buf, M_USBDEV);
+		ufr->buf = NULL;
+	}
+	return;
+}
+
+static usbd_status
+__usbd_transfer_setup(struct ugen_softc *sc,
+		      struct ugen_endpoint *sce,
+		      u_int16_t context_bit,
+		      struct usbd_device *udev,
+		      u_int8_t iface_index,
+		      struct usbd_xfer **pxfer,
+		      const struct usbd_config *setup,
+		      u_int8_t n_setup)
+{
+	struct usbd_xfer * temp[n_setup];
+
+	usbd_status error;
+
+	sce->state |= context_bit;
+
+	mtx_unlock(&sc->sc_mtx);
+
+	/* "usbd_transfer_setup()" can sleep so one
+	 * needs to make a wrapper, exiting
+	 * the mutex and checking things
+	 */
+	error = usbd_transfer_setup(udev, iface_index, &temp[0], 
+				    setup, n_setup, 
+				    sce, &sc->sc_mtx, NULL);
+
+	mtx_lock(&sc->sc_mtx);
+
+	sce->state &= ~context_bit;
+
+	if(sce->state & UGEN_CLOSING)
+	{
+		wakeup(sce);
+		error = USBD_CANCELLED;
+
+		/* "usbd_transfer_unsetup()" will clear "temp[]" */
+		usbd_transfer_unsetup(&temp[0], n_setup);
+	}
+
+	while(n_setup--)
+	{
+		pxfer[n_setup] = temp[n_setup];
+	}
+	return error;
+}
+
+static int
+__uiomove(struct ugen_softc *sc, struct ugen_endpoint *sce,
+	  u_int16_t context_bit, void *cp, int n, 
+	  struct uio *uio)
+{
+	int error;
+
+	sce->state |= context_bit;
+
+	mtx_unlock(&sc->sc_mtx);
+
+	/* "uiomove()" can sleep so one
+	 * needs to make a wrapper, exiting
+	 * the mutex and checking things
+	 */
+	error = uiomove(cp, n, uio);
+
+	mtx_lock(&sc->sc_mtx);
+
+	sce->state &= ~context_bit;
+
+	if(sce->state & UGEN_CLOSING)
+	{
+		wakeup(sce);
+		error = EINTR;
+	}
+	return error;
+}
+
+static int
+ugenopen(struct cdev *dev, int flag, int mode, struct thread *p)
+{
+	struct ugen_softc *sc = DEV2SC(dev);
+	struct ugen_endpoint *sce = DEV2SCE(dev);
+	int error = 0;
+
+ 	PRINTFN(5, ("flag=%d, mode=%d\n", flag, mode));
+
+	if((sc == NULL) || (sce == NULL))
+	{
+		return (EIO);
+	}
+
+	mtx_lock(&sc->sc_mtx);
+
+	if(sce->state & (UGEN_OPEN_DEV|UGEN_GONE))
+	{
+		error = EBUSY;
+		goto done;
+	}
+
+	if(sce != &sc->sc_endpoints[0])
+	{
+		/* non-control endpoint(s) ;
+		 * make sure that there are 
+		 * pipes for all directions
+		 */
+		if(((flag & FWRITE) && !sce->pipe_out) ||
+		   ((flag & FREAD) && !sce->pipe_in))
+		{
+			error = ENXIO;
+			goto done;
+		}
+	}
+
+	sce->state |= UGEN_OPEN_DEV;
+
+ done:
+	mtx_unlock(&sc->sc_mtx);
+	return error;
+}
+
+static int
+ugenclose(struct cdev *dev, int flag, int mode, struct thread *p)
+{
+	struct ugen_softc *sc = DEV2SC(dev);
+	struct ugen_endpoint *sce = DEV2SCE(dev);
+
+	PRINTFN(5, ("flag=%d, mode=%d\n", flag, mode));
+
+	if((sc == NULL) || (sce == NULL))
+	{
+		return (0);
+	}
+
+	mtx_lock(&sc->sc_mtx);
+
+	if(sce->state & (UGEN_OPEN_DEV|UGEN_OPEN_IN|UGEN_OPEN_OUT))
+	{
+		/* control endpoint is also ``closed'' here */
+
+		sce->state |= UGEN_CLOSING;
+
+		if(sce->xfer_in[0])
+		{
+			usbd_transfer_stop(sce->xfer_in[0]);
+		}
+		if(sce->xfer_in[1])
+		{
+			usbd_transfer_stop(sce->xfer_in[1]);
+		}
+		if(sce->xfer_out[0])
+		{
+			usbd_transfer_stop(sce->xfer_out[0]);
+		}
+		if(sce->xfer_out[1])
+		{
+			usbd_transfer_stop(sce->xfer_out[1]);
+		}
+
+		while(sce->state & 
+		      (UGEN_RD_CFG|UGEN_RD_SLP|UGEN_RD_WUP|UGEN_RD_UIO|
+		       UGEN_WR_CFG|UGEN_WR_SLP|UGEN_WR_WUP|UGEN_WR_UIO|
+		       UGEN_IOCTL))
+		{
+			if(sce->state & (UGEN_RD_WUP|UGEN_WR_WUP))
+			{
+				sce->state &= ~(UGEN_RD_WUP|UGEN_WR_WUP);
+				wakeup(sce);
+			}
+
+			/* wait for routine(s) to exit */
+			msleep(sce, &sc->sc_mtx, PRIBIO, "ugensync", 0);
+		}
+
+		/* free all memory after that one has
+		 * waited for all context bits to clear,
+		 * hence functions accessing memory
+		 * like "uiomove", might be sleeping !
+		 */
+
+		ugen_free_blocks(&sce->in_queue);
+		ugen_free_blocks(&sce->out_queue);
+
+		sce->state &= ~(UGEN_OPEN_DEV|UGEN_OPEN_IN|UGEN_OPEN_OUT|UGEN_CLOSING);
+
+		usbd_transfer_unsetup(&sce->xfer_in[0], 2);
+		usbd_transfer_unsetup(&sce->xfer_out[0], 2);
+	}
+	mtx_unlock(&sc->sc_mtx);
+	return (0);
+}
+
+static int
+ugen_open_pipe_write(struct ugen_softc *sc, struct ugen_endpoint *sce)
+{
+	u_int16_t isize;
+	usbd_status err;
+
+	mtx_assert(&sc->sc_mtx, MA_OWNED);
+
+	if(!(sce->state & UGEN_OPEN_OUT))
+	{
+	  if(sce->pipe_out)
+	  {
+		usb_endpoint_descriptor_t *ed = sce->pipe_out->edesc;
+
+		struct usbd_config usbd_config[2] = { /* zero */ };
+
+		usbd_config[1].type = UE_CONTROL;
+		usbd_config[1].endpoint = 0;
+		usbd_config[1].direction = -1;
+		usbd_config[1].timeout = USBD_DEFAULT_TIMEOUT;
+		usbd_config[1].flags = 0;
+		usbd_config[1].bufsize = sizeof(usb_device_request_t);
+		usbd_config[1].callback = &usbd_clearstall_callback;
+
+		usbd_config[0].type = ed->bmAttributes & UE_XFERTYPE;
+		usbd_config[0].endpoint = ed->bEndpointAddress & UE_ADDR;
+		usbd_config[0].direction = UE_DIR_OUT;
+		usbd_config[0].callback = usbd_default_callback;
+		usbd_config[0].interval = USBD_DEFAULT_INTERVAL;
+		usbd_config[0].timeout = sce->in_timeout;
+
+		switch(ed->bmAttributes & UE_XFERTYPE)
+		{
+		case UE_INTERRUPT:
+		case UE_BULK:
+			usbd_config[0].flags = USBD_SYNCHRONOUS;
+			usbd_config[0].bufsize = UGEN_BULK_BUFFER_SIZE;
+			
+			if(__usbd_transfer_setup
+			   (sc, sce, UGEN_WR_CFG,
+			    sc->sc_udev, sce->pipe_out->iface_index,
+			    &sce->xfer_out[0], &usbd_config[0], 2))
+			{
+				return (EIO);
+			}
+			/* setup clear stall */
+			sce->xfer_out[0]->clearstall_xfer =
+			  sce->xfer_out[1];
+			break;
+
+		case UE_ISOCHRONOUS:
+			isize = UGETW(ed->wMaxPacketSize);
+
+			/* wMaxPacketSize is validated 
+			 * by "usbd_fill_iface_data()" 
+			 */
+
+			if(usbd_get_speed(sc->sc_udev) == USB_SPEED_HIGH)
+			{
+				sce->out_frames = UGEN_HW_FRAMES*8;
+			}
+			else
+			{
+				sce->out_frames = UGEN_HW_FRAMES;
+			}
+
+			if(ugen_allocate_blocks
+			   (sc, sce, UGEN_WR_CFG, 
+			    &sce->out_queue, sce->out_frames * 10, isize) == 0)
+			{
+				return ENOMEM;
+			}
+
+			usbd_config[0].flags = USBD_SHORT_XFER_OK;
+			usbd_config[0].bufsize = isize * sce->out_frames;
+			usbd_config[0].frames = sce->out_frames;
+			usbd_config[0].callback = ugenisoc_write_callback;
+			usbd_config[0].timeout = 0;
+
+			err = __usbd_transfer_setup
+			  (sc, sce, UGEN_WR_CFG,
+			   sc->sc_udev, sce->pipe_out->iface_index,
+			   &sce->xfer_out[0], &usbd_config[0], 1);
+
+			if(!err)
+			{
+				err = __usbd_transfer_setup
+				  (sc, sce, UGEN_WR_CFG,
+				   sc->sc_udev, sce->pipe_out->iface_index,
+				   &sce->xfer_out[1], &usbd_config[0], 1);
+			}
+			if(err)
+			{
+				usbd_transfer_unsetup(&sce->xfer_out[0], 1);
+				usbd_transfer_unsetup(&sce->xfer_out[1], 1);
+				ugen_free_blocks(&sce->out_queue);
+				return (EIO);
+			}
+			break;
+
+		default:
+			return (EINVAL);
+		}
+		sce->state |= UGEN_OPEN_OUT;
+	  }
+	  else
+	  {
+		return ENXIO;
+	  }
+	}
+	return 0;
+}
+
+static int
+ugen_open_pipe_read(struct ugen_softc *sc, struct ugen_endpoint *sce)
+{
+	int isize;
+	usbd_status err;
+
+	mtx_assert(&sc->sc_mtx, MA_OWNED);
+
+	if(!(sce->state & UGEN_OPEN_IN))
+	{
+	  if(sce->pipe_in)
+	  {
+		usb_endpoint_descriptor_t *ed = sce->pipe_in->edesc;
+
+		struct usbd_config usbd_config[2] = { /* zero */ };
+
+		usbd_config[1].type = UE_CONTROL;
+		usbd_config[1].endpoint = 0;
+		usbd_config[1].direction = -1;
+		usbd_config[1].timeout = USBD_DEFAULT_TIMEOUT;
+		usbd_config[1].flags = 0;
+		usbd_config[1].bufsize = sizeof(usb_device_request_t);
+		usbd_config[1].callback = &usbd_clearstall_callback;
+
+		usbd_config[0].type = ed->bmAttributes & UE_XFERTYPE;
+		usbd_config[0].endpoint = ed->bEndpointAddress & UE_ADDR;
+		usbd_config[0].direction = UE_DIR_IN;
+		usbd_config[0].timeout = sce->in_timeout;
+
+		switch(ed->bmAttributes & UE_XFERTYPE)
+		{
+		case UE_INTERRUPT:
+		  usbd_config[0].flags = USBD_SHORT_XFER_OK;
+		  usbd_config[0].callback = ugen_interrupt_callback;
+		  usbd_config[0].bufsize = UGETW(ed->wMaxPacketSize);
+		  usbd_config[0].interval = USBD_DEFAULT_INTERVAL;
+
+		  if(ugen_allocate_blocks
+		     (sc, sce, UGEN_RD_CFG,
+		      &sce->in_queue, 1, UGETW(ed->wMaxPacketSize)) == 0)
+		  {
+			return ENOMEM;
+		  }
+
+		  if(__usbd_transfer_setup
+		     (sc, sce, UGEN_RD_CFG,
+		      sc->sc_udev, sce->pipe_in->iface_index,
+		      &sce->xfer_in[0], &usbd_config[0], 2))
+		  {
+			ugen_free_blocks(&sce->in_queue);
+			return (EIO);
+		  }
+
+		  /* setup clear stall */
+		  sce->xfer_in[0]->clearstall_xfer =
+		    sce->xfer_in[1];
+
+		  usbd_transfer_start(sce->xfer_in[0]);
+		  PRINTFN(5, ("interrupt open done\n"));
+		  break;
+
+		case UE_BULK:
+		  usbd_config[0].flags = ((sce->state & UGEN_SHORT_OK) ? 
+					  USBD_SHORT_XFER_OK : 0) | USBD_SYNCHRONOUS;
+		  usbd_config[0].callback = usbd_default_callback;
+		  usbd_config[0].bufsize = UGEN_BULK_BUFFER_SIZE;
+
+		  if(__usbd_transfer_setup
+		     (sc, sce, UGEN_RD_CFG,
+		      sc->sc_udev, sce->pipe_in->iface_index,
+		      &sce->xfer_in[0], &usbd_config[0], 2))
+		  {
+			return (EIO);
+		  }
+
+		  /* setup clear stall */
+		  sce->xfer_in[0]->clearstall_xfer =
+		    sce->xfer_in[1];
+		  break;
+
+		case UE_ISOCHRONOUS:
+
+		  isize = UGETW(ed->wMaxPacketSize);
+
+		  /* wMaxPacketSize is validated by "usbd_fill_iface_data()" */
+
+		  if(usbd_get_speed(sc->sc_udev) == USB_SPEED_HIGH)
+		  {
+			sce->in_frames = UGEN_HW_FRAMES*8;
+		  }
+		  else
+		  {
+			sce->in_frames = UGEN_HW_FRAMES;
+		  }
+
+		  if(ugen_allocate_blocks
+		     (sc, sce, UGEN_RD_CFG,
+		      &sce->in_queue, sce->in_frames * 10, isize) == 0)
+		  {
+			return ENOMEM;
+		  }
+
+		  usbd_config[0].flags = USBD_SHORT_XFER_OK;
+		  usbd_config[0].bufsize = isize * sce->in_frames;
+		  usbd_config[0].frames = sce->in_frames;
+		  usbd_config[0].callback = ugenisoc_read_callback;
+		  usbd_config[0].timeout = 0;
+
+		  err = __usbd_transfer_setup
+		    (sc, sce, UGEN_RD_CFG,
+		     sc->sc_udev, sce->pipe_in->iface_index,
+		     &sce->xfer_in[0], &usbd_config[0], 1);
+
+		  if(!err)
+		  {
+			err = __usbd_transfer_setup
+			  (sc, sce, UGEN_RD_CFG,
+			   sc->sc_udev, sce->pipe_in->iface_index,
+			   &sce->xfer_in[1], &usbd_config[0], 1);
+		  }
+
+		  if(err)
+		  {
+			usbd_transfer_unsetup(&sce->xfer_in[0], 1);
+			usbd_transfer_unsetup(&sce->xfer_in[1], 1);
+			ugen_free_blocks(&sce->in_queue);
+			return (EIO);
+		  }
+
+		  usbd_transfer_start(sce->xfer_in[0]);
+		  usbd_transfer_start(sce->xfer_in[1]);
+		  PRINTFN(5, ("isoc open done\n"));
+		  break;
+
+		default:
+		  return EINVAL;
+		}
+		sce->state |= UGEN_OPEN_IN;
+	  }
+	  else
+	  {
+		return ENXIO;
+	  }
+	}
+	return 0;
+}
+
+static void
+ugen_make_devnodes(struct ugen_softc *sc)
+{
+	struct usbd_pipe *pipe;
+	struct usbd_pipe *pipe_end;
+	struct ugen_endpoint *sce;
+	struct cdev *dev;
+	int endpoint;
+
+	mtx_lock(&sc->sc_mtx);
+
+	pipe = &sc->sc_udev->pipes[0];
+	pipe_end = &sc->sc_udev->pipes_end[0];
+
+	while(pipe < pipe_end)
+	{
+		if(pipe->edesc)
+		{
+			endpoint = pipe->edesc->bEndpointAddress & UE_ADDR;
+			sce = &sc->sc_endpoints[endpoint];
+
+			if(!sce->dev && (endpoint != 0))
+			{
+				mtx_unlock(&sc->sc_mtx); /* XXX "make_dev()" can sleep, 
+							  * XXX caller should have
+							  * XXX set a context bit !
+							  */
+
+				dev = make_dev(&ugen_cdevsw,
+					   UGENMINOR(device_get_unit(sc->sc_dev), endpoint),
+					   UID_ROOT, GID_OPERATOR, 0644, "%s.%d",
+					   device_get_nameunit(sc->sc_dev), endpoint);
+
+				mtx_lock(&sc->sc_mtx); /* XXX */
+
+				sce->dev = dev;
+
+				if(sce->dev)
+				{
+					DEV2SCE(sce->dev) = sce;
+					DEV2SC(sce->dev) = sc;
+				}
+
+			}
+
+			sce->in_timeout = USBD_NO_TIMEOUT;
+			sce->out_frame_size = -1; /* set maximum value */
+			sce->io_buffer_size = UGEN_BULK_BUFFER_SIZE; /* set default value */
+
+			if((pipe->edesc->bEndpointAddress & 
+			    (UE_DIR_IN|UE_DIR_OUT)) == UE_DIR_IN)
+			{
+				sce->pipe_in = pipe;
+			}
+			else
+			{
+				sce->pipe_out = pipe;
+			}
+		}
+		pipe++;
+	}
+	mtx_unlock(&sc->sc_mtx);
+	return;
+}
+
+static void
+ugen_destroy_devnodes(struct ugen_softc *sc, int skip_first)
+{
+	struct ugen_endpoint *sce = &sc->sc_endpoints[0];
+	struct ugen_endpoint *sce_end = &sc->sc_endpoints_end[0];
+
+	if(skip_first)
+	{
+		sce++; /* skip control endpoint */
+	}
+
+	while(sce < sce_end)
+	{
+		if(sce->dev)
+		{
+			ugenclose(sce->dev, 0, 0, 0);
+
+			DEV2SCE(sce->dev) = NULL;
+			DEV2SC(sce->dev) = NULL;
+
+			destroy_dev(sce->dev);
+		}
+
+		sce->pipe_in = NULL;
+		sce->pipe_out = NULL;
+		sce->dev = NULL;
+
+		sce++;
+	}
+	return;
+}
+
+static int
+ugenread(struct cdev *dev, struct uio *uio, int flag)
+{
+	struct ugen_softc *sc = DEV2SC(dev);
+	struct ugen_endpoint *sce = DEV2SCE(dev);
+	struct usbd_xfer *xfer;
+	void *ptr;
+	int error;
+	int n;
+	u_int16_t len;
+
+	PRINTFN(5, ("\n"));
+
+	if((sc == NULL) || (sce == NULL))
+	{
+		return (EIO);
+	}
+
+	/* check for control endpoint */
+	if(sce == &sc->sc_endpoints[0])
+	{
+		return (ENODEV);
+	}
+
+	mtx_lock(&sc->sc_mtx);
+
+	if(sce->state & (UGEN_CLOSING|UGEN_GONE|UGEN_RD_CFG|
+			 UGEN_RD_UIO|UGEN_RD_SLP))
+	{
+		error = EIO;
+		goto done;
+	}
+
+	error = ugen_open_pipe_read(sc,sce);
+	if(error)
+	{
+		goto done;
+	}
+
+	switch (sce->pipe_in->edesc->bmAttributes & UE_XFERTYPE) {
+	case UE_ISOCHRONOUS:
+		n = 1;
+		goto ue_interrupt;
+
+	case UE_INTERRUPT:
+		n = 2;
+
+	ue_interrupt:
+		while(uio->uio_resid)
+		{
+			if((uio->uio_resid < sce->in_queue.frame_size) && 
+			   (n == 0))
+			{
+				/* try to keep data synchronization */
+				break;
+			}
+
+			/* get one frame from input queue */
+
+			ugen_get_output_block(&sce->in_queue, &ptr, &len);
+
+			if(ptr == NULL)
+			{
+			    if(n == 0)
+			    {
+			        /* let application process data */
+			        break;
+			    }
+			    if(flag & IO_NDELAY)
+			    {
+			        if(n)
+				{
+				    error = EWOULDBLOCK;
+				}
+				break;
+			    }
+
+			    /* wait for data */
+
+			    sce->state |= (UGEN_RD_SLP|UGEN_RD_WUP);
+
+			    error = msleep(sce, &sc->sc_mtx, (PZERO|PCATCH),
+					   "ugen wait callback", 0);
+
+			    sce->state &= ~(UGEN_RD_SLP|UGEN_RD_WUP);
+
+			    if(sce->state & UGEN_CLOSING)
+			    {
+			        wakeup(sce);
+                                error = EIO;
+				break;
+			    }
+			    if(error)
+			    {
+			        break;
+			    }
+			    continue;
+			}
+
+			if(len > uio->uio_resid)
+			{
+			    PRINTFN(5, ("dumping %d bytes!\n", 
+					len - (u_int16_t)(uio->uio_resid)));
+
+			    /* rest of this frame will get dumped
+			     * for sake of synchronization!
+			     */
+			    len = uio->uio_resid;
+			}
+
+			PRINTFN(10, ("transferring %d bytes\n", len));
+
+			/* copy data to user memory */
+			error = __uiomove(sc, sce, UGEN_RD_UIO, ptr, len, uio);
+
+			if(error) break;
+
+			ugen_inc_output_index(&sce->in_queue);
+
+			/* only transfer one interrupt frame per read ! */
+
+			if(n == 2) 
+			{
+				/* start interrupt transfer again */
+				usbd_transfer_start(sce->xfer_in[0]);
+				break;
+			}
+
+			n = 0;
+		}
+		break;
+
+	case UE_BULK:
+		while((n = min(UGEN_BULK_BUFFER_SIZE, uio->uio_resid)) != 0)
+		{
+#if 0
+			if(flag & IO_NDELAY)
+			{
+				error = EWOULDBLOCK;
+				break;
+			}
+#endif
+			xfer = sce->xfer_in[0];
+
+			/* update length */
+			xfer->length = n;
+
+			sce->state |= UGEN_RD_UIO;
+
+			/* start transfer */
+			usbd_transfer_start(xfer);
+
+			sce->state &= ~UGEN_RD_UIO;
+
+			if(sce->state & UGEN_CLOSING)
+			{
+				error = EIO;
+				wakeup(sce);
+				break;
+			}
+
+			if(xfer->error)
+			{
+				error = (xfer->error == USBD_CANCELLED) ? 
+				  EINTR : EIO;
+				break;
+			}
+
+			PRINTFN(1, ("got %d of %d bytes\n", xfer->actlen, n));
+			error = __uiomove
+			  (sc, sce, UGEN_RD_UIO, 
+			   xfer->buffer, xfer->actlen, uio);
+
+			if(error || (xfer->actlen < n))
+			{
+				break;
+			}
+		}
+		break;
+
+	default:
+		error = ENXIO;
+		break;
+	}
+
+ done:
+	mtx_unlock(&sc->sc_mtx);
+	return (error);
+}
+
+static int
+ugenwrite(struct cdev *dev, struct uio *uio, int flag)
+{
+	struct ugen_softc *sc = DEV2SC(dev);
+	struct ugen_endpoint *sce = DEV2SCE(dev);
+	struct usbd_xfer *xfer;
+	u_int16_t *plen;
+	void *ptr;
+	int error;
+	int n;
+
+	PRINTFN(5, ("\n"));
+
+	if((sc == NULL) || (sce == NULL))
+	{
+		return (EIO);
+	}
+
+	/* check for control endpoint */
+	if(sce == &sc->sc_endpoints[0])
+	{
+		return (ENODEV);
+	}
+
+	mtx_lock(&sc->sc_mtx);
+
+	if(sce->state & (UGEN_CLOSING|UGEN_GONE|UGEN_WR_CFG|
+			 UGEN_WR_SLP|UGEN_WR_UIO))
+	{
+		error = EIO;
+		goto done;
+	}
+
+	error = ugen_open_pipe_write(sc,sce);
+	if(error)
+	{
+		goto done;
+	}
+
+	switch (sce->pipe_out->edesc->bmAttributes & UE_XFERTYPE) {
+	case UE_BULK:
+	case UE_INTERRUPT:
+		while((n = min(UGEN_BULK_BUFFER_SIZE, uio->uio_resid)) != 0)
+		{
+#if 0
+			if(flag & IO_NDELAY)
+			{
+				error = EWOULDBLOCK;
+				break;
+			}
+#endif
+			xfer = sce->xfer_out[0];
+
+			error = __uiomove
+			  (sc, sce, UGEN_WR_UIO, xfer->buffer, n, uio);
+			if(error)
+			{
+				break;
+			}
+
+			PRINTFN(1, ("transferred %d bytes\n", n));
+
+			/* update length */
+			xfer->length = n;
+
+			sce->state |= UGEN_WR_UIO;
+
+			/* start transfer */
+			usbd_transfer_start(xfer);
+
+			sce->state &= ~UGEN_WR_UIO;
+
+			if(sce->state & UGEN_CLOSING)
+			{
+				error = EIO;
+				wakeup(sce);
+				break;
+			}
+
+			if(xfer->error)
+			{
+				error = (xfer->error == USBD_CANCELLED) ? 
+				  EINTR : EIO;
+				break;
+			}
+		}
+		break;
+
+	case UE_ISOCHRONOUS:
+
+		n = 1;
+
+		while(uio->uio_resid || n)
+		{
+			ugen_get_input_block(&sce->out_queue, &ptr, &plen);
+
+			if(ptr == NULL)
+			{
+				/* make sure that the transfers are 
+				 * started, if not already started.
+				 */
+				usbd_transfer_start(sce->xfer_out[0]);
+				usbd_transfer_start(sce->xfer_out[1]);
+
+				if(flag & IO_NDELAY)
+				{
+					if(n)
+					{
+						error = EWOULDBLOCK;
+					}
+					break;
+				}
+
+				sce->state |= (UGEN_WR_SLP|UGEN_WR_WUP);
+
+				error = msleep(sce, &sc->sc_mtx, (PZERO|PCATCH),
+					       "ugen wait callback", 0);
+
+				sce->state &= ~(UGEN_WR_SLP|UGEN_WR_WUP);
+
+				if(sce->state & UGEN_CLOSING)
+				{
+					wakeup(sce);
+					error = EIO;
+					break;
+				}
+				if(error)
+				{
+					break;
+				}
+				continue;
+			}
+
+			if(*plen > sce->out_frame_size)
+			{
+				*plen = sce->out_frame_size;
+			}
+
+			if(*plen > uio->uio_resid)
+			{
+				*plen = uio->uio_resid;
+			}
+
+			error = __uiomove(sc, sce, UGEN_WR_UIO, ptr, *plen, uio);
+
+			if(error) break;
+
+			ugen_inc_input_index(&sce->out_queue);
+
+			n = 0;
+		}
+		if(n == 0)
+		{
+			/* make sure that the transfers are 
+			 * started, if not already started.
+			 */
+			usbd_transfer_start(sce->xfer_out[0]);
+			usbd_transfer_start(sce->xfer_out[1]);
+		}
+		break;
+
+	default:
+		error = ENXIO;
+		break;
+	}
+
+ done:
+	mtx_unlock(&sc->sc_mtx);
+	return (error);
+}
+
+static void
+ugen_interrupt_callback(struct usbd_xfer *xfer)
+{
+	struct ugen_endpoint *sce = xfer->priv_sc;
+	u_int16_t *plen;
+	void *ptr;
+
+	USBD_CHECK_STATUS(xfer);
+
+ tr_transferred:
+
+	PRINTFN(5, ("xfer=%p actlen=%d\n",
+		     xfer, xfer->actlen));
+
+	ugen_get_input_block(&sce->in_queue, &ptr, &plen);
+
+	if(ptr == NULL)
+	{
+		PRINTFN(5, ("dropping one packet, sce=%p\n", sce));
+	}
+	else
+	{
+		bcopy(xfer->buffer, ptr, xfer->actlen);
+
+		if(xfer->actlen > *plen)
+		{
+			xfer->actlen = *plen;
+		}
+
+		*plen = xfer->actlen;
+
+		ugen_inc_input_index(&sce->in_queue);
+	}
+
+	if(sce->state & UGEN_RD_WUP)
+	{
+		sce->state &= ~UGEN_RD_WUP;
+
+		PRINTFN(5, ("waking %p\n", sce));
+		wakeup(sce);
+	}
+	selwakeuppri(&sce->selinfo, PZERO);
+
+	/* the transfer will be restarted after that
+	 * the packet has been read
+	 */
+	return; 
+
+ tr_setup:
+ tr_error:
+	usbd_start_hardware(xfer);
+	return;
+}
+
+static void
+ugenisoc_read_callback(struct usbd_xfer *xfer)
+{
+	struct ugen_endpoint *sce = xfer->priv_sc;
+	u_int16_t *plen1;
+	u_int16_t *plen2;
+
+	void *ptr1;
+	void *ptr2;
+
+	u_int16_t isize;
+	u_int16_t n;
+
+	USBD_CHECK_STATUS(xfer);
+
+ tr_transferred:
+
+	PRINTFN(5,("actlen=%d\n", xfer->actlen));
+
+	plen1 = xfer->frlengths;
+	ptr1 = xfer->buffer;
+
+	isize = UGETW(sce->pipe_in->edesc->wMaxPacketSize);
+	n = sce->in_frames;
+	while(n--)
+	{
+		if(*plen1 != 0)
+		{
+			ugen_get_input_block(&sce->in_queue, &ptr2, &plen2);
+
+			if(ptr2 == NULL)
+			{
+				break;
+			}
+
+			if(*plen1 > *plen2)
+			{
+				*plen1 = *plen2;
+			}
+
+			bcopy(ptr1, ptr2, *plen1);
+
+			*plen2 = *plen1;
+
+			ugen_inc_input_index(&sce->in_queue);
+		}
+
+		ptr1 = ADD_BYTES(ptr1, isize);
+		plen1++;
+	}
+
+	if(sce->state & UGEN_RD_WUP)
+	{
+		sce->state &= ~UGEN_RD_WUP;
+		wakeup(sce);
+	}
+	selwakeuppri(&sce->selinfo, PZERO);
+
+ tr_setup:
+ tr_error:
+	isize = UGETW(sce->pipe_in->edesc->wMaxPacketSize);
+	for(n = 0; n < sce->in_frames; n++)
+	{
+		/* setup size for next transfer */
+		xfer->frlengths[n] = isize;
+	}
+	usbd_start_hardware(xfer);
+	return;
+}
+
+static void
+ugenisoc_write_callback(struct usbd_xfer *xfer)
+{
+	struct ugen_endpoint *sce = xfer->priv_sc;
+	u_int16_t *plen1;
+	u_int16_t len2;
+
+	void *ptr1;
+	void *ptr2;
+
+	u_int16_t isize;
+	u_int16_t n;
+
+	USBD_CHECK_STATUS(xfer);
+
+ tr_transferred:
+ tr_setup:
+
+	plen1 = xfer->frlengths;
+	ptr1 = xfer->buffer;
+
+	isize = UGETW(sce->pipe_out->edesc->wMaxPacketSize);
+	n = sce->out_frames;
+	while(n--)
+	{
+		ugen_get_output_block(&sce->out_queue, &ptr2, &len2);
+
+		if(ptr2 == NULL)
+		{
+		    break;
+		}
+
+		if(len2 > isize)
+		{
+		    len2 = isize;
+		}
+
+		bcopy(ptr2, ptr1, len2);
+
+		*plen1 = len2;
+
+		ugen_inc_output_index(&sce->out_queue);
+
+		ptr1 = ADD_BYTES(ptr1, len2);
+		plen1++;
+	}
+
+	n = plen1 - xfer->frlengths;
+
+	/* update number of frames */
+	xfer->nframes = n;
+
+	if(sce->state & UGEN_WR_WUP)
+	{
+		sce->state &= ~UGEN_WR_WUP;
+		wakeup(sce);
+	}
+	selwakeuppri(&sce->selinfo, PZERO);
+
+	if(n)
+	{
+ tr_error:
+		usbd_start_hardware(xfer);
+	}
+	return;
+}
+
+static int
+ugen_set_config(struct ugen_softc *sc, int configno)
+{
+	PRINTFN(1,("configno %d, sc=%p\n", configno, sc));
+
+	/* destroy all but control device */
+	ugen_destroy_devnodes(sc, 1);
+
+	/* avoid setting the current value */
+	if((usbd_get_config_descriptor(sc->sc_udev) == NULL) ||
+	   (usbd_get_config_descriptor(sc->sc_udev)->bConfigurationValue != configno))
+	{
+		if(usbd_set_config_no(sc->sc_udev, configno, 1))
+		{
+			return EIO;
+		}
+	}
+
+	/* make devices */
+	ugen_make_devnodes(sc);
+	return 0;
+}
+
+static int
+ugen_set_interface(struct ugen_softc *sc, int ifaceidx, int altno)
+{
+	PRINTFN(15, ("%d %d\n", ifaceidx, altno));
+
+	/* destroy all but control device */
+	ugen_destroy_devnodes(sc, 1);
+
+	/* change setting */
+	if(usbreq_set_interface(sc->sc_udev, ifaceidx, altno))
+	{
+		return EIO;
+	}
+
+	/* make the new devices */
+	ugen_make_devnodes(sc);
+	return (0);
+}
+
+/* retrieve a complete descriptor for a certain device and index */
+static usb_config_descriptor_t *
+ugen_get_cdesc(struct usbd_device *udev, int index, int *lenp)
+{
+	usb_config_descriptor_t *cdesc, *tdesc, cdescr;
+	int len;
+
+	if(index == USB_CURRENT_CONFIG_INDEX)
+	{
+		tdesc = usbd_get_config_descriptor(udev);
+		len = UGETW(tdesc->wTotalLength);
+		if(lenp)
+		{
+			*lenp = len;
+		}
+		cdesc = malloc(len, M_TEMP, M_WAITOK);
+		if(cdesc == NULL)
+		{
+			return 0;
+		}
+		memcpy(cdesc, tdesc, len);
+		PRINTFN(5,("current, len=%d\n", len));
+	}
+	else
+	{
+		if(usbreq_get_config_desc(udev, index, &cdescr))
+		{
+			return (0);
+		}
+		len = UGETW(cdescr.wTotalLength);
+		PRINTFN(5,("index=%d, len=%d\n", index, len));
+		if(lenp)
+		{
+			*lenp = len;
+		}
+		cdesc = malloc(len, M_TEMP, M_WAITOK);
+		if(cdesc == NULL)
+		{
+			return 0;
+		}
+		if(usbreq_get_config_desc_full(udev, index, cdesc, len))
+		{
+			free(cdesc, M_TEMP);
+			return (0);
+		}
+	}
+	return (cdesc);
+}
+
+static int
+ugen_get_alt_index(struct usbd_device *udev, int ifaceidx)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev, ifaceidx);
+
+	return (iface) ? (iface->alt_index) : -1;
+}
+
+static int
+ugenioctl(struct cdev *dev, u_long cmd, caddr_t addr, int flag, struct thread *p)
+{
+	struct ugen_softc *sc = DEV2SC(dev);
+	struct ugen_endpoint *sce = DEV2SCE(dev);
+	struct usbd_interface *iface;
+	usb_interface_descriptor_t *idesc;
+	usb_endpoint_descriptor_t *edesc;
+	void *data = 0;
+	int error = 0;
+	int len;
+	u_int8_t conf;
+	u_int8_t alt;
+
+	PRINTFN(5, ("cmd=%08lx\n", cmd));
+	if((sc == NULL) || (sce == NULL))
+	{
+		return (EIO);
+	}
+
+	mtx_lock(&sc->sc_mtx);
+
+	if(sce->state & (UGEN_CLOSING|UGEN_GONE|UGEN_IOCTL))
+	{
+		error = EIO;
+		goto done;
+	}
+
+	switch (cmd) {
+	case FIONBIO:
+		/* all handled in the upper FS layer */
+		goto done;
+
+	case USB_SET_SHORT_XFER:
+		/* this flag only affects read */
+		/* check for control endpoint */
+		if(sce == &sc->sc_endpoints[0])
+		{
+			error = EINVAL;
+			goto done;
+		}
+		if(sce->pipe_in == NULL)
+		{
+#ifdef USB_DEBUG
+			printf("%s: USB_SET_SHORT_XFER, no pipe\n",
+			       __FUNCTION__);
+#endif
+			error = EIO;
+			goto done;
+		}
+
+		if(*(int *)addr)
+			sce->state |= UGEN_SHORT_OK;
+		else
+			sce->state &= ~UGEN_SHORT_OK;
+		goto done;
+
+	case USB_SET_TIMEOUT:
+		sce->in_timeout = *(int *)addr;
+		goto done;
+
+	case USB_GET_FRAME_SIZE:
+		if(sce->pipe_in)
+		{
+			*(int *)addr = UGETW(sce->pipe_in->edesc->wMaxPacketSize);
+		}
+		else
+		{
+			error = EINVAL;
+		}
+		goto done;
+
+	case USB_SET_FRAME_SIZE:
+		if(!(flag & FWRITE))
+		{
+			error = EPERM;
+			goto done;
+		}
+		if((*((int *)addr) <= 0) ||
+		   (*((int *)addr) >= 65536))
+		{
+			error = EINVAL;
+			goto done;
+		}
+		sce->out_frame_size = *(int *)addr;
+		goto done;
+
+	case USB_SET_BUFFER_SIZE:
+		if(*(int *)addr < 1024)
+		  sce->io_buffer_size = 1024;
+		else if(*(int *)addr < (256*1024))
+		  sce->io_buffer_size = *(int *)addr;
+		else
+		  sce->io_buffer_size = 256*1024;
+		break;
+
+	case USB_GET_BUFFER_SIZE:
+		*(int *)addr = sce->io_buffer_size;
+		break;
+
+	default:
+		break;
+	}
+
+	/* the following ioctls will sleep
+	 * and are only allowed on the
+	 * control endpoint
+	 */
+	if(sce != &sc->sc_endpoints[0])
+	{
+		error = EINVAL;
+		goto done;
+	}
+
+	sce->state |= UGEN_IOCTL;
+
+	mtx_unlock(&sc->sc_mtx);
+
+	switch (cmd) {
+#ifdef USB_DEBUG
+	case USB_SETDEBUG:
+		if(!(flag & FWRITE))
+		{
+			error = EPERM;
+			break;
+		}
+		usbdebug = *(int *)addr;
+		break;
+#endif
+	case USB_GET_CONFIG:
+		error = usbreq_get_config(sc->sc_udev, &conf);
+		if(error)
+		{
+			error = EIO;
+			break;
+		}
+		*(int *)addr = conf;
+		break;
+	case USB_SET_CONFIG:
+		if(!(flag & FWRITE))
+		{
+			error = EPERM;
+			break;
+		}
+		error = ugen_set_config(sc, *(int *)addr);
+		if(error)
+		{
+			break;
+		}
+		break;
+	case USB_GET_ALTINTERFACE:
+#define ai ((struct usb_alt_interface *)addr)
+		iface = usbd_get_iface(sc->sc_udev, ai->uai_interface_index);
+
+		if(!iface ||
+		   !iface->idesc)
+		{
+			error = EINVAL;
+			break;
+		}
+
+		ai->uai_alt_no = iface->idesc->bAlternateSetting;
+		break;
+	case USB_SET_ALTINTERFACE:
+		if(!(flag & FWRITE))
+		{
+			error = EPERM;
+			break;
+		}
+		error = ugen_set_interface(sc, ai->uai_interface_index, ai->uai_alt_no);
+		if(error)
+		{
+			break;
+		}
+		break;
+	case USB_GET_NO_ALT:
+		data = ugen_get_cdesc(sc->sc_udev, ai->uai_config_index, 0);
+		if(data == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		idesc = usbd_find_idesc(data, ai->uai_interface_index, 0);
+		if(idesc == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		ai->uai_alt_no = usbd_get_no_alts(data, idesc->bInterfaceNumber);
+#undef ai
+		break;
+	case USB_GET_DEVICE_DESC:
+		if(!usbd_get_device_descriptor(sc->sc_udev))
+		{
+			error = EIO;
+			break;
+		}
+
+		*(usb_device_descriptor_t *)addr =
+			*usbd_get_device_descriptor(sc->sc_udev);
+		break;
+	case USB_GET_CONFIG_DESC:
+#define cd ((struct usb_config_desc *)addr)
+		data = ugen_get_cdesc(sc->sc_udev, cd->ucd_config_index, 0);
+		if(data == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		cd->ucd_desc = *(usb_config_descriptor_t *)data;
+#undef cd
+		break;
+	case USB_GET_INTERFACE_DESC:
+#define id  ((struct usb_interface_desc *)addr)
+		data = ugen_get_cdesc(sc->sc_udev, id->uid_config_index, 0);
+		if(data == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		if((id->uid_config_index == USB_CURRENT_CONFIG_INDEX) &&
+		   (id->uid_alt_index == USB_CURRENT_ALT_INDEX))
+			alt = ugen_get_alt_index(sc->sc_udev, id->uid_interface_index);
+		else
+			alt = id->uid_alt_index;
+		idesc = usbd_find_idesc(data, id->uid_interface_index, alt);
+		if(idesc == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		id->uid_desc = *idesc;
+#undef id
+		break;
+	case USB_GET_ENDPOINT_DESC:
+#define ed ((struct usb_endpoint_desc *)addr)
+		data = ugen_get_cdesc(sc->sc_udev, ed->ued_config_index, 0);
+		if(data == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		if((ed->ued_config_index == USB_CURRENT_CONFIG_INDEX) &&
+		   (ed->ued_alt_index == USB_CURRENT_ALT_INDEX))
+			alt = ugen_get_alt_index(sc->sc_udev, ed->ued_interface_index);
+		else
+			alt = ed->ued_alt_index;
+		edesc = usbd_find_edesc(data, ed->ued_interface_index,
+					alt, ed->ued_endpoint_index);
+		if(edesc == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		ed->ued_desc = *edesc;
+#undef ed
+		break;
+	case USB_GET_FULL_DESC:
+#define fd ((struct usb_full_desc *)addr)
+		data = ugen_get_cdesc(sc->sc_udev, fd->ufd_config_index, &len);
+		if(data == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		if(len > fd->ufd_size)
+		{
+			len = fd->ufd_size;
+		}
+		if(fd->ufd_data == NULL)
+		{
+			error = EINVAL;
+			break;
+		}
+		error = copyout(data, fd->ufd_data, len);
+#undef fd
+		break;
+	case USB_GET_STRING_DESC:
+#define si ((struct usb_string_desc *)addr)
+		if(usbreq_get_string_desc
+		   (sc->sc_udev, si->usd_string_index,
+		    si->usd_language_id, &si->usd_desc, &len))
+		{
+			error = EINVAL;
+			break;
+		}
+#undef si
+		break;
+	case USB_DO_REQUEST:
+#define ur ((struct usb_ctl_request *)addr)
+		if(!(flag & FWRITE))
+		{
+			error = EPERM;
+			break;
+		}
+		/* avoid requests that would damage the bus integrity */
+		if(((ur->ucr_request.bmRequestType == UT_WRITE_DEVICE) &&
+		    (ur->ucr_request.bRequest == UR_SET_ADDRESS)) ||
+		   ((ur->ucr_request.bmRequestType == UT_WRITE_DEVICE) &&
+		    (ur->ucr_request.bRequest == UR_SET_CONFIG)) ||
+		   ((ur->ucr_request.bmRequestType == UT_WRITE_INTERFACE) &&
+		    (ur->ucr_request.bRequest == UR_SET_INTERFACE)))
+		{
+			error = EINVAL;
+			break;
+		}
+
+		len = UGETW(ur->ucr_request.wLength);
+
+		if((len < 0) || (len > 32767))
+		{
+			error = EINVAL;
+			break;
+		}
+
+		if(len != 0)
+		{
+			if(ur->ucr_data == NULL)
+			{
+				error = EINVAL;
+				break;
+			}
+
+			data = malloc(len, M_TEMP, M_WAITOK);
+			if(data == NULL)
+			{
+				error = ENOMEM;
+				break;
+			}
+			if(!(ur->ucr_request.bmRequestType & UT_READ))
+			{
+				error = copyin(ur->ucr_data, data, len);
+				if(error)
+				{
+					break;
+				}
+			}
+		}
+
+		if(usbd_do_request_flags
+		   (sc->sc_udev, &ur->ucr_request, data,
+		    ur->ucr_flags, &ur->ucr_actlen, USBD_DEFAULT_TIMEOUT))
+		{
+			error = EIO;
+			break;
+		}
+
+		if((len != 0) && (ur->ucr_request.bmRequestType & UT_READ))
+		{
+			error = copyout(data, ur->ucr_data, len);
+			if(error)
+			{
+				break;
+			}
+		}
+#undef ur
+		break;
+
+	case USB_GET_DEVICEINFO:
+		usbd_fill_deviceinfo(sc->sc_udev,
+		    (struct usb_device_info *)addr, 1);
+		break;
+	default:
+		error = EINVAL;
+		break;
+	}
+
+	if(data)
+	{
+		free(data, M_TEMP);
+	}
+
+	mtx_lock(&sc->sc_mtx);
+
+	sce->state &= ~UGEN_IOCTL;
+
+	if(sce->state & UGEN_CLOSING)
+	{
+		wakeup(sce);
+		error = EIO;
+	}
+
+ done:
+	mtx_unlock(&sc->sc_mtx);
+	return (error);
+}
+
+static int
+ugenpoll(struct cdev *dev, int events, struct thread *p)
+{
+	struct ugen_softc *sc = DEV2SC(dev);
+	struct ugen_endpoint *sce = DEV2SCE(dev);
+	int revents = 0;
+
+	PRINTFN(5, ("\n"));
+
+	if((sc == NULL) || (sce == NULL))
+	{
+		return POLLNVAL;
+	}
+
+	if(sce == &sc->sc_endpoints[0])
+	{
+		/* not control endpoint */
+		return 0;
+	}
+
+	mtx_lock(&sc->sc_mtx);
+
+	if(sce->state & (UGEN_CLOSING|UGEN_GONE))
+	{
+		goto done;
+	}
+
+	if(sce->pipe_out && (events & (POLLOUT | POLLWRNORM)) &&
+	   (!(sce->state & (UGEN_WR_CFG|UGEN_WR_SLP|UGEN_WR_UIO))))
+	{
+	    if(ugen_open_pipe_write(sc,sce))
+	    {
+		/* must return, hence the error
+		 * might indicate that the device
+		 * is about to be detached
+		 */
+		revents = POLLNVAL;
+		goto done;
+	    }
+
+	    switch (sce->pipe_out->edesc->bmAttributes & UE_XFERTYPE) {
+	    case UE_ISOCHRONOUS:
+		if(ugen_half_empty(&sce->out_queue))
+		{
+		    revents |= events & (POLLOUT | POLLWRNORM);
+		}
+		else
+		{
+		    selrecord(p, &sce->selinfo);
+		}
+		break;
+
+	    case UE_BULK:
+	    case UE_INTERRUPT:
+		/* pretend that one can write data, hence
+		 * no buffering is done:
+		 */
+		revents |= events & (POLLOUT | POLLWRNORM);
+		break;
+	    }
+	}
+
+	if(sce->pipe_in && (events & (POLLIN | POLLRDNORM)) &&
+	   (!(sce->state & (UGEN_RD_CFG|UGEN_RD_SLP|UGEN_RD_UIO))))
+	{
+	    /* check that pipes are open, so that
+	     * selwakeup is called
+	     */
+	    if(ugen_open_pipe_read(sc,sce))
+	    {
+		/* must return, hence the error
+		 * might indicate that the device
+		 * is about to be detached
+		 */
+		revents = POLLNVAL;
+		goto done;
+	    }
+
+	    switch (sce->pipe_in->edesc->bmAttributes & UE_XFERTYPE) {
+	    case UE_INTERRUPT:
+	    case UE_ISOCHRONOUS:
+	        if(ugen_not_empty(&sce->in_queue))
+		{
+		    revents |= events & (POLLIN | POLLRDNORM);
+		}
+		else
+		{
+		    selrecord(p, &sce->selinfo);
+		}
+		break;
+
+	    case UE_BULK:
+		/* pretend that one can read data,
+		 * hence no buffering is done:
+		 */
+		revents |= events & (POLLIN | POLLRDNORM);
+		break;
+	    }
+	}
+ done:
+	mtx_unlock(&sc->sc_mtx);
+	return (revents);
+}
+
+cdevsw_t ugen_cdevsw = {
+#ifdef D_VERSION
+	.d_version =	D_VERSION,
+#endif
+	.d_open =	ugenopen,
+	.d_close =	ugenclose,
+	.d_read =	ugenread,
+	.d_write =	ugenwrite,
+	.d_ioctl =	ugenioctl,
+	.d_poll =	ugenpoll,
+	.d_name =	"ugen",
+};
+
+static devclass_t ugen_devclass;
+
+static driver_t ugen_driver =
+{
+        .name    = "ugen",
+        .methods = (device_method_t [])
+        {
+          DEVMETHOD(device_probe, ugen_probe),
+          DEVMETHOD(device_attach, ugen_attach),
+          DEVMETHOD(device_detach, ugen_detach),
+          { 0, 0 }
+        },
+        .size    = sizeof(struct ugen_softc),
+};
+
+DRIVER_MODULE(ugen, uhub, ugen_driver, ugen_devclass, usbd_driver_load, 0);
+MODULE_DEPEND(ugen, usb, 1, 1, 1);
diff -rubN /usr/src1/src/sys/dev/usb2/_uhci.c /usr/src/sys/dev/usb2/_uhci.c
--- /usr/src1/src/sys/dev/usb2/_uhci.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_uhci.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,2950 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * USB Universal Host Controller driver.
+ * Handles e.g. PIIX3 and PIIX4.
+ *
+ * UHCI spec: http://developer.intel.com/design/USB/UHCI11D.htm
+ * USB spec: http://www.usb.org/developers/docs/usbspec.zip
+ * PIIXn spec: ftp://download.intel.com/design/intarch/datashts/29055002.pdf
+ *             ftp://download.intel.com/design/intarch/datashts/29056201.pdf
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/endian.h>
+#include <sys/queue.h> /* LIST_XXX() */
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h> /* bus_space_xxx() */
+
+#define INCLUDE_PCIXXX_H
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/uhci.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb/uhci.c $");
+
+#define MS_TO_TICKS(ms) (((ms) * hz) / 1000)
+#define UHCI_BUS2SC(bus) ((uhci_softc_t *)(((u_int8_t *)(bus)) - \
+   POINTER_TO_UNSIGNED(&(((uhci_softc_t *)0)->sc_bus))))
+
+#ifdef USB_DEBUG
+#undef DPRINTF
+#undef DPRINTFN
+#define DPRINTF(x)	{ if (uhcidebug) { printf("%s: ", __FUNCTION__); printf x ; } }
+#define DPRINTFN(n,x)	{ if (uhcidebug > (n)) { printf("%s: ", __FUNCTION__); printf x ; } }
+int uhcidebug = 0;
+int uhcinoloop = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, uhci, CTLFLAG_RW, 0, "USB uhci");
+SYSCTL_INT(_hw_usb_uhci, OID_AUTO, debug, CTLFLAG_RW,
+	   &uhcidebug, 0, "uhci debug level");
+SYSCTL_INT(_hw_usb_uhci, OID_AUTO, loop, CTLFLAG_RW,
+	   &uhcinoloop, 0, "uhci noloop");
+static void
+uhci_dumpregs(uhci_softc_t *sc);
+static void
+uhci_dump_tds(uhci_td_t *td);
+#endif
+
+/* NOTE: ``(sc)->ios'' is not setup */
+#define UBARR(sc) bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->ios, \
+			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
+#define UWRITE1(sc, r, x) \
+ do { UBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); \
+ } while (/*CONSTCOND*/0)
+#define UWRITE2(sc, r, x) \
+ do { UBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); \
+ } while (/*CONSTCOND*/0)
+#define UWRITE4(sc, r, x) \
+ do { UBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); \
+ } while (/*CONSTCOND*/0)
+#define UREAD1(sc, r) (UBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
+#define UREAD2(sc, r) (UBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
+#define UREAD4(sc, r) (UBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))
+
+#define UHCICMD(sc, cmd) UWRITE2(sc, UHCI_CMD, cmd)
+#define UHCISTS(sc) UREAD2(sc, UHCI_STS)
+
+#define UHCI_RESET_TIMEOUT 100	/* ms, reset timeout */
+
+#define UHCI_INTR_ENDPT 1
+
+extern struct usbd_bus_methods uhci_bus_methods;
+extern struct usbd_pipe_methods uhci_device_bulk_methods;
+extern struct usbd_pipe_methods uhci_device_ctrl_methods;
+extern struct usbd_pipe_methods uhci_device_intr_methods;
+extern struct usbd_pipe_methods uhci_device_isoc_methods;
+extern struct usbd_pipe_methods uhci_root_ctrl_methods;
+extern struct usbd_pipe_methods uhci_root_intr_methods;
+
+void
+uhci_reset(uhci_softc_t *sc)
+{
+	u_int n;
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	DPRINTF(("resetting the HC\n"));
+
+	/* disable interrupts */
+
+	UWRITE2(sc, UHCI_INTR, 0);
+
+	/* global reset */
+
+	UHCICMD(sc, UHCI_CMD_GRESET);
+
+	/* wait */
+
+	DELAY(1000*USB_BUS_RESET_DELAY);
+
+	/* terminate all transfers */
+
+	UHCICMD(sc, UHCI_CMD_HCRESET);
+
+	/* the reset bit goes low when the controller is done */
+
+	n = UHCI_RESET_TIMEOUT;
+	while(n--)
+	{
+		/* wait one millisecond */
+
+		DELAY(1000);
+
+		if(!(UREAD2(sc, UHCI_CMD) & UHCI_CMD_HCRESET))
+		{
+			goto done_1;
+		}
+	}
+
+	device_printf(sc->sc_bus.bdev,
+		      "controller did not reset\n");
+
+ done_1:
+
+	n = 10;
+	while(n--)
+	{
+		/* wait one millisecond */
+
+		DELAY(1000);
+
+		/* check if HC is stopped */
+		if(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH)
+		{
+			goto done_2;
+		}
+	}
+
+	device_printf(sc->sc_bus.bdev,
+		      "controller did not stop\n");
+
+ done_2:
+
+	/* reload the configuration */
+
+	UWRITE4(sc, UHCI_FLBASEADDR, sc->sc_physaddr);
+	UWRITE2(sc, UHCI_FRNUM, sc->sc_saved_frnum);
+	UWRITE1(sc, UHCI_SOF, sc->sc_saved_sof);
+	return;
+}
+
+static void
+uhci_start(uhci_softc_t *sc)
+{
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	DPRINTFN(1,("enabling\n"));
+
+	/* enable interrupts */
+
+	UWRITE2(sc, UHCI_INTR, 
+		(UHCI_INTR_TOCRCIE|
+		 UHCI_INTR_RIE|
+		 UHCI_INTR_IOCE|
+		 UHCI_INTR_SPIE));
+
+	/* assume 64 byte packets at frame end and
+	 * start HC controller
+	 */
+
+	UHCICMD(sc, (UHCI_CMD_MAXP|UHCI_CMD_RS));
+
+	u_int8_t n = 10;
+	while(n--)
+	{
+		/* wait one millisecond */
+
+		DELAY(1000);
+
+		/* check that controller has started */
+
+		if(!(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH))
+		{
+			goto done;
+		}
+	}
+
+	device_printf(sc->sc_bus.bdev,
+		      "cannot start HC controller\n");
+
+ done:
+	return;
+}
+
+#define PHYSADDR(sc,what) \
+  ((sc)->sc_physaddr + POINTER_TO_UNSIGNED(&(((struct uhci_softc *)0)->what)))
+
+usbd_status
+uhci_init(uhci_softc_t *sc)
+{
+	u_int16_t bit;
+	u_int16_t x;
+	u_int16_t y;
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	DPRINTF(("start\n"));
+
+#ifdef USB_DEBUG
+	if(uhcidebug > 2)
+	{
+		uhci_dumpregs(sc);
+	}
+#endif
+
+	sc->sc_saved_sof = 0x40; /* default value */
+	sc->sc_saved_frnum = 0; /* default frame number */
+
+	/*
+	 * setup self pointers
+	 */
+	sc->sc_hw.ls_ctl_start.qh_self = htole32(PHYSADDR(sc,sc_hw.ls_ctl_start)|UHCI_PTR_QH);
+	sc->sc_hw.hs_ctl_start.qh_self = htole32(PHYSADDR(sc,sc_hw.hs_ctl_start)|UHCI_PTR_QH);
+	sc->sc_hw.bulk_start.qh_self   = htole32(PHYSADDR(sc,sc_hw.bulk_start)|UHCI_PTR_QH);
+	sc->sc_hw.last_qh.qh_self      = htole32(PHYSADDR(sc,sc_hw.last_qh)|UHCI_PTR_QH);
+	sc->sc_hw.last_td.td_self      = htole32(PHYSADDR(sc,sc_hw.last_td)|UHCI_PTR_TD);
+
+	for(x = 0;
+	    x < UHCI_VFRAMELIST_COUNT;
+	    x++)
+	{
+		sc->sc_hw.isoc_start[x].td_self = htole32(PHYSADDR(sc,sc_hw.isoc_start[x])|UHCI_PTR_TD);
+		sc->sc_isoc_p_last[x] = &sc->sc_hw.isoc_start[x];
+	}
+
+	for(x = 0;
+	    x < UHCI_IFRAMELIST_COUNT;
+	    x++)
+	{
+		sc->sc_hw.intr_start[x].qh_self = htole32(PHYSADDR(sc,sc_hw.intr_start[x])|UHCI_PTR_QH);
+		sc->sc_intr_p_last[x] = &sc->sc_hw.intr_start[x];
+	}
+
+	/*
+	 * the QHs are arranged to give poll intervals that are
+	 * powers of 2 times 1ms
+	 */
+	bit = UHCI_IFRAMELIST_COUNT/2;
+	while(bit)
+	{
+		x = bit;
+		while(x & bit)
+		{
+			y = (x ^ bit)|(bit/2);
+			/* the next QH has half the
+			 * poll interval
+			 */
+			sc->sc_hw.intr_start[x].h_next = NULL;
+			sc->sc_hw.intr_start[x].qh_h_next = 
+			  sc->sc_hw.intr_start[y].qh_self;
+			sc->sc_hw.intr_start[x].e_next = NULL;
+			sc->sc_hw.intr_start[x].qh_e_next = htole32(UHCI_PTR_T);
+			x++;
+		}
+		bit >>= 1;
+	}
+
+	/* start QH for interrupt traffic */
+	sc->sc_hw.intr_start[0].h_next = &sc->sc_hw.ls_ctl_start;
+	sc->sc_hw.intr_start[0].qh_h_next = sc->sc_hw.ls_ctl_start.qh_self;
+	sc->sc_hw.intr_start[0].e_next = 0;
+	sc->sc_hw.intr_start[0].qh_e_next = htole32(UHCI_PTR_T);
+
+	for(x = 0;
+	    x < UHCI_VFRAMELIST_COUNT;
+	    x++)
+	{
+		/* start TD for isochronous traffic */
+		sc->sc_hw.isoc_start[x].next = NULL;
+		sc->sc_hw.isoc_start[x].td_next = 
+		  sc->sc_hw.intr_start[x|(UHCI_IFRAMELIST_COUNT/2)].qh_self;
+		sc->sc_hw.isoc_start[x].td_status = htole32(UHCI_TD_IOS);
+		sc->sc_hw.isoc_start[x].td_token = htole32(0);
+		sc->sc_hw.isoc_start[x].td_buffer = htole32(0);
+	}
+
+	/* start QH where low speed control traffic will be queued */
+	sc->sc_hw.ls_ctl_start.h_next = &sc->sc_hw.hs_ctl_start;
+	sc->sc_hw.ls_ctl_start.qh_h_next = sc->sc_hw.hs_ctl_start.qh_self;
+	sc->sc_hw.ls_ctl_start.e_next = 0;
+	sc->sc_hw.ls_ctl_start.qh_e_next = htole32(UHCI_PTR_T);
+
+	sc->sc_ls_ctl_p_last = &sc->sc_hw.ls_ctl_start;
+
+	/* start QH where high speed control traffic will be queued */
+	sc->sc_hw.hs_ctl_start.h_next = &sc->sc_hw.bulk_start;
+	sc->sc_hw.hs_ctl_start.qh_h_next = sc->sc_hw.bulk_start.qh_self;
+	sc->sc_hw.hs_ctl_start.e_next = 0;
+	sc->sc_hw.hs_ctl_start.qh_e_next = htole32(UHCI_PTR_T);
+
+	sc->sc_hs_ctl_p_last = &sc->sc_hw.hs_ctl_start;
+
+	/* start QH where bulk traffic will be queued */
+	sc->sc_hw.bulk_start.h_next = &sc->sc_hw.last_qh;
+	sc->sc_hw.bulk_start.qh_h_next = sc->sc_hw.last_qh.qh_self;
+	sc->sc_hw.bulk_start.e_next = 0;
+	sc->sc_hw.bulk_start.qh_e_next = htole32(UHCI_PTR_T);
+
+	sc->sc_bulk_p_last = &sc->sc_hw.bulk_start;
+
+	/* end QH which is used for looping the QHs */
+	sc->sc_hw.last_qh.h_next = 0;
+	sc->sc_hw.last_qh.qh_h_next = htole32(UHCI_PTR_T);	/* end of QH chain */
+	sc->sc_hw.last_qh.e_next = &sc->sc_hw.last_td;
+	sc->sc_hw.last_qh.qh_e_next = sc->sc_hw.last_td.td_self;
+
+	/* end TD which hangs from the last QH, 
+	 * to avoid a bug in the PIIX that 
+	 * makes it run berserk otherwise
+	 */
+	sc->sc_hw.last_td.next = 0;
+	sc->sc_hw.last_td.td_next = htole32(UHCI_PTR_T);
+	sc->sc_hw.last_td.td_status = htole32(0); /* inactive */
+	sc->sc_hw.last_td.td_token = htole32(0);
+	sc->sc_hw.last_td.td_buffer = htole32(0);
+
+	/* setup UHCI framelist */
+
+	for(x = 0;
+	    x < UHCI_FRAMELIST_COUNT;
+	    x++)
+	{
+		sc->sc_hw.pframes[x] = sc->sc_hw.isoc_start[x % UHCI_VFRAMELIST_COUNT].td_self;
+	}
+
+	LIST_INIT(&sc->sc_interrupt_list_head);
+
+	/* set up the bus struct */
+	sc->sc_bus.methods = &uhci_bus_methods;
+
+	/* reset the controller */
+	uhci_reset(sc); 
+
+	/* start the controller */
+	uhci_start(sc);
+
+	mtx_unlock(&sc->sc_bus.mtx);
+
+	return 0;
+}
+
+/* NOTE: suspend/resume is called from
+ * interrupt context and cannot sleep!
+ */
+
+void
+uhci_suspend(uhci_softc_t *sc)
+{
+	mtx_lock(&sc->sc_bus.mtx);
+
+#ifdef USB_DEBUG
+	if(uhcidebug > 2)
+	{
+		uhci_dumpregs(sc);
+	}
+#endif
+	/* save some state if BIOS doesn't */
+
+	sc->sc_saved_frnum = UREAD2(sc, UHCI_FRNUM);
+	sc->sc_saved_sof = UREAD1(sc, UHCI_SOF);
+
+	/* stop the controller */
+
+	uhci_reset(sc);
+
+	/* enter global suspend */
+
+	UHCICMD(sc, UHCI_CMD_EGSM);
+
+	DELAY(1000*USB_RESUME_WAIT);
+
+	mtx_unlock(&sc->sc_bus.mtx);
+	return;
+}
+
+void
+uhci_resume(uhci_softc_t *sc)
+{
+	mtx_lock(&sc->sc_bus.mtx);
+
+	/* reset the controller */
+
+	uhci_reset(sc);	
+
+	/* force global resume */
+
+	UHCICMD(sc, UHCI_CMD_FGR);
+
+	DELAY(1000*USB_RESUME_DELAY);
+
+	/* and start traffic again */
+
+	uhci_start(sc);
+
+#ifdef USB_DEBUG
+	if(uhcidebug > 2)
+	{
+		uhci_dumpregs(sc);
+	}
+#endif
+
+	mtx_unlock(&sc->sc_bus.mtx);
+	return;
+}
+
+#ifdef USB_DEBUG
+static void
+uhci_dumpregs(uhci_softc_t *sc)
+{
+	DPRINTFN(-1,("%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, "
+		     "flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\n",
+		     device_get_nameunit(sc->sc_bus.bdev),
+		     UREAD2(sc, UHCI_CMD),
+		     UREAD2(sc, UHCI_STS),
+		     UREAD2(sc, UHCI_INTR),
+		     UREAD2(sc, UHCI_FRNUM),
+		     UREAD4(sc, UHCI_FLBASEADDR),
+		     UREAD1(sc, UHCI_SOF),
+		     UREAD2(sc, UHCI_PORTSC1),
+		     UREAD2(sc, UHCI_PORTSC2)));
+	return;
+}
+
+static void
+uhci_dump_td(uhci_td_t *p)
+{
+	u_int32_t td_next = le32toh(p->td_next);
+	u_int32_t td_status = le32toh(p->td_status);
+
+	printf("TD(%p) at %08lx = link=0x%08lx status=0x%08lx "
+	       "token=0x%08lx buffer=0x%08lx\n",
+	       p, 
+	       (long)le32toh(p->td_self),
+	       (long)le32toh(p->td_next),
+	       (long)le32toh(p->td_status),
+	       (long)le32toh(p->td_token),
+	       (long)le32toh(p->td_buffer));
+
+	printf("TD(%p) td_next=%s%s%s td_status=%s%s%s%s%s%s%s%s%s%s%s, errcnt=%d, actlen=%d pid=%02x,"
+	       "addr=%d,endpt=%d,D=%d,maxlen=%d\n",
+	       p,
+	       (td_next & 1) ? "-T" : "",
+	       (td_next & 2) ? "-Q" : "",
+	       (td_next & 4) ? "-VF" : "",
+	       (td_status & UHCI_TD_BITSTUFF) ? "-BITSTUFF" : "",
+	       (td_status & UHCI_TD_CRCTO) ? "-CRCTO" : "",
+	       (td_status & UHCI_TD_NAK) ? "-NAK" : "",
+	       (td_status & UHCI_TD_BABBLE) ? "-BABBLE" : "",
+	       (td_status & UHCI_TD_DBUFFER) ? "-DBUFFER" : "",
+	       (td_status & UHCI_TD_STALLED) ? "-STALLED" : "",
+	       (td_status & UHCI_TD_ACTIVE) ? "-ACTIVE" : "",
+	       (td_status & UHCI_TD_IOC) ? "-IOC" : "",
+	       (td_status & UHCI_TD_IOS) ? "-IOS" : "",
+	       (td_status & UHCI_TD_LS) ? "-LS" : "",
+	       (td_status & UHCI_TD_SPD) ? "-SPD" : "",
+	       UHCI_TD_GET_ERRCNT(le32toh(p->td_status)),
+	       UHCI_TD_GET_ACTLEN(le32toh(p->td_status)),
+	       UHCI_TD_GET_PID(le32toh(p->td_token)),
+	       UHCI_TD_GET_DEVADDR(le32toh(p->td_token)),
+	       UHCI_TD_GET_ENDPT(le32toh(p->td_token)),
+	       UHCI_TD_GET_DT(le32toh(p->td_token)),
+	       UHCI_TD_GET_MAXLEN(le32toh(p->td_token)));
+	return;
+}
+
+static void
+uhci_dump_qh(uhci_qh_t *sqh)
+{
+	DPRINTFN(-1,("QH(%p) at 0x%08x: h_next=%08x e_next=%08x\n", sqh,
+		     sqh->qh_self, le32toh(sqh->qh_h_next),
+		     le32toh(sqh->qh_e_next)));
+	return;
+}
+
+static void
+uhci_dump_all(uhci_softc_t *sc)
+{
+	uhci_dumpregs(sc);
+	printf("intrs=%d\n", sc->sc_bus.no_intrs);
+	uhci_dump_qh(&sc->sc_hw.ls_ctl_start);
+	uhci_dump_qh(&sc->sc_hw.hs_ctl_start);
+	uhci_dump_qh(&sc->sc_hw.bulk_start);
+	uhci_dump_qh(&sc->sc_hw.last_qh);
+	return;
+}
+
+static void
+uhci_dump_qhs(uhci_qh_t *sqh)
+{
+	uhci_dump_qh(sqh);
+
+	/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards
+	 * Traverses sideways first, then down.
+	 *
+	 * QH1
+	 * QH2
+	 * No QH
+	 * TD2.1
+	 * TD2.2
+	 * TD1.1
+	 * etc.
+	 *
+	 * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.
+	 */
+
+	if ((sqh->h_next != NULL) && !(sqh->qh_h_next & htole32(UHCI_PTR_T)))
+		uhci_dump_qhs(sqh->h_next);
+	else
+		DPRINTF(("No QH\n"));
+
+	if ((sqh->e_next != NULL) && !(sqh->qh_e_next & htole32(UHCI_PTR_T)))
+		uhci_dump_tds(sqh->e_next);
+	else
+		DPRINTF(("No TD\n"));
+
+	return;
+}
+
+static void
+uhci_dump_tds(uhci_td_t *td)
+{
+	for(;
+	    td != NULL; 
+	    td = td->next)
+	{
+		uhci_dump_td(td);
+
+		/* Check whether the link pointer in this TD marks
+		 * the link pointer as end of queue. This avoids
+		 * printing the free list in case the queue/TD has
+		 * already been moved there (seatbelt).
+		 */
+		if ((td->td_next & htole32(UHCI_PTR_T)) ||
+		    (td->td_next == 0))
+		{
+			break;
+		}
+	}
+	return;
+}
+#if 0
+static void
+uhci_dump_iis(struct uhci_softc *sc)
+{
+	struct usbd_xfer *xfer;
+
+	printf("interrupt list:\n");
+	LIST_FOREACH(xfer, &sc->sc_interrupt_list_head, interrupt_list)
+	{
+		usbd_dump_xfer(xfer);
+	}
+	return;
+}
+#endif
+#endif
+
+/*
+ * Let the last QH loop back to the high speed control transfer QH.
+ * This is what intel calls "bandwidth reclamation" and improves
+ * USB performance a lot for some devices.
+ * If we are already looping, just count it.
+ */
+static void
+uhci_add_loop(uhci_softc_t *sc)
+{
+#ifdef USB_DEBUG
+	if(uhcinoloop)
+	{
+		return;
+	}
+#endif
+	if(++sc->sc_loops == 1)
+	{
+		DPRINTFN(5,("add\n"));
+		/* NOTE: we don't loop back the soft pointer */
+#if 0
+		sc->sc_hw.last_qh.qh_h_next =
+		  sc->sc_hw.hs_ctl_start.qh_self;
+#else
+		sc->sc_hw.last_qh.qh_h_next =
+		  sc->sc_hw.bulk_start.qh_self;
+#endif
+	}
+	return;
+}
+
+static void
+uhci_rem_loop(uhci_softc_t *sc)
+{
+#ifdef USB_DEBUG
+	if(uhcinoloop)
+	{
+		return;
+	}
+#endif
+	if(--sc->sc_loops == 0)
+	{
+		DPRINTFN(5,("remove\n"));
+		sc->sc_hw.last_qh.qh_h_next = htole32(UHCI_PTR_T);
+	}
+	return;
+}
+
+#define UHCI_APPEND_TD(std,last) (last) = _uhci_append_td(std,last)
+static uhci_td_t *
+_uhci_append_td(uhci_td_t *std, uhci_td_t *last)
+{
+	DPRINTFN(10, ("%p to %p\n", std, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	std->next = last->next;
+	std->td_next = last->td_next;
+
+	std->prev = last;
+
+	/* the last->next->prev is never followed:
+	 * std->next->prev = std;
+	 */
+	last->next = std;
+	last->td_next = std->td_self;
+
+	return(std);
+}
+
+#define UHCI_APPEND_QH(sqh,last) (last) = _uhci_append_qh(sqh,last)
+static uhci_qh_t *
+_uhci_append_qh(uhci_qh_t *sqh, uhci_qh_t *last)
+{
+	DPRINTFN(10, ("%p to %p\n", sqh, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	sqh->h_next = last->h_next;
+	sqh->qh_h_next = last->qh_h_next;
+
+	sqh->h_prev = last;
+	
+	/* the last->h_next->h_prev is never followed:
+	 * sqh->h_next->h_prev = sqh;
+	 */
+
+	last->h_next = sqh;
+	last->qh_h_next = sqh->qh_self;
+
+	return(sqh);
+}
+/**/
+
+#define UHCI_REMOVE_TD(std,last) (last) = _uhci_remove_td(std,last)
+static uhci_td_t *
+_uhci_remove_td(uhci_td_t *std, uhci_td_t *last)
+{
+	DPRINTFN(10, ("%p from %p\n", std, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	std->prev->next = std->next;
+	std->prev->td_next = std->td_next;
+
+	if(std->next)
+	{
+		std->next->prev = std->prev;
+	}
+
+	return((last == std) ? std->prev : last);
+}
+
+#define UHCI_REMOVE_QH(sqh,last) (last) = _uhci_remove_qh(sqh,last)
+static uhci_qh_t *
+_uhci_remove_qh(uhci_qh_t *sqh, uhci_qh_t *last)
+{
+	DPRINTFN(10, ("%p from %p\n", sqh, last));
+
+	/* (sc->sc_bus.mtx) must be locked */
+
+	/* only remove if not removed from a queue */
+	if(sqh->h_prev)
+	{
+		sqh->h_prev->h_next = sqh->h_next;
+		sqh->h_prev->qh_h_next = sqh->qh_h_next;
+
+		if(sqh->h_next)
+		{
+			sqh->h_next->h_prev = sqh->h_prev;
+		}
+
+		/* set the Terminate-bit in the e_next of the QH,
+		 * in case the transferred packet was short so
+		 * that the QH still points at the last used TD
+		 */
+		sqh->qh_e_next = htole32(UHCI_PTR_T);
+
+		last = ((last == sqh) ? sqh->h_prev : last);
+
+		sqh->h_prev = 0;
+	}
+	return(last);
+}
+
+static void
+uhci_device_done(struct usbd_xfer *xfer, usbd_status error);
+
+static u_int8_t
+uhci_isoc_done(uhci_softc_t *sc, struct usbd_xfer *xfer)
+{
+	u_int32_t nframes = xfer->nframes;
+	u_int32_t actlen = 0;
+	u_int16_t *plen = xfer->frlengths;
+	u_int16_t len = 0;
+	u_int8_t need_delay = 0;
+	uhci_td_t *td = xfer->td_transfer_first;
+	uhci_td_t **pp_last = &sc->sc_isoc_p_last[xfer->qh_pos];
+
+	DPRINTFN(12, ("xfer=%p pipe=%p transfer done\n",
+		      xfer, xfer->pipe));
+
+	while(nframes--)
+	{
+	  if(((void *)td) >= xfer->td_end)
+	  {
+		td = xfer->td_start;
+	  }
+
+	  if(pp_last >= &sc->sc_isoc_p_last[UHCI_VFRAMELIST_COUNT])
+	  {
+		pp_last = &sc->sc_isoc_p_last[0];
+	  }
+#ifdef USB_DEBUG
+	  if(uhcidebug > 5)
+	  {
+		DPRINTFN(-1,("isoc TD\n"));
+		uhci_dump_td(td);
+	  }
+#endif
+	  /* check for active transfers */
+
+	  if(td->td_status & htole32(UHCI_TD_ACTIVE))
+	  {
+		need_delay = 1;
+	  }
+
+	  len = UHCI_TD_GET_ACTLEN(le32toh(td->td_status));
+
+	  if(len > *plen)
+	  {
+		len = *plen;
+	  }
+
+	  *plen = len;
+	  actlen += len;
+
+	  /* remove TD from schedule */
+	  UHCI_REMOVE_TD(td, *pp_last);
+
+	  pp_last++;
+	  plen++;
+	  td++;
+	}
+	xfer->actlen = actlen;
+
+	return need_delay;
+}
+
+static void
+uhci_non_isoc_done(struct usbd_xfer *xfer)
+{
+	u_int32_t status = 0;
+	u_int32_t actlen = 0;
+	uhci_td_t *td = xfer->td_transfer_first;
+
+	DPRINTFN(12, ("xfer=%p pipe=%p transfer done\n",
+		      xfer, xfer->pipe));
+
+#ifdef USB_DEBUG
+	if(uhcidebug > 10)
+	{
+		uhci_dump_tds(td);
+	}
+#endif
+
+	if(!(td->td_status & htole32(UHCI_TD_ACTIVE)) &&
+	   (td->td_status & htole32(UHCI_TD_STALLED | UHCI_TD_NAK)) &&
+	   (UHCI_TD_GET_PID(le32toh(td->td_token)) == UHCI_TD_PID_SETUP))
+	{
+		/*
+		 * UHCI will report CRCTO in addition to a STALL or NAK
+		 * for a SETUP transaction.  See section 3.2.2, "TD
+		 * CONTROL AND STATUS"
+		 */
+		td->td_status &= htole32(~UHCI_TD_CRCTO);
+	}
+
+	/* the transfer is done, compute actual length and status */
+	for (;
+	     td != NULL;
+	     td = td->next)
+	{
+		if(td->td_status & htole32(UHCI_TD_ACTIVE))
+		{
+			break;
+		}
+
+		status = le32toh(td->td_status);
+
+		actlen += UHCI_TD_GET_ACTLEN(status);
+	}
+
+	/* if there are left over TDs 
+	 * the toggle needs to be updated
+	 */
+	if(td != NULL)
+	{
+		xfer->pipe->toggle_next =
+		  (td->td_token & htole32(UHCI_TD_SET_DT(1))) ? 1 : 0;
+	}
+
+	DPRINTFN(10, ("actlen=%d\n", actlen));
+
+	xfer->actlen = actlen;
+
+	status &= UHCI_TD_ERROR;
+
+#ifdef USB_DEBUG
+	if(status == UHCI_TD_STALLED)
+	{
+		DPRINTFN(10,
+			 ("error, addr=%d, endpt=0x%02x, "
+			  "status=%s%s%s%s%s%s%s%s%s%s%s\n",
+			  xfer->address,
+			  xfer->endpoint,
+			  (status & UHCI_TD_BITSTUFF) ? "-BITSTUFF" : "",
+			  (status & UHCI_TD_CRCTO) ? "-CRCTO" : "",
+			  (status & UHCI_TD_NAK) ? "-NAK" : "",
+			  (status & UHCI_TD_BABBLE) ? "-BABBLE" : "",
+			  (status & UHCI_TD_DBUFFER) ? "-DBUFFER" : "",
+			  (status & UHCI_TD_STALLED) ? "-STALLED" : "",
+			  (status & UHCI_TD_ACTIVE) ? "-ACTIVE" : "",
+			  (status & UHCI_TD_IOC) ? "-IOC" : "",
+			  (status & UHCI_TD_IOS) ? "-IOS" : "",
+			  (status & UHCI_TD_LS) ? "-LS" : "",
+			  (status & UHCI_TD_SPD) ? "-SPD" : ""));
+	}
+#endif
+
+	uhci_device_done(xfer, 
+			 (status == 0) ? USBD_NORMAL_COMPLETION :
+			 (status == UHCI_TD_STALLED) ? USBD_STALLED : USBD_IOERROR);
+	return;
+}
+
+/* returns one when transfer is finished 
+ * and callback must be called; else zero
+ */
+static u_int8_t
+uhci_check_transfer(struct usbd_xfer *xfer)
+{
+	uhci_td_t *td;
+
+	DPRINTFN(15, ("xfer=%p\n", xfer));
+
+	if(xfer->usb_thread)
+	{
+	    if(xfer->usb_thread != curthread)
+	    {
+	        /* cannot call this transfer 
+		 * back due to locking !
+		 */
+	        return 0;
+	    }
+	}
+
+	td = xfer->td_transfer_last;
+
+	if(xfer->pipe->methods == &uhci_device_isoc_methods)
+	{
+		/* isochronous transfer */
+		if(!(td->td_status & htole32(UHCI_TD_ACTIVE)))
+		{
+			uhci_device_done(xfer,USBD_NORMAL_COMPLETION);
+			goto transferred;
+		}
+	}
+	else
+	{
+		/* non-isochronous transfer */
+		if(td->td_status & htole32(UHCI_TD_ACTIVE))
+		{
+			/*
+			 * if the last TD is still active we need to
+			 * check whether there is an error somewhere
+			 * in the middle, or whether there was a short
+			 * packet (SPD and not ACTIVE)
+			 */
+
+			DPRINTFN(12, ("xfer=%p active\n", xfer));
+
+			for(td = xfer->td_transfer_first;
+			    td != NULL;
+			    td = td->next)
+			{
+				u_int32_t status;
+
+				status = le32toh(td->td_status);
+
+				/* if there's an active TD 
+				 * the transfer isn't done
+				 */
+				if(status & UHCI_TD_ACTIVE)
+				{
+					DPRINTFN(12, ("xfer=%p is still "
+						      "active\n", xfer));
+					goto done;
+				}
+
+				/* any kind of error makes
+				 * the transfer done 
+				 */
+				if(status & UHCI_TD_STALLED)
+				{
+					break;
+				}
+
+				/* we want short packets, 
+				 * and if it is short: it's done 
+				 */
+				if((status & UHCI_TD_SPD) &&
+				   (UHCI_TD_GET_ACTLEN(status) <
+				    UHCI_TD_GET_MAXLEN(le32toh(td->td_token))))
+				{
+					break;
+				}
+			}
+		}
+
+		uhci_non_isoc_done(xfer);
+		goto transferred;
+	}
+
+ done:
+	return 0;
+
+ transferred:
+	return 1;
+}
+
+void
+uhci_interrupt(uhci_softc_t *sc)
+{
+	enum { FINISH_LIST_MAX = 16 };
+
+	struct usbd_callback_info info[FINISH_LIST_MAX];
+	struct usbd_callback_info *ptr = &info[0];
+	struct usbd_xfer *xfer;
+	u_int32_t status;
+	u_int8_t need_repeat = 0;
+
+	mtx_lock(&sc->sc_bus.mtx);
+
+	/*
+	 * It can happen that an interrupt will be delivered to
+	 * us before the device has been fully attached and the
+	 * softc struct has been configured. Usually this happens
+	 * when kldloading the USB support as a module after the
+	 * system has been booted. If we detect this condition,
+	 * we need to squelch the unwanted interrupts until we're
+	 * ready for them.
+	 */
+	if(sc->sc_bus.bdev == NULL) /* XXX */
+	{
+#if 0
+		UWRITE2(sc, UHCI_STS, 0xFFFF);	/* ack pending interrupts */
+		uhci_reset(sc);			/* stop the controller */
+		UWRITE2(sc, UHCI_INTR, 0);	/* disable interrupts */
+#endif
+		goto done;
+	}
+
+	sc->sc_bus.no_intrs++;
+
+	DPRINTFN(15,("%s: real interrupt\n",
+		     device_get_nameunit(sc->sc_bus.bdev)));
+
+#ifdef USB_DEBUG
+	if(uhcidebug > 15)
+	{
+		DPRINTF(("%s\n", device_get_nameunit(sc->sc_bus.bdev)));
+		uhci_dumpregs(sc);
+	}
+#endif
+
+	status = UREAD2(sc, UHCI_STS) & UHCI_STS_ALLINTRS;
+	if(status == 0)
+	{
+		/* the interrupt was not for us */
+		goto done;
+	}
+
+	if(status & UHCI_STS_RD)
+	{
+#ifdef USB_DEBUG
+		device_printf(sc->sc_bus.bdev,
+			      "resume detect\n");
+#endif
+	}
+	if(status & UHCI_STS_HSE)
+	{
+		device_printf(sc->sc_bus.bdev,
+			      "host system error\n");
+	}
+	if(status & UHCI_STS_HCPE)
+	{
+		device_printf(sc->sc_bus.bdev,
+			      "host controller process error\n");
+	}
+	if(status & UHCI_STS_HCH)
+	{
+		/* no acknowledge needed */
+		device_printf(sc->sc_bus.bdev,
+			      "host controller halted\n");
+#ifdef USB_DEBUG
+		uhci_dump_all(sc);
+#endif
+	}
+
+	/* get acknowledge bits */
+	status &= (UHCI_STS_USBINT|
+		   UHCI_STS_USBEI|
+		   UHCI_STS_RD|
+		   UHCI_STS_HSE|
+		   UHCI_STS_HCPE);
+
+	if(status == 0)
+	{
+		/* nothing to acknowledge */
+		goto done;
+	}
+
+	/* acknowledge interrupts */
+	UWRITE2(sc, UHCI_STS, status); 
+
+	/*
+	 * when the host controller interrupts because a transfer
+	 * is completed, all active transfers must be checked!
+	 * The UHCI controller does not have a queue for finished
+	 * transfers
+	 */
+ repeat:
+	LIST_FOREACH(xfer, &sc->sc_interrupt_list_head, interrupt_list)
+	{
+		/* check if transfer is
+		 * transferred 
+		 */
+		if(uhci_check_transfer(xfer))
+		{
+		    /* queue callback */
+		    ptr->xfer = xfer;
+		    ptr->refcount = xfer->usb_refcount;
+		    ptr++;
+
+		    xfer->usb_root->memory_refcount++;
+
+		    /* check queue length */
+		    if(ptr >= &info[FINISH_LIST_MAX])
+		    {
+		        need_repeat = 1;
+			break;
+		    }
+		}
+	}
+
+ done:
+	mtx_unlock(&sc->sc_bus.mtx);
+
+	usbd_do_callback(&info[0],ptr);
+
+	if(need_repeat)
+	{
+		ptr = &info[0];
+
+		need_repeat = 0;
+
+		mtx_lock(&sc->sc_bus.mtx);
+
+		goto repeat;
+	}
+	return;
+}
+
+/*
+ * called when a request does not complete
+ */
+static void
+uhci_timeout(struct usbd_xfer *xfer)
+{
+	struct usbd_callback_info info[1];
+	uhci_softc_t *sc = xfer->usb_sc;
+
+	DPRINTF(("xfer=%p\n", xfer));
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	/* transfer is transferred */
+	uhci_device_done(xfer, USBD_TIMEOUT);
+
+	/* queue callback */
+	info[0].xfer = xfer;
+	info[0].refcount = xfer->usb_refcount;
+
+	xfer->usb_root->memory_refcount++;
+
+	mtx_unlock(&sc->sc_bus.mtx);
+
+	usbd_do_callback(&info[0],&info[1]);
+
+	return;
+}
+
+static void
+uhci_do_poll(struct usbd_bus *bus)
+{
+	uhci_interrupt(UHCI_BUS2SC(bus));
+	return;
+}
+
+#define uhci_add_interrupt_info(sc, xfer) \
+	LIST_INSERT_HEAD(&(sc)->sc_interrupt_list_head, (xfer), interrupt_list)
+
+static void
+uhci_remove_interrupt_info(struct usbd_xfer *xfer)
+{
+	if((xfer)->interrupt_list.le_prev)
+	{
+		LIST_REMOVE((xfer), interrupt_list);
+		(xfer)->interrupt_list.le_prev = 0;
+	}
+	return;
+}
+
+static uhci_td_t *
+uhci_setup_standard_chain(struct usbd_xfer *xfer)
+{
+	u_int32_t td_status;
+	u_int32_t td_token;
+	u_int32_t average = xfer->max_packet_size;
+	u_int32_t physbuffer = xfer->physbuffer;
+	u_int32_t len = xfer->length;
+	u_int8_t isread;
+	u_int8_t shortpkt = 0;
+	uhci_td_t *td;
+
+	DPRINTFN(8, ("addr=%d endpt=%d len=%d speed=%d\n", 
+		     xfer->address, UE_GET_ADDR(xfer->endpoint),
+		     xfer->length, xfer->udev->speed));
+
+	td = (xfer->td_transfer_first = xfer->td_start);
+
+	td_status = htole32(UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3)|
+						UHCI_TD_ACTIVE));
+
+	if(xfer->udev->speed == USB_SPEED_LOW)
+	{
+		td_status |= htole32(UHCI_TD_LS);
+	}
+
+ 	if(xfer->flags & USBD_SHORT_XFER_OK)
+	{
+		/* set UHCI_TD_SPD */
+		td_status |= htole32(UHCI_TD_SPD);
+	}
+
+	if(xfer->pipe->methods == &uhci_device_ctrl_methods)
+	{
+		isread = ((usb_device_request_t *)xfer->buffer)->bmRequestType & UT_READ;
+
+		/* xfer->length = sizeof(usb_device_request_t) + UGETW(req->wLength)
+		 * check length ??
+		 */
+
+		xfer->pipe->toggle_next = 1;
+
+		/* SETUP message */
+
+		td->next = (td+1);
+		td->td_next = (td+1)->td_self;
+		td->td_status = td_status & htole32(~UHCI_TD_SPD);
+		td->td_token = 
+		  htole32(UHCI_TD_SET_ENDPT(xfer->endpoint)) |
+		  htole32(UHCI_TD_SET_DEVADDR(xfer->address)) |
+		  htole32(UHCI_TD_SET_MAXLEN(sizeof(usb_device_request_t))) |
+		  htole32(UHCI_TD_PID_SETUP)|
+		  htole32(UHCI_TD_SET_DT(0));
+
+		td->td_buffer = htole32(physbuffer);
+
+		physbuffer += sizeof(usb_device_request_t);
+		len -= sizeof(usb_device_request_t);
+		td++;
+	}
+	else
+	{
+		isread = (UE_GET_DIR(xfer->endpoint) == UE_DIR_IN);
+
+		if(xfer->length == 0)
+		{
+			/* must allow access to (td-1),
+			 * so xfer->length cannot be zero
+			 */
+			printf("%s: setting USBD_FORCE_SHORT_XFER!\n", __FUNCTION__);
+			xfer->flags |= USBD_FORCE_SHORT_XFER;
+		}
+	}
+
+	td_token =
+	  htole32(UHCI_TD_SET_ENDPT(xfer->endpoint)) |
+	  htole32(UHCI_TD_SET_DEVADDR(xfer->address)) |
+	  htole32(UHCI_TD_SET_MAXLEN(average)) |
+	  (isread ? htole32(UHCI_TD_PID_IN) : htole32(UHCI_TD_PID_OUT));
+
+	if(xfer->pipe->toggle_next)
+	{
+		td_token |= htole32(UHCI_TD_SET_DT(1));
+	}
+
+	while(1)
+	{
+		if(len == 0)
+		{
+			if(xfer->flags & USBD_FORCE_SHORT_XFER)
+			{
+				if(shortpkt)
+				{
+					break;
+				}
+			}
+			else
+			{
+				break;
+			}
+		}
+		if(len < average)
+		{
+			shortpkt = 1;
+			average = len;
+
+			/* update length */
+			td_token &= htole32(~(0x7ff<<21));
+			td_token |= htole32(UHCI_TD_SET_MAXLEN(average));
+		}
+
+		if(((void *)td) >= xfer->td_end)
+		{
+			panic("%s: software wants to write more data "
+			      "than there is in the buffer!", __FUNCTION__);
+		}
+
+		/* fill out TD */
+       
+		td->next = (td+1);
+		td->td_next = (td+1)->td_self;
+		td->td_status = td_status;
+		td->td_token = td_token;
+		td->td_buffer = htole32(physbuffer);
+
+		td_token ^= htole32(UHCI_TD_SET_DT(1));
+
+		physbuffer += average;
+		len -= average;
+		td++;
+	}
+
+	/* set interrupt bit */
+	td_status |= htole32(UHCI_TD_IOC);
+
+	if(xfer->pipe->methods == &uhci_device_ctrl_methods)
+	{
+		/* STATUS message */
+
+		/* update length and PID */
+		td_token &= htole32(~(0x7ff<<21));
+		td_token |= htole32(UHCI_TD_SET_MAXLEN(0)|UHCI_TD_SET_DT(1));
+		td_token ^= htole32(0x88);
+
+		td->next = 0;
+		td->td_next = htole32(UHCI_PTR_T);
+		td->td_status = td_status;
+		td->td_token = td_token;
+		td->td_buffer = htole32(0);
+
+		physbuffer += 0;
+		len -= 0;
+		td++;
+	}
+	else
+	{
+		(td-1)->next = 0;
+		(td-1)->td_next = htole32(UHCI_PTR_T);
+		(td-1)->td_status = td_status;
+	}
+
+	/* must have at least one frame! */
+
+	xfer->td_transfer_last = (td-1);
+
+	/* store data-toggle */
+	if(td_token & htole32(UHCI_TD_SET_DT(1)))
+	{
+		xfer->pipe->toggle_next = 1;
+	}
+	else
+	{
+		xfer->pipe->toggle_next = 0;
+	}
+
+#ifdef USB_DEBUG
+	if(uhcidebug > 8)
+	{
+		DPRINTF(("nexttog=%d; data before transfer:\n",
+			 xfer->pipe->toggle_next));
+		uhci_dump_tds(xfer->td_start);
+	}
+#endif
+	return(xfer->td_start);
+}
+
+/* NOTE: "done" can be run two times in a row,
+ * from close and from interrupt
+ */
+
+static void
+uhci_device_done(struct usbd_xfer *xfer, usbd_status error)
+{
+	uhci_softc_t *sc = xfer->usb_sc;
+	uhci_td_t *td;
+	uhci_qh_t *qh;
+	u_int8_t need_delay;
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	need_delay = 0;
+
+	DPRINTFN(1,("xfer=%p, pipe=%p length=%d error=%d\n",
+		    xfer, xfer->pipe, xfer->actlen, error));
+
+	for(qh = xfer->qh_start;
+	    ((void *)qh) < xfer->qh_end;
+	    qh++)
+	{
+		if(!(qh->qh_e_next & htole32(UHCI_PTR_T)))
+		{
+			need_delay = 1;
+		}
+		qh->e_next = 0;
+		qh->qh_e_next = htole32(UHCI_PTR_T);
+	}
+
+	if(xfer->flags & USBD_BANDWIDTH_RECLAIMED)
+	{
+		xfer->flags &= ~USBD_BANDWIDTH_RECLAIMED;
+		uhci_rem_loop(sc);
+	}
+
+	if(xfer->pipe->methods == &uhci_device_bulk_methods)
+	{
+		UHCI_REMOVE_QH(xfer->qh_start, sc->sc_bulk_p_last);
+	}
+
+	if(xfer->pipe->methods == &uhci_device_ctrl_methods)
+	{
+		if(xfer->udev->speed == USB_SPEED_LOW)
+		{
+			UHCI_REMOVE_QH(xfer->qh_start, sc->sc_ls_ctl_p_last);
+		}
+		else
+		{
+			UHCI_REMOVE_QH(xfer->qh_start, sc->sc_hs_ctl_p_last);
+		}
+	}
+
+	if(xfer->pipe->methods == &uhci_device_intr_methods)
+	{
+		UHCI_REMOVE_QH(xfer->qh_start, sc->sc_intr_p_last[xfer->qh_pos]);
+	}
+
+	/* finish isochronous transfers or clear active bit
+	 * (will update xfer->actlen and xfer->frlengths;
+	 *  should only be called once)
+	 */
+	if(xfer->td_transfer_first &&
+	   xfer->td_transfer_last)
+	{
+		if(xfer->pipe->methods == &uhci_device_isoc_methods)
+		{
+			if(uhci_isoc_done(sc, xfer))
+			{
+				need_delay = 1;
+			}
+		}
+
+		if(need_delay)
+		{
+			td = xfer->td_transfer_first;
+
+			while(1)
+			{
+				if(((void *)td) >= xfer->td_end)
+				{
+					td = xfer->td_start;
+				}
+
+				td->td_status &= 
+				  htole32(~(UHCI_TD_ACTIVE|UHCI_TD_IOC));
+
+				if(td == xfer->td_transfer_last)
+				{
+					break;
+				}
+				td++;
+			}
+		}
+		xfer->td_transfer_first = 0;
+		xfer->td_transfer_last = 0;
+	}
+
+	/* stop timeout */
+	__callout_stop(&xfer->timeout_handle);
+
+	/* remove interrupt info */
+	uhci_remove_interrupt_info(xfer);
+
+	/* wait until hardware has finished any possible
+	 * use of the transfer and QH
+	 *
+	 * hardware finishes in 1 millisecond
+	 */
+	DELAY(need_delay ? ((3*1000)/2) : UHCI_QH_REMOVE_DELAY);
+
+	if(error)
+	{
+		/* next transfer needs to clear stall */
+		xfer->pipe->clearstall = 1;
+	}
+
+	/* transfer is transferred ! */
+	usbd_transfer_done(xfer,error);
+
+	/* dequeue transfer (and start next transfer)
+	 *
+	 * if two transfers are queued, the second
+	 * transfer must be started before the
+	 * first is called back!
+	 */
+	usbd_transfer_dequeue(xfer);
+
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ * uhci bulk support
+ *---------------------------------------------------------------------------*/
+static void
+uhci_device_bulk_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+uhci_device_bulk_close(struct usbd_xfer *xfer)
+{
+	uhci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+uhci_device_bulk_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+uhci_device_bulk_start(struct usbd_xfer *xfer)
+{
+	uhci_softc_t *sc = xfer->usb_sc;
+	uhci_td_t *td;
+	uhci_qh_t *qh;
+
+	DPRINTFN(3, ("xfer=%p len=%d\n",
+		     xfer, xfer->length));
+
+	/* setup TD's */
+	td = uhci_setup_standard_chain(xfer);
+
+	/* setup QH */
+	qh = xfer->qh_start;
+	qh->e_next = td;
+	qh->qh_e_next = td->td_self;
+
+	UHCI_APPEND_QH(qh, sc->sc_bulk_p_last);
+	uhci_add_loop(sc);
+	xfer->flags |= USBD_BANDWIDTH_RECLAIMED;
+
+	/**/
+	uhci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)uhci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods uhci_device_bulk_methods = 
+{
+  .open = uhci_device_bulk_open,
+  .close = uhci_device_bulk_close,
+  .enter = uhci_device_bulk_enter,
+  .start = uhci_device_bulk_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * uhci control support
+ *---------------------------------------------------------------------------*/
+static void
+uhci_device_ctrl_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+uhci_device_ctrl_close(struct usbd_xfer *xfer)
+{
+	uhci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+uhci_device_ctrl_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+uhci_device_ctrl_start(struct usbd_xfer *xfer)
+{
+	uhci_softc_t *sc = xfer->usb_sc;
+	uhci_qh_t *qh;
+	uhci_td_t *td;
+
+	DPRINTFN(3,("type=0x%02x, request=0x%02x, "
+		    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
+		    ((usb_device_request_t *)(xfer->buffer))->bmRequestType,
+		    ((usb_device_request_t *)(xfer->buffer))->bRequest,
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wValue),
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wIndex), 
+		    UGETW(((usb_device_request_t *)(xfer->buffer))->wLength),
+		    xfer->address, xfer->endpoint));
+
+	/* setup TD's */
+	td = uhci_setup_standard_chain(xfer);
+
+	/* setup QH */
+	qh = xfer->qh_start;
+	qh->e_next = td;
+	qh->qh_e_next = td->td_self;
+
+	/* NOTE: some devices choke on bandwidth-
+	 * reclamation for control transfers
+	 */
+	if(xfer->udev->speed == USB_SPEED_LOW)	
+	{
+		UHCI_APPEND_QH(qh, sc->sc_ls_ctl_p_last);
+	}
+	else
+	{
+		UHCI_APPEND_QH(qh, sc->sc_hs_ctl_p_last);
+	}
+
+	/**/
+	uhci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)uhci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods uhci_device_ctrl_methods = 
+{
+  .open = uhci_device_ctrl_open,
+  .close = uhci_device_ctrl_close,
+  .enter = uhci_device_ctrl_enter,
+  .start = uhci_device_ctrl_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * uhci interrupt support
+ *---------------------------------------------------------------------------*/
+static void
+uhci_device_intr_open(struct usbd_xfer *xfer)
+{
+	uhci_softc_t *sc = xfer->usb_sc;
+	u_int16_t best;
+	u_int16_t bit;
+	u_int16_t x;
+
+	best = 0;
+	bit = UHCI_IFRAMELIST_COUNT/2;
+	while(bit)
+	{
+		if(xfer->interval >= bit)
+		{
+			x = bit;
+			best = bit;
+			while(x & bit)
+			{
+				if(sc->sc_intr_stat[x] < 
+				   sc->sc_intr_stat[best])
+				{
+					best = x;
+				}
+				x++;
+			}
+			break;
+		}
+		bit >>= 1;
+	}
+
+	sc->sc_intr_stat[best]++;
+	xfer->qh_pos = best;
+
+	DPRINTFN(2, ("best=%d interval=%d\n",
+		     best, xfer->interval));
+	return;
+}
+
+static void
+uhci_device_intr_close(struct usbd_xfer *xfer)
+{
+	uhci_softc_t *sc = xfer->usb_sc;
+
+	sc->sc_intr_stat[xfer->qh_pos]--;
+
+	uhci_device_done(xfer,USBD_CANCELLED);
+	return;
+}
+
+static void
+uhci_device_intr_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+uhci_device_intr_start(struct usbd_xfer *xfer)
+{
+	uhci_softc_t *sc = xfer->usb_sc;
+	uhci_qh_t *qh;
+	uhci_td_t *td;
+
+	DPRINTFN(3,("xfer=%p len=%d\n",
+		    xfer, xfer->length));
+
+	/* setup TD's */
+	td = uhci_setup_standard_chain(xfer);
+
+	/* setup QH */
+	qh = xfer->qh_start;
+	qh->e_next = td;
+	qh->qh_e_next = td->td_self;
+
+	/* enter QHs into the controller data structures */
+	UHCI_APPEND_QH(qh, sc->sc_intr_p_last[xfer->qh_pos]);
+
+	/**/
+	uhci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)uhci_timeout, xfer);
+	}
+	return;
+}
+
+struct usbd_pipe_methods uhci_device_intr_methods = 
+{
+  .open = uhci_device_intr_open,
+  .close = uhci_device_intr_close,
+  .enter = uhci_device_intr_enter,
+  .start = uhci_device_intr_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * uhci isochronous support
+ *---------------------------------------------------------------------------*/
+static void
+uhci_device_isoc_open(struct usbd_xfer *xfer)
+{
+	uhci_td_t *td;
+	u_int32_t td_token;
+
+	td_token = 
+	  (UE_GET_DIR(xfer->endpoint) == UE_DIR_IN) ? 
+		  UHCI_TD_IN (0, xfer->endpoint, xfer->address, 0) :
+		  UHCI_TD_OUT(0, xfer->endpoint, xfer->address, 0) ;
+
+	td_token = htole32(td_token);
+
+	/* initialize all TD's */
+
+	for(td = xfer->td_start;
+	    ((void *)td) < xfer->td_end;
+	    td++)
+	{
+		/* mark TD as inactive */
+		td->td_status = htole32(UHCI_TD_IOS);
+		td->td_token = td_token;
+	}
+	return;
+}
+
+static void
+uhci_device_isoc_close(struct usbd_xfer *xfer)
+{
+	uhci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+uhci_device_isoc_enter(struct usbd_xfer *xfer)
+{
+	uhci_softc_t *sc = xfer->usb_sc;
+	u_int32_t physbuffer;
+	u_int32_t nframes;
+	u_int16_t *plen;
+#ifdef USB_DEBUG
+	u_int8_t once = 1;
+#endif
+	uhci_td_t *td;
+	uhci_td_t **pp_last;
+
+	DPRINTFN(5,("xfer=%p next=%d nframes=%d\n",
+		    xfer, xfer->pipe->isoc_next, xfer->nframes));
+
+	nframes = UREAD2(sc, UHCI_FRNUM);
+
+	if(((nframes - xfer->pipe->isoc_next) & 
+	    (UHCI_VFRAMELIST_COUNT-1)) < xfer->nframes)
+	{
+		/* not in use yet, schedule it a few frames ahead */
+		/* data underflow */
+		xfer->pipe->isoc_next = (nframes + 3) & (UHCI_VFRAMELIST_COUNT-1);
+		DPRINTFN(2,("start next=%d\n", xfer->pipe->isoc_next));
+	}
+
+	nframes = xfer->nframes;
+
+	if(nframes == 0)
+	{
+		/* transfer transferred */
+		uhci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+		/* call callback recursively */
+		__usbd_callback(xfer);
+
+		return;
+	}
+
+	physbuffer = xfer->physbuffer;
+
+	plen = xfer->frlengths;
+
+	td = (xfer->td_transfer_first = xfer->td_start);
+
+	pp_last = &sc->sc_isoc_p_last[xfer->pipe->isoc_next];
+
+	/* store starting position */
+
+	xfer->qh_pos = xfer->pipe->isoc_next;
+
+	while(nframes--)
+	{
+		if(((void *)td) >= xfer->td_end)
+		{
+			td = xfer->td_start;
+		}
+
+		if(pp_last >= &sc->sc_isoc_p_last[UHCI_VFRAMELIST_COUNT])
+		{
+			pp_last = &sc->sc_isoc_p_last[0];
+		}
+
+		if(*plen > 0x7FF)
+		{
+#ifdef USB_DEBUG
+			if(once)
+			{
+				once = 0;
+				printf("%s: frame length(%d) exceeds %d bytes "
+				       "(frame truncated)\n", 
+				       __FUNCTION__, *plen, 0x7FF);
+			}
+#endif
+
+			/* set new frame length, so that
+			 * a valid transfer can be setup,
+			 * even if synchronization with
+			 * physbuffer is lost
+			 */
+			*plen = 0x7FF;
+		}
+
+		/* reuse td_token from last transfer */
+
+		td->td_token &= htole32(~UHCI_TD_MAXLEN_MASK);
+		td->td_token |= htole32(UHCI_TD_SET_MAXLEN(*plen));
+
+		td->td_buffer = htole32(physbuffer);
+
+		/* update status */
+		if(nframes == 0)
+		{
+			td->td_status = htole32
+			  (UHCI_TD_ZERO_ACTLEN
+			   (UHCI_TD_SET_ERRCNT(0)|
+			    UHCI_TD_ACTIVE|
+			    UHCI_TD_IOS|
+			    UHCI_TD_IOC));
+		}
+		else
+		{
+			td->td_status = htole32
+			  (UHCI_TD_ZERO_ACTLEN
+			   (UHCI_TD_SET_ERRCNT(0)|
+			    UHCI_TD_ACTIVE|
+			    UHCI_TD_IOS));
+		}
+#ifdef USB_DEBUG
+		if(uhcidebug > 5)
+		{
+			DPRINTFN(5,("TD %d\n", nframes));
+			uhci_dump_td(td);
+		}
+#endif
+		/* insert TD into schedule */
+		UHCI_APPEND_TD(td, *pp_last);
+		pp_last++;
+
+		physbuffer += *plen;
+		plen++;
+		td++;
+	}
+
+	xfer->td_transfer_last = (td-1);
+
+	/* update isoc_next */
+	xfer->pipe->isoc_next = (pp_last - &sc->sc_isoc_p_last[0]) &
+	  (UHCI_VFRAMELIST_COUNT-1);
+
+	/**/
+	uhci_add_interrupt_info(sc, xfer);
+
+	if(xfer->timeout && (!(xfer->flags & USBD_USE_POLLING)))
+	{
+		__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
+				(void *)(void *)uhci_timeout, xfer);
+	}
+
+	/* enqueue transfer 
+	 * (so that it can be aborted through pipe abort)
+	 */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+uhci_device_isoc_start(struct usbd_xfer *xfer)
+{
+	/* already started, nothing to do */
+	return;
+}
+
+struct usbd_pipe_methods uhci_device_isoc_methods = 
+{
+  .open = uhci_device_isoc_open,
+  .close = uhci_device_isoc_close,
+  .enter = uhci_device_isoc_enter,
+  .start = uhci_device_isoc_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * uhci root control support
+ *---------------------------------------------------------------------------*
+ * simulate a hardware hub by handling
+ * all the necessary requests
+ *---------------------------------------------------------------------------*/
+
+static void
+uhci_root_ctrl_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+uhci_root_ctrl_close(struct usbd_xfer *xfer)
+{
+	uhci_device_done(xfer,USBD_CANCELLED);
+	return;
+}
+
+/* data structures and routines
+ * to emulate the root hub:
+ */
+
+static const
+usb_device_descriptor_t uhci_devd =
+{
+	USB_DEVICE_DESCRIPTOR_SIZE,
+	UDESC_DEVICE,		/* type */
+	{0x00, 0x01},		/* USB version */
+	UDCLASS_HUB,		/* class */
+	UDSUBCLASS_HUB,		/* subclass */
+	UDPROTO_FSHUB,		/* protocol */
+	64,			/* max packet */
+	{0},{0},{0x00,0x01},	/* device id */
+	1,2,0,			/* string indicies */
+	1			/* # of configurations */
+};
+
+static const
+usb_config_descriptor_t uhci_confd =
+{
+	USB_CONFIG_DESCRIPTOR_SIZE,
+	UDESC_CONFIG,
+	{USB_CONFIG_DESCRIPTOR_SIZE +
+	 USB_INTERFACE_DESCRIPTOR_SIZE +
+	 USB_ENDPOINT_DESCRIPTOR_SIZE},
+	1,
+	1,
+	0,
+	UC_SELF_POWERED,
+	0			/* max power */
+};
+
+static const
+usb_interface_descriptor_t uhci_ifcd = 
+{
+	USB_INTERFACE_DESCRIPTOR_SIZE,
+	UDESC_INTERFACE,
+	0,
+	0,
+	1,
+	UICLASS_HUB,
+	UISUBCLASS_HUB,
+	UIPROTO_FSHUB,
+	0
+};
+
+static const
+usb_endpoint_descriptor_t uhci_endpd = 
+{
+	USB_ENDPOINT_DESCRIPTOR_SIZE,
+	UDESC_ENDPOINT,
+	UE_DIR_IN | UHCI_INTR_ENDPT,
+	UE_INTERRUPT,
+	{8},
+	255
+};
+
+static const
+usb_hub_descriptor_t uhci_hubd_piix = 
+{
+	USB_HUB_DESCRIPTOR_SIZE,
+	UDESC_HUB,
+	2,
+	{ UHD_PWR_NO_SWITCH | UHD_OC_INDIVIDUAL, 0 },
+	50,			/* power on to power good */
+	0,
+	{ 0x00 },		/* both ports are removable */
+};
+
+static int
+uhci_str(usb_string_descriptor_t *p, int l, char *s)
+{
+	int i;
+
+	if(l == 0)
+	{
+		return (0);
+	}
+	p->bLength = (2 * strlen(s)) + 2;
+	if(l == 1)
+	{
+		return (1);
+	}
+	p->bDescriptorType = UDESC_STRING;
+	l -= 2;
+	for(i = 0; s[i] && (l > 1); i++, l -= 2)
+	{
+		USETW2(p->bString[i], 0, s[i]);
+	}
+	return ((2 * i) + 2);
+}
+
+/*
+ * The USB hub protocol requires that SET_FEATURE(PORT_RESET) also
+ * enables the port, and also states that SET_FEATURE(PORT_ENABLE)
+ * should not be used by the USB subsystem.  As we cannot issue a
+ * SET_FEATURE(PORT_ENABLE) externally, we must ensure that the port
+ * will be enabled as part of the reset.
+ *
+ * On the VT83C572, the port cannot be successfully enabled until the
+ * outstanding "port enable change" and "connection status change"
+ * events have been reset.
+ */
+static usbd_status
+uhci_portreset(uhci_softc_t *sc, int index)
+{
+	int lim, port, x;
+
+	if(index == 1)
+		port = UHCI_PORTSC1;
+	else if(index == 2)
+		port = UHCI_PORTSC2;
+	else
+		return (USBD_IOERROR);
+
+	x = URWMASK(UREAD2(sc, port));
+	UWRITE2(sc, port, x | UHCI_PORTSC_PR);
+
+	DELAY(1000*USB_PORT_ROOT_RESET_DELAY);
+
+	DPRINTFN(3,("uhci port %d reset, status0 = 0x%04x\n",
+		    index, UREAD2(sc, port)));
+
+	x = URWMASK(UREAD2(sc, port));
+	UWRITE2(sc, port, x & ~UHCI_PORTSC_PR);
+
+	DELAY(100);
+
+	DPRINTFN(3,("uhci port %d reset, status1 = 0x%04x\n",
+		    index, UREAD2(sc, port)));
+
+	x = URWMASK(UREAD2(sc, port));
+	UWRITE2(sc, port, x  | UHCI_PORTSC_PE);
+
+	lim = 10;
+	while(lim--)
+	{
+		DELAY(1000*USB_PORT_RESET_DELAY);
+
+		x = UREAD2(sc, port);
+
+		DPRINTFN(3,("uhci port %d iteration %u, status = 0x%04x\n",
+			    index, lim, x));
+
+		if(!(x & UHCI_PORTSC_CCS))
+		{
+			/*
+			 * No device is connected (or was disconnected
+			 * during reset).  Consider the port reset.
+			 * The delay must be long enough to ensure on
+			 * the initial iteration that the device
+			 * connection will have been registered.  50ms
+			 * appears to be sufficient, but 20ms is not.
+			 */
+			DPRINTFN(3,("uhci port %d loop %u, device detached\n",
+				    index, lim));
+			goto done;
+		}
+
+		if(x & (UHCI_PORTSC_POEDC | UHCI_PORTSC_CSC))
+		{
+			/*
+			 * Port enabled changed and/or connection
+			 * status changed were set.  Reset either or
+			 * both raised flags (by writing a 1 to that
+			 * bit), and wait again for state to settle.
+			 */
+			UWRITE2(sc, port, URWMASK(x) |
+				(x & (UHCI_PORTSC_POEDC | UHCI_PORTSC_CSC)));
+			continue;
+		}
+
+		if(x & UHCI_PORTSC_PE)
+		{
+			/* port is enabled */
+			goto done;
+		}
+
+		UWRITE2(sc, port, URWMASK(x) | UHCI_PORTSC_PE);
+	}
+
+	DPRINTFN(1,("uhci port %d reset timed out\n", index));
+	return (USBD_TIMEOUT);
+
+ done:
+	DPRINTFN(3,("uhci port %d reset, status2 = 0x%04x\n",
+		    index, UREAD2(sc, port)));
+
+	sc->sc_isreset = 1;
+	return (USBD_NORMAL_COMPLETION);
+}
+
+static void
+uhci_root_ctrl_enter(struct usbd_xfer *xfer)
+{
+	uhci_softc_t *sc = xfer->usb_sc;
+	usb_device_request_t *req = xfer->buffer;
+	void *buf;
+	int port, x;
+	int len, value, index, status, change, l, totlen = 0;
+	usb_port_status_t ps;
+	usbd_status err;
+
+	DPRINTFN(2,("type=0x%02x request=%02x\n",
+		    req->bmRequestType, req->bRequest));
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	/* set default actual length */
+	xfer->actlen = sizeof(*req);
+
+	len = UGETW(req->wLength);
+	value = UGETW(req->wValue);
+	index = UGETW(req->wIndex);
+
+	if(len != 0)
+	{
+		buf = (req+1);
+	}
+	else
+	{
+		buf = NULL;
+	}
+
+#define C(x,y) ((x) | ((y) << 8))
+	switch(C(req->bRequest, req->bmRequestType)) {
+	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
+	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
+	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
+		/*
+		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
+		 * for the integrated root hub.
+		 */
+		break;
+	case C(UR_GET_CONFIG, UT_READ_DEVICE):
+		if(len > 0)
+		{
+			*(u_int8_t *)buf = sc->sc_conf;
+			totlen = 1;
+		}
+		break;
+	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
+		DPRINTFN(2,("wValue=0x%04x\n", value));
+		switch(value >> 8) {
+		case UDESC_DEVICE:
+			if((value & 0xff) != 0)
+			{
+				err = USBD_IOERROR;
+				goto done;
+			}
+			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
+			memcpy(buf, &uhci_devd, l);
+#if 0
+			if(len >= 12)
+			{
+			  USETW(((usb_device_descriptor_t *)buf)->idVendor,
+				sc->sc_id_vendor);
+			}
+#endif
+			break;
+		case UDESC_CONFIG:
+			if((value & 0xff) != 0)
+			{
+				err = USBD_IOERROR;
+				goto done;
+			}
+			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
+			memcpy(buf, &uhci_confd, l);
+			buf = ((u_int8_t *)buf) + l;
+			len -= l;
+			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
+			totlen += l;
+			memcpy(buf, &uhci_ifcd, l);
+			buf = ((u_int8_t *)buf) + l;
+			len -= l;
+			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
+			totlen += l;
+			memcpy(buf, &uhci_endpd, l);
+			break;
+		case UDESC_STRING:
+			if(len == 0)
+			{
+				break;
+			}
+			*(u_int8_t *)buf = 0;
+			totlen = 1;
+			switch (value & 0xff) {
+			case 1: /* Vendor */
+				totlen = uhci_str(buf, len, sc->sc_vendor);
+				break;
+			case 2: /* Product */
+				totlen = uhci_str(buf, len, "UHCI root hub");
+				break;
+			}
+			break;
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+		break;
+	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
+		if(len > 0)
+		{
+			*(u_int8_t *)buf = 0;
+			totlen = 1;
+		}
+		break;
+	case C(UR_GET_STATUS, UT_READ_DEVICE):
+		if(len > 1)
+		{
+			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
+			totlen = 2;
+		}
+		break;
+	case C(UR_GET_STATUS, UT_READ_INTERFACE):
+	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
+		if(len > 1)
+		{
+			USETW(((usb_status_t *)buf)->wStatus, 0);
+			totlen = 2;
+		}
+		break;
+	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
+		if(value >= USB_MAX_DEVICES)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		sc->sc_addr = value;
+		break;
+	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
+		if((value != 0) && (value != 1))
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		sc->sc_conf = value;
+		break;
+	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
+		break;
+	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
+	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
+	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
+		err = USBD_IOERROR;
+		goto done;
+	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
+		break;
+	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
+		break;
+	/* Hub requests */
+	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
+		break;
+	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
+		DPRINTFN(3, ("UR_CLEAR_PORT_FEATURE "
+			     "port=%d feature=%d\n",
+			     index, value));
+		if(index == 1)
+			port = UHCI_PORTSC1;
+		else if(index == 2)
+			port = UHCI_PORTSC2;
+		else
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		switch(value) {
+		case UHF_PORT_ENABLE:
+			x = URWMASK(UREAD2(sc, port));
+			UWRITE2(sc, port, x & ~UHCI_PORTSC_PE);
+			break;
+		case UHF_PORT_SUSPEND:
+			x = URWMASK(UREAD2(sc, port));
+			UWRITE2(sc, port, x & ~UHCI_PORTSC_SUSP);
+			break;
+		case UHF_PORT_RESET:
+			x = URWMASK(UREAD2(sc, port));
+			UWRITE2(sc, port, x & ~UHCI_PORTSC_PR);
+			break;
+		case UHF_C_PORT_CONNECTION:
+			x = URWMASK(UREAD2(sc, port));
+			UWRITE2(sc, port, x | UHCI_PORTSC_CSC);
+			break;
+		case UHF_C_PORT_ENABLE:
+			x = URWMASK(UREAD2(sc, port));
+			UWRITE2(sc, port, x | UHCI_PORTSC_POEDC);
+			break;
+		case UHF_C_PORT_OVER_CURRENT:
+			x = URWMASK(UREAD2(sc, port));
+			UWRITE2(sc, port, x | UHCI_PORTSC_OCIC);
+			break;
+		case UHF_C_PORT_RESET:
+			sc->sc_isreset = 0;
+			err = USBD_NORMAL_COMPLETION;
+			goto done;
+		case UHF_PORT_CONNECTION:
+		case UHF_PORT_OVER_CURRENT:
+		case UHF_PORT_POWER:
+		case UHF_PORT_LOW_SPEED:
+		case UHF_C_PORT_SUSPEND:
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+		break;
+	case C(UR_GET_BUS_STATE, UT_READ_CLASS_OTHER):
+		if(index == 1)
+			port = UHCI_PORTSC1;
+		else if(index == 2)
+			port = UHCI_PORTSC2;
+		else
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		if(len > 0)
+		{
+			*(u_int8_t *)buf =
+				(UREAD2(sc, port) & UHCI_PORTSC_LS) >>
+				UHCI_PORTSC_LS_SHIFT;
+			totlen = 1;
+		}
+		break;
+	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
+		if((value & 0xff) != 0)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		l = min(len, USB_HUB_DESCRIPTOR_SIZE);
+		totlen = l;
+		memcpy(buf, &uhci_hubd_piix, l);
+		break;
+	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
+		if(len != 4)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		memset(buf, 0, len);
+		totlen = len;
+		break;
+	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
+		if(index == 1)
+			port = UHCI_PORTSC1;
+		else if(index == 2)
+			port = UHCI_PORTSC2;
+		else
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		if(len != 4)
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		x = UREAD2(sc, port);
+		status = change = 0;
+		if(x & UHCI_PORTSC_CCS)
+			status |= UPS_CURRENT_CONNECT_STATUS;
+		if(x & UHCI_PORTSC_CSC)
+			change |= UPS_C_CONNECT_STATUS;
+		if(x & UHCI_PORTSC_PE)
+			status |= UPS_PORT_ENABLED;
+		if(x & UHCI_PORTSC_POEDC)
+			change |= UPS_C_PORT_ENABLED;
+		if(x & UHCI_PORTSC_OCI)
+			status |= UPS_OVERCURRENT_INDICATOR;
+		if(x & UHCI_PORTSC_OCIC)
+			change |= UPS_C_OVERCURRENT_INDICATOR;
+		if(x & UHCI_PORTSC_SUSP)
+			status |= UPS_SUSPEND;
+		if(x & UHCI_PORTSC_LSDA)
+			status |= UPS_LOW_SPEED;
+		status |= UPS_PORT_POWER;
+		if(sc->sc_isreset)
+			change |= UPS_C_PORT_RESET;
+		USETW(ps.wPortStatus, status);
+		USETW(ps.wPortChange, change);
+		l = min(len, sizeof ps);
+		memcpy(buf, &ps, l);
+		totlen = l;
+		break;
+	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
+		err = USBD_IOERROR;
+		goto done;
+	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
+		break;
+	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
+		if(index == 1)
+			port = UHCI_PORTSC1;
+		else if(index == 2)
+			port = UHCI_PORTSC2;
+		else
+		{
+			err = USBD_IOERROR;
+			goto done;
+		}
+		switch(value) {
+		case UHF_PORT_ENABLE:
+			x = URWMASK(UREAD2(sc, port));
+			UWRITE2(sc, port, x | UHCI_PORTSC_PE);
+			break;
+		case UHF_PORT_SUSPEND:
+			x = URWMASK(UREAD2(sc, port));
+			UWRITE2(sc, port, x | UHCI_PORTSC_SUSP);
+			break;
+		case UHF_PORT_RESET:
+			err = uhci_portreset(sc, index);
+			goto done;
+		case UHF_PORT_POWER:
+			/* pretend we turned on power */
+			err = USBD_NORMAL_COMPLETION;
+			goto done;
+		case UHF_C_PORT_CONNECTION:
+		case UHF_C_PORT_ENABLE:
+		case UHF_C_PORT_OVER_CURRENT:
+		case UHF_PORT_CONNECTION:
+		case UHF_PORT_OVER_CURRENT:
+		case UHF_PORT_LOW_SPEED:
+		case UHF_C_PORT_SUSPEND:
+		case UHF_C_PORT_RESET:
+		default:
+			err = USBD_IOERROR;
+			goto done;
+		}
+		break;
+	default:
+		err = USBD_IOERROR;
+		goto done;
+	}
+	xfer->actlen = totlen + sizeof(*req);
+	err = USBD_NORMAL_COMPLETION;
+
+ done:
+	/* transfer transferred */
+	uhci_device_done(xfer,err);
+
+	/* call callback recursively */
+	__usbd_callback(xfer);
+
+	return;
+}
+
+static void
+uhci_root_ctrl_start(struct usbd_xfer *xfer)
+{
+	/* not used */
+	return;
+}
+
+struct usbd_pipe_methods uhci_root_ctrl_methods = 
+{
+  .open = uhci_root_ctrl_open,
+  .close = uhci_root_ctrl_close,
+  .enter = uhci_root_ctrl_enter,
+  .start = uhci_root_ctrl_start,
+};
+
+/*---------------------------------------------------------------------------*
+ * uhci root interrupt support
+ *---------------------------------------------------------------------------*/
+static void
+uhci_root_intr_open(struct usbd_xfer *xfer)
+{
+	return;
+}
+
+static void
+uhci_root_intr_close(struct usbd_xfer *xfer)
+{
+	uhci_device_done(xfer, USBD_CANCELLED);
+	return;
+}
+
+static void
+uhci_root_intr_enter(struct usbd_xfer *xfer)
+{
+	/* enqueue transfer 
+	 * (so that it can be aborted through pipe abort)
+	 */
+	usbd_transfer_enqueue(xfer);
+	return;
+}
+
+static void
+uhci_root_intr_check(struct usbd_xfer *xfer);
+
+static void
+uhci_root_intr_start(struct usbd_xfer *xfer)
+{
+	DPRINTFN(3, ("xfer=%p len=%d\n",
+		     xfer, xfer->length));
+
+	__callout_reset(&xfer->timeout_handle, MS_TO_TICKS(xfer->interval),
+			(void *)(void *)uhci_root_intr_check, xfer);
+	return;
+}
+
+/*
+ * this routine is executed periodically and simulates interrupts
+ * from the root controller interrupt pipe for port status change
+ */
+static void
+uhci_root_intr_check(struct usbd_xfer *xfer)
+{
+	struct usbd_callback_info info[1];
+	uhci_softc_t *sc = xfer->usb_sc;
+	u_int8_t *buf = xfer->buffer;
+
+	DPRINTFN(20,("\n"));
+
+	mtx_assert(&sc->sc_bus.mtx, MA_OWNED);
+
+	buf[0] = 0;
+
+	if(UREAD2(sc, UHCI_PORTSC1) & (UHCI_PORTSC_CSC|UHCI_PORTSC_OCIC))
+	{
+	    buf[0] |= 1<<1;
+	}
+
+	if(UREAD2(sc, UHCI_PORTSC2) & (UHCI_PORTSC_CSC|UHCI_PORTSC_OCIC))
+	{
+	    buf[0] |= 1<<2;
+	}
+
+	if((buf[0] == 0) || !(UREAD2(sc, UHCI_CMD) & UHCI_CMD_RS))
+	{
+	    /* no change or controller not running,
+	     * try again in a while
+	     */
+	    uhci_root_intr_start(xfer);
+
+	    mtx_unlock(&sc->sc_bus.mtx);
+	}
+	else
+	{
+	    xfer->actlen = 1;
+
+	    /* transfer is transferred */
+	    uhci_device_done(xfer, USBD_NORMAL_COMPLETION);
+
+	    /* queue callback */
+	    info[0].xfer = xfer;
+	    info[0].refcount = xfer->usb_refcount;
+
+	    xfer->usb_root->memory_refcount++;
+
+	    mtx_unlock(&sc->sc_bus.mtx);
+
+	    usbd_do_callback(&info[0],&info[1]);
+	}
+	return;
+}
+
+struct usbd_pipe_methods uhci_root_intr_methods = 
+{
+  .open = uhci_root_intr_open,
+  .close = uhci_root_intr_close,
+  .enter = uhci_root_intr_enter,
+  .start = uhci_root_intr_start,
+};
+
+#define ADD_BYTES(ptr,size) ((void *)(((u_int8_t *)(ptr)) + (size)))
+
+static usbd_status
+uhci_xfer_setup(struct usbd_device *udev,
+		u_int8_t iface_index,
+		struct usbd_xfer **pxfer,
+		const struct usbd_config *setup_start,
+		const struct usbd_config *setup_end)
+{
+	uhci_softc_t *sc = UHCI_BUS2SC(udev->bus);
+	const struct usbd_config *setup;
+	struct usbd_memory_info *info;
+	struct usbd_xfer dummy;
+	struct usbd_xfer *xfer;
+	u_int32_t physbuffer;
+	u_int32_t size;
+	u_int32_t total_size;
+	u_int32_t ntd;
+	u_int32_t nqh;
+	u_int32_t n;
+	void *buf;
+	usbd_status error = 0;
+
+	buf = 0;
+	physbuffer = 0;
+	total_size = 0;
+
+ repeat:
+	size = 0;
+
+	/* align data to 8 byte boundary */
+	size += ((-size) & (USB_HOST_ALIGN-1));
+
+	if(buf)
+	{
+	    info = ADD_BYTES(buf,size);
+
+	    info->memory_base = buf;
+	    info->memory_size = total_size;
+	    info->usb_mtx = &sc->sc_bus.mtx;
+	}
+	else
+	{
+	    info = NULL;
+	}
+
+	size += sizeof(info[0]);
+
+	for(setup = setup_start;
+	    setup < setup_end;
+	    setup++)
+	{
+	  ntd = 0;
+	  nqh = 0;
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		*pxfer++ = (xfer = ADD_BYTES(buf,size));
+	  }
+	  else
+	  {
+		/* need dummy xfer to 
+		 * calculate ntd and nqh !
+		 */
+		xfer = &dummy;
+		bzero(&dummy, sizeof(dummy));
+	  }
+
+	  /*
+	   * setup xfer
+	   */
+	  xfer->usb_sc = sc;
+	  xfer->usb_mtx = &sc->sc_bus.mtx;
+	  xfer->usb_root = info;
+	  xfer->flags = setup->flags;
+	  xfer->length = setup->bufsize;
+	  xfer->nframes = setup->frames;
+	  xfer->timeout = setup->timeout;
+	  xfer->callback = setup->callback;
+
+	  __callout_init_mtx(&xfer->timeout_handle, &sc->sc_bus.mtx, 
+			     CALLOUT_RETURNUNLOCKED);
+
+	  xfer->pipe = usbd_get_pipe(udev, iface_index, setup);
+
+	  if(!xfer->pipe)
+	  {
+		/* continue though this error is critical */
+		error = USBD_NO_PIPE;
+		DPRINTF(("no pipe for endpoint %d\n",
+			 setup->endpoint));
+	  }
+	  else
+	  {
+		xfer->interval = setup->interval;
+
+		if(xfer->interval == 0)
+		{
+			xfer->interval = xfer->pipe->edesc->bInterval;
+		}
+
+		if(xfer->interval == 0)
+		{
+			/* one is the smallest interval */
+			xfer->interval = 1;
+		}
+
+		xfer->address = udev->address;
+		xfer->endpoint = xfer->pipe->edesc->bEndpointAddress;
+		xfer->max_packet_size = UGETW(xfer->pipe->edesc->wMaxPacketSize);
+
+		/* wMaxPacketSize is validated by "usbd_fill_iface_data()" */
+
+		/*
+		 * compute ntd and nqh
+		 */
+		if((xfer->pipe->methods == &uhci_device_ctrl_methods) ||
+		   (xfer->pipe->methods == &uhci_device_bulk_methods) ||
+		   (xfer->pipe->methods == &uhci_device_intr_methods))
+		{
+			nqh = 1;
+			ntd = (1+ /* SETUP */ 1+ /* STATUS */
+			       1  /* SHORTPKT */) +
+			  (xfer->length / xfer->max_packet_size) /* DATA */;
+		}
+
+		if(xfer->pipe->methods == &uhci_device_isoc_methods)
+		{
+			if(xfer->nframes >= UHCI_VFRAMELIST_COUNT)
+			{
+				/* continue, though this error is critical */
+				error = USBD_INVAL;
+				DPRINTF(("isochronous frame-limit "
+					 "exceeded by 0x%x frames; "
+					 "endpoint 0x%02x\n",
+					 setup->frames - UHCI_VFRAMELIST_COUNT,
+					 setup->endpoint));
+			}
+			if(xfer->nframes == 0)
+			{
+				/* continue, though this error is critical */
+				error = USBD_ZERO_FRAMES_IN_ISOC_MODE;
+				DPRINTF(("frames == 0 in isochronous mode; "
+					 "endpoint 0x%02x\n", setup->endpoint));
+			}
+			ntd = xfer->nframes;
+		}
+	  }
+
+	  size += sizeof(xfer[0]);
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		xfer->frlengths = ADD_BYTES(buf,size);
+	  }
+
+	  size += UHCI_VFRAMELIST_COUNT * sizeof(xfer->frlengths[0]);
+
+	  /* align data to 8 byte boundary */
+	  size += ((-size) & (USB_HOST_ALIGN-1));
+
+	  if(buf)
+	  {
+		xfer->buffer = ADD_BYTES(buf,size);
+		xfer->physbuffer = (physbuffer + size);
+	  }
+
+	  size += setup->bufsize;
+
+	  size += ((-size) & (UHCI_TD_ALIGN-1)); /* align data */
+
+	  if(buf)
+	  {
+		xfer->td_start = ADD_BYTES(buf,size);
+	  }
+
+	  for(n = 0;
+	      n < ntd;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init TD */
+		((uhci_td_t *)ADD_BYTES(buf,size))->td_self = 
+		  htole32((physbuffer + size)|UHCI_PTR_TD);
+
+		if((xfer->pipe->methods == &uhci_device_bulk_methods) ||
+		   (xfer->pipe->methods == &uhci_device_ctrl_methods) ||
+		   (xfer->pipe->methods == &uhci_device_intr_methods))
+		{
+			/* set depth first bit */
+			((uhci_td_t *)ADD_BYTES(buf,size))->td_self |=
+			  htole32(UHCI_PTR_VF);
+		}
+	    }
+	    size += sizeof(uhci_td_t);
+	  }
+
+	  if(buf)
+	  {
+		xfer->td_end = ADD_BYTES(buf,size);
+	  }
+
+	  size += ((-size) & (UHCI_QH_ALIGN-1)); /* align data */
+
+	  if(buf)
+	  {
+		xfer->qh_start = ADD_BYTES(buf,size);
+	  }
+
+	  for(n = 0;
+	      n < nqh;
+	      n++)
+	  {
+	    if(buf)
+	    {
+		/* init QH */
+		((uhci_qh_t *)ADD_BYTES(buf,size))->qh_self = 
+		  htole32((physbuffer + size)|UHCI_PTR_QH);
+	    }
+	    size += sizeof(uhci_qh_t);
+	  }
+
+	  if(buf)
+	  {
+		xfer->qh_end = ADD_BYTES(buf,size);
+	  }
+	}
+
+	if(!buf && !error)
+	{
+		/* store total buffer size */
+		total_size = size;
+
+		/* allocate zeroed memory */
+		buf = usb_alloc_mem(device_get_dma_tag(sc->sc_dev),
+				    size, LOG2(UHCI_TD_ALIGN));
+
+		if(!buf)
+		{
+			error = USBD_NOMEM;
+			DPRINTF(("cannot allocate memory block for "
+				 "configuration (%d bytes)\n", size));
+		}
+		else
+		{
+#if 1
+			bzero(buf, size);
+#endif
+			physbuffer = usb_vtophys(buf, size);
+			goto repeat;
+		}
+	}
+	return error;
+}
+
+static void
+uhci_pipe_init(struct usbd_device *udev, usb_endpoint_descriptor_t *edesc, 
+               struct usbd_pipe *pipe)
+{
+	uhci_softc_t *sc = UHCI_BUS2SC(udev->bus);
+
+	DPRINTFN(1, ("pipe=%p, addr=%d, endpt=%d (%d)\n",
+		     pipe, udev->address,
+		     edesc->bEndpointAddress, sc->sc_addr));
+
+	if(udev->address == sc->sc_addr)
+	{
+		switch (edesc->bEndpointAddress)
+		{
+		case USB_CONTROL_ENDPOINT:
+			pipe->methods = &uhci_root_ctrl_methods;
+			break;
+		case UE_DIR_IN | UHCI_INTR_ENDPT:
+			pipe->methods = &uhci_root_intr_methods;
+			break;
+		default:
+			panic("invalid endpoint address: 0x%02x",
+			      edesc->bEndpointAddress);
+			break;
+		}
+	}
+	else
+        {
+		switch (edesc->bmAttributes & UE_XFERTYPE)
+		{
+		case UE_CONTROL:
+			pipe->methods = &uhci_device_ctrl_methods;
+			break;
+		case UE_INTERRUPT:
+			pipe->methods = &uhci_device_intr_methods;
+			break;
+		case UE_ISOCHRONOUS:
+			pipe->methods = &uhci_device_isoc_methods;
+			break;
+		case UE_BULK:
+			pipe->methods = &uhci_device_bulk_methods;
+			break;
+		}
+	}
+	return;
+}
+
+struct usbd_bus_methods uhci_bus_methods = 
+{
+	.pipe_init  = uhci_pipe_init,
+	.xfer_setup = uhci_xfer_setup,
+	.do_poll    = uhci_do_poll,
+};
diff -rubN /usr/src1/src/sys/dev/usb2/_uhci_pci.c /usr/src/sys/dev/usb2/_uhci_pci.c
--- /usr/src1/src/sys/dev/usb2/_uhci_pci.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_uhci_pci.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,400 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (augustss@carlstedt.se) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Universal Host Controller Interface
+ *
+ * UHCI spec: http://www.intel.com/
+ */
+
+/* The low level controller code for UHCI has been split into
+ * PCI probes and UHCI specific code. This was done to facilitate the
+ * sharing of code between *BSD's
+ */
+
+#include "opt_bus.h"
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/endian.h>
+#include <sys/queue.h> /* LIST_XXX() */
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h> /* bus_space_xxx() */
+
+#define INCLUDE_PCIXXX_H
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/uhci.h> 
+
+__FBSDID("$FreeBSD: src/sys/dev/usb/uhci_pci.c $");
+
+#define PCI_UHCI_VENDORID_INTEL		0x8086
+#define PCI_UHCI_VENDORID_VIA		0x1106
+
+/* PIIX4E has no separate stepping */
+
+#define PCI_UHCI_BASE_REG               0x20
+
+static int uhci_pci_attach(device_t self);
+static int uhci_pci_detach(device_t self);
+static int uhci_pci_suspend(device_t self);
+static int uhci_pci_resume(device_t self);
+
+static int
+uhci_pci_suspend(device_t self)
+{
+	uhci_softc_t *sc = device_get_softc(self);
+	int err;
+
+	err = bus_generic_suspend(self);
+	if(err)
+	{
+		return err;
+	}
+	uhci_suspend(sc);
+	return 0;
+}
+
+static int
+uhci_pci_resume(device_t self)
+{
+	uhci_softc_t *sc = device_get_softc(self);
+
+	pci_write_config(self, PCI_LEGSUP, PCI_LEGSUP_USBPIRQDEN, 2);
+
+	uhci_resume(sc);
+
+	bus_generic_resume(self);
+	return 0;
+}
+
+static const char *
+uhci_pci_match(device_t self)
+{
+	u_int32_t device_id = pci_get_devid(self);
+
+	if(device_id == 0x70208086) 
+	  { return ("Intel 82371SB (PIIX3) USB controller"); }
+	if(device_id == 0x71128086) 
+	  { return ("Intel 82371AB/EB (PIIX4) USB controller"); }
+	if(device_id == 0x24128086) 
+	  { return ("Intel 82801AA (ICH) USB controller"); }
+	if(device_id == 0x24228086) 
+	  { return ("Intel 82801AB (ICH0) USB controller"); }
+	if(device_id == 0x24428086) 
+	  { return ("Intel 82801BA/BAM (ICH2) USB controller USB-A"); }
+	if(device_id == 0x24448086) 
+	  { return ("Intel 82801BA/BAM (ICH2) USB controller USB-B"); }
+	if(device_id == 0x24828086) 
+	  { return ("Intel 82801CA/CAM (ICH3) USB controller USB-A"); }
+	if(device_id == 0x24848086) 
+	  { return ("Intel 82801CA/CAM (ICH3) USB controller USB-B"); }
+	if(device_id == 0x24878086) 
+	  { return ("Intel 82801CA/CAM (ICH3) USB controller USB-C"); }
+	if(device_id == 0x24c28086) 
+	  { return ("Intel 82801DB (ICH4) USB controller USB-A"); }
+	if(device_id == 0x24c48086) 
+	  { return ("Intel 82801DB (ICH4) USB controller USB-B"); }
+	if(device_id == 0x24c78086) 
+	  { return ("Intel 82801DB (ICH4) USB controller USB-C"); }
+	if(device_id == 0x24d28086) 
+	  { return ("Intel 82801EB (ICH5) USB controller USB-A"); }
+	if(device_id == 0x24d48086) 
+	  { return ("Intel 82801EB (ICH5) USB controller USB-B"); }
+	if(device_id == 0x24d78086) 
+	  { return ("Intel 82801EB (ICH5) USB controller USB-C"); }
+	if(device_id == 0x24de8086) 
+	  { return ("Intel 82801EB (ICH5) USB controller USB-D"); }
+	if(device_id == 0x26588086)
+	  { return ("Intel 82801FB/FR/FW/FRW (ICH6) USB controller USB-A"); }
+	if(device_id == 0x26598086)
+	  { return ("Intel 82801FB/FR/FW/FRW (ICH6) USB controller USB-B"); }
+	if(device_id == 0x265a8086)
+	  { return ("Intel 82801FB/FR/FW/FRW (ICH6) USB controller USB-C"); }
+	if(device_id == 0x265b8086)
+	  { return ("Intel 82801FB/FR/FW/FRW (ICH6) USB controller USB-D"); }
+	if(device_id == 0x719a8086) 
+	  { return ("Intel 82443MX USB controller"); }
+	if(device_id == 0x76028086) 
+	  { return ("Intel 82372FB/82468GX USB controller"); }
+	if(device_id == 0x30381106) 
+	  { return ("VIA 83C572 USB controller"); }
+
+	if((pci_get_class(self) == PCIC_SERIALBUS) &&
+	   (pci_get_subclass(self) == PCIS_SERIALBUS_USB) && 
+	   (pci_get_progif(self) == PCI_INTERFACE_UHCI))
+	{
+		return ("UHCI (generic) USB controller");
+	}
+	return NULL;
+}
+
+static int
+uhci_pci_probe(device_t self)
+{
+	const char *desc = uhci_pci_match(self);
+
+	if(desc)
+	{
+		device_set_desc(self, desc);
+		return 0;
+	}
+	else
+	{
+		return ENXIO;
+	}
+}
+
+static int
+uhci_pci_attach(device_t self)
+{
+	uhci_softc_t *sc;
+	int rid;
+	int err;
+
+	sc = usb_alloc_mem(device_get_dma_tag(self),
+			   sizeof(*sc), LOG2(UHCI_FRAMELIST_ALIGN));
+
+	if(sc == NULL)
+	{
+		device_printf(self, "Could not allocate sc\n");
+		return ENXIO;
+	}
+
+#if 1
+	bzero(sc, sizeof(*sc));
+#endif
+	sc->sc_physaddr = usb_vtophys(sc, sizeof(*sc)); /* physical address of sc */
+
+	mtx_init(&sc->sc_bus.mtx, "usb lock",
+		 NULL, MTX_DEF|MTX_RECURSE);
+
+	device_set_softc(self, sc);
+	sc->sc_dev = self;
+
+	pci_enable_busmaster(self);
+
+	rid = PCI_UHCI_BASE_REG;
+	sc->io_res = bus_alloc_resource_any(self, SYS_RES_IOPORT, &rid,
+					    RF_ACTIVE);
+	if(!sc->io_res)
+	{
+		device_printf(self, "Could not map ports\n");
+		goto error;
+	}
+	sc->iot = rman_get_bustag(sc->io_res);
+	sc->ioh = rman_get_bushandle(sc->io_res);
+
+	/* disable interrupts */
+	bus_space_write_2(sc->iot, sc->ioh, UHCI_INTR, 0);
+
+	rid = 0;
+	sc->irq_res = bus_alloc_resource_any(self, SYS_RES_IRQ, &rid,
+					     RF_SHAREABLE | RF_ACTIVE);
+	if(sc->irq_res == NULL)
+	{
+		device_printf(self, "Could not allocate irq\n");
+		goto error;
+	}
+	sc->sc_bus.bdev = device_add_child(self, "usb", -1);
+	if(!sc->sc_bus.bdev)
+	{
+		device_printf(self, "Could not add USB device\n");
+		goto error;
+	}
+
+	device_set_ivars(sc->sc_bus.bdev, &sc->sc_bus);
+	device_set_softc(sc->sc_bus.bdev, &sc->sc_bus);
+
+	/* uhci_pci_match must never return NULL if uhci_pci_probe succeeded */
+	device_set_desc(sc->sc_bus.bdev, uhci_pci_match(self));
+	switch (pci_get_vendor(self)) {
+	case PCI_UHCI_VENDORID_INTEL:
+		sprintf(sc->sc_vendor, "Intel");
+		break;
+	case PCI_UHCI_VENDORID_VIA:
+		sprintf(sc->sc_vendor, "VIA");
+		break;
+	default:
+		if(bootverbose)
+		{
+			device_printf(self, "(New UHCI DeviceId=0x%08x)\n",
+				      pci_get_devid(self));
+		}
+		sprintf(sc->sc_vendor, "(0x%04x)", pci_get_vendor(self));
+	}
+
+	switch (pci_read_config(self, PCI_USBREV, 1) & PCI_USBREV_MASK) {
+	case PCI_USBREV_PRE_1_0:
+		sc->sc_bus.usbrev = USBREV_PRE_1_0;
+		break;
+	case PCI_USBREV_1_0:
+		sc->sc_bus.usbrev = USBREV_1_0;
+		break;
+	default:
+		sc->sc_bus.usbrev = USBREV_UNKNOWN;
+		break;
+	}
+
+	err = bus_setup_intr(self, sc->irq_res, INTR_TYPE_BIO|INTR_MPSAFE,
+			     (void *)(void *)uhci_interrupt, sc, &sc->ih);
+
+	if(err)
+	{
+		device_printf(self, "Could not setup irq, %d\n", err);
+		sc->ih = NULL;
+		goto error;
+	}
+	/*
+	 * Set the PIRQD enable bit and switch off all the others. We don't
+	 * want legacy support to interfere with us XXX Does this also mean
+	 * that the BIOS won't touch the keyboard anymore if it is connected
+	 * to the ports of the root hub?
+	 */
+#ifdef USB_DEBUG
+	if(pci_read_config(self, PCI_LEGSUP, 2) != PCI_LEGSUP_USBPIRQDEN)
+	{
+		device_printf(self, "LegSup = 0x%04x\n",
+			      pci_read_config(self, PCI_LEGSUP, 2));
+	}
+#endif
+	pci_write_config(self, PCI_LEGSUP, PCI_LEGSUP_USBPIRQDEN, 2);
+
+	err = uhci_init(sc);
+	if(!err)
+	{
+		err = device_probe_and_attach(sc->sc_bus.bdev);
+	}
+	if(err)
+	{
+		device_printf(self, "USB init failed\n");
+		goto error;
+	}
+	return 0;
+
+ error:
+	uhci_pci_detach(self);
+	return ENXIO;
+}
+
+int
+uhci_pci_detach(device_t self)
+{
+	uhci_softc_t *sc = device_get_softc(self);
+
+	if(sc->sc_bus.bdev)
+	{
+		device_delete_child(self, sc->sc_bus.bdev);
+		sc->sc_bus.bdev = NULL;
+	}
+
+	/*
+	 * disable interrupts that might have been switched on in
+	 * uhci_init.
+	 */
+	if(sc->io_res)
+	{
+		mtx_lock(&sc->sc_bus.mtx);
+
+		/* stop the controller */
+		uhci_reset(sc);
+
+		mtx_unlock(&sc->sc_bus.mtx);
+	}
+
+	pci_disable_busmaster(self);
+
+	if(sc->irq_res && sc->ih)
+	{
+		int err = bus_teardown_intr(self, sc->irq_res, sc->ih);
+
+		if(err)
+		{
+			/* XXX or should we panic? */
+			device_printf(self, "Could not tear down irq, %d\n",
+				      err);
+		}
+		sc->ih = NULL;
+	}
+	if(sc->irq_res)
+	{
+		bus_release_resource(self, SYS_RES_IRQ, 0, sc->irq_res);
+		sc->irq_res = NULL;
+	}
+	if(sc->io_res)
+	{
+		bus_release_resource(self, SYS_RES_IOPORT, PCI_UHCI_BASE_REG,
+				     sc->io_res);
+		sc->io_res = NULL;
+	}
+
+	usb_free_mem(sc, sizeof(*sc));
+
+	device_set_softc(self, NULL);
+	return 0;
+}
+
+static driver_t uhci_driver =
+{
+	.name    = "uhci",
+	.methods = (device_method_t [])
+	{
+	  /* device interface */
+	  DEVMETHOD(device_probe, uhci_pci_probe),
+	  DEVMETHOD(device_attach, uhci_pci_attach),
+	  DEVMETHOD(device_detach, uhci_pci_detach),
+
+	  DEVMETHOD(device_suspend, uhci_pci_suspend),
+	  DEVMETHOD(device_resume, uhci_pci_resume),
+	  DEVMETHOD(device_shutdown, bus_generic_shutdown),
+
+	  /* Bus interface */
+	  DEVMETHOD(bus_print_child, bus_generic_print_child),
+	  {0, 0}
+	},
+	.size = 0,
+};
+
+static devclass_t uhci_devclass;
+
+DRIVER_MODULE(uhci, pci, uhci_driver, uhci_devclass, 0, 0);
+DRIVER_MODULE(uhci, cardbus, uhci_driver, uhci_devclass, 0, 0);
diff -rubN /usr/src1/src/sys/dev/usb2/_uhub.c /usr/src/sys/dev/usb2/_uhub.c
--- /usr/src1/src/sys/dev/usb2/_uhub.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_uhub.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,826 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * USB spec: http://www.usb.org/developers/docs/usbspec.zip
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb/uhub.c $");
+
+#define UHUB_INTR_INTERVAL 250	/* ms */
+
+#ifdef USB_DEBUG
+#undef DPRINTF
+#undef DPRINTFN
+#define DPRINTF(x)	{ if (uhubdebug) { printf("%s: ", __FUNCTION__); printf x; } }
+#define DPRINTFN(n,x)	{ if (uhubdebug>(n)) { printf("%s: ", __FUNCTION__); printf x; } }
+int	uhubdebug = 0;
+SYSCTL_NODE(_hw_usb, OID_AUTO, uhub, CTLFLAG_RW, 0, "USB uhub");
+SYSCTL_INT(_hw_usb_uhub, OID_AUTO, debug, CTLFLAG_RW,
+	   &uhubdebug, 0, "uhub debug level");
+#endif
+
+struct uhub_softc
+{
+	device_t       		sc_dev;         /* base device */
+	struct usbd_device *	sc_hub;         /* USB device */
+	struct usbd_xfer *	sc_xfer[2];	/* interrupt xfer */
+	u_int8_t                sc_running;
+};
+#define UHUB_PROTO(sc) ((sc)->sc_hub->ddesc.bDeviceProtocol)
+#define UHUB_IS_HIGH_SPEED(sc) (UHUB_PROTO(sc) != UDPROTO_FSHUB)
+#define UHUB_IS_SINGLE_TT(sc) (UHUB_PROTO(sc) == UDPROTO_HSHUBSTT)
+
+/* prototypes for type checking: */
+
+static device_probe_t uhub_probe;
+static device_attach_t uhub_attach;
+static device_detach_t uhub_detach;
+
+static bus_driver_added_t uhub_driver_added;
+static bus_child_location_str_t uhub_child_location_string;
+static bus_child_pnpinfo_str_t uhub_child_pnpinfo_string;
+
+/*
+ * Hub interrupt.
+ * This an indication that some port has changed status.
+ * Notify the bus event handler thread that we need
+ * to be explored again.
+ */
+static void
+uhub_interrupt(struct usbd_xfer *xfer)
+{
+	USBD_CHECK_STATUS(xfer);
+
+ tr_transferred:
+	usb_needs_explore(((struct uhub_softc *)(xfer->priv_sc))->sc_hub);
+
+ tr_setup:
+ tr_error:
+	/* re-transfer xfer->buffer;
+	 * xfer->length is unchanged
+	 */
+	usbd_start_hardware(xfer);
+	return;
+}
+
+static usbd_status
+uhub_explore(struct usbd_device *udev)
+{
+	usb_hub_descriptor_t *hd = &udev->hub->hubdesc;
+	struct uhub_softc *sc = udev->hub->hubsoftc;
+	struct usbd_port *up;
+	usbd_status err;
+	int speed;
+	int port;
+	int change, status;
+
+	DPRINTFN(10, ("udev=%p addr=%d\n", udev, udev->address));
+
+	if (!sc->sc_running)
+	{
+		return (USBD_NOT_STARTED);
+	}
+
+	/* ignore hubs that are too deep */
+	if(udev->depth > USB_HUB_MAX_DEPTH)
+	{
+		return (USBD_TOO_DEEP);
+	}
+
+	for(port = 1; port <= hd->bNbrPorts; port++)
+	{
+		up = &udev->hub->ports[port-1];
+		err = usbreq_get_port_status(udev, port, &up->status);
+		if (err)
+		{
+			DPRINTF(("get port status failed, "
+				 "error=%s\n", usbd_errstr(err)));
+			continue;
+		}
+		status = UGETW(up->status.wPortStatus);
+		change = UGETW(up->status.wPortChange);
+		DPRINTFN(3,("%s: port %d status 0x%04x 0x%04x\n",
+			    device_get_nameunit(sc->sc_dev), port, status, change));
+		if(change & UPS_C_PORT_ENABLED)
+		{
+			DPRINTF(("C_PORT_ENABLED 0x%x\n", change));
+			usbreq_clear_port_feature(udev, port, UHF_C_PORT_ENABLE);
+			if(change & UPS_C_CONNECT_STATUS)
+			{
+				/* ignore the port error
+				 * if the device vanished
+				 */
+			}
+			else if(status & UPS_PORT_ENABLED)
+			{
+				device_printf(sc->sc_dev,
+					      "illegal enable change, port %d\n", port);
+			}
+			else
+			{
+				/* port error condition */
+				if(up->restartcnt) /* no message first time */
+				{
+					device_printf(sc->sc_dev,
+						      "port error, restarting "
+						      "port %d\n", port);
+				}
+
+				if(up->restartcnt++ < USBD_RESTART_MAX)
+					goto disconnect;
+				else
+					device_printf(sc->sc_dev,
+						      "port error, giving up "
+						      "port %d\n", port);
+			}
+		}
+		if(!(change & UPS_C_CONNECT_STATUS))
+		{
+			DPRINTFN(3,("port=%d !C_CONNECT_"
+				    "STATUS\n", port));
+			/* no status change, just do recursive explore */
+			if(up->device != NULL)
+			{
+				if(up->device->hub != NULL)
+				{
+					(up->device->hub->explore)(up->device);
+				}
+				else
+				{
+					/* allow drivers to be hot-plugged */
+
+					if(up->last_refcount != usb_driver_added_refcount)
+					{
+						usbd_probe_and_attach
+						  (sc->sc_dev, port, up);
+					}
+				}
+			}
+#if 0 && defined(DIAGNOSTIC)
+			if((up->device == NULL) &&
+			   (status & UPS_CURRENT_CONNECT_STATUS))
+			{
+				device_printf(sc->sc_dev,
+					      "connected, no device\n");
+			}
+#endif
+			continue;
+		}
+
+		/* we have a connect status change, handle it */
+
+		DPRINTF(("status change hub=%d port=%d\n",
+			 udev->address, port));
+		usbreq_clear_port_feature(udev, port, UHF_C_PORT_CONNECTION);
+		/*usbreq_clear_port_feature(udev, port, UHF_C_PORT_ENABLE);*/
+		/*
+		 * If there is already a device on the port the change status
+		 * must mean that is has disconnected.  Looking at the
+		 * current connect status is not enough to figure this out
+		 * since a new unit may have been connected before we handle
+		 * the disconnect.
+		 */
+	disconnect:
+		if(up->device != NULL)
+		{
+			/* disconnected */
+			DPRINTF(("device addr=%d disappeared "
+				 "on port %d\n", up->device->address, port));
+			usbd_free_device(up, 1);
+			usbreq_clear_port_feature(udev, port,
+						  UHF_C_PORT_CONNECTION);
+		}
+		if(!(status & UPS_CURRENT_CONNECT_STATUS))
+		{
+			/* nothing connected, just ignore it */
+			DPRINTFN(3,("port=%d !CURRENT_CONNECT_STATUS\n",
+				    port));
+			continue;
+		}
+
+		/* connected */
+
+		if(!(status & UPS_PORT_POWER))
+		{
+			device_printf(sc->sc_dev, "strange, connected port %d "
+				      "has no power\n", port);
+		}
+
+		/* wait for maximum device power up time */
+		usbd_delay_ms(udev, USB_PORT_POWERUP_DELAY);
+
+		/* reset port, which implies enabling it */
+		if(usbreq_reset_port(udev, port, &up->status))
+		{
+			device_printf(sc->sc_dev,
+				      "port %d reset failed\n", port);
+			continue;
+		}
+
+		/* get port status again, it might have changed during reset */
+		err = usbreq_get_port_status(udev, port, &up->status);
+		if(err)
+		{
+			DPRINTF(("get port status failed, "
+				 "error=%s\n", usbd_errstr(err)));
+			continue;
+		}
+		status = UGETW(up->status.wPortStatus);
+		change = UGETW(up->status.wPortChange);
+		if(!(status & UPS_CURRENT_CONNECT_STATUS))
+		{
+			/* nothing connected, just ignore it */
+#ifdef DIAGNOSTIC
+			device_printf(sc->sc_dev,
+				      "port %d, device disappeared "
+				      "after reset\n", port);
+#endif
+			continue;
+		}
+
+		/* figure out device speed */
+		speed = 
+		  (status & UPS_HIGH_SPEED) ? USB_SPEED_HIGH :
+		  (status & UPS_LOW_SPEED) ? USB_SPEED_LOW : USB_SPEED_FULL;
+
+		/* get device info and set its address */
+		err = usbd_new_device(sc->sc_dev, udev->bus,
+				      udev->depth + 1, speed, port, up);
+
+		/* XXX retry a few times? */
+		if(err)
+		{
+			DPRINTFN(-1,("usb_new_device failed, "
+				     "error=%s\n", usbd_errstr(err)));
+			/* Avoid addressing problems by disabling. */
+			/* usbd_reset_port(udev, port, &up->status); */
+
+			/*
+			 * The unit refused to accept a new address, or had
+			 * some other serious problem.  Since we cannot leave
+			 * at 0 we have to disable the port instead.
+			 */
+			device_printf(sc->sc_dev, "device problem (%s), "
+				      "disabling port %d\n", usbd_errstr(err), port);
+			usbreq_clear_port_feature(udev, port, UHF_PORT_ENABLE);
+		}
+		else
+		{
+			/* the port set up succeeded, reset error count */
+			up->restartcnt = 0;
+
+			if(up->device->hub)
+			{
+				(up->device->hub->explore)(up->device);
+			}
+		}
+	}
+	return (USBD_NORMAL_COMPLETION);
+}
+
+static int
+uhub_probe(device_t dev)
+{
+        struct usb_attach_arg *uaa = device_get_ivars(dev);
+	usb_device_descriptor_t *dd = usbd_get_device_descriptor(uaa->device);
+
+	DPRINTFN(5,("dd=%p\n", dd));
+	/*
+	 * the subclass for hubs, is ignored,
+	 * because it is 0 for some
+	 * and 1 for others
+	 */
+	if((uaa->iface == NULL) && (dd->bDeviceClass == UDCLASS_HUB))
+	{
+		return (UMATCH_DEVCLASS_DEVSUBCLASS);
+	}
+	return (UMATCH_NONE);
+}
+
+static int
+uhub_attach(device_t dev)
+{
+	struct uhub_softc *sc = device_get_softc(dev);
+	struct usb_attach_arg *uaa = device_get_ivars(dev);
+	struct usbd_device *udev = uaa->device;
+	struct usbd_hub *hub;
+	usbd_status err;
+	usb_device_request_t req;
+	usb_hub_descriptor_t hubdesc;
+	int port, nports, removable, pwrdly;
+	char devinfo[1024];
+
+	/* XXX no range check for devinfo */
+
+	DPRINTFN(1,("\n"));
+
+	sc->sc_hub = udev;
+	sc->sc_dev = dev; 
+
+	err = usbd_set_config_index(udev, 0, 1);
+	if(err)
+	{
+		DPRINTF(("%s: configuration failed, error=%s\n",
+			 device_get_nameunit(dev), usbd_errstr(err)));
+		goto error;
+	}
+
+	/* NOTE: "usbd_set_config_index()" will change
+	 * variables in "udev" !
+	 */
+	DPRINTFN(1,("depth=%d selfpowered=%d, parent=%p, "
+		    "parent->selfpowered=%d\n",
+		    udev->depth,
+		    udev->self_powered, 
+		    udev->powersrc->parent,
+		    udev->powersrc->parent ?
+		    udev->powersrc->parent->self_powered : 0));
+
+	if(udev->depth > USB_HUB_MAX_DEPTH)
+	{
+		device_printf(dev, "hub depth (%d) exceeded, hub ignored\n",
+			      USB_HUB_MAX_DEPTH);
+		goto error;
+	}
+
+	if(!udev->self_powered && 
+	    (udev->powersrc->parent != NULL) &&
+	    (!udev->powersrc->parent->self_powered))
+	{
+		device_printf(dev, "bus powered hub connected to bus powered hub, "
+			      "ignored\n");
+		goto error;
+	}
+
+	/* get hub descriptor */
+
+	DPRINTFN(1,("getting hub descriptor\n"));
+
+	req.bmRequestType = UT_READ_CLASS_DEVICE;
+	req.bRequest = UR_GET_DESCRIPTOR;
+	USETW2(req.wValue, UDESC_HUB, 0);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE);
+
+	err = usbd_do_request(udev, &req, &hubdesc);
+
+	nports = hubdesc.bNbrPorts;
+
+	if(!err && (nports >= 8))
+	{
+		USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE + (nports / 8));
+		err = usbd_do_request(udev, &req, &hubdesc);
+	}
+
+	if(err)
+	{
+		DPRINTF(("%s: getting hub descriptor failed, error=%s\n",
+			 device_get_nameunit(dev), usbd_errstr(err)));
+		goto error;
+	}
+
+	if(hubdesc.bNbrPorts != nports)
+	{
+		DPRINTF(("%s: number of ports changed!\n",
+			 device_get_nameunit(dev)));
+		goto error;
+	}
+
+	if(nports == 0)
+	{
+		DPRINTF(("%s: portless HUB!\n", 
+			 device_get_nameunit(dev)));
+		goto error;
+	}
+
+	udev->hub = malloc((sizeof(hub[0]) + (sizeof(hub[0].ports[0]) * nports)),
+			   M_USBDEV, M_NOWAIT|M_ZERO);
+
+	if(udev->hub == NULL)
+	{
+		goto error;
+	}
+
+	hub = udev->hub;
+
+	hub->hubsoftc = sc;
+	hub->explore = uhub_explore;
+	hub->hubdesc = hubdesc;
+
+	static const struct usbd_config usbd_config[2] =
+	{
+	  [0] = {
+	    .type      = UE_INTERRUPT,
+	    .endpoint  = -1, /* any pipe number */
+	    .direction = -1, /* any pipe direction */
+	    .timeout   = 0,
+	    .flags     = USBD_SHORT_XFER_OK,
+	    .bufsize   = 0x100 / 8,
+	    .callback  = uhub_interrupt,
+	    .interval  = UHUB_INTR_INTERVAL,
+	  },
+
+	  [1] = {
+	    .type      = UE_CONTROL,
+	    .endpoint  = 0,
+	    .direction = -1,
+	    .timeout   = USBD_DEFAULT_TIMEOUT,
+	    .flags     = 0,
+	    .bufsize   = sizeof(usb_device_request_t),
+	    .callback  = &usbd_clearstall_callback,
+	  },
+	};
+
+	/* set up interrupt pipe */
+	err = usbd_transfer_setup(udev, 0, &sc->sc_xfer[0], 
+				  &usbd_config[0], 2, sc, NULL, NULL);
+	if(err) 
+	{
+		device_printf(dev, "cannot open interrupt pipe\n");
+		goto error;
+	}
+
+	/* setup clear stall */
+	sc->sc_xfer[0]->clearstall_xfer = 
+	  sc->sc_xfer[1];
+
+	usbd_transfer_start_safe(sc->sc_xfer[0]);
+
+	/* wait with power off for a while */
+	usbd_delay_ms(udev, USB_POWER_DOWN_TIME);
+
+	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, udev, dev);
+
+	/*
+	 * To have the best chance of success we do things in the exact same
+	 * order as Windoze98.  This should not be necessary, but some
+	 * devices do not follow the USB specs to the letter.
+	 *
+	 * These are the events on the bus when a hub is attached:
+	 *  Get device and config descriptors (see attach code)
+	 *  Get hub descriptor (see above)
+	 *  For all ports
+	 *     turn on power
+	 *     wait for power to become stable
+	 * (all below happens in explore code)
+	 *  For all ports
+	 *     clear C_PORT_CONNECTION
+	 *  For all ports
+	 *     get port status
+	 *     if device connected
+	 *        wait 100 ms
+	 *        turn on reset
+	 *        wait
+	 *        clear C_PORT_RESET
+	 *        get port status
+	 *        proceed with device attachment
+	 */
+
+	/* XXX should check for none, individual, or ganged power? */
+
+	removable = 0;
+	pwrdly = (hubdesc.bPwrOn2PwrGood * UHD_PWRON_FACTOR) +
+			USB_EXTRA_POWER_UP_TIME;
+
+	for(port = 1;
+	    port <= nports;
+	    port++)
+	{
+		/* set up data structures */
+		struct usbd_port *up = &hub->ports[port-1];
+		up->device = NULL;
+		up->parent = udev;
+		up->portno = port;
+
+		/* self powered hub, give ports maximum current */
+		up->power = (udev->self_powered) ? 
+		  USB_MAX_POWER :
+		  USB_MIN_POWER ;
+
+		up->restartcnt = 0;
+
+		/* check if port is removable */
+		if(!UHD_NOT_REMOV(&hubdesc, port))
+		{
+			removable++;
+		}
+
+		/* turn the power on */
+		err = usbreq_set_port_feature(udev, port, UHF_PORT_POWER);
+		if(err)
+		{
+			device_printf(dev, "port %d power on failed, %s\n",
+				      port, usbd_errstr(err));
+		}
+		DPRINTF(("turn on port %d power\n", port));
+
+		/* wait for stable power */
+		usbd_delay_ms(udev, pwrdly);
+	}
+
+	usbd_devinfo(udev, 1, &devinfo[0]);
+	device_set_desc_copy(dev, &devinfo[0]);
+	device_printf(dev, "%s\n", &devinfo[0]);
+	device_printf(dev, "%d port%s with %d "
+		      "removable, %s powered\n",
+		      nports, (nports != 1) ? "s" : "",
+		      removable, udev->self_powered ? "self" : "bus");
+
+	/* the usual exploration will finish the setup */
+
+	sc->sc_running = 1;
+	return 0;
+
+ error:
+	if(udev->hub)
+	{
+		free(udev->hub, M_USBDEV);
+	}
+	udev->hub = NULL;
+	return ENXIO;
+}
+
+/*
+ * Called from process context when the hub is gone.
+ * Detach all devices on active ports.
+ */
+static int
+uhub_detach(device_t dev)
+{
+        struct uhub_softc *sc = device_get_softc(dev);
+	struct usbd_hub *hub = sc->sc_hub->hub;
+	struct usbd_port *up;
+	int port, nports;
+
+	DPRINTF(("sc=%port\n", sc));
+
+	if(hub == NULL)		/* must be partially working */
+	{
+		return (0);
+	}
+
+	nports = hub->hubdesc.bNbrPorts;
+	for(port = 0;
+	    port < nports;
+	    port++)
+	{
+		up = &hub->ports[port];
+		if(up->device)
+		{
+			/* subdevices are not freed, because
+			 * the caller of uhub_detach() will
+			 * do that
+			 */
+			usbd_free_device(up, 0);
+		}
+	}
+
+	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_hub,
+			   sc->sc_dev);
+
+	usbd_transfer_unsetup(&sc->sc_xfer[0], 2);
+
+	free(hub, M_USBDEV);
+	sc->sc_hub->hub = NULL;
+	return (0);
+}
+
+static void
+uhub_driver_added(device_t dev, driver_t *driver)
+{
+	usb_needs_probe_and_attach();
+	return;
+}
+
+static int
+uhub_child_location_string(device_t parent, device_t child, 
+			   char *buf, size_t buflen)
+{
+	struct uhub_softc *sc = device_get_softc(parent);
+	struct usbd_hub *hub = sc->sc_hub->hub;
+	struct usbd_device *udev;
+	int port, nports, iface_index;
+
+	mtx_lock(&usb_global_lock);
+
+	nports = hub->hubdesc.bNbrPorts;
+        for(port = 0;
+            port < nports;
+            port++)
+        {
+		udev = hub->ports[port].device;
+		if(udev)
+		{
+			device_t * subdev = 
+			  &udev->subdevs[0];
+			device_t * subdev_end = 
+			  &udev->subdevs_end[0];
+
+			iface_index = 0;
+
+			while(subdev < subdev_end)
+			{
+				if(subdev[0] == child)
+				{
+					goto found;
+				}
+
+				subdev++;
+				iface_index++;
+			}
+		}
+	}
+
+	mtx_unlock(&usb_global_lock);
+
+	DPRINTFN(0,("device not on hub\n"));
+
+	if(buflen)
+	{
+		buf[0] = '\0';
+	}
+
+	return 0;
+
+
+ found:
+
+	if(udev->probed == USBD_PROBED_IFACE_AND_FOUND)
+	{
+		snprintf(buf, buflen, "port=%i interface=%i",
+			 port, iface_index);
+	}
+	else
+	{
+                snprintf(buf, buflen, "port=%i", port);
+	}
+
+	mtx_unlock(&usb_global_lock);
+
+        return (0);
+}
+
+static int
+uhub_child_pnpinfo_string(device_t parent, device_t child, 
+			  char *buf, size_t buflen)
+{
+	struct uhub_softc *sc = device_get_softc(parent);
+	struct usbd_hub *hub = sc->sc_hub->hub;
+        struct usbd_interface *iface;
+	struct usbd_device *udev;
+	int port, nports, iface_index;
+
+	mtx_lock(&usb_global_lock);
+
+	nports = hub->hubdesc.bNbrPorts;
+        for(port = 0;
+            port < nports;
+            port++)
+        {
+		udev = hub->ports[port].device;
+		if(udev)
+		{
+			device_t * subdev = 
+			  &udev->subdevs[0];
+			device_t * subdev_end = 
+			  &udev->subdevs_end[0];
+
+			iface_index = 0;
+
+			while(subdev < subdev_end)
+			{
+				if(subdev[0] == child)
+				{
+					goto found;
+				}
+
+				subdev++;
+				iface_index++;
+			}
+		}
+	}
+
+	mtx_unlock(&usb_global_lock);
+
+	DPRINTFN(0,("device not on hub\n"));
+
+	if(buflen)
+	{
+		buf[0] = '\0';
+	}
+
+	return 0;
+
+ found:
+
+	iface = usbd_get_iface(udev, iface_index);
+
+	if((udev->probed == USBD_PROBED_IFACE_AND_FOUND) &&
+	   iface && iface->idesc)
+	{
+		snprintf(buf, buflen, "vendor=0x%04x product=0x%04x "
+			 "devclass=0x%02x devsubclass=0x%02x "
+			 "sernum=\"%s\" "
+			 "intclass=0x%02x intsubclass=0x%02x",
+			 UGETW(udev->ddesc.idVendor),
+			 UGETW(udev->ddesc.idProduct),
+			 udev->ddesc.bDeviceClass,
+			 udev->ddesc.bDeviceSubClass,
+			 &udev->serial[0],
+			 iface->idesc->bInterfaceClass,
+			 iface->idesc->bInterfaceSubClass);
+	}
+	else
+	{
+		snprintf(buf, buflen, "vendor=0x%04x product=0x%04x "
+			 "devclass=0x%02x devsubclass=0x%02x "
+			 "sernum=\"%s\"",
+			 UGETW(udev->ddesc.idVendor), 
+			 UGETW(udev->ddesc.idProduct),
+			 udev->ddesc.bDeviceClass, 
+			 udev->ddesc.bDeviceSubClass,
+			 &udev->serial[0]);
+	}
+
+	mtx_unlock(&usb_global_lock);
+
+        return (0);
+}
+
+/*
+ * driver instance for "hub" connected to "usb" 
+ * and "hub" connected to "hub"
+ */
+static devclass_t uhub_devclass;
+
+static driver_t uhub_driver =
+{
+	.name    = "uhub",
+	.methods = (device_method_t [])
+        {
+	  DEVMETHOD(device_probe, uhub_probe),
+	  DEVMETHOD(device_attach, uhub_attach),
+	  DEVMETHOD(device_detach, uhub_detach),
+
+	  DEVMETHOD(device_suspend, bus_generic_suspend),
+	  DEVMETHOD(device_resume, bus_generic_resume),
+	  DEVMETHOD(device_shutdown, bus_generic_shutdown),
+
+	  DEVMETHOD(bus_child_location_str, uhub_child_location_string),
+	  DEVMETHOD(bus_child_pnpinfo_str, uhub_child_pnpinfo_string),
+	  DEVMETHOD(bus_driver_added, uhub_driver_added),
+	  {0,0}
+	},
+	.size    = sizeof(struct uhub_softc)
+};
+
+DRIVER_MODULE(uhub, usb, uhub_driver, uhub_devclass, 0, 0);
+MODULE_DEPEND(uhub, usb, 1, 1, 1);
+
+DRIVER_MODULE(uhub, uhub, uhub_driver, uhub_devclass, usbd_driver_load, 0);
diff -rubN /usr/src1/src/sys/dev/usb2/_usb.c /usr/src/sys/dev/usb2/_usb.c
--- /usr/src1/src/sys/dev/usb2/_usb.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_usb.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,1105 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * USB specifications and other documentation can be found at
+ * http://www.usb.org/developers/docs/ and
+ * http://www.usb.org/developers/devclass_docs/
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <sys/uio.h> /* UIO_XXX */
+#include <sys/proc.h>
+#include <sys/unistd.h>
+#include <sys/filio.h> /* FXXX */
+#include <sys/ioccom.h> /* IOR()/IOW()/IORW() */
+#include <sys/kthread.h>
+#include <sys/poll.h>
+#include <sys/signalvar.h>
+#include <sys/vnode.h>
+
+#include <machine/bus.h>
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/usb_quirks.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb2/usb.c $");
+
+#define DEV2UNIT(d)	(minor(d))
+#define DEV2BUS(d)	(*((struct usbd_bus **)&((d)->si_drv1)))
+
+#define USB_DEV_MINOR	255		/* event queue device */
+
+MALLOC_DEFINE(M_USB, "USB", "USB");
+MALLOC_DEFINE(M_USBDEV, "USBdev", "USB device");
+MALLOC_DEFINE(M_USBHC, "USBHC", "USB host controller");
+
+/* define this unconditionally in case a kernel module is loaded that
+ * has been compiled with debugging options.
+ */
+SYSCTL_NODE(_hw, OID_AUTO, usb, CTLFLAG_RW, 0, "USB debugging");
+
+#ifdef USB_DEBUG
+int	usbdebug = 0;
+SYSCTL_INT(_hw_usb, OID_AUTO, debug, CTLFLAG_RW,
+	   &usbdebug, 0, "usb debug level");
+
+/*
+ * 0  - do usual exploration
+ * 1  - do not use timeout exploration
+ * >1 - do no exploration
+ */
+int	usb_noexplore = 0;
+#endif
+
+#define USB_MAX_EVENTS 100
+struct usb_event_wrapper
+{
+	struct usb_event ue;
+	TAILQ_ENTRY(usb_event_wrapper) next;
+};
+
+static TAILQ_HEAD(, usb_event_wrapper) usb_events =
+	TAILQ_HEAD_INITIALIZER(usb_events);
+
+#ifndef usb_global_lock
+struct mtx usb_global_lock;
+#endif
+
+/* these variables are protected by "usb_global_lock" */
+static int usb_nevents = 0;
+static struct selinfo usb_selevent;
+static struct proc *usb_async_proc;  /* process that wants USB SIGIO */
+static int usb_dev_open = 0;
+
+/**/
+static const char * const usbrev_str[] = USBREV_STR;
+
+/* 
+ * usb_discover - explore the device tree from the root
+ * 
+ * usb_discover device nodes, kthread
+ */
+static void
+usb_discover(struct usbd_bus *bus)
+{
+	PRINTFN(2,("\n"));
+
+#ifdef USB_DEBUG
+	if(usb_noexplore > 1)
+	{
+		return;
+	}
+#endif
+	mtx_assert(&usb_global_lock, MA_OWNED);
+
+	/* check that only one thread is exploring
+	 * at a time
+	 */
+	while(bus->is_exploring)
+	{
+		bus->wait_explore = 1;
+
+		msleep(&bus->wait_explore, &usb_global_lock, PWAIT,
+		       "usb wait explore", 0);
+	}
+
+	bus->is_exploring = 1;
+
+	while(bus->root_port.device &&
+	      bus->root_port.device->hub &&
+	      bus->needs_explore &&
+	      (bus->wait_explore == 0))
+	{
+		bus->needs_explore = 0;
+
+		/* explore the hub 
+		 * (this call can sleep,
+		 *  exiting usb_global_lock, 
+		 *  which is actually Giant)
+		 */
+		(bus->root_port.device->hub->explore)
+		  (bus->root_port.device);
+	}
+
+	bus->is_exploring = 0;
+
+	if(bus->wait_explore)
+	{
+		bus->wait_explore = 0;
+		wakeup(&bus->wait_explore);
+	}
+	return;
+}
+
+static void
+usb_event_thread(struct usbd_bus *bus)
+{
+	mtx_lock(&usb_global_lock);
+
+	while(1)
+	{
+		if(bus->root_port.device == 0)
+		{
+			break;
+		}
+
+#ifdef USB_DEBUG
+		if(usb_noexplore < 2)
+#endif
+		{
+			usb_discover(bus);
+		}
+
+#ifdef USB_DEBUG
+		msleep(&bus->needs_explore, &usb_global_lock, PWAIT,
+		       "usbevt", usb_noexplore ? 0 : hz * 60);
+#else
+		msleep(&bus->needs_explore, &usb_global_lock, PWAIT,
+		       "usbevt", hz * 60);
+#endif
+		PRINTFN(2,("woke up\n"));
+	}
+
+	bus->event_thread = NULL;
+
+	/* in case parent is waiting for us to exit */
+	wakeup(bus);
+
+	mtx_unlock(&usb_global_lock);
+
+	PRINTF(("exit\n"));
+
+	kthread_exit(0);
+
+	return;
+}
+
+void
+usb_needs_explore(struct usbd_device *udev)
+{
+	PRINTFN(2,("\n"));
+
+	mtx_lock(&usb_global_lock);
+	udev->bus->needs_explore = 1;
+	wakeup(&udev->bus->needs_explore);
+	mtx_unlock(&usb_global_lock);
+	return;
+}
+
+u_int8_t usb_driver_added_refcount;
+
+void
+usb_needs_probe_and_attach(void)
+{
+	struct usbd_bus *bus;
+	devclass_t dc;
+	device_t dev;
+	int max;
+
+	PRINTFN(2,("\n"));
+
+	mtx_lock(&usb_global_lock);
+
+	usb_driver_added_refcount++;
+
+	dc = devclass_find("usb");
+
+	if(dc)
+	{
+	    max = devclass_get_maxunit(dc);
+ 	    while(max >= 0)
+	    {
+	        dev = devclass_get_device(dc, max);
+		if(dev)
+		{
+		    bus = device_get_softc(dev);
+
+		    bus->needs_explore = 1;
+		    wakeup(&bus->needs_explore);
+		}
+		max--;
+	    }
+	}
+	else
+	{
+	    printf("%s: \"usb\" devclass not present!\n",
+		   __FUNCTION__);
+	}
+	mtx_unlock(&usb_global_lock);
+	return;
+}
+
+static void
+usb_create_event_thread(struct usbd_bus *bus)
+{
+	if(usb_kthread_create1((void*)(void*)&usb_event_thread, bus, &bus->event_thread,
+			       "%s", device_get_nameunit(bus->bdev)))
+	{
+		device_printf(bus->bdev, "unable to create event thread for\n");
+		panic("usb_create_event_thread");
+	}
+	return;
+}
+
+static int
+usb_event_get_next(struct usb_event *ue)
+{
+	struct usb_event_wrapper *uew;
+	int err;
+
+	mtx_lock(&usb_global_lock);
+
+	uew = TAILQ_FIRST(&usb_events);
+
+	if(uew == NULL)
+	{
+		usb_nevents = 0;
+		err = 0;
+	}
+	else
+	{
+		*ue = uew->ue;
+
+		TAILQ_REMOVE(&usb_events, uew, next);
+
+		free(uew, M_USBDEV);
+
+		if(usb_nevents)
+		{
+		   usb_nevents--;
+		}
+		err = 1;
+	}
+	mtx_unlock(&usb_global_lock);
+	return (err);
+}
+
+static void
+usb_event_add(int type, struct usb_event *uep)
+{
+	struct usb_event_wrapper *uew;
+	struct timeval thetime;
+
+	uew = malloc(sizeof *uew, M_USBDEV, M_WAITOK|M_ZERO);
+	if(uew == NULL)
+	{
+		return;
+	}
+	uew->ue = *uep;
+	uew->ue.ue_type = type;
+	microtime(&thetime);
+	TIMEVAL_TO_TIMESPEC(&thetime, &uew->ue.ue_time);
+
+	mtx_lock(&usb_global_lock);
+
+	if(USB_EVENT_IS_DETACH(type))
+	{
+		struct usb_event_wrapper *uewi, *uewi_next;
+
+		for (uewi = TAILQ_FIRST(&usb_events);
+		     uewi;
+		     uewi = uewi_next)
+		{
+			uewi_next = TAILQ_NEXT(uewi, next);
+			if(uewi->ue.u.ue_driver.ue_cookie.cookie ==
+			    uep->u.ue_device.udi_cookie.cookie)
+			{
+				TAILQ_REMOVE(&usb_events, uewi, next);
+				free(uewi, M_USBDEV);
+				usb_nevents--;
+				uewi_next = TAILQ_FIRST(&usb_events);
+			}
+		}
+	}
+	if(usb_nevents >= USB_MAX_EVENTS)
+	{
+		/* too many queued events, drop an old one */
+		PRINTF(("event dropped\n"));
+
+		struct usb_event ue;
+		(void)usb_event_get_next(&ue);
+	}
+	TAILQ_INSERT_TAIL(&usb_events, uew, next);
+	usb_nevents++;
+	wakeup(&usb_events);
+	selwakeuppri(&usb_selevent, PZERO);
+	if(usb_async_proc != NULL)
+	{
+		PROC_LOCK(usb_async_proc);
+		psignal(usb_async_proc, SIGIO);
+		PROC_UNLOCK(usb_async_proc);
+	}
+
+	mtx_unlock(&usb_global_lock);
+	return;
+}
+
+void
+usbd_add_dev_event(int type, struct usbd_device *udev)
+{
+	struct usb_event ue;
+
+	bzero(&ue, sizeof(ue));
+
+	usbd_fill_deviceinfo(udev, &ue.u.ue_device,
+			     USB_EVENT_IS_ATTACH(type));
+	usb_event_add(type, &ue);
+	return;
+}
+
+void
+usbd_add_drv_event(int type, struct usbd_device *udev, device_t dev)
+{
+	struct usb_event ue;
+
+	bzero(&ue, sizeof(ue));
+
+	ue.u.ue_driver.ue_cookie = udev->cookie;
+	strncpy(ue.u.ue_driver.ue_devname, device_get_nameunit(dev),
+		sizeof ue.u.ue_driver.ue_devname);
+	usb_event_add(type, &ue);
+	return;
+}
+
+/* called from uhci_pci_attach */
+
+static int
+usb_probe(device_t dev)
+{
+	PRINTF(("\n"));
+	return (UMATCH_GENERIC);
+}
+
+extern cdevsw_t usb_cdevsw;
+
+static void
+__usb_attach(device_t dev, struct usbd_bus *bus)
+{
+	usbd_status err;
+	u_int8_t speed;
+	struct usb_event ue;
+	struct cdev *cdev;
+
+	PRINTF(("\n"));
+
+	mtx_assert(&usb_global_lock, MA_OWNED);
+
+	bus->root_port.power = USB_MAX_POWER;
+
+	device_printf(bus->bdev, "USB revision %s",
+		      usbrev_str[bus->usbrev]);
+
+	switch (bus->usbrev)
+	{
+	case USBREV_1_0:
+	case USBREV_1_1:
+		speed = USB_SPEED_FULL;
+		break;
+
+	case USBREV_2_0:
+		speed = USB_SPEED_HIGH;
+		break;
+
+	default:
+		printf(", not supported\n");
+		return;
+	}
+
+	printf("\n");
+
+	/* make sure not to use tsleep() if we are cold booting */
+	if(cold)
+	{
+		bus->use_polling++;
+	}
+
+	ue.u.ue_ctrlr.ue_bus = device_get_unit(bus->bdev);
+	usb_event_add(USB_EVENT_CTRLR_ATTACH, &ue);
+
+	err = usbd_new_device(bus->bdev, bus, 0, speed, 0,
+			      &bus->root_port);
+	if(!err)
+	{
+		if(bus->root_port.device->hub == NULL)
+		{
+			device_printf(bus->bdev, 
+				      "root device is not a hub\n");
+			return;
+		}
+
+		/*
+		 * the USB bus is explored here so that devices, 
+		 * for example the keyboard, can work during boot
+		 */
+
+		/* make sure that the bus is explored */
+		bus->needs_explore = 1;
+
+		usb_discover(bus);
+	}
+	else
+	{
+		device_printf(bus->bdev, "root hub problem, error=%s\n",
+			      usbd_errstr(err));
+	}
+
+	if(cold)
+	{
+		bus->use_polling--;
+	}
+
+	usb_create_event_thread(bus);
+
+	/* the per controller devices (used for usb_discover) */
+	/* XXX This is redundant now, but old usbd's will want it */
+	cdev = make_dev(&usb_cdevsw, device_get_unit(dev), UID_ROOT, GID_OPERATOR,
+			0660, "usb%d", device_get_unit(dev));
+
+	if(cdev)
+	{
+		DEV2BUS(cdev) = bus;
+	}
+	return;
+}
+
+static u_int8_t usb_post_init_called = 0;
+
+static int
+usb_attach(device_t dev)
+{
+	struct usbd_bus *bus = device_get_softc(dev);
+
+	mtx_lock(&usb_global_lock);
+
+	if(usb_post_init_called != 0)
+	{
+		__usb_attach(dev, bus);
+	}
+
+	mtx_unlock(&usb_global_lock);
+
+	USB_ATTACH_SUCCESS_RETURN;
+}
+
+static void
+usb_post_init(void *arg)
+{
+	struct usbd_bus *bus;
+	devclass_t dc;
+	device_t dev;
+	int max;
+	int n;
+
+	mtx_lock(&usb_global_lock);
+
+	dc = devclass_find("usb");
+
+	if(dc)
+	{
+	    max = devclass_get_maxunit(dc);
+	    for(n = 0; n <= max; n++)
+	    {
+	        dev = devclass_get_device(dc, n);
+		if(dev)
+		{
+		    bus = device_get_softc(dev);
+
+		    __usb_attach(dev, bus);
+		}
+	    }
+	}
+	else
+	{
+	    printf("%s: \"usb\" devclass not present!\n",
+		   __FUNCTION__);
+	}
+
+	usb_post_init_called = 1;
+
+	mtx_unlock(&usb_global_lock);
+
+	return;
+}
+
+SYSINIT(usb_post_init, SI_SUB_PSEUDO, SI_ORDER_ANY, usb_post_init, NULL);
+
+static int
+usb_detach(device_t dev, int flags)
+{
+	struct usbd_bus *bus = device_get_softc(dev);
+	struct usb_event ue;
+
+	PRINTF(("start\n"));
+
+	mtx_lock(&usb_global_lock);
+
+	/* wait for any possible explore calls to finish */
+	while(bus->is_exploring)
+	{
+		bus->wait_explore = 1;
+
+		msleep(&bus->wait_explore, &usb_global_lock, PWAIT,
+		       "usb wait explore", 0);
+	}
+
+	if(bus->root_port.device != NULL)
+	{
+		/* free device, but not sub-devices,
+		 * hence they are freed by the 
+		 * caller of this function
+		 */
+		usbd_free_device(&bus->root_port, 0);
+	}
+
+	/* kill off event thread */
+	if(bus->event_thread != NULL)
+	{
+		wakeup(&bus->needs_explore);
+
+		if(msleep(bus, &usb_global_lock, PWAIT, "usbdet", hz * 60))
+		{
+			device_printf(bus->bdev,
+				      "event thread didn't die\n");
+		}
+		PRINTF(("event thread dead\n"));
+	}
+
+	mtx_unlock(&usb_global_lock);
+
+	ue.u.ue_ctrlr.ue_bus = device_get_unit(bus->bdev);
+	usb_event_add(USB_EVENT_CTRLR_DETACH, &ue);
+
+	mtx_lock(&bus->mtx);
+	if(bus->bdev == dev)
+	{
+		/* need to clear bus->bdev
+		 * here so that the parent
+		 * detach routine does not
+		 * free this device again
+		 */
+		bus->bdev = NULL;
+	}
+	else
+	{
+		device_printf(dev, "unexpected bus->bdev value!\n");
+	}
+	mtx_unlock(&bus->mtx);
+	return (0);
+}
+
+static int
+usbopen(struct cdev *dev, int flag, int mode, struct thread *proc)
+{
+	int error = 0;
+
+	mtx_lock(&usb_global_lock);
+
+	if(DEV2UNIT(dev) == USB_DEV_MINOR)
+	{
+		if(usb_dev_open)
+		{
+			error = EBUSY;
+			goto done;
+		}
+		usb_dev_open = 1;
+		usb_async_proc = 0;
+	}
+	else
+	{
+		struct usbd_bus *bus = DEV2BUS(dev);
+
+		if(bus->root_port.device == NULL)
+		{
+			/* device is beeing detached */
+			error = EIO;
+			goto done;
+		}
+	}
+
+ done:
+	mtx_unlock(&usb_global_lock);
+	return (error);
+}
+
+static int
+usbread(struct cdev *dev, struct uio *uio, int flag)
+{
+	struct usb_event ue;
+	int error = 0;
+
+	if(DEV2UNIT(dev) != USB_DEV_MINOR)
+	{
+		return (ENODEV);
+	}
+
+	if(uio->uio_resid != sizeof(struct usb_event))
+	{
+		return (EINVAL);
+	}
+
+	mtx_lock(&usb_global_lock);
+
+	for(;;)
+	{
+		if(usb_event_get_next(&ue) != 0)
+		{
+			break;
+		}
+		if(flag & IO_NDELAY)
+		{
+			error = EWOULDBLOCK;
+			break;
+		}
+		error = msleep(&usb_events, &usb_global_lock,
+			       (PZERO|PCATCH), "usbrea", 0);
+		if(error)
+		{
+			break;
+		}
+	}
+
+	mtx_unlock(&usb_global_lock);
+
+	if(!error)
+	{
+		error = uiomove((void *)&ue, uio->uio_resid, uio);
+	}
+	return (error);
+}
+
+static int
+usbclose(struct cdev *dev, int flag, int mode, struct thread *proc)
+{
+	if(DEV2UNIT(dev) == USB_DEV_MINOR)
+	{
+		mtx_lock(&usb_global_lock);
+
+		usb_async_proc = 0;
+		usb_dev_open = 0;
+
+		mtx_unlock(&usb_global_lock);
+	}
+	return (0);
+}
+
+static int
+usbioctl(struct cdev *dev, u_long cmd, caddr_t data, int flag, struct thread *p)
+{
+	int error = 0;
+
+	mtx_lock(&usb_global_lock);
+
+	if(DEV2UNIT(dev) == USB_DEV_MINOR)
+	{
+		switch (cmd)
+		{
+		case FIONBIO:
+			/* all handled in the upper FS layer */
+			break;
+
+		case FIOASYNC:
+			if(*(int *)data)
+#if __FreeBSD_version >= 500000
+				usb_async_proc = p->td_proc;
+#else
+				usb_async_proc = p;
+#endif
+			else
+				usb_async_proc = 0;
+
+			break;
+
+		default:
+			error = EINVAL;
+			break;
+		}
+	}
+	else
+	{
+		struct usbd_bus *bus = DEV2BUS(dev);
+
+		if(bus->root_port.device == NULL)
+		{
+			/* detached */
+			error = EIO;
+			goto done;
+		}
+
+		switch (cmd)
+		{
+#if defined(__FreeBSD__)
+		/* this part should be deleted */
+		case USB_DISCOVER:
+			break;
+#endif
+		case USB_REQUEST:
+		{
+			struct usb_ctl_request *ur = (void *)data;
+			int len = UGETW(ur->ucr_request.wLength);
+			struct iovec iov;
+			struct uio uio;
+			void *ptr = 0;
+			int addr = ur->ucr_addr;
+			usbd_status err;
+			int error = 0;
+
+			PRINTF(("USB_REQUEST addr=%d len=%d\n", addr, len));
+			if((len < 0) ||
+			   (len > 32768))
+			{
+				error = EINVAL;
+				goto done;
+			}
+
+			if((addr < 0) || 
+			   (addr >= USB_MAX_DEVICES) ||
+			   (bus->devices[addr] == 0 /* might be checked by usbd_do_request_flags */))
+			{
+				error = EINVAL;
+				goto done;
+			}
+
+			if(len != 0)
+			{
+				iov.iov_base = (caddr_t)ur->ucr_data;
+				iov.iov_len = len;
+				uio.uio_iov = &iov;
+				uio.uio_iovcnt = 1;
+				uio.uio_resid = len;
+				uio.uio_offset = 0;
+				uio.uio_segflg = UIO_USERSPACE;
+				uio.uio_rw =
+				  ur->ucr_request.bmRequestType & UT_READ ?
+				  UIO_READ : UIO_WRITE;
+				uio.uio_procp = p;
+				ptr = malloc(len, M_TEMP, M_WAITOK);
+				if(uio.uio_rw == UIO_WRITE)
+				{
+					error = uiomove(ptr, len, &uio);
+					if(error)
+					{
+						goto ret;
+					}
+				}
+			}
+			err = usbd_do_request_flags
+			  (bus->devices[addr], &ur->ucr_request, ptr,
+			   ur->ucr_flags, &ur->ucr_actlen,
+			   USBD_DEFAULT_TIMEOUT);
+			if(err)
+			{
+				error = EIO;
+				goto ret;
+			}
+			if(len != 0)
+			{
+				if(uio.uio_rw == UIO_READ)
+				{
+					error = uiomove(ptr, len, &uio);
+					if(error)
+					{
+						goto ret;
+					}
+				}
+			}
+		ret:
+			if(ptr)
+			{
+				free(ptr, M_TEMP);
+			}
+			goto done;
+		}
+
+		case USB_DEVICEINFO:
+		{
+			struct usb_device_info *di = (void *)data;
+			int addr = di->udi_addr;
+
+			if((addr < 1) ||
+			   (addr >= USB_MAX_DEVICES) ||
+			   (bus->devices[addr] == 0))
+			{
+				error = EINVAL;
+				goto done;
+			}
+
+			error = usbd_fill_deviceinfo(bus->devices[addr], di, 1);
+			goto done;
+		}
+
+		case USB_DEVICESTATS:
+			*(struct usb_device_stats *)data = bus->stats;
+			break;
+
+		default:
+			error = EINVAL;
+			break;
+		}
+	}
+
+ done:
+	mtx_unlock(&usb_global_lock);
+	return (error);
+}
+
+static int
+usbpoll(struct cdev *dev, int events, struct thread *td)
+{
+	int revents, mask;
+	int unit = DEV2UNIT(dev);
+
+	if(unit == USB_DEV_MINOR)
+	{
+		revents = 0;
+		mask = POLLIN | POLLRDNORM;
+
+		mtx_lock(&usb_global_lock);
+
+		if((events & mask) && (usb_nevents > 0))
+		{
+			revents |= events & mask;
+		}
+		if((revents == 0) && (events & mask))
+		{
+			selrecord(td, &usb_selevent);
+		}
+
+		mtx_unlock(&usb_global_lock);
+
+		return (revents);
+	}
+	else
+	{
+		/* select/poll never wakes up - back compat */
+		return 0;
+	}
+}
+
+cdevsw_t usb_cdevsw = {
+#ifdef D_VERSION
+	.d_version =	D_VERSION,
+#endif
+	.d_open =	usbopen,
+	.d_close =	usbclose,
+	.d_read =	usbread,
+	.d_ioctl =	usbioctl,
+	.d_poll =	usbpoll,
+	.d_name =	"usb",
+};
+
+static void
+usb_init(void *arg)
+{
+	struct cdev *cdev;
+
+#ifndef usb_global_lock
+	mtx_init(&usb_global_lock, "usb_global_lock",
+		 NULL, MTX_DEF|MTX_RECURSE);
+#endif
+	/* the device spitting out events */
+	cdev = make_dev(&usb_cdevsw, USB_DEV_MINOR, UID_ROOT, 
+			GID_OPERATOR, 0660, "usb");
+
+	if(cdev)
+	{
+		DEV2BUS(cdev) = NULL;
+	}
+	return;
+}
+
+SYSINIT(usb_init, SI_SUB_DRIVERS, SI_ORDER_FIRST, usb_init, NULL);
+
+#ifdef __FreeBSD__
+static void
+bus_dmamap_load_callback(void *arg, bus_dma_segment_t *segs, int nseg, int error)
+{
+	((u_int32_t *)arg)[0] = segs->ds_addr;
+
+	if(error)
+	{
+	    printf("%s: %s: error=%d\n",
+		   __FILE__, __FUNCTION__, error);
+	}
+	return;
+}
+
+struct usb_dma {
+	struct bus_dma_tag *	tag;
+	struct bus_dmamap *	map;
+	bus_size_t		physaddr;
+} __packed;
+
+void *
+usb_alloc_mem(struct bus_dma_tag *tag, u_int32_t size, u_int8_t align_power)
+{
+	struct bus_dmamap *map;
+	bus_size_t physaddr = 0;
+	void *ptr;
+
+	size += sizeof(struct usb_dma);
+
+	if(tag == NULL)
+	{
+	  if(bus_dma_tag_create
+	   ( /* parent    */NULL,
+	     /* alignment */(1 << align_power),
+	     /* boundary  */0,
+	     /* lowaddr   */BUS_SPACE_MAXADDR_32BIT,
+	     /* highaddr  */BUS_SPACE_MAXADDR,
+	     /* filter    */NULL,
+	     /* filterarg */NULL,
+	     /* maxsize   */size,
+	     /* nsegments */1,
+	     /* maxsegsz  */size,
+	     /* flags     */0,
+#if __FreeBSD_version >= 500000
+	     /* lock      */NULL,
+	     /*           */NULL,
+#endif
+	     &tag))
+	  {
+		return NULL;
+
+	  }
+	}
+
+	if(bus_dmamem_alloc
+	   (tag, &ptr, (BUS_DMA_NOWAIT|BUS_DMA_COHERENT), &map))
+	{
+		bus_dma_tag_destroy(tag);
+		return NULL;
+	}
+
+	if(bus_dmamap_load
+	   (tag, map, ptr, size, &bus_dmamap_load_callback, 
+	    &physaddr, (BUS_DMA_NOWAIT|BUS_DMA_COHERENT)))
+	{
+		bus_dmamem_free(tag, ptr, map);
+		bus_dma_tag_destroy(tag);
+		return NULL;
+	}
+
+	size -= sizeof(struct usb_dma);
+
+	((struct usb_dma *)(((u_int8_t *)ptr) + size))->tag = tag;
+	((struct usb_dma *)(((u_int8_t *)ptr) + size))->map = map;
+	((struct usb_dma *)(((u_int8_t *)ptr) + size))->physaddr = physaddr;
+
+#ifdef USB_DEBUG
+	if(usbdebug > 14)
+	{
+	    printf("%s: %p, %d bytes\n", 
+		   __FUNCTION__, ptr, size);
+	}
+#endif
+	return ptr;
+}
+
+bus_size_t
+usb_vtophys(void *ptr, u_int32_t size)
+{
+	bus_size_t temp = 
+	  ((struct usb_dma *)(((u_int8_t *)ptr) + size))->physaddr;
+
+#ifdef USB_DEBUG
+	if(usbdebug > 14)
+	{
+	    printf("%s: %p, physaddr = %p\n", 
+		   __FUNCTION__, ptr, ((char *)0) + temp);
+	}
+#endif
+  	return temp;
+}
+
+void
+usb_free_mem(void *ptr, u_int32_t size)
+{
+	struct bus_dma_tag *tag = 
+	  ((struct usb_dma *)(((u_int8_t *)ptr) + size))->tag;
+	struct bus_dmamap *map =
+	  ((struct usb_dma *)(((u_int8_t *)ptr) + size))->map;
+
+	bus_dmamap_unload(tag, map);
+
+	bus_dmamem_free(tag, ptr, map);
+
+	bus_dma_tag_destroy(tag);
+
+#ifdef USB_DEBUG
+	if(usbdebug > 14)
+	{
+	    printf("%s: %p, %d bytes\n", 
+		   __FUNCTION__, ptr, size);
+	}
+#endif
+	return;
+}
+#endif
+
+static devclass_t usb_devclass;
+static driver_t usb_driver =
+{
+	.name    = "usb",
+	.methods = (device_method_t [])
+	{
+	  DEVMETHOD(device_probe, usb_probe),
+	  DEVMETHOD(device_attach, usb_attach),
+	  DEVMETHOD(device_detach, usb_detach),
+	  DEVMETHOD(device_suspend, bus_generic_suspend),
+	  DEVMETHOD(device_resume, bus_generic_resume),
+	  DEVMETHOD(device_shutdown, bus_generic_shutdown),
+	  {0,0}
+	},
+	.size    = 0, /* the softc must be set by the attacher! */
+};
+
+DRIVER_MODULE(usb, ohci, usb_driver, usb_devclass, 0, 0);
+DRIVER_MODULE(usb, uhci, usb_driver, usb_devclass, 0, 0);
+DRIVER_MODULE(usb, ehci, usb_driver, usb_devclass, 0, 0);
+
+MODULE_DEPEND(usb, usb, 1, 1, 1);
+MODULE_VERSION(usb, 1);
+
diff -rubN /usr/src1/src/sys/dev/usb2/_usb_requests.c /usr/src/sys/dev/usb2/_usb_requests.c
--- /usr/src1/src/sys/dev/usb2/_usb_requests.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_usb_requests.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,651 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/usb_hid.h>
+#include <dev/usb2/usb_quirks.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb2/usbdi_util.c $");
+
+usbd_status
+usbreq_reset_port(struct usbd_device *udev, int port, usb_port_status_t *ps)
+{
+	usb_device_request_t req;
+	usbd_status err;
+	int n;
+
+	req.bmRequestType = UT_WRITE_CLASS_OTHER;
+	req.bRequest = UR_SET_FEATURE;
+	USETW(req.wValue, UHF_PORT_RESET);
+	USETW(req.wIndex, port);
+	USETW(req.wLength, 0);
+	err = usbd_do_request(udev, &req, 0);
+
+	PRINTFN(1,("port %d reset done, error=%s\n",
+		    port, usbd_errstr(err)));
+
+	if(err)
+	{
+		goto done;
+	}
+
+	n = 10;
+	do {
+		/* wait for device to recover from reset */
+		usbd_delay_ms(udev, USB_PORT_RESET_DELAY);
+		err = usbreq_get_port_status(udev, port, ps);
+
+		if(err)
+		{
+			PRINTF(("get status failed %d\n",
+				 err));
+			goto done;
+		}
+
+		/* if the device disappeared, just give up */
+		if(!(UGETW(ps->wPortStatus) & UPS_CURRENT_CONNECT_STATUS))
+		{
+			err = USBD_NORMAL_COMPLETION;
+			goto done;
+		}
+	} while (((UGETW(ps->wPortChange) & UPS_C_PORT_RESET) == 0) && (--n > 0));
+
+	if(n == 0)
+	{
+		err = USBD_TIMEOUT;
+		goto done;
+	}
+
+	err = usbreq_clear_port_feature(udev, port, UHF_C_PORT_RESET);
+#ifdef USB_DEBUG
+	if(err)
+	{
+		PRINTF(("clear port feature failed %d\n",
+			 err));
+	}
+#endif
+
+	/* wait for the device to recover from reset */
+	usbd_delay_ms(udev, USB_PORT_RESET_RECOVERY);
+ done:
+	return (err);
+}
+
+usbd_status
+usbreq_get_desc(struct usbd_device *udev, int type, int index,
+		int len, void *desc, int timeout)
+{
+	usb_device_request_t req;
+	usbd_status err;
+
+	PRINTFN(3,("type=%d, index=%d, len=%d\n",
+		    type, index, len));
+
+	req.bmRequestType = UT_READ_DEVICE;
+	req.bRequest = UR_GET_DESCRIPTOR;
+	USETW2(req.wValue, type, index);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, len);
+
+ repeat:
+	err = usbd_do_request(udev, &req, desc);
+
+	if(err && timeout--)
+	{
+		usbd_delay_ms(udev, 200);
+		goto repeat;
+	}
+	return (err);
+}
+
+/* Use "usbreq_get_string_any()" instead of
+ * "usbreq_get_string_desc()", when the language id is not known. The
+ * maximum length of the string, "len", includes the terminating zero.
+ * "usbreq_get_string_any()" will always write a terminating zero to "buf",
+ * also on error.
+ */
+usbd_status
+usbreq_get_string_any(struct usbd_device *udev, int si, char *buf, int len)
+{
+	int swap = udev->quirks->uq_flags & UQ_SWAP_UNICODE;
+	usb_string_descriptor_t us;
+	char *s;
+	int i, n;
+	u_int16_t c;
+	usbd_status err;
+
+	if(len == 0)
+	{
+		return (USBD_NORMAL_COMPLETION);
+	}
+
+	buf[0] = 0;
+
+	/* subtract the terminating zero */
+	len--;
+
+	if(si == 0)
+	{
+		return (USBD_INVAL);
+	}
+	if(udev->quirks->uq_flags & UQ_NO_STRINGS)
+	{
+		return (USBD_STALLED);
+	}
+	if(udev->langid == USBD_NOLANG)
+	{
+		/* set up default language */
+		err = usbreq_get_string_desc(udev, USB_LANGUAGE_TABLE, 0, &us, 0);
+		if(err || (us.bLength < 4))
+		{
+			udev->langid = 0; /* well, just pick something then */
+		}
+		else
+		{
+			/* pick the first language as the default */
+			udev->langid = UGETW(us.bString[0]);
+		}
+	}
+	err = usbreq_get_string_desc(udev, si, udev->langid, &us, 0);
+	if(err)
+	{
+		return (err);
+	}
+	s = buf;
+	n = (us.bLength / 2) - 1;
+	for(i = 0; (i < n) && len; i++, len--)
+	{
+		c = UGETW(us.bString[i]);
+
+		/* convert from Unicode, handle buggy strings */
+		if ((c & 0xff00) == 0)
+		{
+			*s++ = c;
+		}
+		else if(((c & 0x00ff) == 0) && swap)
+		{
+			*s++ = c >> 8;
+		}
+		else
+		{
+			*s++ = '?';
+		}
+	}
+	*s++ = 0;
+	return (USBD_NORMAL_COMPLETION);
+}
+
+usbd_status
+usbreq_get_string_desc(struct usbd_device *udev, int sindex, int langid,
+		       usb_string_descriptor_t *sdesc, int *plen)
+{
+	usb_device_request_t req;
+	usbd_status err;
+	int actlen;
+
+	req.bmRequestType = UT_READ_DEVICE;
+	req.bRequest = UR_GET_DESCRIPTOR;
+	USETW2(req.wValue, UDESC_STRING, sindex);
+	USETW(req.wIndex, langid);
+	USETW(req.wLength, 2);	/* only size byte first */
+	err = usbd_do_request_flags(udev, &req, sdesc, USBD_SHORT_XFER_OK,
+				    &actlen, USBD_DEFAULT_TIMEOUT);
+	if(err)
+	{
+		return (err);
+	}
+
+	if(actlen < 2)
+	{
+		return (USBD_SHORT_XFER);
+	}
+
+	if(plen)
+	{
+		*plen = sdesc->bLength;
+	}
+
+	USETW(req.wLength, sdesc->bLength);	/* the whole string */
+	return (usbd_do_request(udev, &req, sdesc));
+}
+
+usbd_status
+usbreq_get_config_desc(struct usbd_device *udev, int confidx,
+		       usb_config_descriptor_t *d)
+{
+	usbd_status err;
+
+	PRINTFN(3,("confidx=%d\n", confidx));
+	err = usbreq_get_desc(udev, UDESC_CONFIG, confidx,
+			      USB_CONFIG_DESCRIPTOR_SIZE, d, 0);
+	if(err)
+	{
+		return (err);
+	}
+	if(d->bDescriptorType != UDESC_CONFIG)
+	{
+		PRINTFN(-1,("confidx=%d, bad desc len=%d type=%d\n",
+			     confidx, d->bLength, d->bDescriptorType));
+		return (USBD_INVAL);
+	}
+	return (USBD_NORMAL_COMPLETION);
+}
+
+usbd_status
+usbreq_get_config_desc_full(struct usbd_device *udev, int conf, void *d, int size)
+{
+	PRINTFN(3,("conf=%d\n", conf));
+	return (usbreq_get_desc(udev, UDESC_CONFIG, conf, size, d, 0));
+}
+
+usbd_status
+usbreq_get_device_desc(struct usbd_device *udev, usb_device_descriptor_t *d)
+{
+	PRINTFN(3,("\n"));
+	return (usbreq_get_desc(udev, UDESC_DEVICE,
+				0, USB_DEVICE_DESCRIPTOR_SIZE, d, 3));
+}
+
+usbd_status
+usbreq_get_interface(struct usbd_device *udev, u_int8_t iface_index,
+		     u_int8_t *aiface)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	usb_device_request_t req;
+
+	if((iface == NULL) || (iface->idesc == NULL))
+	{
+		return (USBD_INVAL);
+	}
+
+	req.bmRequestType = UT_READ_INTERFACE;
+	req.bRequest = UR_GET_INTERFACE;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
+	USETW(req.wLength, 1);
+	return (usbd_do_request(udev, &req, aiface));
+}
+
+usbd_status
+usbreq_set_interface(struct usbd_device *udev, u_int8_t iface_index,
+		     u_int8_t altno)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	usb_device_request_t req;
+	usbd_status err;
+
+	if(iface == NULL)
+	{
+		return (USBD_INVAL);
+	}
+
+	err = usbd_fill_iface_data(udev, iface_index, altno);
+	if(err)
+	{
+		return (err);
+	}
+
+	req.bmRequestType = UT_WRITE_INTERFACE;
+	req.bRequest = UR_SET_INTERFACE;
+	USETW(req.wValue, iface->idesc->bAlternateSetting);
+	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+usbd_status
+usbreq_get_device_status(struct usbd_device *udev, usb_status_t *st)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_READ_DEVICE;
+	req.bRequest = UR_GET_STATUS;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, sizeof(usb_status_t));
+	return (usbd_do_request(udev, &req, st));
+}
+
+usbd_status
+usbreq_get_hub_descriptor(struct usbd_device *udev, usb_hub_descriptor_t *hd)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_READ_CLASS_DEVICE;
+	req.bRequest = UR_GET_DESCRIPTOR;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE);
+	return (usbd_do_request(udev, &req, hd));
+}
+
+usbd_status
+usbreq_get_hub_status(struct usbd_device *udev, usb_hub_status_t *st)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_READ_CLASS_DEVICE;
+	req.bRequest = UR_GET_STATUS;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, sizeof(usb_hub_status_t));
+	return (usbd_do_request(udev, &req, st));
+}
+
+usbd_status
+usbreq_set_address(struct usbd_device *udev, int addr)
+{
+	usb_device_request_t req;
+
+	PRINTFN(5,("setting device address=%d\n", addr));
+
+	req.bmRequestType = UT_WRITE_DEVICE;
+	req.bRequest = UR_SET_ADDRESS;
+	USETW(req.wValue, addr);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+usbd_status
+usbreq_get_port_status(struct usbd_device *udev, int port, usb_port_status_t *ps)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_READ_CLASS_OTHER;
+	req.bRequest = UR_GET_STATUS;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, port);
+	USETW(req.wLength, sizeof *ps);
+	return (usbd_do_request(udev, &req, ps));
+}
+
+usbd_status
+usbreq_clear_hub_feature(struct usbd_device *udev, int sel)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_WRITE_CLASS_DEVICE;
+	req.bRequest = UR_CLEAR_FEATURE;
+	USETW(req.wValue, sel);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+usbd_status
+usbreq_set_hub_feature(struct usbd_device *udev, int sel)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_WRITE_CLASS_DEVICE;
+	req.bRequest = UR_SET_FEATURE;
+	USETW(req.wValue, sel);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+usbd_status
+usbreq_clear_port_feature(struct usbd_device *udev, int port, int sel)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_WRITE_CLASS_OTHER;
+	req.bRequest = UR_CLEAR_FEATURE;
+	USETW(req.wValue, sel);
+	USETW(req.wIndex, port);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+usbd_status
+usbreq_set_port_feature(struct usbd_device *udev, int port, int sel)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_WRITE_CLASS_OTHER;
+	req.bRequest = UR_SET_FEATURE;
+	USETW(req.wValue, sel);
+	USETW(req.wIndex, port);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+usbd_status
+usbreq_set_protocol(struct usbd_device *udev, u_int8_t iface_index,
+		    u_int16_t report)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	usb_device_request_t req;
+
+	if((iface == NULL) || (iface->idesc == NULL))
+	{
+		return (USBD_INVAL);
+	}
+	PRINTFN(4, ("iface=%p, report=%d, endpt=%d\n",
+		     iface, report, iface->idesc->bInterfaceNumber));
+
+	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	req.bRequest = UR_SET_PROTOCOL;
+	USETW(req.wValue, report);
+	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+#ifdef USB_COMPAT_OLD
+usbd_status
+usbreq_set_report_async(struct usbd_device *udev, u_int8_t iface_index,
+		  u_int8_t type, u_int8_t id, void *data, int len)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	usb_device_request_t req;
+
+	if((iface == NULL) || (iface->idesc == NULL))
+	{
+		return (USBD_INVAL);
+	}
+	/* this function call should be replaced by an allocated
+	 * transfer that is started when a transfer is needed, and
+	 * stopped when the device is detached. This implementation
+	 * use polling because it may be called from an interrupt
+	 * context.
+	 */
+
+	PRINTF(("this function is depreceated"));
+
+	PRINTFN(4, ("len=%d\n", len));
+
+	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	req.bRequest = UR_SET_REPORT;
+	USETW2(req.wValue, type, id);
+	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
+	USETW(req.wLength, len);
+
+	return (usbd_do_request_flags
+		(udev, &req, data, USBD_USE_POLLING, 0, 500 /* ms */));
+}
+#endif
+
+usbd_status
+usbreq_set_report(struct usbd_device *udev, u_int8_t iface_index,
+		  u_int8_t type, u_int8_t id, void *data, int len)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	usb_device_request_t req;
+
+	if((iface == NULL) || (iface->idesc == NULL))
+	{
+		return (USBD_INVAL);
+	}
+	PRINTFN(4, ("len=%d\n", len));
+
+	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	req.bRequest = UR_SET_REPORT;
+	USETW2(req.wValue, type, id);
+	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
+	USETW(req.wLength, len);
+	return (usbd_do_request(udev, &req, data));
+}
+
+usbd_status
+usbreq_get_report(struct usbd_device *udev, u_int8_t iface_index,
+		  u_int8_t type, u_int8_t id, void *data, int len)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	usb_device_request_t req;
+
+	if((iface == NULL) || (iface->idesc == NULL) || (id == 0))
+	{
+		return (USBD_INVAL);
+	}
+	PRINTFN(4, ("len=%d\n", len));
+
+	req.bmRequestType = UT_READ_CLASS_INTERFACE;
+	req.bRequest = UR_GET_REPORT;
+	USETW2(req.wValue, type, id);
+	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
+	USETW(req.wLength, len);
+	return (usbd_do_request(udev, &req, data));
+}
+
+usbd_status
+usbreq_set_idle(struct usbd_device *udev, u_int8_t iface_index,
+		int duration, int id)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	usb_device_request_t req;
+
+	if((iface == NULL) || (iface->idesc == NULL))
+	{
+		return (USBD_INVAL);
+	}
+	PRINTFN(4, ("%d %d\n", duration, id));
+
+	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
+	req.bRequest = UR_SET_IDLE;
+	USETW2(req.wValue, duration, id);
+	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+usbd_status
+usbreq_get_report_descriptor(struct usbd_device *udev, int ifcno,
+			     int size, void *d)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_READ_INTERFACE;
+	req.bRequest = UR_GET_DESCRIPTOR;
+	USETW2(req.wValue, UDESC_REPORT, 0); /* report id should be 0 */
+	USETW(req.wIndex, ifcno);
+	USETW(req.wLength, size);
+	return (usbd_do_request(udev, &req, d));
+}
+
+usbd_status
+usbreq_read_report_desc(struct usbd_device *udev, u_int8_t iface_index,
+ 			void **descp, int *sizep, usb_malloc_type mem)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	usb_hid_descriptor_t *hid;
+	usbd_status err;
+
+	if((iface == NULL) || (iface->idesc == NULL))
+	{
+		return (USBD_INVAL);
+	}
+	hid = usbd_get_hdesc(usbd_get_config_descriptor(udev), iface->idesc);
+	if(hid == NULL)
+	{
+		return (USBD_IOERROR);
+	}
+	*sizep = UGETW(hid->descrs[0].wDescriptorLength);
+	*descp = malloc(*sizep, mem, M_NOWAIT);
+	if(*descp == NULL)
+	{
+		return (USBD_NOMEM);
+	}
+	err = usbreq_get_report_descriptor(udev, iface->idesc->bInterfaceNumber,
+					   *sizep, *descp);
+	if(err)
+	{
+		free(*descp, mem);
+		*descp = NULL;
+		return (err);
+	}
+	return (USBD_NORMAL_COMPLETION);
+}
+
+usbd_status
+usbreq_set_config(struct usbd_device *udev, int conf)
+{
+	usb_device_request_t req;
+
+	PRINTF(("setting config %d\n", conf));
+
+	req.bmRequestType = UT_WRITE_DEVICE;
+	req.bRequest = UR_SET_CONFIG;
+	USETW(req.wValue, conf);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, 0);
+	return (usbd_do_request(udev, &req, 0));
+}
+
+usbd_status
+usbreq_get_config(struct usbd_device *udev, u_int8_t *conf)
+{
+	usb_device_request_t req;
+
+	req.bmRequestType = UT_READ_DEVICE;
+	req.bRequest = UR_GET_CONFIG;
+	USETW(req.wValue, 0);
+	USETW(req.wIndex, 0);
+	USETW(req.wLength, 1);
+	return (usbd_do_request(udev, &req, conf));
+}
diff -rubN /usr/src1/src/sys/dev/usb2/_usb_subr.c /usr/src/sys/dev/usb2/_usb_subr.c
--- /usr/src1/src/sys/dev/usb2/_usb_subr.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_usb_subr.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,1557 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/endian.h>
+#include <sys/queue.h> /* LIST_XXX() */
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+#include <dev/usb2/usb_hid.h>
+#include "usbdevs.h"
+#include <dev/usb2/usb_quirks.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb2/usb_subr.c $");
+
+#ifdef USBVERBOSE
+/*
+ * descriptions of of known vendors and devices ("products")
+ */
+struct usb_knowndev {
+	u_int16_t		vendor;
+	u_int16_t		product;
+	int			flags;
+	char			*vendorname, *productname;
+};
+#define	USB_KNOWNDEV_NOPROD	0x01		/* match on vendor only */
+
+#include "usbdevs_data.h"
+#endif /* USBVERBOSE */
+
+static void
+usbd_trim_spaces(char *p)
+{
+	char *q, *e;
+
+	if(p == NULL)
+	{
+		return;
+	}
+	q = e = p;
+	while(*q == ' ')	/* skip leading spaces */
+	{
+		q++;
+	}
+	while((*p = *q++))	/* copy string */
+	{
+		if(*p++ != ' ') /* remember last non-space */
+		{
+			e = p;
+		}
+	}
+	*e = 0;			/* kill trailing spaces */
+	return;
+}
+
+static void
+usbd_devinfo_vp(struct usbd_device *udev, char *v, char *p, int usedev)
+{
+	usb_device_descriptor_t *udd = &udev->ddesc;
+	char *vendor, *product;
+#ifdef USBVERBOSE
+	const struct usb_knowndev *kdp;
+#endif
+
+	if(udev == NULL)
+	{
+		v[0] = p[0] = '\0';
+		return;
+	}
+
+	vendor = NULL;
+	product = NULL;
+
+	if(usedev)
+	{
+		(void) usbreq_get_string_any
+		  (udev, udd->iManufacturer, v, USB_MAX_STRING_LEN);
+
+		vendor = v;
+		usbd_trim_spaces(vendor);
+
+		if(!vendor[0])
+		{
+			vendor = NULL;
+		}
+
+		(void) usbreq_get_string_any
+		  (udev, udd->iProduct, p, USB_MAX_STRING_LEN);
+
+		product = p;
+		usbd_trim_spaces(product);
+
+		if(!product[0])
+		{
+			product = NULL;
+		}
+	}
+#ifdef USBVERBOSE
+	if((vendor == NULL) || (product == NULL))
+	{
+		for(kdp = usb_knowndevs;
+		    kdp->vendorname != NULL;
+		    kdp++)
+		{
+			if((kdp->vendor == UGETW(udd->idVendor)) &&
+			   ((kdp->product == UGETW(udd->idProduct)) ||
+			    ((kdp->flags & USB_KNOWNDEV_NOPROD) != 0)))
+			{
+				break;
+			}
+		}
+		if(kdp->vendorname != NULL)
+		{
+			if(vendor == NULL)
+			{
+				vendor = kdp->vendorname;
+			}
+			if(product == NULL)
+			{
+				product = ((kdp->flags & USB_KNOWNDEV_NOPROD) == 0) ?
+				  kdp->productname : NULL;
+			}
+		}
+	}
+#endif
+	if((vendor != NULL) && *vendor)
+	{
+		strcpy(v, vendor);
+	}
+	else
+	{
+		sprintf(v, "vendor 0x%04x", UGETW(udd->idVendor));
+	}
+	if((product != NULL) && *product)
+	{
+		strcpy(p, product);
+	}
+	else
+	{
+		sprintf(p, "product 0x%04x", UGETW(udd->idProduct));
+	}
+	return;
+}
+
+static int
+usbd_printBCD(char *cp, int bcd)
+{
+	return (sprintf(cp, "%x.%02x", bcd >> 8, bcd & 0xff));
+}
+
+void
+usbd_devinfo(struct usbd_device *udev, int showclass, char *cp)
+{
+	usb_device_descriptor_t *udd = &udev->ddesc;
+	char vendor[USB_MAX_STRING_LEN];
+	char product[USB_MAX_STRING_LEN];
+	int bcdDevice, bcdUSB;
+
+	usbd_devinfo_vp(udev, vendor, product, 1);
+	cp += sprintf(cp, "%s %s", vendor, product);
+	if(showclass)
+	{
+		cp += sprintf(cp, ", class %d/%d",
+			      udd->bDeviceClass, udd->bDeviceSubClass);
+	}
+	bcdUSB = UGETW(udd->bcdUSB);
+	bcdDevice = UGETW(udd->bcdDevice);
+	cp += sprintf(cp, ", rev ");
+	cp += usbd_printBCD(cp, bcdUSB);
+	*cp++ = '/';
+	cp += usbd_printBCD(cp, bcdDevice);
+	cp += sprintf(cp, ", addr %d", udev->address);
+	*cp = 0;
+	return;
+}
+
+const char * 
+usbd_errstr(usbd_status err)
+{
+	static const char * const
+	  MAKE_TABLE(USBD_STATUS,DESC,[]);
+
+	return (err < N_USBD_STATUS) ?
+	  USBD_STATUS_DESC[err] : "unknown error!";
+}
+
+/* delay for a certain number of ms */
+void
+usb_delay_ms(struct usbd_bus *bus, u_int ms)
+{
+	/* wait at least two clock ticks, 
+	 * so that we know the time has passed
+	 */
+	if(bus->use_polling || cold)
+	{
+		DELAY((ms+1) * 1000);
+	}
+	else
+	{
+		tsleep(&ms, PRIBIO, "usbdly", (((ms*hz)+999)/1000) + 1);
+	}
+}
+
+/* delay given a device handle */
+void
+usbd_delay_ms(struct usbd_device *udev, u_int ms)
+{
+	usb_delay_ms(udev->bus, ms);
+}
+
+#define ADD_BYTES(ptr,len) ((void *)(((u_int8_t *)(ptr)) + (len)))
+
+usb_hid_descriptor_t *
+usbd_get_hdesc(usb_config_descriptor_t *cd, usb_interface_descriptor_t *id)
+{
+	void *end = ADD_BYTES(cd, UGETW(cd->wTotalLength));
+
+	if((id == NULL) ||
+	   (((void *)id) < ((void *)cd)) ||
+	   (((void *)id) >= end))
+	{
+		return NULL;
+	}
+
+	for(id = ADD_BYTES(id, id->bLength);
+	    (((void *)id) < end) &&
+	      (ADD_BYTES(id, USB_HID_DESCRIPTOR_SIZE(0)) <= end) &&
+	      (ADD_BYTES(id, id->bLength) <= end);
+	    id = ADD_BYTES(id, id->bLength))
+	{
+		if(id->bDescriptorType == UDESC_HID)
+		{
+			return (void *)id;
+		}
+		if(id->bDescriptorType == UDESC_INTERFACE)
+		{
+			break;
+		}
+	}
+	return (0);
+}
+
+usb_interface_descriptor_t *
+usbd_find_idesc(usb_config_descriptor_t *cd, int iface_index, int alt_index)
+{
+	void *end = ADD_BYTES(cd, UGETW(cd->wTotalLength));
+	usb_interface_descriptor_t *id;
+	int curidx, lastidx, curaidx = 0;
+
+	curidx = lastidx = -1;
+
+	for(id = ADD_BYTES(cd, 0);
+	    (((void *)id) < end) &&
+	      (ADD_BYTES(id,USB_INTERFACE_DESCRIPTOR_SIZE) <= end) &&
+	      (ADD_BYTES(id,id->bLength) <= end);
+	    id = ADD_BYTES(id, id->bLength))
+	{
+		PRINTFN(4,("iface_index=%d(%d) alt_index=%d(%d) len=%d "
+			    "type=%d\n",
+			    iface_index, curidx, alt_index, curaidx,
+			    id->bLength, id->bDescriptorType));
+
+		if(id->bLength == 0)
+		{
+			/* bad descriptor */
+			break;
+		}
+		if(id->bDescriptorType == UDESC_INTERFACE)
+		{
+			if(id->bInterfaceNumber != lastidx)
+			{
+				lastidx = id->bInterfaceNumber;
+				curidx++;
+				curaidx = 0;
+			}
+			else
+			{
+				curaidx++;
+			}
+			if((iface_index == curidx) && (alt_index == curaidx))
+			{
+				return (id);
+			}
+		}
+	}
+	return (NULL);
+}
+
+usb_endpoint_descriptor_t *
+usbd_find_edesc(usb_config_descriptor_t *cd, int iface_index, int alt_index,
+		int endptidx)
+{
+	void *end = ADD_BYTES(cd, UGETW(cd->wTotalLength));
+	usb_interface_descriptor_t *d;
+	usb_endpoint_descriptor_t *ed;
+	int curidx;
+
+	d = usbd_find_idesc(cd, iface_index, alt_index);
+	if(d == NULL)
+	{
+		return (NULL);
+	}
+	if(endptidx >= d->bNumEndpoints) /* quick exit */
+	{
+		return (NULL);
+	}
+	curidx = 0;
+	for(ed = ADD_BYTES(d, d->bLength);
+	    (((void *)ed) < end) &&
+	      (ADD_BYTES(ed, USB_ENDPOINT_DESCRIPTOR_SIZE) <= end) &&
+	      (ADD_BYTES(ed, ed->bLength) <= end);
+	    ed = ADD_BYTES(ed, ed->bLength))
+	{
+		if((ed->bLength == 0) ||
+		   (ed->bDescriptorType == UDESC_INTERFACE))
+		{
+			/* bad descriptor */
+			break;
+		}
+		if(ed->bDescriptorType == UDESC_ENDPOINT)
+		{
+			if(curidx == endptidx)
+			{
+				return (ed);
+			}
+			curidx++;
+		}
+	}
+	return (NULL);
+}
+
+usb_descriptor_t *
+usbd_find_descriptor(usb_config_descriptor_t *cd, int type, int subtype)
+{
+	void *end = ADD_BYTES(cd, UGETW(cd->wTotalLength));
+	usb_descriptor_t *desc;
+
+	for(desc = ADD_BYTES(cd, 0);
+	    (((void *)desc) < end) &&
+	      (ADD_BYTES(desc, sizeof(usb_descriptor_t)) <= end) &&
+	      (ADD_BYTES(desc, desc->bLength) <= end);
+	    desc = ADD_BYTES(desc, desc->bLength))
+	{
+		if(desc->bLength == 0)
+		{
+			/* bad descriptor */
+			break;
+		}
+		if((desc->bDescriptorType == type) &&
+		   ((subtype == USBD_SUBTYPE_ANY) ||
+		    (subtype == desc->bDescriptorSubtype)))
+		{
+			return desc;
+		}
+	}
+	return (NULL);
+}
+
+int
+usbd_get_no_alts(usb_config_descriptor_t *cd, int ifaceno)
+{
+	void *end = ADD_BYTES(cd, UGETW(cd->wTotalLength));
+	int n;
+
+	for(n = 0;
+	    (((void *)cd) < end) &&
+	      (ADD_BYTES(cd,USB_INTERFACE_DESCRIPTOR_SIZE) <= end) &&
+	      (ADD_BYTES(cd,cd->bLength) <= end);
+	    cd = ADD_BYTES(cd, cd->bLength))
+	{
+	  if((((usb_interface_descriptor_t *)cd)->bDescriptorType == UDESC_INTERFACE) &&
+	     (((usb_interface_descriptor_t *)cd)->bInterfaceNumber == ifaceno))
+	  {
+		n++;
+	  }
+	}
+	return (n);
+}
+
+static void
+usbd_fill_pipe_data(struct usbd_device *udev, u_int8_t iface_index,
+		    usb_endpoint_descriptor_t *edesc, struct usbd_pipe *pipe)
+{
+	bzero(pipe, sizeof(*pipe));
+#ifdef USB_COMPAT_OLD
+	pipe->udev = udev;
+#endif
+	pipe->edesc = edesc;
+	pipe->iface_index = iface_index;
+	LIST_INIT(&pipe->list_head);
+
+	/* first transfer needs to clear stall! */
+	pipe->clearstall = 1;
+
+	(udev->bus->methods->pipe_init)(udev,edesc,pipe);
+	return;
+}
+
+/* NOTE: pipes should not be in use when
+ * ``usbd_free_pipe_data()'' is called
+ */
+static void
+usbd_free_pipe_data(struct usbd_device *udev, int iface_index)
+{
+	struct usbd_pipe *pipe = &udev->pipes[0];
+	struct usbd_pipe *pipe_end = &udev->pipes_end[0];
+
+	while(pipe < pipe_end)
+	{
+		if((iface_index == pipe->iface_index) ||
+		   (iface_index == -1))
+		{
+			/* free pipe */
+			pipe->edesc = NULL;
+		}
+		pipe++;
+	}
+	return;
+}
+
+usbd_status
+usbd_fill_iface_data(struct usbd_device *udev, int iface_index, int alt_index)
+{
+	struct usbd_interface *iface = usbd_get_iface(udev,iface_index);
+	struct usbd_pipe *pipe = &udev->pipes[0];
+	struct usbd_pipe *pipe_end = &udev->pipes_end[0];
+	usb_interface_descriptor_t *id;
+	usb_endpoint_descriptor_t *ed;
+	void *end;
+	u_int8_t nendpt;
+
+	if(iface == NULL)
+	{
+		return (USBD_INVAL);
+	}
+
+	PRINTFN(4,("iface_index=%d alt_index=%d\n",
+		    iface_index, alt_index));
+
+	/* mtx_assert() */
+
+	while(pipe < pipe_end)
+	{
+		if(pipe->iface_index == iface_index)
+		{
+			if(pipe->refcount)
+			{
+				return(USBD_IN_USE);
+			}
+		}
+		pipe++;
+	}
+
+	/**/
+	pipe = &udev->pipes[0];
+
+	/* free old pipes if any */
+	usbd_free_pipe_data(udev, iface_index);
+
+	id = usbd_find_idesc(udev->cdesc, iface_index, alt_index);
+	if(id == NULL)
+	{
+		return (USBD_INVAL);
+	}
+#ifdef USB_COMPAT_OLD
+	iface->udev = udev;
+#endif
+	iface->idesc = id;
+	iface->alt_index = alt_index;
+
+	USBD_CLR_IFACE_NO_PROBE(udev, iface_index);
+
+	nendpt = id->bNumEndpoints;
+	PRINTFN(4,("found idesc nendpt=%d\n", nendpt));
+
+	ed = ADD_BYTES(id, id->bLength);
+	end = ADD_BYTES(udev->cdesc, UGETW(udev->cdesc->wTotalLength));
+
+	while(nendpt--)
+	{
+		PRINTFN(10,("endpt=%d\n", nendpt));
+
+		while(ADD_BYTES(ed,USB_ENDPOINT_DESCRIPTOR_SIZE) <= end)
+		{
+			PRINTFN(10,("ed=%p end=%p "
+				     "len=%d type=%d\n",
+				     ed, end, ed->bLength,
+				     ed->bDescriptorType));
+
+			if((ADD_BYTES(ed, ed->bLength) <= end) &&
+			   (ed->bLength != 0) &&
+			   (ed->bDescriptorType == UDESC_ENDPOINT))
+			{
+				goto found;
+			}
+			if((ed->bLength == 0) ||
+			   (ed->bDescriptorType == UDESC_INTERFACE))
+			{
+				break;
+			}
+			ed = ADD_BYTES(ed, ed->bLength);
+		}
+		goto error;
+
+	found:
+		if(udev->speed == USB_SPEED_HIGH)
+		{
+			u_int16_t mps;
+			/* control and bulk endpoints have max packet limits */
+			switch (UE_GET_XFERTYPE(ed->bmAttributes)) {
+			case UE_CONTROL:
+				mps = USB_2_MAX_CTRL_PACKET;
+				goto check;
+			case UE_BULK:
+				mps = USB_2_MAX_BULK_PACKET;
+			check:
+				if(UGETW(ed->wMaxPacketSize) != mps)
+				{
+					USETW(ed->wMaxPacketSize, mps);
+#ifdef DIAGNOSTIC
+					printf("%s: bad wMaxPacketSize, addr=%d!\n",
+					       __FUNCTION__, udev->address);
+#endif
+				}
+				break;
+			default:
+				break;
+			}
+		}
+		if(UGETW(ed->wMaxPacketSize) == 0)
+		{
+#ifdef USB_DEBUG
+			printf("%s: invalid wMaxPacketSize, addr=%d!\n",
+			     __FUNCTION__, udev->address);
+#endif
+		      /* avoid division by zero 
+		       * (in EHCI/UHCI/OHCI drivers) 
+		       */
+		      USETW(ed->wMaxPacketSize, USB_MAX_IPACKET);
+		}
+
+		/* find a free pipe */
+		while(pipe < pipe_end)
+		{
+			if(pipe->edesc == NULL)
+			{
+				/* pipe is free */
+				usbd_fill_pipe_data(udev,iface_index,ed,pipe);
+				break;
+			}
+			pipe++;
+		}
+		ed = ADD_BYTES(ed, ed->bLength);
+	}
+	return (USBD_NORMAL_COMPLETION);
+
+ error:
+	/* passed end, or bad desc */
+	printf("%s: bad descriptor(s), addr=%d!\n",
+	       __FUNCTION__, udev->address);
+
+	/* free old pipes if any */
+	usbd_free_pipe_data(udev, iface_index);
+	return (USBD_INVAL);
+}
+
+static void
+usbd_free_iface_data(struct usbd_device *udev)
+{
+	struct usbd_interface *iface = &udev->ifaces[0];
+	struct usbd_interface *iface_end = &udev->ifaces_end[0];
+
+	/* mtx_assert() */
+
+	/* free all pipes, if any */
+	usbd_free_pipe_data(udev, -1);
+
+	/* free all interfaces, if any */
+	while(iface < iface_end)
+	{
+		iface->idesc = NULL;
+		iface++;
+	}
+
+	if(udev->cdesc != NULL)
+	{
+		/* free "cdesc" after "ifaces" */
+		free(udev->cdesc, M_USB);
+	}
+	udev->cdesc = NULL;
+	udev->config = USB_UNCONFIG_NO;
+	return;
+}
+
+/* - USB config 0
+ *   - USB interfaces
+ *     - USB alternative interfaces
+ *       - USB pipes
+ *
+ * - USB config 1
+ *   - USB interfaces
+ *     - USB alternative interfaces
+ *       - USB pipes
+ */
+usbd_status
+usbd_search_and_set_config(struct usbd_device *udev, int no, int msg)
+{
+	usb_config_descriptor_t cd;
+	usbd_status err;
+	int index;
+
+	if(no == USB_UNCONFIG_NO)
+	{
+		return (usbd_set_config_index(udev, USB_UNCONFIG_INDEX, msg));
+	}
+
+	PRINTFN(5,("%d\n", no));
+
+	/* figure out what config index to use */
+	for(index = 0; 
+	    index < udev->ddesc.bNumConfigurations;
+	    index++)
+	{
+		err = usbreq_get_config_desc(udev, index, &cd);
+		if(err)
+		{
+			return (err);
+		}
+		if(cd.bConfigurationValue == no)
+		{
+			return (usbd_set_config_index(udev, index, msg));
+		}
+	}
+	return (USBD_INVAL);
+}
+
+usbd_status
+usbd_set_config_index(struct usbd_device *udev, int index, int msg)
+{
+	usb_status_t ds;
+	usb_hub_descriptor_t hd;
+	usb_config_descriptor_t cd, *cdp;
+	usbd_status err;
+	int nifc, len, selfpowered, power;
+
+	PRINTFN(5,("udev=%p index=%d\n", udev, index));
+
+	if(index == USB_UNCONFIG_INDEX)
+	{
+		/* leave unallocated when
+		 * unconfiguring the device
+		 */
+		err = usbreq_set_config(udev, USB_UNCONFIG_NO);
+		goto error;
+	}
+
+	/* get the short descriptor */
+	err = usbreq_get_config_desc(udev, index, &cd);
+	if(err)
+	{
+		goto error;
+	}
+
+	/* free all configuration data structures */
+	usbd_free_iface_data(udev);
+
+	/* get full descriptor */
+	len = UGETW(cd.wTotalLength);
+	udev->cdesc = malloc(len, M_USB, M_NOWAIT|M_ZERO);
+	if(udev->cdesc == NULL)
+	{
+		return (USBD_NOMEM);
+	}
+
+	cdp = udev->cdesc;
+
+	/* get the full descriptor */
+	err = usbreq_get_desc(udev, UDESC_CONFIG, index, len, cdp, 3);
+	if(err)
+	{
+		goto error;
+	}
+	if(cdp->bDescriptorType != UDESC_CONFIG)
+	{
+		PRINTF(("bad desc %d\n",
+			     cdp->bDescriptorType));
+		err = USBD_INVAL;
+		goto error;
+	}
+	if(cdp->bNumInterface > (sizeof(udev->ifaces)/sizeof(udev->ifaces[0])))
+	{
+		PRINTF(("too many interfaces: %d\n", cdp->bNumInterface));
+		cdp->bNumInterface = (sizeof(udev->ifaces)/sizeof(udev->ifaces[0]));
+	}
+
+	/* figure out if the device is self or bus powered */
+	selfpowered = 0;
+	if(!(udev->quirks->uq_flags & UQ_BUS_POWERED) &&
+	    (cdp->bmAttributes & UC_SELF_POWERED))
+	{
+		/* may be self powered */
+		if(cdp->bmAttributes & UC_BUS_POWERED)
+		{
+			/* must ask device */
+			if(udev->quirks->uq_flags & UQ_POWER_CLAIM)
+			{
+				/*
+				 * Hub claims to be self powered, but isn't.
+				 * It seems that the power status can be
+				 * determined by the hub characteristics.
+				 */
+				err = usbreq_get_hub_descriptor(udev, &hd);
+
+				if(!err &&
+				   (UGETW(hd.wHubCharacteristics) &
+				    UHD_PWR_INDIVIDUAL))
+				{
+					selfpowered = 1;
+				}
+				PRINTF(("characteristics=0x%04x, error=%s\n",
+					 UGETW(hd.wHubCharacteristics),
+					 usbd_errstr(err)));
+			}
+			else
+			{
+				err = usbreq_get_device_status(udev, &ds);
+				if(!err &&
+				   (UGETW(ds.wStatus) & UDS_SELF_POWERED))
+				{
+					selfpowered = 1;
+				}
+				PRINTF(("status=0x%04x, error=%s\n",
+					 UGETW(ds.wStatus), usbd_errstr(err)));
+			}
+		}
+		else
+		{
+			selfpowered = 1;
+		}
+	}
+	PRINTF(("udev=%p cdesc=%p (addr %d) cno=%d attr=0x%02x, "
+		 "selfpowered=%d, power=%d\n",
+		 udev, cdp,
+		 cdp->bConfigurationValue, udev->address, cdp->bmAttributes,
+		 selfpowered, cdp->bMaxPower * 2));
+
+	/* check if we have enough power */
+	power = cdp->bMaxPower * 2;
+	if(power > udev->powersrc->power)
+	{
+		PRINTF(("power exceeded %d %d\n", power, udev->powersrc->power));
+		/* XXX print nicer message */
+		if(msg)
+		{
+			device_printf(udev->bus->bdev,
+				      "device addr %d (config %d) exceeds power "
+				      "budget, %d mA > %d mA\n",
+				      udev->address,
+				      cdp->bConfigurationValue,
+				      power, udev->powersrc->power);
+		}
+		err = USBD_NO_POWER;
+		goto error;
+	}
+
+	udev->power = power;
+	udev->self_powered = selfpowered;
+	udev->config = cdp->bConfigurationValue;
+
+	/* set the actual configuration value */
+	err = usbreq_set_config(udev, cdp->bConfigurationValue);
+	if(err)
+	{
+		goto error;
+	}
+
+	/* allocate and fill interface data */
+	nifc = cdp->bNumInterface;
+	while(nifc--)
+	{
+		err = usbd_fill_iface_data(udev, nifc, 0);
+		if (err)
+		{
+			goto error;
+		}
+	}
+	return (USBD_NORMAL_COMPLETION);
+
+ error:
+	PRINTF(("error=%s\n", usbd_errstr(err)));
+	usbd_free_iface_data(udev);
+	return (err);
+}
+
+int
+usbd_fill_deviceinfo(struct usbd_device *udev, struct usb_device_info *di,
+		     int usedev)
+{
+	struct usbd_port *p;
+	int i, err, s;
+
+	if((udev == NULL) || (di == NULL))
+	{
+		return (ENXIO);
+	}
+
+	bzero(di, sizeof(di[0]));
+
+	di->udi_bus = device_get_unit(udev->bus->bdev);
+	di->udi_addr = udev->address;
+	di->udi_cookie = udev->cookie;
+	usbd_devinfo_vp(udev, di->udi_vendor, di->udi_product, usedev);
+	usbd_printBCD(di->udi_release, UGETW(udev->ddesc.bcdDevice));
+	di->udi_vendorNo = UGETW(udev->ddesc.idVendor);
+	di->udi_productNo = UGETW(udev->ddesc.idProduct);
+	di->udi_releaseNo = UGETW(udev->ddesc.bcdDevice);
+	di->udi_class = udev->ddesc.bDeviceClass;
+	di->udi_subclass = udev->ddesc.bDeviceSubClass;
+	di->udi_protocol = udev->ddesc.bDeviceProtocol;
+	di->udi_config = udev->config;
+	di->udi_power = udev->self_powered ? 0 : udev->power;
+	di->udi_speed = udev->speed;
+
+	for(i = 0;
+	    (i < (sizeof(udev->subdevs)/sizeof(udev->subdevs[0]))) &&
+	      (i < USB_MAX_DEVNAMES);
+	    i++)
+	{
+		if(udev->subdevs[i] &&
+		   device_is_attached(udev->subdevs[i]))
+		{
+			strncpy(di->udi_devnames[i],
+				device_get_nameunit(udev->subdevs[i]),
+				USB_MAX_DEVNAMELEN);
+			di->udi_devnames[i][USB_MAX_DEVNAMELEN-1] = 0;
+		}
+		/* else { di->udi_devnames[i][0] = 0; } */
+	}
+
+	if(udev->hub)
+	{
+		for(i = 0;
+		    (i < (sizeof(di->udi_ports)/sizeof(di->udi_ports[0]))) &&
+		      (i < udev->hub->hubdesc.bNbrPorts);
+		    i++)
+		{
+			p = &udev->hub->ports[i];
+			if(p->device)
+			{
+				err = p->device->address;
+			}
+			else
+			{
+				s = UGETW(p->status.wPortStatus);
+				if (s & UPS_PORT_ENABLED)
+				{
+					err = USB_PORT_ENABLED;
+				}
+				else if (s & UPS_SUSPEND)
+				{
+					err = USB_PORT_SUSPENDED;
+				}
+				else if (s & UPS_PORT_POWER)
+				{
+					err = USB_PORT_POWERED;
+				}
+				else
+				{
+					err = USB_PORT_DISABLED;
+				}
+			}
+			di->udi_ports[i] = err;
+		}
+		di->udi_nports = udev->hub->hubdesc.bNbrPorts;
+	}
+	return 0;
+}
+
+/* "usbd_probe_and_attach()" is called 
+ * from "usbd_new_device()" and "uhub_explore()"
+ */
+usbd_status
+usbd_probe_and_attach(device_t parent, int port, struct usbd_port *up)
+{
+	struct usb_attach_arg uaa;
+	struct usbd_device *udev = up->device;
+	device_t bdev = NULL;
+	usbd_status err = 0;
+	u_int8_t config;
+	u_int8_t i;
+
+	up->last_refcount = usb_driver_added_refcount;
+
+	if(udev == NULL)
+	{
+		PRINTF(("%s: port %d has no device\n", 
+			device_get_nameunit(parent), port));
+		return (USBD_INVAL);
+	}
+
+	bzero(&uaa, sizeof(uaa));
+
+	/* probe and attach */
+
+	uaa.device = udev;
+	uaa.port = port;
+	uaa.configno = -1;
+	uaa.vendor = UGETW(udev->ddesc.idVendor);
+	uaa.product = UGETW(udev->ddesc.idProduct);
+	uaa.release = UGETW(udev->ddesc.bcdDevice);
+
+	if((udev->probed == USBD_PROBED_SPECIFIC_AND_FOUND) ||
+	   (udev->probed == USBD_PROBED_GENERIC_AND_FOUND))
+	{
+		/* nothing more to probe */
+		goto done;
+	}
+
+	bdev = device_add_child(parent, NULL, -1);
+	if(!bdev)
+	{
+		device_printf(udev->bus->bdev,
+			      "Device creation failed\n");
+		err = USBD_INVAL;
+		goto done;
+	}
+
+	device_set_ivars(bdev, &uaa);
+	device_quiet(bdev);
+
+	if(udev->probed == USBD_PROBED_NOTHING)
+	{
+		/* first try device specific drivers */
+		PRINTF(("trying device specific drivers\n"));
+
+		if(device_probe_and_attach(bdev) == 0)
+		{
+			device_set_ivars(bdev, NULL); /* no longer accessible */
+			udev->subdevs[0] = bdev;
+			udev->probed = USBD_PROBED_SPECIFIC_AND_FOUND;
+			bdev = 0;
+			goto done;
+		}
+
+		PRINTF(("no device specific driver found; "
+			"looping over %d configurations\n",
+			udev->ddesc.bNumConfigurations));
+	}
+
+	/* next try interface drivers */
+
+	if((udev->probed == USBD_PROBED_NOTHING) ||
+	   (udev->probed == USBD_PROBED_IFACE_AND_FOUND))
+	{
+	  for(config = 0; config < udev->ddesc.bNumConfigurations; config++)
+	  {
+		struct usbd_interface *iface;
+
+		/* only set config index the first 
+		 * time the devices are probed
+		 */
+		if(udev->probed == USBD_PROBED_NOTHING)
+		{
+			err = usbd_set_config_index(udev, config, 1);
+			if(err)
+			{
+			    device_printf(parent,
+					  "port %d, set config at addr %d "
+					  "failed, error=%s\n",
+					  port, udev->address, 
+					  usbd_errstr(err));
+			    goto done;
+			}
+
+			/* ``bNumInterface'' is checked 
+			 * by ``usbd_set_config_index()''
+			 *
+			 * ``USBD_CLR_IFACE_NO_PROBE()'' is run
+			 * by ``usbd_fill_iface_data()'', which
+			 * is called by ``usbd_set_config_index()''
+			 */
+		}
+
+		/*
+		 * else the configuration is already set
+		 */
+
+		uaa.configno = udev->cdesc->bConfigurationValue;
+		uaa.ifaces_start = &udev->ifaces[0];
+		uaa.ifaces_end = &udev->ifaces[udev->cdesc->bNumInterface];
+#ifdef USB_COMPAT_OLD
+		uaa.nifaces = udev->cdesc->bNumInterface;
+
+		for(i = 0; i < uaa.nifaces; i++)
+		{
+			if(USBD_GET_IFACE_NO_PROBE(udev, i))
+				uaa.ifaces[i] = NULL;
+			else
+				uaa.ifaces[i] = &udev->ifaces[i];
+		}
+#endif
+		for(iface = uaa.ifaces_start;
+		    iface < uaa.ifaces_end;
+		    iface++)
+		{
+			uaa.iface = iface;
+			uaa.iface_index = (i = (iface - &udev->ifaces[0]));
+
+			if(uaa.iface_index >= (sizeof(udev->subdevs)/
+					       sizeof(udev->subdevs[0])))
+			{
+				device_printf(udev->bus->bdev,
+					      "Too many subdevices\n");
+				break;
+			}
+#ifdef USB_COMPAT_OLD
+			if(uaa.ifaces[i])
+#endif
+			if((USBD_GET_IFACE_NO_PROBE(udev, i) == 0) &&
+			   (udev->subdevs[i] == NULL) &&
+			   (device_probe_and_attach(bdev) == 0))
+			{
+				/* "ivars" are no longer accessible: */
+				device_set_ivars(bdev, NULL); 
+				udev->subdevs[i] = bdev;
+				udev->probed = USBD_PROBED_IFACE_AND_FOUND;
+				bdev = 0;
+
+				/* create another child for the next iface [if any] */
+				bdev = device_add_child(parent, NULL, -1);
+				if(!bdev)
+				{
+					device_printf(udev->bus->bdev,
+						      "Device creation failed\n");
+
+					/* need to update "IFACE_NO_PROBE": */
+					break; 
+				}
+				device_set_ivars(bdev, &uaa);
+				device_quiet(bdev);
+			}
+		}
+
+		if(udev->probed == USBD_PROBED_IFACE_AND_FOUND)
+		{
+#ifdef USB_COMPAT_OLD
+			uaa.nifaces = udev->cdesc->bNumInterface;
+
+			for(i = 0; i < uaa.nifaces; i++)
+			{
+				/* mark ifaces that should
+				 * not be probed
+				 */
+				if(uaa.ifaces[i] == NULL)
+				{
+					USBD_SET_IFACE_NO_PROBE(udev, i);
+				}
+			}
+#endif
+			break;
+		}
+	  }
+	}
+
+	if(udev->probed == USBD_PROBED_NOTHING)
+	{
+		/* set config index 0 */
+
+		err = usbd_set_config_index(udev, 0, 1);
+		if(err)
+		{
+		    device_printf(parent,
+				  "port %d, set config at addr %d "
+				  "failed, error=%s\n",
+				  port, udev->address, 
+				  usbd_errstr(err));
+		    goto done;
+		}
+
+		PRINTF(("no interface drivers found\n"));
+
+		/* finally try the generic driver */
+		uaa.iface = NULL;
+		uaa.iface_index = 0;
+		uaa.ifaces_start = NULL;
+		uaa.ifaces_end = NULL;
+		uaa.usegeneric = 1;
+		uaa.configno = -1;
+
+		if(device_probe_and_attach(bdev) == 0)
+		{
+			device_set_ivars(bdev, NULL); /* no longer accessible */
+			udev->subdevs[0] = bdev;
+			udev->probed = USBD_PROBED_GENERIC_AND_FOUND;
+			bdev = 0;
+			goto done;
+		}
+
+		/*
+		 * Generic attach failed. 
+		 * The device is left as it is.
+		 * It has no driver, but is fully operational.
+		 */
+		PRINTF(("generic attach failed\n"));
+	}
+ done:
+	if(bdev)
+	{
+		/* remove the last created child; it is unused */
+		device_delete_child(parent, bdev);
+	}
+	return err;
+}
+
+/*
+ * Called when a new device has been put in the powered state,
+ * but not yet in the addressed state.
+ * Get initial descriptor, set the address, get full descriptor,
+ * and attach a driver.
+ */
+usbd_status
+usbd_new_device(device_t parent, struct usbd_bus *bus, int depth,
+		int speed, int port, struct usbd_port *up)
+{
+	struct usbd_device *adev;
+	struct usbd_device *udev;
+	struct usbd_device *hub;
+	usb_port_status_t ps;
+	usbd_status err = 0;
+	int addr;
+	int i;
+
+	PRINTF(("bus=%p port=%d depth=%d speed=%d\n",
+		 bus, port, depth, speed));
+
+	/* find unused address */
+	addr = USB_MAX_DEVICES;
+#if (USB_MAX_DEVICES == 0)
+#error "(USB_MAX_DEVICES == 0)"
+#endif
+	while(addr--)
+	{
+		if(addr == 0)
+		{
+			/* address 0 is always unused */
+			device_printf(bus->bdev,
+				      "No free USB addresses, "
+				      "new device ignored.\n");
+			return (USBD_NO_ADDR);
+		}
+		if(bus->devices[addr] == 0)
+		{
+			break;
+		}
+	}
+
+	udev = malloc(sizeof(udev[0]), M_USB, M_NOWAIT|M_ZERO);
+	if(udev == NULL)
+	{
+		return (USBD_NOMEM);
+	}
+
+	up->device = udev;
+
+	/* set up default endpoint descriptor */
+	udev->default_ep_desc.bLength = USB_ENDPOINT_DESCRIPTOR_SIZE;
+	udev->default_ep_desc.bDescriptorType = UDESC_ENDPOINT;
+	udev->default_ep_desc.bEndpointAddress = USB_CONTROL_ENDPOINT;
+	udev->default_ep_desc.bmAttributes = UE_CONTROL;
+	USETW(udev->default_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);
+	udev->default_ep_desc.bInterval = 0;
+
+	/**/
+	udev->bus = bus;
+	udev->quirks = &usbd_no_quirk;
+	udev->address = USB_START_ADDR;
+	udev->ddesc.bMaxPacketSize = 0;
+	udev->depth = depth;
+	udev->powersrc = up;
+	udev->myhub = up->parent;
+
+	hub = up->parent;
+
+	if(hub)
+	{
+		if(speed > hub->speed)
+		{
+#ifdef USB_DEBUG
+			printf("%s: maxium speed of attached "
+			       "device, %d, is higher than speed "
+			       "of parent HUB, %d.\n",
+			       __FUNCTION__, speed, hub->speed);
+#endif
+			/* speed down 
+			 * (else there is trouble setting 
+			 *  up the right transfer methods)
+			 */
+			speed = hub->speed;
+		}
+	}
+
+	adev = udev;
+	while(hub && (hub->speed != USB_SPEED_HIGH))
+	{
+		adev = hub;
+		hub = hub->myhub;
+	}
+
+	if(hub)
+	{
+		for(i = 0; i < hub->hub->hubdesc.bNbrPorts; i++)
+		{
+			if(hub->hub->ports[i].device == adev)
+			{
+				udev->myhsport = &hub->hub->ports[i];
+				break;
+			}
+		}
+	}
+
+	udev->speed = speed;
+	udev->langid = USBD_NOLANG;
+
+	/* usb_cookie_no is used by "usb.c" */
+
+	static u_int32_t usb_cookie_no = 0;
+
+	udev->cookie.cookie = ++usb_cookie_no;
+
+	/* init the default pipe */
+	usbd_fill_pipe_data(udev, 0,
+			    &udev->default_ep_desc,
+			    &udev->default_pipe);
+
+	/* Set the address.  Do this early; some devices need that.
+	 * Try a few times in case the device is slow (i.e. outside specs.)
+	 */
+	for (i = 0; i < 15; i++)
+	{
+		err = usbreq_set_address(udev, addr);
+		if(!err)
+		{
+			break;
+		}
+		usbd_delay_ms(udev, 200);
+		if(((i & 3) == 3) && (up->parent))
+		{
+			PRINTF(("set address %d "
+				 "failed - trying a port reset\n", addr));
+			usbreq_reset_port(up->parent, port, &ps);
+		}
+	}
+	if(err)
+	{
+		PRINTF(("set address %d failed\n", addr));
+		err = USBD_SET_ADDR_FAILED;
+		goto done;
+	}
+
+	/* allow device time to set new address */
+	usbd_delay_ms(udev, USB_SET_ADDRESS_SETTLE);
+	udev->address = addr;	/* new device address now */
+	bus->devices[addr] = udev;
+
+	/* get the first 8 bytes of the device descriptor */
+	err = usbreq_get_desc(udev, UDESC_DEVICE, 0, USB_MAX_IPACKET, &udev->ddesc, 0);
+	if(err)
+	{
+		PRINTF(("addr=%d, getting first desc failed\n",
+			 udev->address));
+		goto done;
+	}
+
+	if(speed == USB_SPEED_HIGH)
+	{
+		/* max packet size must be 64 (sec 5.5.3) */
+		if(udev->ddesc.bMaxPacketSize != USB_2_MAX_CTRL_PACKET)
+		{
+#ifdef DIAGNOSTIC
+			printf("%s: addr=%d bad max packet size\n",
+			       __FUNCTION__, udev->address);
+#endif
+			udev->ddesc.bMaxPacketSize = USB_2_MAX_CTRL_PACKET;
+		}
+	}
+
+	if(udev->ddesc.bMaxPacketSize == 0)
+	{
+#ifdef USB_DEBUG
+		printf("%s: addr=%d invalid bMaxPacketSize!\n",
+		       __FUNCTION__, udev->address);
+#endif
+		/* avoid division by zero */
+		udev->ddesc.bMaxPacketSize = USB_MAX_IPACKET;
+	}
+
+	PRINTF(("adding unit addr=%d, rev=%02x, class=%d, "
+		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, speed=%d\n",
+		 udev->address, UGETW(udev->ddesc.bcdUSB),
+		 udev->ddesc.bDeviceClass,
+		 udev->ddesc.bDeviceSubClass,
+		 udev->ddesc.bDeviceProtocol,
+		 udev->ddesc.bMaxPacketSize,
+		 udev->ddesc.bLength,
+		 udev->speed));
+
+	if(udev->ddesc.bDescriptorType != UDESC_DEVICE)
+	{
+		/* illegal device descriptor */
+		PRINTF(("illegal descriptor %d\n",
+			 udev->ddesc.bDescriptorType));
+		err = USBD_INVAL;
+		goto done;
+	}
+	if(udev->ddesc.bLength < USB_DEVICE_DESCRIPTOR_SIZE)
+	{
+		PRINTF(("bad length %d\n",
+			 udev->ddesc.bLength));
+		err = USBD_INVAL;
+		goto done;
+	}
+
+	USETW(udev->default_ep_desc.wMaxPacketSize, udev->ddesc.bMaxPacketSize);
+
+	/* get the full device descriptor */
+	err = usbreq_get_device_desc(udev, &udev->ddesc);
+	if(err)
+	{
+		PRINTF(("addr=%d, getting full desc failed\n",
+			 udev->address));
+		goto done;
+	}
+
+	/* figure out what's wrong with this device */
+	udev->quirks = usbd_find_quirk(&udev->ddesc);
+
+	/* assume 100mA bus powered for now. Changed when configured. */
+	udev->power = USB_MIN_POWER;
+	udev->self_powered = 0;
+
+	/* buffer serial number */
+	(void) usbreq_get_string_any
+	  (udev, udev->ddesc.iSerialNumber, 
+	   &udev->serial[0], sizeof(udev->serial));
+
+	/* check serial number format */
+
+	for(i = 0;;i++)
+	{
+		if(udev->serial[i] == '\0') break;
+		if(udev->serial[i] == '\"') udev->serial[i] = ' ';
+		if(udev->serial[i] == '\n') udev->serial[i] = ' ';
+	}
+
+	PRINTF(("new dev (addr %d), udev=%p, parent=%p\n",
+		 udev->address, udev, parent));
+
+	err = usbd_probe_and_attach(parent, port, up);
+
+ done:
+	if(err)
+	{
+		/* remove device and sub-devices */
+		usbd_free_device(up, 1);
+	}
+	else
+	{
+		usbd_add_dev_event(USB_EVENT_DEVICE_ATTACH, udev);
+	}
+	return(err);
+}
+
+/* called when a port has been disconnected
+ *
+ * The general mechanism for detaching:
+ *
+ * The drivers should use a static softc or a softc which is not freed
+ * immediately, so that calls to routines which are about to access
+ * the softc, does not access freed memory.
+ *
+ * The drivers mutex should also be available for some time after
+ * detach.
+ *
+ * The drivers should have a detach flag which is set when the driver
+ * is detached. The detach flag is checked after locking drivers mutex
+ * and after waking up from sleep. When the detach flag is set, the
+ * driver must unlock drivers mutex and exit.
+ */
+void
+usbd_free_device(struct usbd_port *up, u_int8_t free_subdev)
+{
+	struct usbd_device *udev = up->device;
+	device_t *subdev = &udev->subdevs[0];
+	device_t *subdev_end = &udev->subdevs_end[0];
+	int error = 0;
+
+	/* mtx_assert() */
+
+	if(udev == NULL)
+	{
+		/* already freed */
+		return;
+	}
+
+	PRINTFN(3,("up=%p udev=%p port=%d; "
+		    "disconnect subdevs\n",
+		    up, udev, up->portno));
+
+	while(subdev < subdev_end)
+	{
+		if(subdev[0] && free_subdev)
+		{
+			device_printf(subdev[0], "at %s ", device_get_nameunit
+				(device_get_parent(subdev[0])));
+
+			if(up->portno != 0)
+			{
+				printf("port %d ", up->portno);
+			}
+
+			printf("(addr %d) disconnected\n", udev->address);
+
+			/* device_delete_child() will detach all sub-devices ! */
+			if(device_delete_child
+				(device_get_parent(subdev[0]), subdev[0]))
+			{
+				/* if detach fails sub-devices will still
+				 * be referring to the udev structure
+				 * which cannot be freed
+				 */
+				device_printf(subdev[0], "detach failed "
+					"(please ensure that this "
+					"device driver supports detach)\n");
+
+				error = ENXIO;
+			}
+		}
+
+		/* always clear subdev[0], 
+		 * because it might be used by
+		 * usbd_add_dev_event()
+		 */
+		subdev[0] = NULL;
+		subdev++;
+	}
+
+	/* issue detach event and free address */
+	if(udev->bus != NULL)
+	{
+		usbd_add_dev_event(USB_EVENT_DEVICE_DETACH, udev);
+
+		/* NOTE: address 0 is always unused */
+		udev->bus->devices[udev->address] = 0;
+	}
+
+	usbd_free_iface_data(udev);
+
+	if(error)
+	{
+		panic("%s: some USB devices would not detach\n",
+			__FUNCTION__);
+	}
+
+	/* free device */
+	free(udev, M_USB);
+	up->device = 0;
+	return;
+}
+
+void
+usb_detach_wait(device_t dev)
+{
+	PRINTF(("waiting for %s\n", device_get_nameunit(dev)));
+
+	/* XXX should use msleep */
+
+	if(tsleep(dev, PZERO, "usbdet", hz * 60))
+	{
+		device_printf(dev, "didn't detach\n");
+	}
+	PRINTF(("%s done\n", device_get_nameunit(dev)));
+	return;
+}
+
+void
+usb_detach_wakeup(device_t dev)
+{
+	PRINTF(("for %s\n", device_get_nameunit(dev)));
+	wakeup(dev);
+	return;
+}
+
+struct usbd_interface *
+usbd_get_iface(struct usbd_device *udev, u_int8_t iface_index)
+{
+	struct usbd_interface *iface = &udev->ifaces[iface_index];
+
+	if((iface < &udev->ifaces[0]) ||
+	   (iface >= &udev->ifaces_end[0]) ||
+	   (udev->cdesc == NULL) ||
+	   (iface_index >= udev->cdesc->bNumInterface))
+	{
+		return NULL;
+	}
+	return iface;
+}
+
+void
+usbd_set_desc(device_t dev, struct usbd_device *udev)
+{
+	u_int8_t devinfo[1024];
+
+	usbd_devinfo(udev, 1, &devinfo[0]);
+	device_set_desc_copy(dev, &devinfo[0]);
+	device_printf(dev, "<%s>\n", &devinfo[0]);
+	return;
+}
diff -rubN /usr/src1/src/sys/dev/usb2/_usb_transfer.c /usr/src/sys/dev/usb2/_usb_transfer.c
--- /usr/src1/src/sys/dev/usb2/_usb_transfer.c	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/_usb_transfer.c	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,1780 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+
+#include <dev/usb2/usb_port.h>
+#include <dev/usb2/usb.h>
+#include <dev/usb2/usb_subr.h>
+
+__FBSDID("$FreeBSD: src/sys/dev/usb2/usb_transfer.c $");
+
+#ifdef USB_DEBUG
+void
+usbd_dump_iface(struct usbd_interface *iface)
+{
+	printf("usbd_dump_iface: iface=%p\n", iface);
+	if(iface == NULL)
+	{
+		return;
+	}
+	printf(" iface=%p idesc=%p altindex=%d\n",
+	       iface, iface->idesc, iface->alt_index);
+	return;
+}
+
+void
+usbd_dump_device(struct usbd_device *udev)
+{
+	printf("usbd_dump_device: dev=%p\n", udev);
+	if(udev == NULL)
+	{
+		return;
+	}
+	printf(" bus=%p \n"
+	       " address=%d config=%d depth=%d speed=%d self_powered=%d\n"
+	       " power=%d langid=%d\n",
+	       udev->bus, 
+	       udev->address, udev->config, udev->depth, udev->speed,
+	       udev->self_powered, udev->power, udev->langid);
+	return;
+}
+
+void
+usbd_dump_queue(struct usbd_pipe *pipe)
+{
+	struct usbd_xfer *xfer;
+
+	printf("usbd_dump_queue: pipe=%p\n", pipe);
+	LIST_FOREACH(xfer, &pipe->list_head, pipe_list)
+	{
+		printf("  xfer=%p\n", xfer);
+	}
+	return;
+}
+
+void
+usbd_dump_pipe(struct usbd_pipe *pipe)
+{
+	if(pipe)
+	{
+		printf("usbd_dump_pipe: pipe=%p", pipe);
+
+		printf(" edesc=%p isoc_next=%d toggle_next=%d",
+		       pipe->edesc, pipe->isoc_next, pipe->toggle_next);
+
+		if(pipe->edesc)
+		{
+			printf(" bEndpointAddress=0x%02x",
+			       pipe->edesc->bEndpointAddress);
+		}
+		printf("\n");
+		usbd_dump_queue(pipe);
+	}
+	else
+	{
+		printf("usbd_dump_pipe: pipe=NULL\n");
+	}
+	return;
+}
+
+void
+usbd_dump_xfer(struct usbd_xfer *xfer)
+{
+	printf("usbd_dump_xfer: xfer=%p\n", xfer);
+	if(xfer == NULL)
+	{
+		return;
+	}
+        if(xfer->pipe == NULL)
+	{
+		printf("xfer %p: pipe=NULL\n",
+		       xfer);
+                return;
+	}
+	printf("xfer %p: udev=%p vid=0x%04x pid=0x%04x addr=%d "
+	       "pipe=%p ep=0x%02x attr=0x%02x\n",
+	       xfer, xfer->udev,
+	       UGETW(xfer->udev->ddesc.idVendor),
+	       UGETW(xfer->udev->ddesc.idProduct),
+	       xfer->udev->address, xfer->pipe,
+	       xfer->pipe->edesc->bEndpointAddress, 
+	       xfer->pipe->edesc->bmAttributes);
+	return;
+}
+#endif
+
+u_int32_t
+usb_get_devid(device_t dev)
+{
+	struct usb_attach_arg *uaa = device_get_ivars(dev);
+	return ((uaa->vendor << 16) | (uaa->product));
+}
+
+struct usbd_pipe *
+usbd_get_pipe(struct usbd_device *udev, u_int8_t iface_index,
+	      const struct usbd_config *setup)
+{
+	struct usbd_pipe *pipe;
+	u_int8_t index = setup->index;
+
+	PRINTFN(8,("udev=%p iface_index=%d address=0x%x "
+		    "type=0x%x dir=0x%x index=%d\n",
+		    udev, iface_index, setup->endpoint,
+		    setup->type, setup->direction, setup->index));
+
+	pipe = &udev->pipes_end[0];
+	while(--pipe >= &udev->pipes[0])
+	{
+		if((pipe->edesc) &&
+		   (pipe->iface_index == iface_index) &&
+		   (((pipe->edesc->bEndpointAddress & (UE_DIR_IN|UE_DIR_OUT)) == setup->direction) || (setup->direction == 0xff)) &&
+		   (((pipe->edesc->bEndpointAddress & UE_ADDR) == setup->endpoint) || (setup->endpoint == 0xff)) &&
+		   (((pipe->edesc->bmAttributes & UE_XFERTYPE) == setup->type) || (setup->type == 0xff))
+		   )
+		{
+			if(!index--)
+			{
+				goto found;
+			}
+		}
+	}
+
+	/* match against default pipe last, so that "any pipe", 
+	 * "any address" and "any direction" returns the first 
+	 * pipe of the interface
+	 */
+	if((setup->endpoint == 0) &&
+	   (setup->type == 0))
+	  /* "iface_index" and "direction" is ignored */
+	{
+		pipe = &udev->default_pipe;
+		goto found;
+	}
+	return NULL;
+
+ found:
+	return pipe;
+}
+
+usbd_status
+usbd_interface_count(struct usbd_device *udev, u_int8_t *count)
+{
+	if(udev->cdesc == NULL)
+	{
+		return (USBD_NOT_CONFIGURED);
+	}
+	*count = udev->cdesc->bNumInterface;
+	return (USBD_NORMAL_COMPLETION);
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_transfer_setup - setup an array of USB transfers
+ *
+ * NOTE: must always call unsetup after setup 
+ * NOTE: the parameter "iface_index" is ignored in
+ *       case of control pipes
+ *
+ * The idea that the USB device driver should pre-allocate all
+ * its transfers by one call to this function.
+ *---------------------------------------------------------------------------*/
+usbd_status
+usbd_transfer_setup(struct usbd_device *udev, 
+		    u_int8_t iface_index, 
+		    struct usbd_xfer **pxfer,
+		    const struct usbd_config *setup_start, 
+		    u_int16_t n_setup, 
+		    void *priv_sc,
+		    struct mtx *priv_mtx,
+		    usbd_unsetup_callback_t *priv_func)
+{
+	const struct usbd_config *setup_end = setup_start + n_setup;
+	const struct usbd_config *setup;
+	struct usbd_memory_info *info;
+	struct usbd_xfer *xfer;
+	usbd_status error = 0;
+	u_int16_t n;
+
+	/* do some checking first */
+
+	if(n_setup == 0)
+	{
+		PRINTFN(5, ("setup array has zero length!\n"));
+		return USBD_INVAL;
+	}
+
+	if(priv_mtx == NULL)
+	{
+		PRINTFN(5, ("using global lock\n"));
+		priv_mtx = &usb_global_lock;
+	}
+
+	for(setup = setup_start, n = n_setup; n--; setup++)
+	{
+		if((setup->bufsize == 0) ||
+		   (setup->bufsize == 0xffffffff))
+		{
+		    error = USBD_BAD_BUFSIZE;
+		    PRINTF(("invalid bufsize\n"));
+		}
+		if(setup->flags & USBD_SYNCHRONOUS)
+		{
+		    if(setup->callback != &usbd_default_callback)
+		    {
+		        error = USBD_SYNC_TRANSFER_MUST_USE_DEFAULT_CALLBACK;
+			PRINTF(("synchronous transfers "
+				"must use default callback\n"));
+		    }
+		}
+		if(setup->flags & 
+		   (~(USBD_SYNCHRONOUS|
+		      USBD_FORCE_SHORT_XFER|
+		      USBD_SHORT_XFER_OK|
+		      USBD_CUSTOM_CLEARSTALL|
+		      USBD_USE_POLLING|
+		      USBD_SELF_DESTRUCT)))
+		{
+		    error = USBD_BAD_FLAG;
+		    PRINTF(("invalid flag(s) specified: "
+			    "0x%08x\n", setup->flags));
+		}
+		if(setup->callback == NULL)
+		{
+		    error = USBD_NO_CALLBACK;
+		    PRINTF(("no callback\n"));
+		}
+		pxfer[n] = NULL;
+	}
+
+	if(error)
+	{
+		goto done;
+	}
+
+	error = (udev->bus->methods->xfer_setup)
+	  (udev,iface_index,pxfer,setup_start,setup_end);
+
+
+	/* common setup */
+
+	for(setup = setup_start, n = n_setup; n--; setup++)
+	{
+		xfer = pxfer[n];
+
+		if(xfer)
+		{
+		    xfer->priv_sc = priv_sc;
+		    xfer->priv_mtx = priv_mtx;
+		    xfer->udev = udev;
+		    if(xfer->pipe)
+		    {
+		        xfer->pipe->refcount++;
+		    }
+
+		    info = xfer->usb_root;
+		    info->memory_refcount++;
+		    info->priv_sc = priv_sc;
+		    info->priv_mtx = priv_mtx;
+		    info->priv_func = priv_func;
+		}
+	}
+
+ done:
+	if(error)
+	{
+		usbd_transfer_unsetup(pxfer, n_setup);
+	}
+	return (error);
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_drop_refcount 
+ *
+ * This function is called from various places, and its job is to
+ * free the memory holding a set of "transfers", when it 
+ * is safe to do so.
+ *---------------------------------------------------------------------------*/
+static void
+usbd_drop_refcount(struct usbd_memory_info *info)
+{
+    u_int8_t free_memory;
+
+    mtx_lock(info->usb_mtx);
+
+    __KASSERT(info->memory_refcount != 0, ("Invalid memory reference count!\n"));
+
+    free_memory = ((--(info->memory_refcount)) == 0);
+
+    mtx_unlock(info->usb_mtx);
+
+    if(free_memory)
+    {
+        if(info->priv_func)
+	{
+	    (info->priv_func)(info);
+	}
+	usb_free_mem(info->memory_base, info->memory_size);
+    }
+    return;
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_transfer_unsetup - unsetup/free an array of USB transfers
+ *
+ * NOTE: if the transfer was in progress, the callback will 
+ * called with "xfer->error=USBD_CANCELLED", before this
+ * function returns
+ *
+ * NOTE: the mutex "xfer->priv_mtx" might be in use by 
+ * the USB system after that this function has returned! 
+ * Therefore the mutex, "xfer->priv_mtx", should be allocated 
+ * in static memory. The function "priv_func" will be called
+ * when it is safe to destroy this mutex.
+ *---------------------------------------------------------------------------*/
+void
+usbd_transfer_unsetup(struct usbd_xfer **pxfer, u_int16_t n_setup)
+{
+	struct usbd_xfer *xfer;
+
+	while(n_setup--)
+	{
+	    xfer = pxfer[n_setup];
+	    pxfer[n_setup] = NULL;
+
+	    if(xfer)
+	    {
+		if(xfer->pipe)
+		{
+		    mtx_lock(xfer->priv_mtx);
+
+		    usbd_transfer_stop(xfer);
+
+		    /* NOTE: default pipe does not
+		     * have an interface, even if
+		     * pipe->iface_index == 0
+		     */
+		    xfer->pipe->refcount--;
+
+		    mtx_unlock(xfer->priv_mtx);
+		}
+
+		if(xfer->usb_root)
+		{
+		    usbd_drop_refcount(xfer->usb_root);
+		}
+	    }
+	}
+	return;
+}
+
+/* CALLBACK EXAMPLES:
+ * ==================
+ *
+ * USBD_CHECK_STATUS() overview of possible program paths:
+ * =======================================================
+ *
+ *       +->-----------------------+
+ *       |                         |    
+ *   +-<-+-------[tr_setup]--------+-<-+-<-[start/restart]
+ *   |                                 |
+ *   |                                 |
+ *   |                                 |
+ *   +------>-[tr_transferred]---------+
+ *   |                                 |
+ *   +--------->-[tr_error]------------+
+ *
+ * NOTE: the USB-driver automatically
+ * recovers from errors if 
+ * "xfer->clearstall_xfer" is set
+ *
+ * Host-transmit callback example (bulk/interrupt/isochronous):
+ * ============================================================
+ * static void
+ * usb_callback_tx(struct usbd_xfer *xfer)
+ * {
+ *   USBD_CHECK_STATUS(xfer);
+ *
+ * tr_transferred:
+ * tr_setup:
+ *
+ *   ... setup "xfer->length" ...
+ *
+ *   ... write data to buffer ...
+ *
+ * tr_error:
+ *
+ *   ... [re-]transfer "xfer->buffer" ...
+ *
+ *   usbd_start_hardware(xfer);
+ *   return;
+ * }
+ *
+ * Host-receive callback example (bulk/interrupt/isochronous):
+ * ===========================================================
+ * static void
+ * usb_callback_rx(struct usbd_xfer *xfer)
+ * {
+ *   USBD_CHECK_STATUS(xfer);
+ *
+ * tr_transferred:
+ *
+ *   ... process data in buffer ...
+ *
+ * tr_setup:
+ *
+ *   ... setup "xfer->length" ...
+ *
+ * tr_error:
+ *
+ *   ... [re-]transfer "xfer->buffer" ...
+ *
+ *   usbd_start_hardware(xfer);
+ *   return;
+ * }
+ *
+ *
+ * "usbd_start_hardware()" is called when 
+ * "xfer->buffer" is ready for transfer
+ *
+ * "usbd_start_hardware()" should only be called
+ *  from callback
+ */
+
+/*---------------------------------------------------------------------------*
+ *	usbd_start_hardware - start USB hardware for the given transfer
+ *---------------------------------------------------------------------------*/
+void
+usbd_start_hardware(struct usbd_xfer *xfer)
+{
+	PRINTFN(0,("xfer=%p, pipe=%p len=%d dir=%s\n",
+		    xfer, xfer->pipe, xfer->length, 
+		    ((xfer->pipe->edesc->bEndpointAddress & 
+		      (UE_DIR_IN|UE_DIR_OUT)) == UE_DIR_IN) ? "in" : "out"));
+
+#ifdef USB_DEBUG
+	if(usbdebug > 0)
+	{
+		mtx_lock(xfer->usb_mtx);
+
+		usbd_dump_pipe(xfer->pipe);
+
+		mtx_unlock(xfer->usb_mtx);
+	}
+#endif
+
+	mtx_assert(xfer->priv_mtx, MA_OWNED);
+
+	if(xfer->flags & USBD_DEV_OPEN)
+	{
+		/* set USBD_DEV_TRANSFERRING and USBD_DEV_RECURSED_2 */
+		xfer->flags |= (USBD_DEV_TRANSFERRING|USBD_DEV_RECURSED_2);
+
+		if(xfer->pipe->clearstall &&
+		   xfer->clearstall_xfer)
+		{
+#ifdef USB_DEBUG
+			if(xfer->clearstall_xfer->flags & USBD_DEV_TRANSFERRING)
+			{
+				PRINTF(("clearstall_xfer is transferrring!\n"));
+			}
+#endif
+			/* the polling flag is inherited */
+
+			if(xfer->flags & USBD_USE_POLLING)
+			  xfer->clearstall_xfer->flags |= USBD_USE_POLLING;
+			else
+			  xfer->clearstall_xfer->flags &= ~USBD_USE_POLLING;
+
+			/* store pointer to transfer */
+			xfer->clearstall_xfer->priv_sc = xfer;
+
+			usbd_transfer_start(xfer->clearstall_xfer);
+		}
+		else
+		{
+#ifdef USB_COMPAT_OLD
+			if(xfer->d_copy_src)
+			{
+				bcopy(xfer->d_copy_src, xfer->d_copy_ptr, xfer->d_copy_len);
+			}
+			if(xfer->f_copy_src)
+			{
+				bcopy(xfer->f_copy_src, xfer->f_copy_ptr, xfer->f_copy_len);
+			}
+#endif
+			mtx_lock(xfer->usb_mtx);
+
+			/* enter the transfer */
+			(xfer->pipe->methods->enter)(xfer);
+
+			xfer->usb_thread = (xfer->flags & USBD_USE_POLLING) ? 
+			  curthread : NULL;
+
+			mtx_unlock(xfer->usb_mtx);
+ 		}
+	}
+	return;
+}
+
+void
+usbd_transfer_start_safe(struct usbd_xfer *xfer)
+{
+	mtx_lock(xfer->priv_mtx);
+	usbd_transfer_start(xfer);
+	mtx_unlock(xfer->priv_mtx);
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_transfer_start - start a USB transfer
+ *
+ * NOTE: this function can be called any number of times
+ * NOTE: if USBD_SYNCHRONOUS is set in "xfer->flags", then this
+ *       function will sleep for transfer completion
+ * NOTE: if USBD_USE_POLLING is set in "xfer->flags", then this
+ *       function will spin until transfer is completed
+ *---------------------------------------------------------------------------*/
+void
+usbd_transfer_start(struct usbd_xfer *xfer)
+{
+	mtx_assert(xfer->priv_mtx, MA_OWNED);
+
+	if(!(xfer->flags & USBD_DEV_OPEN))
+	{
+		xfer->flags |= USBD_DEV_OPEN;
+
+		/*
+		 * open transfer
+		 */
+		mtx_lock(xfer->usb_mtx);
+		(xfer->pipe->methods->open)(xfer);
+		mtx_unlock(xfer->usb_mtx);
+	}
+
+	/* "USBD_DEV_TRANSFERRING" is only changed
+	 * when "priv_mtx" is locked;
+	 * check first recurse flag
+	 */
+	if(!(xfer->flags & (USBD_DEV_TRANSFERRING)))
+	{
+		if(xfer->flags & USBD_SELF_DESTRUCT)
+		{
+		    /* increment refcount 
+		     * in case the callback
+		     * frees itself:
+		     */
+		    mtx_lock(xfer->usb_mtx);
+		    xfer->usb_root->memory_refcount++;
+		    mtx_unlock(xfer->usb_mtx);
+		}
+
+		/* call callback */
+		__usbd_callback(xfer);
+
+		/* wait for completion
+		 * if the transfer is synchronous
+		 */
+		if(xfer->flags & (USBD_SYNCHRONOUS|USBD_USE_POLLING))
+		{
+			u_int timeout = xfer->timeout +1;
+			struct usbd_bus *bus = xfer->udev->bus;
+
+			while(xfer->flags & USBD_DEV_TRANSFERRING)
+			{
+				if(bus->use_polling ||
+				   (xfer->flags & USBD_USE_POLLING))
+				{
+					if(!timeout--)
+					{
+						/* stop the transfer */
+						usbd_transfer_stop(xfer);
+						break;
+					}
+
+					/* delay one millisecond */
+					DELAY(1000);
+
+					/* call the interrupt handler,
+					 * which will call __usbd_callback():
+					 */
+					(bus->methods->do_poll)(bus);
+				}
+				else
+				{
+					u_int recurse = xfer->priv_mtx->mtx_recurse;
+					u_int __recurse = recurse;
+
+					/* need to unlock private mutex so that
+					 * callback can be called
+					 */
+					while(__recurse--)
+					{
+						mtx_unlock(xfer->priv_mtx);
+					}
+
+					if(msleep(xfer, xfer->priv_mtx,
+						  (PRIBIO|PCATCH), "usbsync", 0))
+					{
+						/* stop the transfer */
+						usbd_transfer_stop(xfer);
+					}
+
+					while(recurse--)
+					{
+						mtx_lock(xfer->priv_mtx);
+					}
+					break;
+				}
+			}
+		}
+		if(xfer->flags & USBD_SELF_DESTRUCT)
+		{
+		    usbd_drop_refcount(xfer->usb_root);
+		}
+	}
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_transfer_stop - stop a USB transfer
+ *
+ * NOTE: this function can be called any number of times
+ *---------------------------------------------------------------------------*/
+void
+usbd_transfer_stop(struct usbd_xfer *xfer)
+{
+	mtx_assert(xfer->priv_mtx, MA_OWNED);
+
+	if(xfer->flags & USBD_DEV_OPEN)
+	{
+		xfer->flags &= ~USBD_DEV_OPEN;
+
+		/*
+		 * stop clearstall first
+		 */
+		if(xfer->clearstall_xfer)
+		{
+			usbd_transfer_stop(xfer->clearstall_xfer);
+		}
+
+		/*
+		 * close transfer (should not call callback)
+		 */
+		mtx_lock(xfer->usb_mtx);
+		(xfer->pipe->methods->close)(xfer);
+
+		/* always set error */
+		xfer->error = USBD_CANCELLED;
+
+		if(xfer->flags & USBD_SELF_DESTRUCT)
+		{
+		    /* increment refcount 
+		     * in case the callback
+		     * frees itself:
+		     */
+		    mtx_lock(xfer->usb_mtx);
+		    xfer->usb_root->memory_refcount++;
+		    mtx_unlock(xfer->usb_mtx);
+		}
+
+		if(xfer->flags & USBD_DEV_TRANSFERRING)
+		{
+		    /* increment refcount so that scheduled
+		     * callbacks, if any, are not called by 
+		     * the interrupt or timeout routines:
+		     */
+		    xfer->usb_refcount++;
+
+		    /* call callback, which 
+		     * will clear USBD_DEV_TRANSFERRING
+		     */
+		    __usbd_callback(xfer);
+		}
+		mtx_unlock(xfer->usb_mtx);
+
+		if(xfer->flags & USBD_SELF_DESTRUCT)
+		{
+		    usbd_drop_refcount(xfer->usb_root);
+		}
+	}
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ *	__usbd_callback
+ *
+ * This is a wrapper for USB callbacks, which handles
+ * recursation, which can happen during boot.
+ *---------------------------------------------------------------------------*/
+void
+__usbd_callback(struct usbd_xfer *xfer)
+{
+	mtx_assert(xfer->priv_mtx, MA_OWNED);
+
+	/* check first recurse flag */
+	if(!(xfer->flags & USBD_DEV_RECURSED_1))
+	{
+		do {
+			/* set both recurse flags */
+			xfer->flags |= (USBD_DEV_RECURSED_2|
+					USBD_DEV_RECURSED_1);
+
+			/* call processing routine */
+			(xfer->callback)(xfer);
+
+		/* check second recurse flag */
+		} while(!(xfer->flags & USBD_DEV_RECURSED_2));
+
+		/* clear first recurse flag */
+		xfer->flags &= ~USBD_DEV_RECURSED_1;
+	}
+	else
+	{
+		/* clear second recurse flag */
+		xfer->flags &= ~USBD_DEV_RECURSED_2;
+	}
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_do_callback
+ *
+ * This function is used to call back a list of USB callbacks. 
+ *---------------------------------------------------------------------------*/
+void
+usbd_do_callback(struct usbd_callback_info *ptr, 
+		 struct usbd_callback_info *limit)
+{
+    struct usbd_xfer *xfer;
+
+    if(limit < ptr)
+    {
+        /* parameter order switched */
+        register void *temp = ptr;
+	ptr = limit;
+	limit = temp;
+    }
+
+    while(ptr < limit)
+    {
+        xfer = ptr->xfer;
+
+	/*
+	 * During the unlocked period, the
+	 * transfer can be restarted by 
+	 * another thread, which must be
+	 * checked here:
+	 */
+	mtx_lock(xfer->priv_mtx);
+
+	if(xfer->usb_refcount == ptr->refcount)
+	{
+	    /* call callback */
+	    __usbd_callback(xfer);
+	}
+	/* 
+	 * else already called back !
+	 */
+	mtx_unlock(xfer->priv_mtx);
+
+	usbd_drop_refcount(xfer->usb_root);
+
+	ptr++;
+    }
+    return;
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_transfer_done
+ *
+ * NOTE: this function does not call the callback!
+ *---------------------------------------------------------------------------*/
+void
+usbd_transfer_done(struct usbd_xfer *xfer, usbd_status error)
+{
+	mtx_assert(xfer->usb_mtx, MA_OWNED);
+
+	PRINTFN(5,("xfer=%p pipe=%p status=%d "
+		    "actlen=%d\n", xfer, xfer->pipe, error, xfer->actlen));
+
+#if defined(DIAGNOSTIC) || defined(USB_DEBUG)
+	if(xfer->pipe == NULL)
+	{
+		printf("xfer=%p, pipe=NULL\n", xfer);
+		return;
+	}
+#endif
+       	/* count completed transfers */
+	++(xfer->udev->bus->stats.uds_requests
+		[xfer->pipe->edesc->bmAttributes & UE_XFERTYPE]);
+
+	/* check for short transfers */
+	if(!error)
+	{
+		if(xfer->actlen > xfer->length)
+		{
+			printf("%s: overrun actlen(%d) > len(%d)\n",
+			       __FUNCTION__, xfer->actlen, xfer->length);
+			xfer->actlen = xfer->length;
+		}
+
+		if((xfer->actlen < xfer->length) &&
+		   !(xfer->flags & USBD_SHORT_XFER_OK))
+		{
+			printf("%s: short transfer actlen(%d) < len(%d)\n",
+			       __FUNCTION__, xfer->actlen, xfer->length);
+			error = USBD_SHORT_XFER;
+		}
+	}
+	xfer->error = error;
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_transfer_enqueue
+ *
+ * This function is used to put a USB transfer on
+ * the pipe list. If there was no previous 
+ * USB transfer on the list, the start method of
+ * the transfer will be called.
+ *---------------------------------------------------------------------------*/
+void
+usbd_transfer_enqueue(struct usbd_xfer *xfer)
+{
+	mtx_assert(xfer->usb_mtx, MA_OWNED);
+
+	/* if xfer is not inserted, 
+	 * insert xfer in xfer queue
+	 */
+	if(xfer->pipe_list.le_prev == NULL)
+	{
+		LIST_INSERT_HEAD(&xfer->pipe->list_head, xfer, pipe_list);
+
+		/* start first transfer enqueued */
+
+		if(xfer->pipe_list.le_next == NULL)
+		{
+			(xfer->pipe->methods->start)(xfer);
+		}
+	}
+	return;
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_transfer_dequeue
+ *
+ * This function is used to remove a USB transfer from
+ * the pipe list. If the first USB transfer on the pipe
+ * list is removed, the start method of the next USB
+ * transfer will be called, if any.
+ *---------------------------------------------------------------------------*/
+void
+usbd_transfer_dequeue(struct usbd_xfer *xfer)
+{
+	mtx_assert(xfer->usb_mtx, MA_OWNED);
+
+	/* if two transfers are queued, the
+	 * second transfer must be started
+	 * before the first is called back
+	 */
+
+	/* if xfer is not removed,
+	 * remove xfer from xfer queue
+	 */
+	if(xfer->pipe_list.le_prev)
+	{
+		LIST_REMOVE(xfer,pipe_list);
+
+		/* if started transfer is dequeued,
+		 * start next transfer
+		 */
+		if((xfer->pipe_list.le_next == 0) && /* last xfer */
+		   (!LIST_EMPTY(&xfer->pipe->list_head)))
+		{
+		  (xfer->pipe->methods->start)
+		    ((void *)
+		     (((u_int8_t *)(xfer->pipe_list.le_prev)) - 
+		      POINTER_TO_UNSIGNED(&LIST_NEXT((struct usbd_xfer *)0,pipe_list))));
+		}
+		xfer->pipe_list.le_prev = 0;
+	}
+	return;
+}
+
+void
+usbd_default_callback(struct usbd_xfer *xfer)
+{
+	USBD_CHECK_STATUS(xfer);
+
+ tr_setup:
+	/**/
+	usbd_start_hardware(xfer);
+	return;
+
+ tr_transferred:
+ tr_error:
+	if((xfer->flags & USBD_SYNCHRONOUS) && 
+	   (!(xfer->udev->bus->use_polling || (xfer->flags & USBD_USE_POLLING))))
+	{
+		wakeup(xfer);
+	}
+
+#ifdef USB_COMPAT_OLD
+
+	if(xfer->d_copy_dst)
+	{
+		bcopy(xfer->d_copy_ptr, xfer->d_copy_dst, xfer->d_copy_len);
+	}
+
+	if(xfer->f_copy_dst)
+	{
+		bcopy(xfer->f_copy_ptr, xfer->f_copy_dst, xfer->f_copy_len);
+	}
+
+	if(xfer->d_callback)
+	{
+		PRINTFN(3,("xfer=%p, error=0x%x(%s)\n", xfer, 
+			    xfer->error, usbd_errstr(xfer->error)));
+
+		(xfer->d_callback)(xfer->priv_fifo, xfer->priv_sc, xfer->error);
+
+		if(((void *)(xfer->pipe->alloc_xfer)) == xfer->priv_fifo)
+		{
+			/* restart transfer */
+			usbd_start_hardware(xfer);
+		}
+	}
+#endif
+	return;
+}
+
+usbd_status
+usbd_do_request(struct usbd_device *udev, usb_device_request_t *req, void *data)
+{
+	return (usbd_do_request_flags(udev, req, data, 0, 0, 
+				      USBD_DEFAULT_TIMEOUT));
+}
+
+/*---------------------------------------------------------------------------*
+ *	usbd_do_request_flags
+ *
+ * NOTE: the caller should hold "Giant" while calling this function
+ *---------------------------------------------------------------------------*/
+usbd_status
+usbd_do_request_flags(struct usbd_device *udev, usb_device_request_t *req,
+		      void *data, u_int32_t flags, int *actlen,
+		      u_int32_t timeout)
+{
+	struct usbd_config usbd_config[1] = { /* zero */ };
+	struct usbd_xfer *xfer = NULL;
+	usbd_status err;
+
+	usbd_config[0].type = UE_CONTROL;
+	usbd_config[0].endpoint = 0; /* control pipe */
+	usbd_config[0].direction = -1;
+	usbd_config[0].timeout = timeout;
+	usbd_config[0].flags = flags|USBD_SYNCHRONOUS;
+	usbd_config[0].bufsize = sizeof(req[0]) + UGETW(req->wLength);
+	usbd_config[0].callback = &usbd_default_callback;
+
+	/* setup transfer */
+	err = usbd_transfer_setup(udev, 0, &xfer, &usbd_config[0], 1,
+				  NULL, NULL, NULL);
+	if(err)
+	{
+	    goto done;
+	}
+
+	/* copy IN */
+
+	bcopy(req, xfer->buffer, sizeof(req[0]));
+
+	if(!(req->bmRequestType & UT_READ))
+	{
+	    bcopy(data, ((u_int8_t *)xfer->buffer) + sizeof(req[0]), UGETW(req->wLength));
+	}
+
+	usbd_transfer_start_safe(xfer);
+
+	/* copy OUT */
+
+	if(req->bmRequestType & UT_READ)
+	{
+	    bcopy(((u_int8_t *)xfer->buffer) + sizeof(req[0]), data, UGETW(req->wLength));
+	}
+
+	err = xfer->error;
+
+	if(actlen != NULL)
+	{
+	    actlen[0] = (xfer->actlen < sizeof(req[0])) ?
+	      0 : (xfer->actlen - sizeof(req[0]));
+	}
+
+ done:
+	usbd_transfer_unsetup(&xfer, 1);
+	return (err);
+}
+
+void
+usbd_clearstall_callback(struct usbd_xfer *xfer)
+{
+	usb_device_request_t *req;
+	USBD_CHECK_STATUS(xfer);
+
+ tr_setup:
+	req = xfer->buffer;
+
+	/* setup a CLEAR STALL packet */
+	req->bmRequestType = UT_WRITE_ENDPOINT;
+	req->bRequest = UR_CLEAR_FEATURE;
+	USETW(req->wValue, UF_ENDPOINT_HALT);
+	req->wIndex[0] = ((struct usbd_xfer *)(xfer->priv_sc))->pipe
+	  ->edesc->bEndpointAddress;
+	req->wIndex[1] = 0;
+	USETW(req->wLength, 0);
+
+	usbd_start_hardware(xfer);
+	return;
+
+ tr_transferred:
+ tr_error:
+	PRINTFN(3,("xfer=%p\n", xfer));
+
+	/* clear any stall and make sure DATA0
+	 * toggle will be used next
+	 *
+	 * NOTE: some devices reject this command,
+	 * so ignore a STALL
+	 */
+	xfer = xfer->priv_sc;
+
+	xfer->pipe->clearstall = 0;
+	xfer->pipe->toggle_next = 0;
+
+	usbd_start_hardware(xfer);
+	return;
+}
+
+/* clearstall config:
+ *
+ *	.type = UE_CONTROL,
+ *	.endpoint = 0,
+ *	.direction = -1,
+ *	.timeout = USBD_DEFAULT_TIMEOUT,
+ *	.flags = 0,
+ *	.bufsize = sizeof(usb_device_request_t),
+ *	.callback = &usbd_clearstall_callback,
+ */
+
+/*
+ * called from keyboard driver when in polling mode
+ */
+void
+usbd_do_poll(struct usbd_device *udev)
+{
+	(udev->bus->methods->do_poll)(udev->bus);
+	return;
+}
+
+void
+usbd_set_polling(struct usbd_device *udev, int on)
+{
+	if(on)
+	{
+		udev->bus->use_polling++;
+	}
+	else
+	{
+		udev->bus->use_polling--;
+	}
+
+	/* make sure there is nothing pending to do */
+	if(udev->bus->use_polling)
+	{
+		(udev->bus->methods->do_poll)(udev->bus);
+	}
+	return;
+}
+
+/*
+ * usbd_ratecheck() can limit the number of error messages that occurs.
+ * When a device is unplugged it may take up to 0.25s for the hub driver
+ * to notice it.  If the driver continuosly tries to do I/O operations
+ * this can generate a large number of messages.
+ */
+int
+usbd_ratecheck(struct timeval *last)
+{
+	if(last->tv_sec == time_second)
+	{
+		return (0);
+	}
+	last->tv_sec = time_second;
+	return (1);
+}
+
+/*
+ * Search for a vendor/product pair in an array.  The item size is
+ * given as an argument.
+ */
+const struct usb_devno *
+usb_match_device(const struct usb_devno *tbl, u_int nentries, u_int size,
+		 u_int16_t vendor, u_int16_t product)
+{
+	while(nentries-- > 0)
+	{
+		if((tbl->ud_vendor == vendor) &&
+		   ((tbl->ud_product == product) ||
+		    (tbl->ud_product == USB_PRODUCT_ANY)))
+		{
+			return (tbl);
+		}
+		tbl = (const struct usb_devno *)
+		  (((const u_int8_t *)tbl) + size);
+	}
+	return (NULL);
+}
+
+int
+usbd_driver_load(struct module *mod, int what, void *arg)
+{
+	/* XXX should implement something like a 
+	 * function that removes all generic devices
+	 */
+
+ 	return (0);
+}
+
+#ifdef USB_COMPAT_OLD
+
+/*****************************************************************************
+ * compatibility layer for the old USB drivers
+ *****************************************************************************/
+
+usbd_status
+usbd_transfer(struct usbd_xfer *xfer)
+{
+	if(xfer->alloc_xfer)
+	{
+	    usbd_transfer_start_safe(xfer->alloc_xfer);
+	    return USBD_NORMAL_COMPLETION;
+	}
+	else
+	{
+	    return USBD_NOMEM;
+	}
+}
+
+usbd_status
+usbd_sync_transfer(struct usbd_xfer *xfer)
+{
+	if(xfer->alloc_xfer)
+	{
+	    /* XXX USBD_SYNCHRONOUS should be set in struct usbd_config 
+	     * passed to usbd_transfer_setup (!)
+	     */
+	    xfer->alloc_xfer->flags |= USBD_SYNCHRONOUS;
+	}
+	return usbd_transfer(xfer);
+}
+
+void *
+usbd_alloc_buffer(struct usbd_xfer *xfer, u_int32_t size)
+{
+	if(xfer->alloc_ptr)
+	{
+	    printf("%s: buffer already "
+		   "allocated\n", __FUNCTION__);
+	    return NULL;
+	}
+
+	xfer->alloc_ptr = malloc(size, M_USBDEV, M_NOWAIT);
+	xfer->alloc_len = size;
+
+	return xfer->alloc_ptr;
+}
+
+void
+usbd_free_buffer(struct usbd_xfer *xfer)
+{
+	if(xfer->alloc_ptr)
+	{
+	    free(xfer->alloc_ptr, M_USBDEV);
+	    xfer->alloc_ptr = NULL;
+	}
+	return;
+}
+
+void
+usbd_get_xfer_status(struct usbd_xfer *xfer, void **priv,
+		     void **buffer, u_int32_t *count, usbd_status *status)
+{
+	PRINTFN(8, ("\n"));
+
+	if(xfer->alloc_xfer)
+	{
+	    if(priv != NULL)
+	      *priv = xfer->alloc_xfer->priv_sc;
+	    if(buffer != NULL)
+	      *buffer = xfer->alloc_xfer->buffer;
+	    if(count != NULL)
+	      *count = xfer->alloc_xfer->actlen;
+	    if(status != NULL)
+	      *status = xfer->alloc_xfer->error;
+	}
+	else
+	{
+	    if(priv != NULL)
+	      *priv = xfer->priv_sc;
+	    if(buffer != NULL)
+	      *buffer = xfer->buffer;
+	    if(count != NULL)
+	      *count = xfer->actlen;
+	    if(status != NULL)
+	      *status = xfer->error;
+	}
+	return;
+}
+
+struct usbd_xfer *
+usbd_alloc_xfer(struct usbd_device *dev)
+{
+	struct usbd_xfer *xfer;
+
+	xfer = malloc(sizeof(*xfer), M_USBDEV, M_NOWAIT);
+
+	if(xfer)
+	{
+	    bzero(xfer, sizeof(*xfer));
+	}
+	return xfer;
+}
+
+static void
+__usbd_free_xfer(struct usbd_xfer *xfer)
+{
+	if(xfer)
+	{
+	    if(xfer->clearstall_xfer)
+	    {
+	        usbd_transfer_unsetup(&xfer->clearstall_xfer, 1);
+	    }
+	    usbd_transfer_unsetup(&xfer, 1);
+	}
+	return;
+}
+
+usbd_status 
+usbd_free_xfer(struct usbd_xfer *xfer)
+{
+	if(xfer)
+	{
+	    usbd_free_buffer(xfer);
+
+	    __usbd_free_xfer(xfer->alloc_xfer);
+
+	    free(xfer, M_USBDEV);
+	}
+	return USBD_NORMAL_COMPLETION;
+}
+
+usbd_status 
+usbd_open_pipe(struct usbd_interface *iface, u_int8_t address,
+               u_int8_t flags, struct usbd_pipe **pp)
+{ 
+	u_int8_t iface_index = iface - &iface->udev->ifaces[0];
+        struct usbd_pipe *pipe = &iface->udev->pipes[0];
+        struct usbd_pipe *pipe_end = &iface->udev->pipes_end[0];
+
+	while(pipe < pipe_end)
+	{
+	    if((pipe->iface_index == iface_index) && 
+	       (pipe->edesc) &&
+	       (pipe->edesc->bEndpointAddress == address))
+	    {
+	        (*pp) = pipe;
+		return USBD_NORMAL_COMPLETION;
+	    }
+	    pipe++;
+	}
+	(*pp) = NULL;
+	return USBD_INVAL;
+}
+
+usbd_status 
+usbd_open_pipe_intr(struct usbd_interface *iface, u_int8_t address,
+                    u_int8_t flags, struct usbd_pipe **pipe,
+                    void *priv, void *buffer, u_int32_t len,
+                    usbd_callback callback, int ival)
+{
+	usbd_status error;
+
+	if(usbd_open_pipe(iface, address, 0, pipe))
+	{
+	    return USBD_INVAL;
+	}
+
+	if((*pipe)->alloc_xfer)
+	{
+	    printf("%s: warning: pipe already opened\n",
+		   __FUNCTION__);
+	}
+
+	(*pipe)->alloc_xfer = usbd_alloc_xfer(NULL);
+
+	if(!(*pipe)->alloc_xfer)
+	{
+	    return USBD_NOMEM;
+	}
+
+        error = usbd_setup_xfer((*pipe)->alloc_xfer, *pipe, priv, buffer, len, flags,
+			        USBD_NO_TIMEOUT, callback);
+	if(error == 0)
+	{
+	    error = usbd_transfer((*pipe)->alloc_xfer);
+	}
+	if(error)
+	{
+	    usbd_free_xfer((*pipe)->alloc_xfer);
+	    (*pipe)->alloc_xfer = 0;
+	    *pipe = NULL;
+	}
+	return error;
+}
+
+usbd_status
+usbd_setup_xfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
+                void *priv, void *buffer, u_int32_t length,
+                u_int32_t flags, u_int32_t timeout,
+                usbd_callback callback)
+{
+	struct usbd_config usbd_config[2] = { /* zero */ };
+	struct usbd_xfer *__xfer[2];
+
+	/* free current transfer, if any */
+	if(xfer->alloc_xfer)
+	{
+	    if(xfer->alloc_xfer->flags & USBD_DEV_TRANSFERRING)
+	    {
+	        /* transfer is in progress */
+	        PRINTFN(3,("transfer is already in progress\n"));
+		return USBD_NORMAL_COMPLETION;
+	    }
+
+	    __usbd_free_xfer(xfer->alloc_xfer);
+	    xfer->alloc_xfer = NULL;
+	}
+
+	usbd_config[1].type = UE_CONTROL;
+	usbd_config[1].endpoint = 0;
+	usbd_config[1].direction = -1;
+	usbd_config[1].timeout = USBD_DEFAULT_TIMEOUT;
+	usbd_config[1].flags = USBD_SELF_DESTRUCT;
+	usbd_config[1].bufsize = sizeof(usb_device_request_t);
+	usbd_config[1].callback = &usbd_clearstall_callback;
+
+	usbd_config[0].type = pipe->edesc->bmAttributes & UE_XFERTYPE;
+	usbd_config[0].endpoint = pipe->edesc->bEndpointAddress & UE_ADDR;
+	usbd_config[0].direction = pipe->edesc->bEndpointAddress & (UE_DIR_IN|UE_DIR_OUT);
+	usbd_config[0].callback = usbd_default_callback;
+	usbd_config[0].interval = USBD_DEFAULT_INTERVAL;
+	usbd_config[0].timeout = timeout;
+	usbd_config[0].flags = flags|USBD_SELF_DESTRUCT;
+	usbd_config[0].bufsize = length;
+
+	if(usbd_transfer_setup(pipe->udev, pipe->iface_index, 
+			       &__xfer[0], &usbd_config[0], 
+			       (flags & USBD_CUSTOM_CLEARSTALL) ? 1 : 2,
+			       priv, NULL, NULL))
+	{
+	    PRINTFN(3,("USBD_NOMEM\n"));
+	    return USBD_NOMEM;
+	}
+
+	xfer->alloc_xfer = __xfer[0];
+
+	/* automatic clear-stall */
+	xfer->alloc_xfer->clearstall_xfer = 
+	  (flags & USBD_CUSTOM_CLEARSTALL) ? NULL : __xfer[1];
+
+	xfer->alloc_xfer->priv_fifo = xfer; /* used by callback */
+	xfer->alloc_xfer->d_copy_ptr = xfer->alloc_xfer->buffer;
+	xfer->alloc_xfer->d_copy_len = length;
+	xfer->alloc_xfer->d_callback = callback;
+
+	if(length && buffer)
+	{
+	    if(usbd_config[0].direction == UE_DIR_IN)
+	    {
+	        xfer->alloc_xfer->d_copy_dst = buffer;
+	    }
+	    else
+	    {
+	        xfer->alloc_xfer->d_copy_src = buffer;
+	    }
+	}
+	return USBD_NORMAL_COMPLETION;
+}
+
+usbd_status
+usbd_setup_default_xfer(struct usbd_xfer *xfer, struct usbd_device *udev,
+                        void *priv, u_int32_t timeout,
+                        usb_device_request_t *req, void *buffer,
+                        u_int32_t length, u_int16_t flags,
+                        usbd_callback callback)
+{
+	struct usbd_config usbd_config[1] = { /* zero */ };
+
+	/* free current transfer, if any */
+	if(xfer->alloc_xfer)
+	{
+	    if(xfer->alloc_xfer->flags & USBD_DEV_TRANSFERRING)
+	    {
+	        /* transfer is in progress */
+	        PRINTFN(3,("transfer is already in progress\n"));
+		return USBD_NORMAL_COMPLETION;
+	    }
+
+	    __usbd_free_xfer(xfer->alloc_xfer);
+	    xfer->alloc_xfer = NULL;
+	}
+	
+	usbd_config[0].type = UE_CONTROL;
+	usbd_config[0].endpoint = 0;
+	usbd_config[0].direction = -1;
+	usbd_config[0].timeout = timeout;
+	usbd_config[0].flags = flags|USBD_SELF_DESTRUCT;
+	usbd_config[0].bufsize = sizeof(usb_device_request_t) + length;
+	usbd_config[0].callback = usbd_default_callback;
+
+	if(usbd_transfer_setup(udev, 0, 
+			       &xfer->alloc_xfer, &usbd_config[0], 1, 
+			       priv, NULL, NULL))
+	{
+	    PRINTFN(3,("USBD_NOMEM\n"));
+	    return USBD_NOMEM;
+	}
+
+	bcopy(req, xfer->alloc_xfer->buffer, sizeof(*req));
+
+	xfer->alloc_xfer->priv_fifo = xfer; /* used by callback */
+	xfer->alloc_xfer->d_copy_ptr = ((u_int8_t *)(xfer->alloc_xfer->buffer)) + sizeof(*req);
+	xfer->alloc_xfer->d_copy_len = length;
+	xfer->alloc_xfer->d_callback = callback;
+
+	if(length && buffer)
+	{
+	    if(req->bmRequestType & UT_READ)
+	    {
+	        xfer->alloc_xfer->d_copy_dst = buffer;
+	    }
+	    else
+	    {
+	        xfer->alloc_xfer->d_copy_src = buffer;
+	    }
+	}
+	return USBD_NORMAL_COMPLETION;
+}
+
+usbd_status
+usbd_setup_isoc_xfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
+                     void *priv, u_int16_t *frlengths, u_int32_t nframes, 
+		     u_int16_t flags, usbd_callback callback)
+{
+	struct usbd_config usbd_config[1] = { /* zero */ };
+
+	/* free current transfer, if any */
+	if(xfer->alloc_xfer)
+	{
+	    if(xfer->alloc_xfer->flags & USBD_DEV_TRANSFERRING)
+	    {
+	        /* transfer is in progress */
+	        PRINTFN(3,("transfer is already in progress\n"));
+		return USBD_NORMAL_COMPLETION;
+	    }
+	    __usbd_free_xfer(xfer->alloc_xfer);
+	    xfer->alloc_xfer = NULL;
+	}
+
+	if(xfer->alloc_ptr == NULL)
+	{
+	    /* no data-buffer allocated */
+	    return USBD_NOMEM;
+	}
+
+	usbd_config[0].type = pipe->edesc->bmAttributes & UE_XFERTYPE;
+	usbd_config[0].endpoint = pipe->edesc->bEndpointAddress & UE_ADDR;
+	usbd_config[0].direction = pipe->edesc->bEndpointAddress & (UE_DIR_IN|UE_DIR_OUT);
+	usbd_config[0].callback = usbd_default_callback;
+	usbd_config[0].interval = USBD_DEFAULT_INTERVAL;
+	usbd_config[0].flags = flags|USBD_SELF_DESTRUCT;
+	usbd_config[0].bufsize = xfer->alloc_len;
+	usbd_config[0].frames = nframes;
+
+	if(usbd_transfer_setup(pipe->udev, pipe->iface_index, 
+			       &xfer->alloc_xfer, &usbd_config[0], 1,
+			       priv, NULL, NULL))
+	{
+	    return USBD_NOMEM;
+	}
+
+	xfer->alloc_xfer->priv_fifo = xfer; /* used by callback */
+	xfer->alloc_xfer->d_copy_ptr = xfer->alloc_xfer->buffer;
+	xfer->alloc_xfer->d_copy_len = xfer->alloc_len;
+	xfer->alloc_xfer->f_copy_ptr = &xfer->alloc_xfer->frlengths[0];
+	xfer->alloc_xfer->f_copy_len = nframes*sizeof(xfer->alloc_xfer->frlengths[0]);
+	xfer->alloc_xfer->d_callback = callback;
+
+	xfer->alloc_xfer->f_copy_src = frlengths;
+	xfer->alloc_xfer->f_copy_dst = frlengths;
+
+	if(usbd_config[0].direction == UE_DIR_IN)
+	{
+	    xfer->alloc_xfer->d_copy_dst = xfer->alloc_ptr;
+	}
+	else
+	{
+	    xfer->alloc_xfer->d_copy_src = xfer->alloc_ptr;
+	}
+	return USBD_NORMAL_COMPLETION;
+}
+
+usbd_status
+usbd_bulk_transfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
+                   u_int16_t flags, u_int32_t timeout, void *buf,
+                   u_int32_t *size, char *lbl)
+{
+        usbd_status err;
+
+        if(usbd_setup_xfer(xfer, pipe, 0, buf, *size,
+			   flags|USBD_SYNCHRONOUS, timeout, NULL))
+	{
+	    return USBD_NOMEM;
+	}
+
+	if(usbd_transfer(xfer))
+	{
+	    return USBD_NOMEM;
+	}
+
+        usbd_get_xfer_status(xfer, NULL, NULL, size, &err);
+        return (err);
+}
+
+usbd_status 
+usbd_abort_pipe(struct usbd_pipe *pipe)
+{
+	enum { FINISH_LIST_MAX = 16 };
+
+	struct usbd_xfer * finish_list[FINISH_LIST_MAX];
+	struct usbd_xfer **ptr;
+
+	ptr = &finish_list[0];
+
+	struct usbd_xfer *xfer;
+
+	mtx_lock(&pipe->udev->bus->mtx);
+
+	xfer = pipe->alloc_xfer;
+
+	if(xfer)
+	{
+	    xfer = xfer->alloc_xfer;
+
+	    if(xfer)
+	    {
+	        *ptr++ = xfer;
+
+		/* make sure that memory doesn't
+		 * get freed during the lock switch:
+		 */
+		xfer->usb_root->memory_refcount++;
+	    }
+	}
+
+	LIST_FOREACH(xfer, &pipe->list_head, pipe_list)
+	{
+	    *ptr++ = xfer;
+
+	    /* make sure that memory doesn't
+	     * get freed during the lock switch:
+	     */
+	    xfer->usb_root->memory_refcount++;
+
+	    if(ptr >= &finish_list[FINISH_LIST_MAX])
+	    {
+	        printf("%s: too many xfers "
+		       "on pipe list!\n", __FUNCTION__);
+		break;
+	    }
+	}
+
+	mtx_unlock(&pipe->udev->bus->mtx);
+
+	while(--ptr >= &finish_list[0])
+	{
+	    xfer = ptr[0];
+
+	    mtx_lock(xfer->priv_mtx);
+
+	    usbd_transfer_stop(xfer);
+
+	    mtx_unlock(xfer->priv_mtx);
+
+	    usbd_drop_refcount(xfer->usb_root);
+	}
+	return USBD_NORMAL_COMPLETION;
+}
+
+usbd_status 
+usbd_abort_default_pipe(struct usbd_device *udev)
+{
+	return (usbd_abort_pipe(&udev->default_pipe));
+}
+
+usbd_status
+usbd_close_pipe(struct usbd_pipe *pipe)
+{
+	usbd_free_xfer(pipe->alloc_xfer);
+	pipe->alloc_xfer = NULL;
+
+	return USBD_NORMAL_COMPLETION;
+}
+
+usbd_status 
+usbd_clear_endpoint_stall(struct usbd_pipe *pipe)
+{
+	return USBD_NORMAL_COMPLETION;
+}
+
+usbd_status 
+usbd_clear_endpoint_stall_async(struct usbd_pipe *pipe)
+{
+	return USBD_NORMAL_COMPLETION;
+}
+
+usbd_status 
+usbd_endpoint_count(struct usbd_interface *iface, u_int8_t *count)
+{
+        *count = iface->idesc->bNumEndpoints;
+        return (USBD_NORMAL_COMPLETION);
+}
+
+void
+usbd_interface2device_handle(struct usbd_interface *iface,
+                             struct usbd_device **udev)
+{
+        *udev = iface->udev;
+}
+
+struct usbd_device *
+usbd_pipe2device_handle(struct usbd_pipe *pipe)
+{
+        return (pipe->udev);
+}
+
+usbd_status 
+usbd_device2interface_handle(struct usbd_device *udev,
+                             u_int8_t iface_index, struct usbd_interface **iface)
+{
+	(*iface) = usbd_get_iface(udev, iface_index);
+
+	return ((*iface) ? USBD_NORMAL_COMPLETION : USBD_INVAL);
+}
+
+usb_endpoint_descriptor_t *
+usbd_interface2endpoint_descriptor(struct usbd_interface *iface, u_int8_t index)
+{
+	u_int8_t iface_index = iface - &iface->udev->ifaces[0];
+        struct usbd_pipe *pipe = &iface->udev->pipes[0];
+        struct usbd_pipe *pipe_end = &iface->udev->pipes_end[0];
+
+        if(index >= iface->idesc->bNumEndpoints)
+	{
+	    return (NULL);
+	}
+
+	while(pipe < pipe_end)
+	{
+	    if((pipe->edesc) &&
+	       (pipe->iface_index == iface_index))
+	    {
+	        if(!index--)
+		{
+		    return(pipe->edesc);
+		}
+	    }
+	    pipe++;
+	}
+	return (NULL);
+}
+
+usb_endpoint_descriptor_t *
+usbd_get_endpoint_descriptor(struct usbd_interface *iface, u_int8_t address)
+{
+	struct usbd_pipe *pipe = &iface->udev->pipes[0];
+	struct usbd_pipe *pipe_end = &iface->udev->pipes_end[0];
+
+	while(pipe < pipe_end)
+	{
+	    if(pipe->edesc &&
+	       (pipe->edesc->bEndpointAddress == address))
+	    {
+	        return pipe->edesc;
+	    }
+	    pipe++;
+	}
+	return NULL;
+}
+
+void
+usb_call_task(void *arg, int count)
+{
+	struct usb_task *task = arg;
+
+	((task)->func)((task)->arg);
+
+	return;
+}
+
+#endif /* USB_COMPAT_OLD */
diff -rubN /usr/src1/src/sys/dev/usb2/ehci.h /usr/src/sys/dev/usb2/ehci.h
--- /usr/src1/src/sys/dev/usb2/ehci.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/ehci.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,486 @@
+/*-
+ * Copyright (c) 2001 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net).
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _EHCI_H_
+#define _EHCI_H_
+
+/*** PCI config registers ***/
+
+#define PCI_CBMEM		0x10	/* configuration base MEM */
+
+#define PCI_INTERFACE_EHCI	0x20
+
+#define PCI_USBREV		0x60	/* RO USB protocol revision */
+#define  PCI_USBREV_MASK	0xff
+#define  PCI_USBREV_PRE_1_0	0x00
+#define  PCI_USBREV_1_0		0x10
+#define  PCI_USBREV_1_1		0x11
+#define  PCI_USBREV_2_0		0x20
+
+#define PCI_EHCI_FLADJ		0x61	/* RW Frame len adj, SOF=59488+6*fladj */
+
+#define PCI_EHCI_PORTWAKECAP	0x62	/* RW Port wake caps (opt)  */
+
+/* EHCI Extended Capabilities */
+#define EHCI_EC_LEGSUP		0x01
+
+#define EHCI_EECP_NEXT(x)	(((x) >> 8) & 0xff)
+#define EHCI_EECP_ID(x)		((x) & 0xff)
+
+/* Legacy support extended capability */
+#define EHCI_LEGSUP_LEGSUP	0x01
+#define  EHCI_LEGSUP_OSOWNED	0x01000000 /* OS owned semaphore */
+#define  EHCI_LEGSUP_BIOSOWNED	0x00010000 /* BIOS owned semaphore */
+#define EHCI_LEGSUP_USBLEGCTLSTS 0x04
+
+/*** EHCI capability registers ***/
+
+#define EHCI_CAPLENGTH		0x00	/* RO Capability register length field */
+/* reserved			0x01 */
+#define EHCI_HCIVERSION		0x02	/* RO Interface version number */
+
+#define EHCI_HCSPARAMS		0x04	/* RO Structural parameters */
+#define  EHCI_HCS_DEBUGPORT(x)	(((x) >> 20) & 0xf)
+#define  EHCI_HCS_P_INDICATOR(x) ((x) & 0x10000)
+#define  EHCI_HCS_N_CC(x)	(((x) >> 12) & 0xf) /* # of companion ctlrs */
+#define  EHCI_HCS_N_PCC(x)	(((x) >> 8) & 0xf) /* # of ports per comp. */
+#define  EHCI_HCS_PPC(x)	((x) & 0x10) /* port power control */
+#define  EHCI_HCS_N_PORTS(x)	((x) & 0xf) /* # of ports */
+
+#define EHCI_HCCPARAMS		0x08	/* RO Capability parameters */
+#define  EHCI_HCC_EECP(x)	(((x) >> 8) & 0xff) /* extended ports caps */
+#define  EHCI_HCC_IST(x)	(((x) >> 4) & 0xf) /* isoc sched threshold */
+#define  EHCI_HCC_ASPC(x)	((x) & 0x4) /* async sched park cap */
+#define  EHCI_HCC_PFLF(x)	((x) & 0x2) /* prog frame list flag */
+#define  EHCI_HCC_64BIT(x)	((x) & 0x1) /* 64 bit address cap */
+
+#define EHCI_HCSP_PORTROUTE	0x0c	/*RO Companion port route description */
+
+/* EHCI operational registers.  Offset given by EHCI_CAPLENGTH register */
+#define EHCI_USBCMD		0x00	/* RO, RW, WO Command register */
+#define  EHCI_CMD_ITC_M		0x00ff0000 /* RW interrupt threshold ctrl */
+#define   EHCI_CMD_ITC_1	0x00010000
+#define   EHCI_CMD_ITC_2	0x00020000
+#define   EHCI_CMD_ITC_4	0x00040000
+#define   EHCI_CMD_ITC_8	0x00080000
+#define   EHCI_CMD_ITC_16	0x00100000
+#define   EHCI_CMD_ITC_32	0x00200000
+#define   EHCI_CMD_ITC_64	0x00400000
+#define  EHCI_CMD_ASPME		0x00000800 /* RW/RO async park enable */
+#define  EHCI_CMD_ASPMC		0x00000300 /* RW/RO async park count */
+#define  EHCI_CMD_LHCR		0x00000080 /* RW light host ctrl reset */
+#define  EHCI_CMD_IAAD		0x00000040 /* RW intr on async adv door bell */
+#define  EHCI_CMD_ASE		0x00000020 /* RW async sched enable */
+#define  EHCI_CMD_PSE		0x00000010 /* RW periodic sched enable */
+#define  EHCI_CMD_FLS_M		0x0000000c /* RW/RO frame list size */
+#define  EHCI_CMD_FLS(x)	(((x) >> 2) & 3) /* RW/RO frame list size */
+#define  EHCI_CMD_HCRESET	0x00000002 /* RW reset */
+#define  EHCI_CMD_RS		0x00000001 /* RW run/stop */
+
+#define EHCI_USBSTS		0x04	/* RO, RW, RWC Status register */
+#define  EHCI_STS_ASS		0x00008000 /* RO async sched status */
+#define  EHCI_STS_PSS		0x00004000 /* RO periodic sched status */
+#define  EHCI_STS_REC		0x00002000 /* RO reclamation */
+#define  EHCI_STS_HCH		0x00001000 /* RO host controller halted */
+#define  EHCI_STS_IAA		0x00000020 /* RWC interrupt on async adv */
+#define  EHCI_STS_HSE		0x00000010 /* RWC host system error */
+#define  EHCI_STS_FLR		0x00000008 /* RWC frame list rollover */
+#define  EHCI_STS_PCD		0x00000004 /* RWC port change detect */
+#define  EHCI_STS_ERRINT	0x00000002 /* RWC error interrupt */
+#define  EHCI_STS_INT		0x00000001 /* RWC interrupt */
+#define  EHCI_STS_INTRS(x)	((x) & 0x3f)
+
+#define EHCI_NORMAL_INTRS (/* EHCI_STS_IAA | */EHCI_STS_HSE | EHCI_STS_PCD | EHCI_STS_ERRINT | EHCI_STS_INT)
+
+#define EHCI_USBINTR		0x08	/* RW Interrupt register */
+#define EHCI_INTR_IAAE		0x00000020 /* interrupt on async advance ena */
+#define EHCI_INTR_HSEE		0x00000010 /* host system error ena */
+#define EHCI_INTR_FLRE		0x00000008 /* frame list rollover ena */
+#define EHCI_INTR_PCIE		0x00000004 /* port change ena */
+#define EHCI_INTR_UEIE		0x00000002 /* USB error intr ena */
+#define EHCI_INTR_UIE		0x00000001 /* USB intr ena */
+
+#define EHCI_FRINDEX		0x0c	/* RW Frame Index register */
+
+#define EHCI_CTRLDSSEGMENT	0x10	/* RW Control Data Structure Segment */
+
+#define EHCI_PERIODICLISTBASE	0x14	/* RW Periodic List Base */
+#define EHCI_ASYNCLISTADDR	0x18	/* RW Async List Base */
+
+#define EHCI_CONFIGFLAG		0x40	/* RW Configure Flag register */
+#define  EHCI_CONF_CF		0x00000001 /* RW configure flag */
+
+#define EHCI_PORTSC(n)		(0x40+(4*(n))) /* RO, RW, RWC Port Status reg */
+#define  EHCI_PS_WKOC_E		0x00400000 /* RW wake on over current ena */
+#define  EHCI_PS_WKDSCNNT_E	0x00200000 /* RW wake on disconnect ena */
+#define  EHCI_PS_WKCNNT_E	0x00100000 /* RW wake on connect ena */
+#define  EHCI_PS_PTC		0x000f0000 /* RW port test control */
+#define  EHCI_PS_PIC		0x0000c000 /* RW port indicator control */
+#define  EHCI_PS_PO		0x00002000 /* RW port owner */
+#define  EHCI_PS_PP		0x00001000 /* RW,RO port power */
+#define  EHCI_PS_LS		0x00000c00 /* RO line status */
+#define  EHCI_PS_IS_LOWSPEED(x)	(((x) & EHCI_PS_LS) == 0x00000400)
+#define  EHCI_PS_PR		0x00000100 /* RW port reset */
+#define  EHCI_PS_SUSP		0x00000080 /* RW suspend */
+#define  EHCI_PS_FPR		0x00000040 /* RW force port resume */
+#define  EHCI_PS_OCC		0x00000020 /* RWC over current change */
+#define  EHCI_PS_OCA		0x00000010 /* RO over current active */
+#define  EHCI_PS_PEC		0x00000008 /* RWC port enable change */
+#define  EHCI_PS_PE		0x00000004 /* RW port enable */
+#define  EHCI_PS_CSC		0x00000002 /* RWC connect status change */
+#define  EHCI_PS_CS		0x00000001 /* RO connect status */
+#define  EHCI_PS_CLEAR		(EHCI_PS_OCC|EHCI_PS_PEC|EHCI_PS_CSC)
+
+#define EHCI_PORT_RESET_COMPLETE 2 /* ms */
+
+/* alignment NOTE:
+ * structures must be aligned so that
+ * the hardware can index without 
+ * performing addition !
+ */
+#define EHCI_FRAMELIST_ALIGN          0x1000 /* bytes */
+#define EHCI_FRAMELIST_COUNT            1024 /* units */
+#define EHCI_VIRTUAL_FRAMELIST_COUNT     128 /* units */
+
+/* data buffers are divided into one or more pages */
+#define EHCI_PAGE_SIZE 0x1000
+
+/* link types */
+#define EHCI_LINK_TERMINATE	0x00000001
+#define EHCI_LINK_TYPE(x)	((x) & 0x00000006)
+#define  EHCI_LINK_ITD		0x0
+#define  EHCI_LINK_QH		0x2
+#define  EHCI_LINK_SITD		0x4
+#define  EHCI_LINK_FSTN		0x6
+#define EHCI_LINK_ADDR(x)	((x) &~ 0x1f)
+
+/* Isochronous Transfer Descriptor 
+ * this descriptor is used for high speed transfers only
+ */
+#define EHCI_ITD_ALIGN 128 /* bytes */
+typedef struct ehci_itd {
+	__volatile__ u_int32_t	itd_next;
+	__volatile__ u_int32_t  itd_status[8];
+#define EHCI_ITD_SET_LEN(x)   ((x) << 16)
+#define EHCI_ITD_GET_LEN(x)   (((x) >> 16) & 0xFFF)
+#define EHCI_ITD_IOC          (1 << 15)
+#define EHCI_ITD_SET_PG(x)    ((x) << 12)
+#define EHCI_ITD_GET_PG(x)    (((x) >> 12) & 0x7)
+#define EHCI_ITD_SET_OFFS(x)  (x)
+#define EHCI_ITD_GET_OFFS(x)  (((x) >> 0) & 0xFFF)
+#define EHCI_ITD_ACTIVE       (1 << 31)
+#define EHCI_ITD_DATABUFERR   (1 << 30)
+#define EHCI_ITD_BABBLE       (1 << 29)
+#define EHCI_ITD_XACTERR      (1 << 28)
+	__volatile__ u_int32_t  itd_bp[7];
+			     /* itd_bp[0] */
+#define EHCI_ITD_SET_ADDR(x)  (x)
+#define EHCI_ITD_GET_ADDR(x)  (((x) >> 0) & 0x7F)
+#define EHCI_ITD_SET_ENDPT(x)  ((x) << 8)
+#define EHCI_ITD_GET_ENDPT(x)  (((x) >> 8) & 0xF)
+			     /* itd_bp[1] */
+#define EHCI_ITD_SET_DIR_IN   (1 << 11)
+#define EHCI_ITD_SET_DIR_OUT  (0 << 11)
+#define EHCI_ITD_SET_MPL(x)   (x)
+#define EHCI_ITD_GET_MPL(x)   (((x) >> 0) & 0x7FF)
+
+	__volatile__ u_int32_t  itd_bp_hi[7];
+
+  /* 
+   * extra information needed:
+   */
+	u_int32_t	itd_self;
+
+	struct ehci_itd *next;
+	struct ehci_itd *prev;
+
+} __attribute__((__aligned__(EHCI_ITD_ALIGN))) ehci_itd_t;
+
+/* Split Transaction Isochronous Transfer Descriptor
+ * this descriptor is used for full speed transfers only
+ */
+#define EHCI_SITD_ALIGN 64 /* bytes */
+typedef struct ehci_sitd {
+	__volatile__ u_int32_t	sitd_next;
+	__volatile__ u_int32_t	sitd_portaddr;
+#define EHCI_SITD_SET_DIR_OUT (0 << 31)
+#define EHCI_SITD_SET_DIR_IN (1 << 31)
+#define EHCI_SITD_SET_ADDR(x) (x)
+#define EHCI_SITD_GET_ADDR(x) ((x) & 0x7F)
+#define EHCI_SITD_SET_ENDPT(x) ((x) << 8)
+#define EHCI_SITD_GET_ENDPT(x) (((x) >> 8) & 0xF)
+#define EHCI_SITD_GET_DIR(x) ((x) >> 31)
+#define EHCI_SITD_SET_PORT(x) ((x) << 24)
+#define EHCI_SITD_GET_PORT(x) (((x) >> 24) & 0x7F)
+#define EHCI_SITD_SET_HUBA(x) ((x) << 16)
+#define EHCI_SITD_GET_HUBA(x) (((x) >> 16) & 0x7F)
+	__volatile__ u_int32_t	sitd_mask;
+#define EHCI_SITD_SET_SMASK(x) (x)
+#define EHCI_SITD_SET_CMASK(x) ((x) << 8)
+	__volatile__ u_int32_t	sitd_status;
+#define EHCI_SITD_COMPLETE_SPLIT (1<<1)
+#define EHCI_SITD_START_SPLIT (0<<1)
+#define EHCI_SITD_MISSED_MICRO_FRAME (1<<2)
+#define EHCI_SITD_XACTERR    (1<<3)
+#define EHCI_SITD_BABBLE     (1<<4)
+#define EHCI_SITD_DATABUFERR (1<<5)
+#define EHCI_SITD_ERROR      (1<<6)
+#define EHCI_SITD_ACTIVE     (1<<7)
+#define EHCI_SITD_IOC        (1<<31)
+#define EHCI_SITD_SET_LEN(len) ((len)<<16)
+#define EHCI_SITD_GET_LEN(x) (((x)>>16) & 0x3FF)
+	__volatile__ u_int32_t	sitd_bp[2];
+	__volatile__ u_int32_t	sitd_back;
+
+	__volatile__ u_int32_t	sitd_bp_hi[2];
+
+  /* 
+   * extra information needed:
+   */
+	u_int32_t	sitd_self;
+
+	struct ehci_sitd *next;
+	struct ehci_sitd *prev;
+
+} __attribute__((__aligned__(EHCI_SITD_ALIGN))) ehci_sitd_t;
+
+/* Queue Element Transfer Descriptor */
+#define EHCI_QTD_NBUFFERS 5
+#define EHCI_QTD_ALIGN 64 /* bytes */
+typedef struct ehci_qtd {
+	__volatile__ u_int32_t	qtd_next;
+	__volatile__ u_int32_t	qtd_altnext;
+	__volatile__ u_int32_t	qtd_status;
+#define EHCI_QTD_GET_STATUS(x)	(((x) >>  0) & 0xff)
+#define EHCI_QTD_SET_STATUS(x)  ((x) << 0)
+#define  EHCI_QTD_ACTIVE	0x80
+#define  EHCI_QTD_HALTED	0x40
+#define  EHCI_QTD_BUFERR	0x20
+#define  EHCI_QTD_BABBLE	0x10
+#define  EHCI_QTD_XACTERR	0x08
+#define  EHCI_QTD_MISSEDMICRO	0x04
+#define  EHCI_QTD_SPLITXSTATE	0x02
+#define  EHCI_QTD_PINGSTATE	0x01
+#define  EHCI_QTD_STATERRS	0x74
+#define EHCI_QTD_GET_PID(x)	(((x) >>  8) & 0x3)
+#define EHCI_QTD_SET_PID(x)	((x) <<  8)
+#define  EHCI_QTD_PID_OUT	0x0
+#define  EHCI_QTD_PID_IN	0x1
+#define  EHCI_QTD_PID_SETUP	0x2
+#define EHCI_QTD_GET_CERR(x)	(((x) >> 10) &  0x3)
+#define EHCI_QTD_SET_CERR(x)	((x) << 10)
+#define EHCI_QTD_GET_C_PAGE(x)	(((x) >> 12) &  0x7)
+#define EHCI_QTD_SET_C_PAGE(x)	((x) << 12)
+#define EHCI_QTD_GET_IOC(x)	(((x) >> 15) &  0x1)
+#define EHCI_QTD_IOC		0x00008000
+#define EHCI_QTD_GET_BYTES(x)	(((x) >> 16) &  0x7fff)
+#define EHCI_QTD_SET_BYTES(x)	((x) << 16)
+#define EHCI_QTD_GET_TOGGLE(x)	(((x) >> 31) &  0x1)
+#define	EHCI_QTD_SET_TOGGLE(x)	((x) << 31)
+#define EHCI_QTD_TOGGLE_MASK	0x80000000
+	__volatile__ u_int32_t	qtd_buffer[EHCI_QTD_NBUFFERS];
+	__volatile__ u_int32_t	qtd_buffer_hi[EHCI_QTD_NBUFFERS];
+
+  /* 
+   * extra information needed:
+   */
+
+	u_int32_t	qtd_self;
+
+	u_int16_t	len;
+
+	struct ehci_qtd *next;
+
+} __attribute__((__aligned__(EHCI_QTD_ALIGN))) ehci_qtd_t;
+
+/* Queue Head */
+#define EHCI_QH_ALIGN 128 /* bytes */
+typedef struct ehci_qh {
+	__volatile__ u_int32_t	qh_link;
+	__volatile__ u_int32_t	qh_endp;
+#define EHCI_QH_GET_ADDR(x)	(((x) >>  0) & 0x7f) /* endpoint addr */
+#define EHCI_QH_SET_ADDR(x)	(x)
+#define EHCI_QH_ADDRMASK	0x0000007f
+#define EHCI_QH_GET_INACT(x)	(((x) >>  7) & 0x01) /* inactivate on next */
+#define EHCI_QH_INACT		0x00000080
+#define EHCI_QH_GET_ENDPT(x)	(((x) >>  8) & 0x0f) /* endpoint no */
+#define EHCI_QH_SET_ENDPT(x)	((x) <<  8)
+#define EHCI_QH_GET_EPS(x)	(((x) >> 12) & 0x03) /* endpoint speed */
+#define EHCI_QH_SET_EPS(x)	((x) << 12)
+#define  EHCI_QH_SPEED_FULL	0x0
+#define  EHCI_QH_SPEED_LOW	0x1
+#define  EHCI_QH_SPEED_HIGH	0x2
+#define EHCI_QH_GET_DTC(x)	(((x) >> 14) & 0x01) /* data toggle control */
+#define EHCI_QH_DTC		0x00004000
+#define EHCI_QH_GET_HRECL(x)	(((x) >> 15) & 0x01) /* head of reclamation */
+#define EHCI_QH_HRECL		0x00008000
+#define EHCI_QH_GET_MPL(x)	(((x) >> 16) & 0x7ff) /* max packet len */
+#define EHCI_QH_SET_MPL(x)	((x) << 16)
+#define EHCI_QH_MPLMASK		0x07ff0000
+#define EHCI_QH_GET_CTL(x)	(((x) >> 27) & 0x01) /* control endpoint */
+#define EHCI_QH_CTL		0x08000000
+#define EHCI_QH_GET_NRL(x)	(((x) >> 28) & 0x0f) /* NAK reload */
+#define EHCI_QH_SET_NRL(x)	((x) << 28)
+	__volatile__ u_int32_t	qh_endphub;
+#define EHCI_QH_GET_SMASK(x)	(((x) >>  0) & 0xff) /* intr sched mask */
+#define EHCI_QH_SET_SMASK(x)	((x) <<  0)
+#define EHCI_QH_GET_CMASK(x)	(((x) >>  8) & 0xff) /* split completion mask */
+#define EHCI_QH_SET_CMASK(x)	((x) <<  8)
+#define EHCI_QH_GET_HUBA(x)	(((x) >> 16) & 0x7f) /* hub address */
+#define EHCI_QH_SET_HUBA(x)	((x) << 16)
+#define EHCI_QH_GET_PORT(x)	(((x) >> 23) & 0x7f) /* hub port */
+#define EHCI_QH_SET_PORT(x)	((x) << 23)
+#define EHCI_QH_GET_MULT(x)	(((x) >> 30) & 0x03) /* pipe multiplier */
+#define EHCI_QH_SET_MULT(x)	((x) << 30)
+	__volatile__ u_int32_t	qh_curqtd;
+	struct {
+	  __volatile__ u_int32_t qtd_next;
+	  __volatile__ u_int32_t qtd_altnext;
+	  __volatile__ u_int32_t qtd_status;
+	  __volatile__ u_int32_t qtd_buffer[EHCI_QTD_NBUFFERS];
+	  __volatile__ u_int32_t qtd_buffer_hi[EHCI_QTD_NBUFFERS];
+	} __attribute__((__aligned__(4))) qh_qtd;
+
+  /* 
+   * extra information needed:
+   */
+	u_int32_t	qh_self;
+	struct ehci_qh *next;
+	struct ehci_qh *prev;
+
+} __attribute__((__aligned__(EHCI_QH_ALIGN))) ehci_qh_t;
+
+/* Periodic Frame Span Traversal Node */
+#define EHCI_FSTN_ALIGN 32 /* bytes */
+typedef struct {
+	__volatile__ u_int32_t	fstn_link;
+	__volatile__ u_int32_t	fstn_back;
+
+} __attribute__((__aligned__(EHCI_FSTN_ALIGN))) ehci_fstn_t;
+
+struct ehci_hw_softc {
+	u_int32_t		pframes[EHCI_FRAMELIST_COUNT]; /* start TD pointer */
+
+	/* structures with highest alignment are first */
+
+	ehci_qh_t		async_start;
+	ehci_qh_t		intr_start[EHCI_VIRTUAL_FRAMELIST_COUNT];
+	ehci_itd_t		isoc_hs_start[EHCI_VIRTUAL_FRAMELIST_COUNT];
+	ehci_sitd_t		isoc_fs_start[EHCI_VIRTUAL_FRAMELIST_COUNT];
+};
+
+typedef struct ehci_softc {
+	struct ehci_hw_softc sc_hw; /* hardware structures first */
+
+	ehci_qh_t *		sc_async_p_last;
+	ehci_qh_t *		sc_intr_p_last[EHCI_VIRTUAL_FRAMELIST_COUNT];
+	u_int16_t		sc_intr_stat[EHCI_VIRTUAL_FRAMELIST_COUNT];
+	ehci_sitd_t *		sc_isoc_fs_p_last[EHCI_VIRTUAL_FRAMELIST_COUNT];
+	ehci_itd_t *		sc_isoc_hs_p_last[EHCI_VIRTUAL_FRAMELIST_COUNT];
+
+	u_int32_t		sc_physaddr;
+
+	struct usbd_bus		sc_bus; /* base device */
+
+	bus_space_tag_t		iot;
+	bus_space_handle_t	ioh;
+	bus_size_t		sc_size;
+
+	void *			ih;
+
+	struct resource *	io_res;
+	struct resource *	irq_res;
+
+	device_t		sc_dev;
+
+	u_int8_t		sc_offs; /* offset to operational registers */
+	u_int8_t		sc_doorbell_disable; /* set on doorbell failure */
+
+	char sc_vendor[16];		/* vendor string for root hub */
+	int sc_id_vendor;		/* vendor ID for root hub */
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+	void *sc_powerhook;		/* cookie from power hook */
+	void *sc_shutdownhook;		/* cookie from shutdown hook */
+#endif
+
+	LIST_HEAD(, usbd_xfer)	sc_interrupt_list_head;
+
+	u_int8_t		sc_noport;
+	u_int8_t		sc_addr;       	/* device address */
+	u_int8_t		sc_conf;      	/* device configuration */
+	struct usbd_xfer *	sc_intrxfer;
+	u_int8_t		sc_isreset;
+
+	u_int32_t		sc_eintrs;
+	u_int32_t		sc_cmd;	/* shadow of cmd register during suspend */
+
+	struct __callout	sc_tmo_pcd;
+
+} ehci_softc_t;
+
+#define EREAD1(sc, a) bus_space_read_1((sc)->iot, (sc)->ioh, (a))
+#define EREAD2(sc, a) bus_space_read_2((sc)->iot, (sc)->ioh, (a))
+#define EREAD4(sc, a) bus_space_read_4((sc)->iot, (sc)->ioh, (a))
+#define EWRITE1(sc, a, x) bus_space_write_1((sc)->iot, (sc)->ioh, (a), (x))
+#define EWRITE2(sc, a, x) bus_space_write_2((sc)->iot, (sc)->ioh, (a), (x))
+#define EWRITE4(sc, a, x) bus_space_write_4((sc)->iot, (sc)->ioh, (a), (x))
+#define EOREAD1(sc, a) bus_space_read_1((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a))
+#define EOREAD2(sc, a) bus_space_read_2((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a))
+#define EOREAD4(sc, a) bus_space_read_4((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a))
+#define EOWRITE1(sc, a, x) bus_space_write_1((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a), (x))
+#define EOWRITE2(sc, a, x) bus_space_write_2((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a), (x))
+#define EOWRITE4(sc, a, x) bus_space_write_4((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a), (x))
+
+usbd_status
+ehci_init(ehci_softc_t *sc);
+
+void
+ehci_detach(struct ehci_softc *sc);
+
+void
+ehci_suspend(struct ehci_softc *sc);
+
+void
+ehci_resume(struct ehci_softc *sc);
+
+void
+ehci_shutdown(ehci_softc_t *sc);
+
+void
+ehci_interrupt(ehci_softc_t *sc);
+
+#endif /* _EHCI_H_ */
diff -rubN /usr/src1/src/sys/dev/usb2/hid.h /usr/src/sys/dev/usb2/hid.h
--- /usr/src1/src/sys/dev/usb2/hid.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/hid.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1 @@
+#include <dev/usb/hid.h>
diff -rubN /usr/src1/src/sys/dev/usb2/ohci.h /usr/src/sys/dev/usb2/ohci.h
--- /usr/src1/src/sys/dev/usb2/ohci.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/ohci.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,342 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _OHCI_H_
+#define _OHCI_H_
+
+/*** PCI config registers ***/
+
+#define PCI_CBMEM		0x10	/* configuration base memory */
+
+#define PCI_INTERFACE_OHCI	0x10
+
+/*** OHCI registers */
+
+#define OHCI_REVISION		0x00	/* OHCI revision # */
+#define  OHCI_REV_LO(rev)	((rev) & 0xf)
+#define  OHCI_REV_HI(rev)	(((rev)>>4) & 0xf)
+#define  OHCI_REV_LEGACY(rev)	((rev) & 0x100)
+
+#define OHCI_CONTROL		0x04
+#define  OHCI_CBSR_MASK		0x00000003 /* Control/Bulk Service Ratio */
+#define  OHCI_RATIO_1_1		0x00000000
+#define  OHCI_RATIO_1_2		0x00000001
+#define  OHCI_RATIO_1_3		0x00000002
+#define  OHCI_RATIO_1_4		0x00000003
+#define  OHCI_PLE		0x00000004 /* Periodic List Enable */
+#define  OHCI_IE		0x00000008 /* Isochronous Enable */
+#define  OHCI_CLE		0x00000010 /* Control List Enable */
+#define  OHCI_BLE		0x00000020 /* Bulk List Enable */
+#define  OHCI_HCFS_MASK		0x000000c0 /* HostControllerFunctionalState */
+#define  OHCI_HCFS_RESET	0x00000000
+#define  OHCI_HCFS_RESUME	0x00000040
+#define  OHCI_HCFS_OPERATIONAL	0x00000080
+#define  OHCI_HCFS_SUSPEND	0x000000c0
+#define  OHCI_IR		0x00000100 /* Interrupt Routing */
+#define  OHCI_RWC		0x00000200 /* Remote Wakeup Connected */
+#define  OHCI_RWE		0x00000400 /* Remote Wakeup Enabled */
+#define OHCI_COMMAND_STATUS	0x08
+#define  OHCI_HCR		0x00000001 /* Host Controller Reset */
+#define  OHCI_CLF		0x00000002 /* Control List Filled */
+#define  OHCI_BLF		0x00000004 /* Bulk List Filled */
+#define  OHCI_OCR		0x00000008 /* Ownership Change Request */
+#define  OHCI_SOC_MASK		0x00030000 /* Scheduling Overrun Count */
+#define OHCI_INTERRUPT_STATUS	0x0c
+#define  OHCI_SO		0x00000001 /* Scheduling Overrun */
+#define  OHCI_WDH		0x00000002 /* Writeback Done Head */
+#define  OHCI_SF		0x00000004 /* Start of Frame */
+#define  OHCI_RD		0x00000008 /* Resume Detected */
+#define  OHCI_UE		0x00000010 /* Unrecoverable Error */
+#define  OHCI_FNO		0x00000020 /* Frame Number Overflow */
+#define  OHCI_RHSC		0x00000040 /* Root Hub Status Change */
+#define  OHCI_OC		0x40000000 /* Ownership Change */
+#define  OHCI_MIE		0x80000000 /* Master Interrupt Enable */
+#define OHCI_INTERRUPT_ENABLE	0x10
+#define OHCI_INTERRUPT_DISABLE	0x14
+#define OHCI_HCCA		0x18
+#define OHCI_PERIOD_CURRENT_ED	0x1c
+#define OHCI_CONTROL_HEAD_ED	0x20
+#define OHCI_CONTROL_CURRENT_ED	0x24
+#define OHCI_BULK_HEAD_ED	0x28
+#define OHCI_BULK_CURRENT_ED	0x2c
+#define OHCI_DONE_HEAD		0x30
+#define OHCI_FM_INTERVAL	0x34
+#define  OHCI_GET_IVAL(s)	((s) & 0x3fff)
+#define  OHCI_GET_FSMPS(s)	(((s) >> 16) & 0x7fff)
+#define  OHCI_FIT		0x80000000
+#define OHCI_FM_REMAINING	0x38
+#define OHCI_FM_NUMBER		0x3c
+#define OHCI_PERIODIC_START	0x40
+#define OHCI_LS_THRESHOLD	0x44
+#define OHCI_RH_DESCRIPTOR_A	0x48
+#define  OHCI_GET_NDP(s)	((s) & 0xff)
+#define  OHCI_PSM		0x0100     /* Power Switching Mode */
+#define  OHCI_NPS		0x0200	   /* No Power Switching */
+#define  OHCI_DT		0x0400     /* Device Type */
+#define  OHCI_OCPM		0x0800     /* Overcurrent Protection Mode */
+#define  OHCI_NOCP		0x1000     /* No Overcurrent Protection */
+#define  OHCI_GET_POTPGT(s)	((s) >> 24)
+#define OHCI_RH_DESCRIPTOR_B	0x4c
+#define OHCI_RH_STATUS		0x50
+#define  OHCI_LPS		0x00000001 /* Local Power Status */
+#define  OHCI_OCI		0x00000002 /* OverCurrent Indicator */
+#define  OHCI_DRWE		0x00008000 /* Device Remote Wakeup Enable */
+#define  OHCI_LPSC		0x00010000 /* Local Power Status Change */
+#define  OHCI_CCIC		0x00020000 /* OverCurrent Indicator Change */
+#define  OHCI_CRWE		0x80000000 /* Clear Remote Wakeup Enable */
+#define OHCI_RH_PORT_STATUS(n)	(0x50 + ((n)*4)) /* 1 based indexing */
+
+#define OHCI_LES (OHCI_PLE | OHCI_IE | OHCI_CLE | OHCI_BLE)
+#define OHCI_ALL_INTRS (OHCI_SO | OHCI_WDH | OHCI_SF | OHCI_RD | OHCI_UE | \
+                        OHCI_FNO | OHCI_RHSC | OHCI_OC)
+#define OHCI_NORMAL_INTRS (OHCI_WDH | OHCI_RD | OHCI_UE | OHCI_RHSC)
+
+#define OHCI_FSMPS(i) (((i-210)*6/7) << 16)
+#define OHCI_PERIODIC(i) ((i)*9/10)
+
+#define OHCI_NO_INTRS 32
+#define OHCI_HCCA_SIZE 256
+#define OHCI_HCCA_ALIGN 256 /* bytes */
+struct ohci_hcca {
+	__volatile__ u_int32_t	hcca_interrupt_table[OHCI_NO_INTRS];
+	__volatile__ u_int32_t	hcca_frame_number;
+	__volatile__ u_int32_t	hcca_done_head;
+#define OHCI_DONE_INTRS 1
+} __attribute__((__aligned__(OHCI_HCCA_ALIGN)));
+
+#define OHCI_PAGE_SIZE 0x1000
+#define OHCI_PAGE(x) ((x) &~ 0xfff)
+#define OHCI_PAGE_OFFSET(x) ((x) & 0xfff)
+#define OHCI_PAGE_MASK(x) ((x) & 0xfff)
+
+#define OHCI_ED_ALIGN 16 /* bytes */
+
+typedef struct ohci_ed {
+	__volatile__ u_int32_t	ed_flags;
+#define OHCI_ED_GET_FA(s)	((s) & 0x7f)
+#define OHCI_ED_ADDRMASK	0x0000007f
+#define OHCI_ED_SET_FA(s)	(s)
+#define OHCI_ED_GET_EN(s)	(((s) >> 7) & 0xf)
+#define OHCI_ED_SET_EN(s)	((s) << 7)
+#define OHCI_ED_DIR_MASK	0x00001800
+#define  OHCI_ED_DIR_TD		0x00000000
+#define  OHCI_ED_DIR_OUT	0x00000800
+#define  OHCI_ED_DIR_IN		0x00001000
+#define OHCI_ED_SPEED		0x00002000
+#define OHCI_ED_SKIP		0x00004000
+#define OHCI_ED_FORMAT_GEN	0x00000000
+#define OHCI_ED_FORMAT_ISO	0x00008000
+#define OHCI_ED_GET_MAXP(s)	(((s) >> 16) & 0x07ff)
+#define OHCI_ED_SET_MAXP(s)	((s) << 16)
+#define OHCI_ED_MAXPMASK	(0x7ff << 16)
+	__volatile__ u_int32_t	ed_tailp;
+	__volatile__ u_int32_t	ed_headp;
+#define OHCI_HALTED		0x00000001
+#define OHCI_TOGGLECARRY	0x00000002
+#define OHCI_HEADMASK		0xfffffffc
+	__volatile__ u_int32_t	ed_next;
+
+  /* 
+   * extra information needed:
+   */
+	u_int32_t	ed_self;
+
+	struct ohci_ed *next;
+	struct ohci_ed *prev;
+
+} __attribute__((__aligned__(OHCI_ED_ALIGN))) ohci_ed_t;
+
+#define OHCI_TD_ALIGN 16 /* bytes */
+
+typedef struct ohci_td {
+	__volatile__ u_int32_t	td_flags;
+#define OHCI_TD_R		0x00040000		/* Buffer Rounding  */
+#define OHCI_TD_DP_MASK		0x00180000		/* Direction / PID */
+#define  OHCI_TD_SETUP		0x00000000
+#define  OHCI_TD_OUT		0x00080000
+#define  OHCI_TD_IN		0x00100000
+#define OHCI_TD_GET_DI(x)	(((x) >> 21) & 7)	/* Delay Interrupt */
+#define OHCI_TD_SET_DI(x)	((x) << 21)
+#define  OHCI_TD_NOINTR		0x00e00000
+#define  OHCI_TD_INTR_MASK	0x00e00000
+#define OHCI_TD_TOGGLE_CARRY	0x00000000
+#define OHCI_TD_TOGGLE_0	0x02000000
+#define OHCI_TD_TOGGLE_1	0x03000000
+#define OHCI_TD_TOGGLE_MASK	0x03000000
+#define OHCI_TD_GET_EC(x)	(((x) >> 26) & 3)	/* Error Count */
+#define OHCI_TD_GET_CC(x)	((x) >> 28)		/* Condition Code */
+#define  OHCI_TD_NOCC		0xf0000000
+	__volatile__ u_int32_t	td_cbp;		/* Current Buffer Pointer */
+	__volatile__ u_int32_t	td_next;	/* Next TD */
+	__volatile__ u_int32_t	td_be;		/* Buffer End */
+
+  /*
+   * extra information needed:
+   */
+	u_int32_t		td_self;
+  
+	struct ohci_td *	next;
+
+	u_int16_t		len;
+
+} __attribute__((__aligned__(OHCI_TD_ALIGN))) ohci_td_t;
+
+
+#define OHCI_ITD_NOFFSET 8
+#define OHCI_ITD_ALIGN 32 /* bytes */
+typedef struct ohci_itd {
+	__volatile__ u_int32_t	itd_flags;
+#define OHCI_ITD_GET_SF(x)	((x) & 0x0000ffff)
+#define OHCI_ITD_SET_SF(x)	((x) & 0xffff)
+#define OHCI_ITD_GET_DI(x)	(((x) >> 21) & 7)	/* Delay Interrupt */
+#define OHCI_ITD_SET_DI(x)	((x) << 21)
+#define  OHCI_ITD_NOINTR	0x00e00000
+#define OHCI_ITD_GET_FC(x)	((((x) >> 24) & 7)+1)	/* Frame Count */
+#define OHCI_ITD_SET_FC(x)	(((x)-1) << 24)
+#define OHCI_ITD_GET_CC(x)	((x) >> 28)		/* Condition Code */
+#define  OHCI_ITD_NOCC		0xf0000000
+	__volatile__ u_int32_t	itd_bp0;			/* Buffer Page 0 */
+	__volatile__ u_int32_t	itd_next;			/* Next ITD */
+	__volatile__ u_int32_t	itd_be;				/* Buffer End */
+	__volatile__ u_int16_t	itd_offset[OHCI_ITD_NOFFSET];	/* Buffer offsets and Status */
+#define OHCI_ITD_PAGE_SELECT	0x00001000
+#define OHCI_ITD_MK_OFFS(len)	(0xe000 | ((len) & 0x1fff))
+#define OHCI_ITD_PSW_LENGTH(x)	((x) & 0xfff)		/* Transfer length */
+#define OHCI_ITD_PSW_GET_CC(x)	((x) >> 12)		/* Condition Code */
+
+  /*
+   * extra information needed
+   */
+	u_int32_t	itd_self;
+
+	struct ohci_itd *next;
+
+	u_int8_t frames;
+
+} __attribute__((__aligned__(OHCI_ITD_ALIGN))) ohci_itd_t;
+
+#define OHCI_CC_NO_ERROR		0
+#define OHCI_CC_CRC			1
+#define OHCI_CC_BIT_STUFFING		2
+#define OHCI_CC_DATA_TOGGLE_MISMATCH	3
+#define OHCI_CC_STALL			4
+#define OHCI_CC_DEVICE_NOT_RESPONDING	5
+#define OHCI_CC_PID_CHECK_FAILURE	6
+#define OHCI_CC_UNEXPECTED_PID		7
+#define OHCI_CC_DATA_OVERRUN		8
+#define OHCI_CC_DATA_UNDERRUN		9
+#define OHCI_CC_BUFFER_OVERRUN		12
+#define OHCI_CC_BUFFER_UNDERRUN		13
+#define OHCI_CC_NOT_ACCESSED		15
+
+/* Some delay needed when changing certain registers. */
+#define OHCI_ENABLE_POWER_DELAY	5
+#define OHCI_READ_DESC_DELAY	5
+
+#define OHCI_NO_EDS (2*OHCI_NO_INTRS)
+
+struct ohci_hw_softc {
+	struct ohci_hcca	hcca;
+	ohci_ed_t		ctrl_start;
+	ohci_ed_t		bulk_start;
+	ohci_ed_t		isoc_start;
+	ohci_ed_t		intr_start[OHCI_NO_EDS];
+};
+
+typedef struct ohci_softc {
+	struct ohci_hw_softc  sc_hw;     /* hardware structures first */
+
+	ohci_ed_t *		sc_ctrl_p_last;
+	ohci_ed_t *		sc_bulk_p_last;
+	ohci_ed_t *		sc_isoc_p_last;
+	ohci_ed_t *		sc_intr_p_last[OHCI_NO_EDS];
+	u_int16_t		sc_intr_stat[OHCI_NO_EDS];
+
+	struct usbd_bus		sc_bus; /* base device */
+	u_int32_t		sc_physaddr;
+
+	bus_space_tag_t iot;
+	bus_space_handle_t ioh;
+	bus_size_t sc_size;
+
+	void *ih;
+
+	struct resource *io_res;
+	struct resource *irq_res;
+
+	u_int32_t sc_eintrs;		/* enabled interrupts */
+
+	u_int8_t sc_noport;
+	u_int8_t sc_addr;		/* device address */
+	u_int8_t sc_conf;		/* device configuration */
+
+	device_t sc_dev;
+
+	struct usbd_xfer *sc_intrxfer;
+
+	u_int8_t sc_vendor[16];
+	int sc_id_vendor;
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+	void *sc_powerhook;		/* cookie from power hook */
+	void *sc_shutdownhook;		/* cookie from shutdown hook */
+#endif
+	u_int32_t sc_control;		/* Preserved during suspend/standby */
+	u_int32_t sc_intre;
+
+	LIST_HEAD(, usbd_xfer) sc_interrupt_list_head;
+
+	struct __callout sc_tmo_rhsc;
+} ohci_softc_t;
+
+usbd_status
+ohci_init(ohci_softc_t *sc);
+
+void
+ohci_detach(struct ohci_softc *sc);
+
+void
+ohci_suspend(ohci_softc_t *sc);
+
+void
+ohci_resume(ohci_softc_t *sc);
+
+void
+ohci_interrupt(ohci_softc_t *sc);
+
+#endif /* _OHCI_H_ */
+
diff -rubN /usr/src1/src/sys/dev/usb2/uhci.h /usr/src/sys/dev/usb2/uhci.h
--- /usr/src1/src/sys/dev/usb2/uhci.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/uhci.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,302 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _UHCI_H_
+#define _UHCI_H_
+
+/*** PCI config registers ***/
+
+#define PCI_USBREV		0x60	/* USB protocol revision */
+#define  PCI_USBREV_MASK	0xff
+#define  PCI_USBREV_PRE_1_0	0x00
+#define  PCI_USBREV_1_0		0x10
+#define  PCI_USBREV_1_1		0x11
+
+#define PCI_LEGSUP		0xc0	/* Legacy Support register */
+#define  PCI_LEGSUP_USBPIRQDEN	0x2000	/* USB PIRQ D Enable */
+
+#define PCI_CBIO		0x20	/* configuration base IO */
+
+#define PCI_INTERFACE_UHCI	0x00
+
+/*** UHCI registers ***/
+
+#define UHCI_CMD		0x00
+#define  UHCI_CMD_RS		0x0001
+#define  UHCI_CMD_HCRESET	0x0002
+#define  UHCI_CMD_GRESET	0x0004
+#define  UHCI_CMD_EGSM		0x0008
+#define  UHCI_CMD_FGR		0x0010
+#define  UHCI_CMD_SWDBG		0x0020
+#define  UHCI_CMD_CF		0x0040
+#define  UHCI_CMD_MAXP		0x0080
+
+#define UHCI_STS		0x02
+#define  UHCI_STS_USBINT	0x0001
+#define  UHCI_STS_USBEI		0x0002
+#define  UHCI_STS_RD		0x0004
+#define  UHCI_STS_HSE		0x0008
+#define  UHCI_STS_HCPE		0x0010
+#define  UHCI_STS_HCH		0x0020
+#define  UHCI_STS_ALLINTRS	0x003f
+
+#define UHCI_INTR		0x04
+#define  UHCI_INTR_TOCRCIE	0x0001
+#define  UHCI_INTR_RIE		0x0002
+#define  UHCI_INTR_IOCE		0x0004
+#define  UHCI_INTR_SPIE		0x0008
+
+#define UHCI_FRNUM		0x06
+#define  UHCI_FRNUM_MASK	0x03ff
+
+#define UHCI_FLBASEADDR		0x08
+
+#define UHCI_SOF		0x0c
+#define  UHCI_SOF_MASK		0x7f
+
+#define UHCI_PORTSC1      	0x010
+#define UHCI_PORTSC2      	0x012
+#define UHCI_PORTSC_CCS		0x0001
+#define UHCI_PORTSC_CSC		0x0002
+#define UHCI_PORTSC_PE		0x0004
+#define UHCI_PORTSC_POEDC	0x0008
+#define UHCI_PORTSC_LS		0x0030
+#define UHCI_PORTSC_LS_SHIFT	4
+#define UHCI_PORTSC_RD		0x0040
+#define UHCI_PORTSC_LSDA	0x0100
+#define UHCI_PORTSC_PR		0x0200
+#define UHCI_PORTSC_OCI		0x0400
+#define UHCI_PORTSC_OCIC	0x0800
+#define UHCI_PORTSC_SUSP	0x1000
+
+#define URWMASK(x) \
+  ((x) & (UHCI_PORTSC_SUSP | UHCI_PORTSC_PR | UHCI_PORTSC_RD | UHCI_PORTSC_PE))
+
+#define UHCI_FRAMELIST_COUNT	1024 /* units */
+#define UHCI_FRAMELIST_ALIGN	4096 /* bytes */
+
+#define UHCI_TD_ALIGN		16 /* bytes */
+#define UHCI_QH_ALIGN		16 /* bytes */
+
+typedef u_int32_t uhci_physaddr_t;
+#define UHCI_PTR_T		0x00000001
+#define UHCI_PTR_TD		0x00000000
+#define UHCI_PTR_QH		0x00000002
+#define UHCI_PTR_VF		0x00000004
+
+#define UHCI_QH_REMOVE_DELAY	5 /* us - QH remove delay */
+
+/*
+ * The Queue Heads (QH) and Transfer Descriptors (TD) are accessed by
+ * both the CPU and the USB-controller which run concurrently. Great
+ * care must be taken. When the data-structures are linked into the
+ * USB controller's frame list, the USB-controller "owns" the
+ * td_status and qh_elink fields, which will not be written by the
+ * CPU.
+ *
+ */
+
+typedef struct uhci_td {
+/*
+ * data used by the UHCI controller
+ *
+ * volatile is used so that the compiler
+ * does not change the order in which
+ * the variables are accessed
+ */
+	__volatile__ u_int32_t td_next;
+	__volatile__ u_int32_t td_status;
+#define UHCI_TD_GET_ACTLEN(s)	(((s) + 1) & 0x3ff)
+#define UHCI_TD_ZERO_ACTLEN(t)	((t) | 0x3ff)
+#define UHCI_TD_BITSTUFF	0x00020000
+#define UHCI_TD_CRCTO		0x00040000
+#define UHCI_TD_NAK		0x00080000
+#define UHCI_TD_BABBLE		0x00100000
+#define UHCI_TD_DBUFFER		0x00200000
+#define UHCI_TD_STALLED		0x00400000
+#define UHCI_TD_ACTIVE		0x00800000
+#define UHCI_TD_IOC		0x01000000
+#define UHCI_TD_IOS		0x02000000
+#define UHCI_TD_LS		0x04000000
+#define UHCI_TD_GET_ERRCNT(s)	(((s) >> 27) & 3)
+#define UHCI_TD_SET_ERRCNT(n)	((n) << 27)
+#define UHCI_TD_SPD		0x20000000
+	__volatile__ u_int32_t td_token;
+#define UHCI_TD_PID		0x000000ff
+#define UHCI_TD_PID_IN		0x00000069
+#define UHCI_TD_PID_OUT		0x000000e1
+#define UHCI_TD_PID_SETUP	0x0000002d
+#define UHCI_TD_GET_PID(s)	((s) & 0xff)
+#define UHCI_TD_SET_DEVADDR(a)	((a) << 8)
+#define UHCI_TD_GET_DEVADDR(s)	(((s) >> 8) & 0x7f)
+#define UHCI_TD_SET_ENDPT(e)	(((e) & 0xf) << 15)
+#define UHCI_TD_GET_ENDPT(s)	(((s) >> 15) & 0xf)
+#define UHCI_TD_SET_DT(t)	((t) << 19)
+#define UHCI_TD_GET_DT(s)	(((s) >> 19) & 1)
+#define UHCI_TD_SET_MAXLEN(l)	(((l)-1) << 21)
+#define UHCI_TD_GET_MAXLEN(s)	((((s) >> 21) + 1) & 0x7ff)
+#define UHCI_TD_MAXLEN_MASK	0xffe00000
+	__volatile__ u_int32_t td_buffer;
+
+/*
+ * extra information needed:
+ */
+	u_int32_t td_self;
+
+	struct uhci_td *next;
+	struct uhci_td *prev;
+
+} __attribute__((__aligned__(UHCI_TD_ALIGN))) uhci_td_t;
+
+#define UHCI_TD_ERROR (UHCI_TD_BITSTUFF|UHCI_TD_CRCTO|UHCI_TD_BABBLE|UHCI_TD_DBUFFER|UHCI_TD_STALLED)
+
+#define UHCI_TD_SETUP(len, endp, dev) (UHCI_TD_SET_MAXLEN(len) | \
+     UHCI_TD_SET_ENDPT(endp) | UHCI_TD_SET_DEVADDR(dev) | \
+     UHCI_TD_PID_SETUP)
+
+#define UHCI_TD_OUT(len, endp, dev, dt) (UHCI_TD_SET_MAXLEN(len) | \
+     UHCI_TD_SET_ENDPT(endp) | UHCI_TD_SET_DEVADDR(dev) | \
+     UHCI_TD_PID_OUT | UHCI_TD_SET_DT(dt))
+
+#define UHCI_TD_IN(len, endp, dev, dt) (UHCI_TD_SET_MAXLEN(len) | \
+     UHCI_TD_SET_ENDPT(endp) | UHCI_TD_SET_DEVADDR(dev) | \
+     UHCI_TD_PID_IN | UHCI_TD_SET_DT(dt))
+
+typedef struct uhci_qh {
+/*
+ * data used by the UHCI controller
+ */
+	__volatile__ u_int32_t qh_h_next;
+	__volatile__ u_int32_t qh_e_next;
+
+/*
+ * extra information needed:
+ */
+	u_int32_t qh_self;
+
+	struct uhci_qh *h_next;
+	struct uhci_qh *h_prev;
+
+	struct uhci_td *e_next;
+
+	u_int16_t	intr_pos;
+
+} __attribute__((__aligned__(UHCI_QH_ALIGN))) uhci_qh_t;
+
+#define UHCI_VFRAMELIST_COUNT 128 /* maximum number of isochronous TD's */
+#define UHCI_IFRAMELIST_COUNT (2*UHCI_VFRAMELIST_COUNT) /* maximum number of interrupt QH's */
+
+#if (((UHCI_VFRAMELIST_COUNT & (UHCI_VFRAMELIST_COUNT-1)) != 0) ||	\
+     (UHCI_VFRAMELIST_COUNT > UHCI_FRAMELIST_COUNT))
+
+#error "UHCI_VFRAMELIST_COUNT is not power of two"
+#error "or UHCI_VFRAMELIST_COUNT > UHCI_FRAMELIST_COUNT"
+#endif
+
+struct uhci_hw_softc {
+	u_int32_t pframes[UHCI_FRAMELIST_COUNT]; /* start TD pointer */
+
+	struct uhci_td isoc_start[UHCI_VFRAMELIST_COUNT]; /* start TD for isochronous */
+	struct uhci_qh intr_start[UHCI_IFRAMELIST_COUNT]; /* start QH for interrupt */
+
+	struct uhci_qh ls_ctl_start;	/* start QH for low speed control */
+	struct uhci_qh hs_ctl_start;	/* start QH for high speed control */
+	struct uhci_qh bulk_start;	/* start QH for bulk */
+
+	struct uhci_qh last_qh;	/* last QH */
+	struct uhci_td last_td;	/* last TD */
+
+};
+
+typedef struct uhci_softc {
+	struct uhci_hw_softc sc_hw; /* hardware structures first */
+  
+	u_int32_t       sc_physaddr;	/* physical address of this structure */
+
+	struct uhci_td *sc_isoc_p_last[UHCI_VFRAMELIST_COUNT]; /* pointer to last TD for isochronous */
+	struct uhci_qh *sc_intr_p_last[UHCI_IFRAMELIST_COUNT]; /* pointer to last QH for interrupt */
+
+	u_int16_t	sc_intr_stat[UHCI_IFRAMELIST_COUNT];
+
+	struct uhci_qh *sc_ls_ctl_p_last; /* pointer to last QH for low speed control */
+	struct uhci_qh *sc_hs_ctl_p_last; /* pointer to last QH for high speed control */
+	struct uhci_qh *sc_bulk_p_last;   /* pointer to last QH for bulk */
+
+	struct usbd_bus sc_bus;		/* base device */
+
+	bus_space_tag_t iot;
+	bus_space_handle_t ioh;
+	bus_size_t ios;
+
+	void *ih;
+
+	struct resource *io_res;
+	struct resource *irq_res;
+
+	device_t sc_dev;
+
+	u_int32_t sc_loops;		/* number of QHs that wants looping */
+
+	u_int8_t sc_addr;		/* device address */
+	u_int8_t sc_conf;		/* device configuration */
+	u_int8_t sc_isreset;
+
+	u_int8_t sc_saved_sof;
+	u_int16_t sc_saved_frnum;
+
+	LIST_HEAD(, usbd_xfer) sc_interrupt_list_head;
+
+	char sc_vendor[16];		/* vendor string for root hub */
+
+} uhci_softc_t;
+
+usbd_status
+uhci_init(uhci_softc_t *sc);
+
+void
+uhci_suspend(uhci_softc_t *sc);
+
+void
+uhci_resume(uhci_softc_t *sc);
+
+void
+uhci_reset(uhci_softc_t *sc);
+
+void
+uhci_interrupt(uhci_softc_t *sc);
+
+#endif /* _UHCI_H_ */
diff -rubN /usr/src1/src/sys/dev/usb2/usb.h /usr/src/sys/dev/usb2/usb.h
--- /usr/src1/src/sys/dev/usb2/usb.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/usb.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,731 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _USB_H_
+#define _USB_H_
+
+#include <sys/types.h>
+#include <sys/time.h>
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/ioctl.h>
+#endif
+
+#if defined(_KERNEL)
+#include <dev/usb2/usb_port.h>
+#endif /* _KERNEL */
+
+/* These two defines are used by usbd to autoload the usb kld */
+#define USB_KLD		"usb"		/* name of usb module */
+#define USB_UHUB	"usb/uhub"	/* root hub */
+
+#define USB_STACK_VERSION 2
+
+#define USB_HOST_ALIGN    8 /* bytes, must be power of two */
+
+#define USB_MAX_DEVICES 128
+#define USB_START_ADDR 0
+
+#define USB_CONTROL_ENDPOINT 0
+#define USB_MAX_ENDPOINTS 16
+
+#define USB_FRAMES_PER_SECOND 1000
+
+#ifndef __UA_TYPES_H__
+#define __UA_TYPES_H__
+
+/* the following structures are
+ * used to force the compiler to
+ * generate un-aligned memory
+ * access code on processors that
+ * do not support un-aligned
+ * memory accesses:
+ */
+
+struct void_p {
+  void *data;
+} __packed;
+
+struct u_int16_p {
+  u_int16_t data;
+} __packed;
+
+struct u_int32_p {
+  u_int32_t data;
+} __packed;
+
+struct u_int64_p {
+  u_int64_t data;
+} __packed;
+
+typedef struct void_p    void_p_t;
+typedef struct u_int16_p u_int16_p_t;
+typedef struct u_int32_p u_int32_p_t;
+typedef struct u_int64_p u_int64_p_t;
+#endif
+
+/*
+ * The USB records contain some unaligned little-endian word
+ * components.  The U[SG]ETW macros take care of both the alignment
+ * and endian problem and should always be used to access non-byte
+ * values.
+ */
+typedef u_int8_t uByte;
+typedef u_int8_t uWord[2];
+typedef u_int8_t uDWord[4];
+
+#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))
+
+#if 1
+#define UGETW(w) ((w)[0] | ((w)[1] << 8))
+#define USETW(w,v) ((w)[0] = (u_int8_t)(v), (w)[1] = (u_int8_t)((v) >> 8))
+#define UGETDW(w) ((w)[0] | ((w)[1] << 8) | ((w)[2] << 16) | ((w)[3] << 24))
+#define USETDW(w,v) ((w)[0] = (u_int8_t)(v), \
+		     (w)[1] = (u_int8_t)((v) >> 8), \
+		     (w)[2] = (u_int8_t)((v) >> 16), \
+		     (w)[3] = (u_int8_t)((v) >> 24))
+#else
+/*
+ * On little-endian machines that can handle unanliged accesses
+ * (e.g. i386) these macros can be replaced by the following.
+ */
+#define UGETW(w) (*(u_int16_t *)(w))
+#define USETW(w,v) (*(u_int16_t *)(w) = (v))
+#define UGETDW(w) (*(u_int32_t *)(w))
+#define USETDW(w,v) (*(u_int32_t *)(w) = (v))
+#endif
+
+#if defined(__FreeBSD__) && (__FreeBSD_version <= 500014)
+#define UPACKED __attribute__ ((packed))
+#else
+#define UPACKED __packed
+#endif
+
+typedef struct {
+	uByte		bmRequestType;
+	uByte		bRequest;
+	uWord		wValue;
+	uWord		wIndex;
+	uWord		wLength;
+	uByte		bData[0];
+} UPACKED usb_device_request_t;
+
+#define UT_WRITE		0x00
+#define UT_READ			0x80
+#define UT_STANDARD		0x00
+#define UT_CLASS		0x20
+#define UT_VENDOR		0x40
+#define UT_DEVICE		0x00
+#define UT_INTERFACE		0x01
+#define UT_ENDPOINT		0x02
+#define UT_OTHER		0x03
+
+#define UT_READ_DEVICE		(UT_READ  | UT_STANDARD | UT_DEVICE)
+#define UT_READ_INTERFACE	(UT_READ  | UT_STANDARD | UT_INTERFACE)
+#define UT_READ_ENDPOINT	(UT_READ  | UT_STANDARD | UT_ENDPOINT)
+#define UT_WRITE_DEVICE		(UT_WRITE | UT_STANDARD | UT_DEVICE)
+#define UT_WRITE_INTERFACE	(UT_WRITE | UT_STANDARD | UT_INTERFACE)
+#define UT_WRITE_ENDPOINT	(UT_WRITE | UT_STANDARD | UT_ENDPOINT)
+#define UT_READ_CLASS_DEVICE	(UT_READ  | UT_CLASS | UT_DEVICE)
+#define UT_READ_CLASS_INTERFACE	(UT_READ  | UT_CLASS | UT_INTERFACE)
+#define UT_READ_CLASS_OTHER	(UT_READ  | UT_CLASS | UT_OTHER)
+#define UT_READ_CLASS_ENDPOINT	(UT_READ  | UT_CLASS | UT_ENDPOINT)
+#define UT_WRITE_CLASS_DEVICE	(UT_WRITE | UT_CLASS | UT_DEVICE)
+#define UT_WRITE_CLASS_INTERFACE (UT_WRITE | UT_CLASS | UT_INTERFACE)
+#define UT_WRITE_CLASS_OTHER	(UT_WRITE | UT_CLASS | UT_OTHER)
+#define UT_WRITE_CLASS_ENDPOINT	(UT_WRITE | UT_CLASS | UT_ENDPOINT)
+#define UT_READ_VENDOR_DEVICE	(UT_READ  | UT_VENDOR | UT_DEVICE)
+#define UT_READ_VENDOR_INTERFACE (UT_READ  | UT_VENDOR | UT_INTERFACE)
+#define UT_READ_VENDOR_OTHER	(UT_READ  | UT_VENDOR | UT_OTHER)
+#define UT_READ_VENDOR_ENDPOINT	(UT_READ  | UT_VENDOR | UT_ENDPOINT)
+#define UT_WRITE_VENDOR_DEVICE	(UT_WRITE | UT_VENDOR | UT_DEVICE)
+#define UT_WRITE_VENDOR_INTERFACE (UT_WRITE | UT_VENDOR | UT_INTERFACE)
+#define UT_WRITE_VENDOR_OTHER	(UT_WRITE | UT_VENDOR | UT_OTHER)
+#define UT_WRITE_VENDOR_ENDPOINT (UT_WRITE | UT_VENDOR | UT_ENDPOINT)
+
+/* Requests */
+#define UR_GET_STATUS		0x00
+#define UR_CLEAR_FEATURE	0x01
+#define UR_SET_FEATURE		0x03
+#define UR_SET_ADDRESS		0x05
+#define UR_GET_DESCRIPTOR	0x06
+#define  UDESC_DEVICE		0x01
+#define  UDESC_CONFIG		0x02
+#define  UDESC_STRING		0x03
+#define  UDESC_INTERFACE	0x04
+#define  UDESC_ENDPOINT		0x05
+#define  UDESC_DEVICE_QUALIFIER	0x06
+#define  UDESC_OTHER_SPEED_CONFIGURATION 0x07
+#define  UDESC_INTERFACE_POWER	0x08
+#define  UDESC_OTG		0x09
+#define  UDESC_CS_DEVICE	0x21	/* class specific */
+#define  UDESC_CS_CONFIG	0x22
+#define  UDESC_CS_STRING	0x23
+#define  UDESC_CS_INTERFACE	0x24
+#define  UDESC_CS_ENDPOINT	0x25
+#define  UDESC_HUB		0x29
+#define UR_SET_DESCRIPTOR	0x07
+#define UR_GET_CONFIG		0x08
+#define UR_SET_CONFIG		0x09
+#define UR_GET_INTERFACE	0x0a
+#define UR_SET_INTERFACE	0x0b
+#define UR_SYNCH_FRAME		0x0c
+
+/* Feature numbers */
+#define UF_ENDPOINT_HALT	0
+#define UF_DEVICE_REMOTE_WAKEUP	1
+#define UF_TEST_MODE		2
+
+#define USB_MAX_IPACKET		8 /* maximum size of the initial packet */
+
+#define USB_2_MAX_CTRL_PACKET	64
+#define USB_2_MAX_BULK_PACKET	512
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uByte		bDescriptorSubtype;
+} UPACKED usb_descriptor_t;
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uWord		bcdUSB;
+#define UD_USB_2_0		0x0200
+#define UD_IS_USB2(d) (UGETW((d)->bcdUSB) >= UD_USB_2_0)
+	uByte		bDeviceClass;
+	uByte		bDeviceSubClass;
+	uByte		bDeviceProtocol;
+	uByte		bMaxPacketSize;
+	/* The fields below are not part of the initial descriptor. */
+	uWord		idVendor;
+	uWord		idProduct;
+	uWord		bcdDevice;
+	uByte		iManufacturer;
+	uByte		iProduct;
+	uByte		iSerialNumber;
+	uByte		bNumConfigurations;
+} UPACKED usb_device_descriptor_t;
+#define USB_DEVICE_DESCRIPTOR_SIZE 18
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uWord		wTotalLength;
+	uByte		bNumInterface;
+	uByte		bConfigurationValue;
+	uByte		iConfiguration;
+	uByte		bmAttributes;
+#define UC_BUS_POWERED		0x80
+#define UC_SELF_POWERED		0x40
+#define UC_REMOTE_WAKEUP	0x20
+	uByte		bMaxPower; /* max current in 2 mA units */
+#define UC_POWER_FACTOR 2
+} UPACKED usb_config_descriptor_t;
+#define USB_CONFIG_DESCRIPTOR_SIZE 9
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uByte		bInterfaceNumber;
+	uByte		bAlternateSetting;
+	uByte		bNumEndpoints;
+	uByte		bInterfaceClass;
+	uByte		bInterfaceSubClass;
+	uByte		bInterfaceProtocol;
+	uByte		iInterface;
+} UPACKED usb_interface_descriptor_t;
+#define USB_INTERFACE_DESCRIPTOR_SIZE 9
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uByte		bEndpointAddress;
+#define UE_GET_DIR(a)	((a) & 0x80)
+#define UE_SET_DIR(a,d)	((a) | (((d)&1) << 7))
+#define UE_DIR_IN	0x80
+#define UE_DIR_OUT	0x00
+#define UE_ADDR		0x0f
+#define UE_GET_ADDR(a)	((a) & UE_ADDR)
+	uByte		bmAttributes;
+#define UE_XFERTYPE	0x03
+#define  UE_CONTROL	0x00
+#define  UE_ISOCHRONOUS	0x01
+#define  UE_BULK	0x02
+#define  UE_INTERRUPT	0x03
+#define UE_GET_XFERTYPE(a)	((a) & UE_XFERTYPE)
+#define UE_ISO_TYPE	0x0c
+#define  UE_ISO_ASYNC	0x04
+#define  UE_ISO_ADAPT	0x08
+#define  UE_ISO_SYNC	0x0c
+#define UE_GET_ISO_TYPE(a)	((a) & UE_ISO_TYPE)
+	uWord		wMaxPacketSize;
+	uByte		bInterval;
+} UPACKED usb_endpoint_descriptor_t;
+#define USB_ENDPOINT_DESCRIPTOR_SIZE 7
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uWord		bString[127];
+} UPACKED usb_string_descriptor_t;
+#define USB_MAX_STRING_LEN 128
+#define USB_LANGUAGE_TABLE 0	/* # of the string language id table */
+
+/* Hub specific request */
+#define UR_GET_BUS_STATE	0x02
+#define UR_CLEAR_TT_BUFFER	0x08
+#define UR_RESET_TT		0x09
+#define UR_GET_TT_STATE		0x0a
+#define UR_STOP_TT		0x0b
+
+/* Hub features */
+#define UHF_C_HUB_LOCAL_POWER	0
+#define UHF_C_HUB_OVER_CURRENT	1
+#define UHF_PORT_CONNECTION	0
+#define UHF_PORT_ENABLE		1
+#define UHF_PORT_SUSPEND	2
+#define UHF_PORT_OVER_CURRENT	3
+#define UHF_PORT_RESET		4
+#define UHF_PORT_POWER		8
+#define UHF_PORT_LOW_SPEED	9
+#define UHF_C_PORT_CONNECTION	16
+#define UHF_C_PORT_ENABLE	17
+#define UHF_C_PORT_SUSPEND	18
+#define UHF_C_PORT_OVER_CURRENT	19
+#define UHF_C_PORT_RESET	20
+#define UHF_PORT_TEST		21
+#define UHF_PORT_INDICATOR	22
+
+typedef struct {
+	uByte		bDescLength;
+	uByte		bDescriptorType;
+	uByte		bNbrPorts;
+	uWord		wHubCharacteristics;
+#define UHD_PWR			0x0003
+#define  UHD_PWR_GANGED		0x0000
+#define  UHD_PWR_INDIVIDUAL	0x0001
+#define  UHD_PWR_NO_SWITCH	0x0002
+#define UHD_COMPOUND		0x0004
+#define UHD_OC			0x0018
+#define  UHD_OC_GLOBAL		0x0000
+#define  UHD_OC_INDIVIDUAL	0x0008
+#define  UHD_OC_NONE		0x0010
+#define UHD_TT_THINK		0x0060
+#define  UHD_TT_THINK_8		0x0000
+#define  UHD_TT_THINK_16	0x0020
+#define  UHD_TT_THINK_24	0x0040
+#define  UHD_TT_THINK_32	0x0060
+#define UHD_PORT_IND		0x0080
+	uByte		bPwrOn2PwrGood;	/* delay in 2 ms units */
+#define UHD_PWRON_FACTOR 2
+	uByte		bHubContrCurrent;
+	uByte		DeviceRemovable[32]; /* max 255 ports */
+#define UHD_NOT_REMOV(desc, i) \
+    (((desc)->DeviceRemovable[(i)/8] >> ((i) % 8)) & 1)
+	/* deprecated */ uByte		PortPowerCtrlMask[1];
+} UPACKED usb_hub_descriptor_t;
+#define USB_HUB_DESCRIPTOR_SIZE 9 /* includes deprecated PortPowerCtrlMask */
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uWord		bcdUSB;
+	uByte		bDeviceClass;
+	uByte		bDeviceSubClass;
+	uByte		bDeviceProtocol;
+	uByte		bMaxPacketSize0;
+	uByte		bNumConfigurations;
+	uByte		bReserved;
+} UPACKED usb_device_qualifier_t;
+#define USB_DEVICE_QUALIFIER_SIZE 10
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uByte		bmAttributes;
+#define UOTG_SRP	0x01
+#define UOTG_HNP	0x02
+} UPACKED usb_otg_descriptor_t;
+
+/* OTG feature selectors */
+#define UOTG_B_HNP_ENABLE	3
+#define UOTG_A_HNP_SUPPORT	4
+#define UOTG_A_ALT_HNP_SUPPORT	5
+
+typedef struct {
+	uWord		wStatus;
+/* Device status flags */
+#define UDS_SELF_POWERED		0x0001
+#define UDS_REMOTE_WAKEUP		0x0002
+/* Endpoint status flags */
+#define UES_HALT			0x0001
+} UPACKED usb_status_t;
+
+typedef struct {
+	uWord		wHubStatus;
+#define UHS_LOCAL_POWER			0x0001
+#define UHS_OVER_CURRENT		0x0002
+	uWord		wHubChange;
+} UPACKED usb_hub_status_t;
+
+typedef struct {
+	uWord		wPortStatus;
+#define UPS_CURRENT_CONNECT_STATUS	0x0001
+#define UPS_PORT_ENABLED		0x0002
+#define UPS_SUSPEND			0x0004
+#define UPS_OVERCURRENT_INDICATOR	0x0008
+#define UPS_RESET			0x0010
+#define UPS_PORT_POWER			0x0100
+#define UPS_LOW_SPEED			0x0200
+#define UPS_HIGH_SPEED			0x0400
+#define UPS_PORT_TEST			0x0800
+#define UPS_PORT_INDICATOR		0x1000
+	uWord		wPortChange;
+#define UPS_C_CONNECT_STATUS		0x0001
+#define UPS_C_PORT_ENABLED		0x0002
+#define UPS_C_SUSPEND			0x0004
+#define UPS_C_OVERCURRENT_INDICATOR	0x0008
+#define UPS_C_PORT_RESET		0x0010
+} UPACKED usb_port_status_t;
+
+/* Device class codes */
+#define UDCLASS_IN_INTERFACE	0x00
+#define UDCLASS_COMM		0x02
+#define UDCLASS_HUB		0x09
+#define  UDSUBCLASS_HUB		0x00
+#define  UDPROTO_FSHUB		0x00
+#define  UDPROTO_HSHUBSTT	0x01
+#define  UDPROTO_HSHUBMTT	0x02
+#define UDCLASS_DIAGNOSTIC	0xdc
+#define UDCLASS_WIRELESS	0xe0
+#define  UDSUBCLASS_RF		0x01
+#define   UDPROTO_BLUETOOTH	0x01
+#define UDCLASS_VENDOR		0xff
+
+/* Interface class codes */
+#define UICLASS_UNSPEC		0x00
+
+#define UICLASS_AUDIO		0x01
+#define  UISUBCLASS_AUDIOCONTROL	1
+#define  UISUBCLASS_AUDIOSTREAM		2
+#define  UISUBCLASS_MIDISTREAM		3
+
+#define UICLASS_CDC		0x02 /* communication */
+#define	 UISUBCLASS_DIRECT_LINE_CONTROL_MODEL	1
+#define  UISUBCLASS_ABSTRACT_CONTROL_MODEL	2
+#define	 UISUBCLASS_TELEPHONE_CONTROL_MODEL	3
+#define	 UISUBCLASS_MULTICHANNEL_CONTROL_MODEL	4
+#define	 UISUBCLASS_CAPI_CONTROLMODEL		5
+#define	 UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL 6
+#define	 UISUBCLASS_ATM_NETWORKING_CONTROL_MODEL 7
+#define   UIPROTO_CDC_AT			1
+
+#define UICLASS_HID		0x03
+#define  UISUBCLASS_BOOT	1
+#define  UIPROTO_BOOT_KEYBOARD	1
+
+#define UICLASS_PHYSICAL	0x05
+
+#define UICLASS_IMAGE		0x06
+
+#define UICLASS_PRINTER		0x07
+#define  UISUBCLASS_PRINTER	1
+#define  UIPROTO_PRINTER_UNI	1
+#define  UIPROTO_PRINTER_BI	2
+#define  UIPROTO_PRINTER_1284	3
+
+#define UICLASS_MASS		0x08
+#define  UISUBCLASS_RBC		1
+#define  UISUBCLASS_SFF8020I	2
+#define  UISUBCLASS_QIC157	3
+#define  UISUBCLASS_UFI		4
+#define  UISUBCLASS_SFF8070I	5
+#define  UISUBCLASS_SCSI	6
+#define  UIPROTO_MASS_CBI_I	0
+#define  UIPROTO_MASS_CBI	1
+#define  UIPROTO_MASS_BBB_OLD	2	/* Not in the spec anymore */
+#define  UIPROTO_MASS_BBB	80	/* 'P' for the Iomega Zip drive */
+
+#define UICLASS_HUB		0x09
+#define  UISUBCLASS_HUB		0
+#define  UIPROTO_FSHUB		0
+#define  UIPROTO_HSHUBSTT	0 /* Yes, same as previous */
+#define  UIPROTO_HSHUBMTT	1
+
+#define UICLASS_CDC_DATA	0x0a
+#define  UISUBCLASS_DATA		0
+#define   UIPROTO_DATA_ISDNBRI		0x30    /* Physical iface */
+#define   UIPROTO_DATA_HDLC		0x31    /* HDLC */
+#define   UIPROTO_DATA_TRANSPARENT	0x32    /* Transparent */
+#define   UIPROTO_DATA_Q921M		0x50    /* Management for Q921 */
+#define   UIPROTO_DATA_Q921		0x51    /* Data for Q921 */
+#define   UIPROTO_DATA_Q921TM		0x52    /* TEI multiplexer for Q921 */
+#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */
+#define   UIPROTO_DATA_Q931		0x91    /* Euro-ISDN */
+#define   UIPROTO_DATA_V120		0x92    /* V.24 rate adaption */
+#define   UIPROTO_DATA_CAPI		0x93    /* CAPI 2.0 commands */
+#define   UIPROTO_DATA_HOST_BASED	0xfd    /* Host based driver */
+#define   UIPROTO_DATA_PUF		0xfe    /* see Prot. Unit Func. Desc.*/
+#define   UIPROTO_DATA_VENDOR		0xff    /* Vendor specific */
+
+#define UICLASS_SMARTCARD	0x0b
+
+/*#define UICLASS_FIRM_UPD	0x0c*/
+
+#define UICLASS_SECURITY	0x0d
+
+#define UICLASS_DIAGNOSTIC	0xdc
+
+#define UICLASS_WIRELESS	0xe0
+#define  UISUBCLASS_RF			0x01
+#define   UIPROTO_BLUETOOTH		0x01
+
+#define UICLASS_APPL_SPEC	0xfe
+#define  UISUBCLASS_FIRMWARE_DOWNLOAD	1
+#define  UISUBCLASS_IRDA		2
+#define  UIPROTO_IRDA			0
+
+#define UICLASS_VENDOR		0xff
+#define  UISUBCLASS_XBOX360_CONTROLLER	0x5d
+#define  UIPROTO_XBOX360_GAMEPAD	0x01
+
+#define USB_HUB_MAX_DEPTH 5
+
+/*
+ * Minimum time a device needs to be powered down to go through
+ * a power cycle.  XXX Are these time in the spec?
+ */
+#define USB_POWER_DOWN_TIME	200 /* ms */
+#define USB_PORT_POWER_DOWN_TIME	100 /* ms */
+
+#if 0
+/* These are the values from the spec. */
+#define USB_PORT_RESET_DELAY	10  /* ms */
+#define USB_PORT_ROOT_RESET_DELAY 50  /* ms */
+#define USB_PORT_RESET_RECOVERY	10  /* ms */
+#define USB_PORT_POWERUP_DELAY	100 /* ms */
+#define USB_SET_ADDRESS_SETTLE	2   /* ms */
+#define USB_RESUME_DELAY	(20*5)  /* ms */
+#define USB_RESUME_WAIT		10  /* ms */
+#define USB_RESUME_RECOVERY	10  /* ms */
+#define USB_EXTRA_POWER_UP_TIME	0   /* ms */
+#else
+/* Allow for marginal (i.e. non-conforming) devices. */
+#define USB_PORT_RESET_DELAY	50  /* ms */
+#define USB_PORT_ROOT_RESET_DELAY 250  /* ms */
+#define USB_PORT_RESET_RECOVERY	250  /* ms */
+#define USB_PORT_POWERUP_DELAY	300 /* ms */
+#define USB_SET_ADDRESS_SETTLE	10  /* ms */
+#define USB_RESUME_DELAY	(50*5)  /* ms */
+#define USB_RESUME_WAIT		50  /* ms */
+#define USB_RESUME_RECOVERY	50  /* ms */
+#define USB_EXTRA_POWER_UP_TIME	20  /* ms */
+#endif
+
+#define USB_MIN_POWER		100 /* mA */
+#define USB_MAX_POWER		500 /* mA */
+
+#define USB_BUS_RESET_DELAY	100 /* ms XXX?*/
+
+
+#define USB_UNCONFIG_NO 0
+#define USB_UNCONFIG_INDEX (-1)
+
+/*---------------------------------------------------------------------------*
+ * ioctl() related stuff
+ *---------------------------------------------------------------------------*/
+struct usb_ctl_request {
+	int	ucr_addr;
+	usb_device_request_t ucr_request;
+	void	*ucr_data;
+	int	ucr_flags;
+#define USBD_SHORT_XFER_OK       0x0004 /* allow short reads */
+	int	ucr_actlen;		/* actual length transferred */
+};
+
+struct usb_alt_interface {
+	int	uai_config_index;
+	int	uai_interface_index;
+	int	uai_alt_no;
+};
+
+#define USB_CURRENT_CONFIG_INDEX (-1)
+#define USB_CURRENT_ALT_INDEX (-1)
+
+struct usb_config_desc {
+	int	ucd_config_index;
+	usb_config_descriptor_t ucd_desc;
+};
+
+struct usb_interface_desc {
+	int	uid_config_index;
+	int	uid_interface_index;
+	int	uid_alt_index;
+	usb_interface_descriptor_t uid_desc;
+};
+
+struct usb_endpoint_desc {
+	int	ued_config_index;
+	int	ued_interface_index;
+	int	ued_alt_index;
+	int	ued_endpoint_index;
+	usb_endpoint_descriptor_t ued_desc;
+};
+
+struct usb_full_desc {
+	int	ufd_config_index;
+	u_int	ufd_size;
+	u_char	*ufd_data;
+};
+
+struct usb_string_desc {
+	int	usd_string_index;
+	int	usd_language_id;
+	usb_string_descriptor_t usd_desc;
+};
+
+struct usb_ctl_report_desc {
+	int	ucrd_size;
+	u_char	ucrd_data[1024];	/* filled data size will vary */
+};
+
+typedef struct { u_int32_t cookie; } usb_event_cookie_t;
+
+#define USB_MAX_DEVNAMES 4
+#define USB_MAX_DEVNAMELEN 16
+struct usb_device_info {
+	u_int8_t	udi_bus;
+	u_int8_t	udi_addr;	/* device address */
+	usb_event_cookie_t udi_cookie;
+	char		udi_product[USB_MAX_STRING_LEN];
+	char		udi_vendor[USB_MAX_STRING_LEN];
+	char		udi_release[8];
+	u_int16_t	udi_productNo;
+	u_int16_t	udi_vendorNo;
+	u_int16_t	udi_releaseNo;
+	u_int8_t	udi_class;
+	u_int8_t	udi_subclass;
+	u_int8_t	udi_protocol;
+	u_int8_t	udi_config;
+	u_int8_t	udi_speed;
+#define USB_SPEED_LOW  1
+#define USB_SPEED_FULL 2
+#define USB_SPEED_HIGH 3
+	int		udi_power;	/* power consumption in mA, 0 if selfpowered */
+	int		udi_nports;
+	char		udi_devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
+	u_int8_t	udi_ports[16];/* hub only: addresses of devices on ports */
+#define USB_PORT_ENABLED 0xff
+#define USB_PORT_SUSPENDED 0xfe
+#define USB_PORT_POWERED 0xfd
+#define USB_PORT_DISABLED 0xfc
+};
+
+struct usb_ctl_report {
+	int	ucr_report;
+	u_char	ucr_data[1024];	/* filled data size will vary */
+};
+
+struct usb_device_stats {
+	u_long	uds_requests[4];	/* indexed by transfer type UE_* */
+};
+
+/* Events that can be read from /dev/usb */
+struct usb_event {
+	int			ue_type;
+#define USB_EVENT_CTRLR_ATTACH 1
+#define USB_EVENT_CTRLR_DETACH 2
+#define USB_EVENT_DEVICE_ATTACH 3
+#define USB_EVENT_DEVICE_DETACH 4
+#define USB_EVENT_DRIVER_ATTACH 5
+#define USB_EVENT_DRIVER_DETACH 6
+#define USB_EVENT_IS_ATTACH(n) ((n) == USB_EVENT_CTRLR_ATTACH || (n) == USB_EVENT_DEVICE_ATTACH || (n) == USB_EVENT_DRIVER_ATTACH)
+#define USB_EVENT_IS_DETACH(n) ((n) == USB_EVENT_CTRLR_DETACH || (n) == USB_EVENT_DEVICE_DETACH || (n) == USB_EVENT_DRIVER_DETACH)
+	struct timespec		ue_time;
+	union {
+		struct {
+			int			ue_bus;
+		} ue_ctrlr;
+		struct usb_device_info		ue_device;
+		struct {
+			usb_event_cookie_t	ue_cookie;
+			char			ue_devname[16];
+		} ue_driver;
+	} u;
+};
+
+/* USB controller */
+#define USB_REQUEST		_IOWR('U', 1, struct usb_ctl_request)
+#define USB_SETDEBUG		_IOW ('U', 2, int)
+#define USB_DISCOVER		_IO  ('U', 3)
+#define USB_DEVICEINFO		_IOWR('U', 4, struct usb_device_info)
+#define USB_DEVICESTATS		_IOR ('U', 5, struct usb_device_stats)
+
+/* Generic HID device */
+#define USB_GET_REPORT_DESC	_IOR ('U', 21, struct usb_ctl_report_desc)
+#define USB_SET_IMMED		_IOW ('U', 22, int)
+#define USB_GET_REPORT		_IOWR('U', 23, struct usb_ctl_report)
+#define USB_SET_REPORT		_IOW ('U', 24, struct usb_ctl_report)
+#define USB_GET_REPORT_ID	_IOR ('U', 25, int)
+
+/* Generic USB device */
+#define USB_GET_CONFIG		_IOR ('U', 100, int)
+#define USB_SET_CONFIG		_IOW ('U', 101, int)
+#define USB_GET_ALTINTERFACE	_IOWR('U', 102, struct usb_alt_interface)
+#define USB_SET_ALTINTERFACE	_IOWR('U', 103, struct usb_alt_interface)
+#define USB_GET_NO_ALT		_IOWR('U', 104, struct usb_alt_interface)
+#define USB_GET_DEVICE_DESC	_IOR ('U', 105, usb_device_descriptor_t)
+#define USB_GET_CONFIG_DESC	_IOWR('U', 106, struct usb_config_desc)
+#define USB_GET_INTERFACE_DESC	_IOWR('U', 107, struct usb_interface_desc)
+#define USB_GET_ENDPOINT_DESC	_IOWR('U', 108, struct usb_endpoint_desc)
+#define USB_GET_FULL_DESC	_IOWR('U', 109, struct usb_full_desc)
+#define USB_GET_STRING_DESC	_IOWR('U', 110, struct usb_string_desc)
+#define USB_DO_REQUEST		_IOWR('U', 111, struct usb_ctl_request)
+#define USB_GET_DEVICEINFO	_IOR ('U', 112, struct usb_device_info)
+#define USB_SET_SHORT_XFER	_IOW ('U', 113, int)
+#define USB_SET_TIMEOUT		_IOW ('U', 114, int)
+#define USB_GET_FRAME_SIZE	_IOR ('U', 115, int)
+#define USB_SET_FRAME_SIZE	_IOW ('U', 116, int)
+#define USB_GET_BUFFER_SIZE	_IOR ('U', 117, int)
+#define USB_SET_BUFFER_SIZE	_IOW ('U', 118, int)
+
+/* Modem device */
+#define USB_GET_CM_OVER_DATA	_IOR ('U', 130, int)
+#define USB_SET_CM_OVER_DATA	_IOW ('U', 131, int)
+
+#endif /* _USB_H_ */
diff -rubN /usr/src1/src/sys/dev/usb2/usb_hid.h /usr/src/sys/dev/usb2/usb_hid.h
--- /usr/src1/src/sys/dev/usb2/usb_hid.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/usb_hid.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1 @@
+#include <dev/usb/usbhid.h>
diff -rubN /usr/src1/src/sys/dev/usb2/usb_hid_copy.h /usr/src/sys/dev/usb2/usb_hid_copy.h
--- /usr/src1/src/sys/dev/usb2/usb_hid_copy.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/usb_hid_copy.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,181 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _USBHID_H_
+#define _USBHID_H_
+
+#define UR_GET_HID_DESCRIPTOR	0x06
+#define  UDESC_HID		0x21
+#define  UDESC_REPORT		0x22
+#define  UDESC_PHYSICAL		0x23
+#define UR_SET_HID_DESCRIPTOR	0x07
+#define UR_GET_REPORT		0x01
+#define UR_SET_REPORT		0x09
+#define UR_GET_IDLE		0x02
+#define UR_SET_IDLE		0x0a
+#define UR_GET_PROTOCOL		0x03
+#define UR_SET_PROTOCOL		0x0b
+
+typedef struct usb_hid_descriptor {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uWord		bcdHID;
+	uByte		bCountryCode;
+	uByte		bNumDescriptors;
+	struct {
+		uByte		bDescriptorType;
+		uWord		wDescriptorLength;
+	} descrs[1];
+} UPACKED usb_hid_descriptor_t;
+#define USB_HID_DESCRIPTOR_SIZE(n) (9+(n)*3)
+
+/* Usage pages */
+#define HUP_UNDEFINED		0x0000
+#define HUP_GENERIC_DESKTOP	0x0001
+#define HUP_SIMULATION		0x0002
+#define HUP_VR_CONTROLS		0x0003
+#define HUP_SPORTS_CONTROLS	0x0004
+#define HUP_GAMING_CONTROLS	0x0005
+#define HUP_KEYBOARD		0x0007
+#define HUP_LEDS		0x0008
+#define HUP_BUTTON		0x0009
+#define HUP_ORDINALS		0x000a
+#define HUP_TELEPHONY		0x000b
+#define HUP_CONSUMER		0x000c
+#define HUP_DIGITIZERS		0x000d
+#define HUP_PHYSICAL_IFACE	0x000e
+#define HUP_UNICODE		0x0010
+#define HUP_ALPHANUM_DISPLAY	0x0014
+#define HUP_MONITOR		0x0080
+#define HUP_MONITOR_ENUM_VAL	0x0081
+#define HUP_VESA_VC		0x0082
+#define HUP_VESA_CMD		0x0083
+#define HUP_POWER		0x0084
+#define HUP_BATTERY_SYSTEM	0x0085
+#define HUP_BARCODE_SCANNER	0x008b
+#define HUP_SCALE		0x008c
+#define HUP_CAMERA_CONTROL	0x0090
+#define HUP_ARCADE		0x0091
+#define HUP_MICROSOFT		0xff00
+
+/* Usages, generic desktop */
+#define HUG_POINTER		0x0001
+#define HUG_MOUSE		0x0002
+#define HUG_JOYSTICK		0x0004
+#define HUG_GAME_PAD		0x0005
+#define HUG_KEYBOARD		0x0006
+#define HUG_KEYPAD		0x0007
+#define HUG_X			0x0030
+#define HUG_Y			0x0031
+#define HUG_Z			0x0032
+#define HUG_RX			0x0033
+#define HUG_RY			0x0034
+#define HUG_RZ			0x0035
+#define HUG_SLIDER		0x0036
+#define HUG_DIAL		0x0037
+#define HUG_WHEEL		0x0038
+#define HUG_HAT_SWITCH		0x0039
+#define HUG_COUNTED_BUFFER	0x003a
+#define HUG_BYTE_COUNT		0x003b
+#define HUG_MOTION_WAKEUP	0x003c
+#define HUG_VX			0x0040
+#define HUG_VY			0x0041
+#define HUG_VZ			0x0042
+#define HUG_VBRX		0x0043
+#define HUG_VBRY		0x0044
+#define HUG_VBRZ		0x0045
+#define HUG_VNO			0x0046
+#define HUG_TWHEEL		0x0048 // M$ Wireless Intellimouse Wheel
+#define HUG_SYSTEM_CONTROL	0x0080
+#define HUG_SYSTEM_POWER_DOWN	0x0081
+#define HUG_SYSTEM_SLEEP	0x0082
+#define HUG_SYSTEM_WAKEUP	0x0083
+#define HUG_SYSTEM_CONTEXT_MENU	0x0084
+#define HUG_SYSTEM_MAIN_MENU	0x0085
+#define HUG_SYSTEM_APP_MENU	0x0086
+#define HUG_SYSTEM_MENU_HELP	0x0087
+#define HUG_SYSTEM_MENU_EXIT	0x0088
+#define HUG_SYSTEM_MENU_SELECT	0x0089
+#define HUG_SYSTEM_MENU_RIGHT	0x008a
+#define HUG_SYSTEM_MENU_LEFT	0x008b
+#define HUG_SYSTEM_MENU_UP	0x008c
+#define HUG_SYSTEM_MENU_DOWN	0x008d
+
+/* Usages Digitizers */
+#define HUD_UNDEFINED		0x0000
+#define HUD_TIP_PRESSURE	0x0030
+#define HUD_BARREL_PRESSURE	0x0031
+#define HUD_IN_RANGE		0x0032
+#define HUD_TOUCH		0x0033
+#define HUD_UNTOUCH		0x0034
+#define HUD_TAP			0x0035
+#define HUD_QUALITY		0x0036
+#define HUD_DATA_VALID		0x0037
+#define HUD_TRANSDUCER_INDEX	0x0038
+#define HUD_TABLET_FKEYS	0x0039
+#define HUD_PROGRAM_CHANGE_KEYS	0x003a
+#define HUD_BATTERY_STRENGTH	0x003b
+#define HUD_INVERT		0x003c
+#define HUD_X_TILT		0x003d
+#define HUD_Y_TILT		0x003e
+#define HUD_AZIMUTH		0x003f
+#define HUD_ALTITUDE		0x0040
+#define HUD_TWIST		0x0041
+#define HUD_TIP_SWITCH		0x0042
+#define HUD_SEC_TIP_SWITCH	0x0043
+#define HUD_BARREL_SWITCH	0x0044
+#define HUD_ERASER		0x0045
+#define HUD_TABLET_PICK		0x0046
+
+#define HID_USAGE2(p,u) (((p) << 16) | u)
+
+#define UHID_INPUT_REPORT 0x01
+#define UHID_OUTPUT_REPORT 0x02
+#define UHID_FEATURE_REPORT 0x03
+
+/* Bits in the input/output/feature items */
+#define HIO_CONST	0x001
+#define HIO_VARIABLE	0x002
+#define HIO_RELATIVE	0x004
+#define HIO_WRAP	0x008
+#define HIO_NONLINEAR	0x010
+#define HIO_NOPREF	0x020
+#define HIO_NULLSTATE	0x040
+#define HIO_VOLATILE	0x080
+#define HIO_BUFBYTES	0x100
+
+#endif /* _USBHID_H_ */
diff -rubN /usr/src1/src/sys/dev/usb2/usb_port.h /usr/src/sys/dev/usb2/usb_port.h
--- /usr/src1/src/sys/dev/usb2/usb_port.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/usb_port.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,454 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _USB_PORT_H
+#define _USB_PORT_H
+
+# ifdef _KERNEL
+
+#  ifdef __FreeBSD__
+
+#   include <sys/conf.h>
+#   include <machine/resource.h> /* SYS_XXX */
+#   include <sys/bus.h> /* device_xxx() */
+#   ifdef INCLUDE_PCIXXX_H
+/* NOTE: one does not want to include these
+ * files when building the USB device driver
+ * modules!
+ */
+#    include <dev/pci/pcireg.h>
+#    include <dev/pci/pcivar.h>
+#   endif
+#   include <sys/lockmgr.h>
+#   include <sys/module.h>
+#   include <sys/mutex.h>
+#   include <sys/rman.h> 
+#   include <sys/selinfo.h>
+#   include <sys/sysctl.h> /* SYSCTL_XXX() */
+#   include <sys/fcntl.h>
+#   include <sys/taskqueue.h>
+#   include <sys/callout.h> /* callout_xxx() */
+
+#   ifndef __KASSERT
+     typedef struct cdevsw cdevsw_t;
+#    define __lockmgr lockmgr
+#    define __KASSERT KASSERT
+#    define uio_procp uio_td
+#   endif
+#   ifndef __callout_init_mtx
+#    define __callout_init_mtx(c,m,f) callout_init_mtx(&(c)->co,m,f)
+#    define __callout_reset(c,t,f,d) callout_reset(&(c)->co,t,f,d)
+#    define __callout_stop(c) callout_stop(&(c)->co)
+#    define __callout_pending(c) callout_pending(&(c)->co)
+     struct __callout { struct callout co; };
+#   endif
+
+#  else
+#   include <sys/freebsd_compat.h>
+#  endif
+# endif
+
+/*
+ * Macros to cope with the differences between operating systems.
+ */
+
+#ifdef __NetBSD__
+/*
+ * NetBSD
+ */
+
+#include "opt_usbverbose.h"
+
+#define SCSI_MODE_SENSE		MODE_SENSE
+
+#define usb_kthread_create1	kthread_create1
+#define usb_kthread_create	kthread_create
+
+#if (__NetBSD_Version__ >= 300000000)
+typedef void * usb_malloc_type;
+#else
+typedef int usb_malloc_type;
+#endif
+
+#define Ether_ifattach ether_ifattach
+#define IF_INPUT(ifp, m) (*(ifp)->if_input)((ifp), (m))
+
+#elif defined(__OpenBSD__)
+/*
+ * OpenBSD
+ */
+
+#define UCOMBUSCF_PORTNO		-1
+#define UCOMBUSCF_PORTNO_DEFAULT	-1
+
+#define SCSI_MODE_SENSE		MODE_SENSE
+#define XS_STS_DONE		ITSDONE
+#define XS_CTL_POLL		SCSI_POLL
+#define XS_CTL_DATA_IN		SCSI_DATA_IN
+#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
+#define scsipi_adapter		scsi_adapter
+#define scsipi_cmd		scsi_cmd
+#define scsipi_device		scsi_device
+#define scsipi_done		scsi_done
+#define scsipi_link		scsi_link
+#define scsipi_minphys		scsi_minphys
+#define scsipi_sense		scsi_sense
+#define scsipi_xfer		scsi_xfer
+#define xs_control		flags
+#define xs_status		status
+
+#define	memcpy(d, s, l)		bcopy((s),(d),(l))
+#define	memset(d, v, l)		bzero((d),(l))
+#define bswap32(x)		swap32(x)
+#define bswap16(x)		swap16(x)
+
+/*
+ * The UHCI/OHCI controllers are little endian, so on big endian machines
+ * the data strored in memory needs to be swapped.
+ */
+
+#if defined(letoh32)
+#define le32toh(x) letoh32(x)
+#define le16toh(x) letoh16(x)
+#endif
+
+#if (BYTE_ORDER == BIG_ENDIAN)
+#define htole32(x) (bswap32(x))
+#define le32toh(x) (bswap32(x))
+#else
+#define htole32(x) (x)
+#define le32toh(x) (x)
+#endif
+
+#define usb_kthread_create1	kthread_create
+#define usb_kthread_create	kthread_create_deferred
+
+typedef int usb_malloc_type;
+
+#define Ether_ifattach(ifp, eaddr) ether_ifattach(ifp)
+#define if_deactivate(x)
+#define IF_INPUT(ifp, m) do {						\
+	struct ether_header *eh;					\
+									\
+	eh = mtod(m, struct ether_header *);				\
+	m_adj(m, sizeof(struct ether_header));				\
+	ether_input((ifp), (eh), (m));					\
+} while (0)
+
+#define powerhook_establish(fn, sc) (fn)
+#define powerhook_disestablish(hdl)
+#define PWR_RESUME 0
+
+#define swap_bytes_change_sign16_le swap_bytes_change_sign16
+#define change_sign16_swap_bytes_le change_sign16_swap_bytes
+#define change_sign16_le change_sign16
+
+extern int cold;
+
+#elif defined(__FreeBSD__)
+/*
+ * FreeBSD
+ */
+
+#include "opt_usb.h"
+
+#define usb_kthread_create1(f, s, p, a0, a1) \
+		kthread_create((f), (s), (p), RFHIGHPID, 0, (a0), (a1))
+#define usb_kthread_create2(f, s, p, a0) \
+		kthread_create((f), (s), (p), RFHIGHPID, 0, (a0))
+#define usb_kthread_create	kthread_create
+
+#define clalloc(p, s, x) (clist_alloc_cblocks((p), (s), (s)), 0)
+#define clfree(p) clist_free_cblocks((p))
+
+#define PWR_RESUME 0
+#define PWR_SUSPEND 1
+
+typedef struct malloc_type *usb_malloc_type;
+
+#endif /* __FreeBSD__ */
+
+#define USBVERBOSE
+
+#ifndef Static
+#define Static               static
+#endif
+
+#ifndef logprintf
+#define logprintf printf
+#endif
+
+#ifdef MALLOC_DECLARE
+MALLOC_DECLARE(M_USB);
+MALLOC_DECLARE(M_USBDEV);
+MALLOC_DECLARE(M_USBHC);
+#endif
+
+#ifdef SYSCTL_DECL
+SYSCTL_DECL(_hw_usb);
+#endif
+
+/* enable support for the old USB interface: */
+#define USB_COMPAT_OLD
+
+/* force debugging until further */
+#ifndef USB_DEBUG
+#define USB_DEBUG
+#endif
+
+#ifdef USB_DEBUG
+#define PRINTF(x)      { if (usbdebug) { printf("%s: ", __FUNCTION__); printf x ; } }
+#define PRINTFN(n,x)   { if (usbdebug > (n)) { printf("%s: ", __FUNCTION__); printf x ; } }
+extern int usbdebug;
+#else
+#define PRINTF(x)
+#define PRINTFN(n,x)
+#endif
+
+#define USBD_CHECK_STATUS(xfer)			\
+{ if((xfer)->flags & USBD_DEV_TRANSFERRING)	\
+  {						\
+     (xfer)->flags &= ~USBD_DEV_TRANSFERRING;	\
+     if( (xfer)->error )			\
+     { goto tr_error; }				\
+     else					\
+     { goto tr_transferred; }			\
+  }						\
+  else						\
+  { goto tr_setup; }				\
+}						\
+/**/
+
+#define _MAKE_ENUM(enum,value,arg...)		\
+        enum value,				\
+/**/
+
+#define MAKE_ENUM(macro,end...)			\
+enum { macro(_MAKE_ENUM) end }			\
+/**/
+
+#define __MAKE_TABLE(a...) a    /* double pass to expand all macros */
+#define _MAKE_TABLE(a...) (a),  /* add comma */
+#define MAKE_TABLE(m,field,p,a...) m##_##field p = { __MAKE_TABLE(m(m##_##field _MAKE_TABLE)) a }
+
+#ifndef LOG2
+#define LOG2(x) ( \
+((x) <= (1<<0x0)) ? 0x0 : \
+((x) <= (1<<0x1)) ? 0x1 : \
+((x) <= (1<<0x2)) ? 0x2 : \
+((x) <= (1<<0x3)) ? 0x3 : \
+((x) <= (1<<0x4)) ? 0x4 : \
+((x) <= (1<<0x5)) ? 0x5 : \
+((x) <= (1<<0x6)) ? 0x6 : \
+((x) <= (1<<0x7)) ? 0x7 : \
+((x) <= (1<<0x8)) ? 0x8 : \
+((x) <= (1<<0x9)) ? 0x9 : \
+((x) <= (1<<0xA)) ? 0xA : \
+((x) <= (1<<0xB)) ? 0xB : \
+((x) <= (1<<0xC)) ? 0xC : \
+((x) <= (1<<0xD)) ? 0xD : \
+((x) <= (1<<0xE)) ? 0xE : \
+((x) <= (1<<0xF)) ? 0xF : \
+0x10)
+#endif /* LOG2 */
+
+/* preliminary fix for a bug in msleep on FreeBSD, 
+ * which cannot sleep with Giant:
+ */
+#define msleep(i,m,p,w,t) msleep(i,(((m) == &Giant) ? NULL : (m)),p,w,t)
+
+#ifdef USB_COMPAT_OLD
+
+/*
+ * NOTE: All macros in this section 
+ * should be expanded in new drivers.
+ * One day USB_COMPAT_OLD will
+ * be undefined!
+ */
+
+typedef struct thread *usb_proc_ptr;
+
+#define device_ptr_t         device_t
+#define USBBASEDEVICE        device_t
+#define USBDEV(bdev)         (bdev)
+#define USBDEVNAME(bdev)     device_get_nameunit(bdev)
+#define USBDEVUNIT(bdev)     device_get_unit(bdev)
+#define USBDEVPTRNAME(bdev)  device_get_nameunit(bdev)
+#define USBDEVUNIT(bdev)     device_get_unit(bdev)
+#define USBGETSOFTC(bdev)    device_get_softc(bdev)
+#define	USB_DNAME(dname)     dname
+
+typedef struct __callout              usb_callout_t;
+#define usb_callout_init(h)           __callout_init_mtx(&(h), &Giant, 0)
+#define usb_callout(h, t, f, d)       __callout_reset(&(h), (t), (f), (d))
+#define usb_uncallout(h, f, d)        __callout_stop(&(h))
+#define usb_uncallout_drain(h, f, d)  __callout_stop(&(h))
+
+#define USB_DECLARE_DRIVER_INIT(dname, init...)		\
+  Static device_probe_t __CONCAT(dname,_match);		\
+  Static device_attach_t __CONCAT(dname,_attach);	\
+  Static device_detach_t __CONCAT(dname,_detach);	\
+							\
+  Static devclass_t __CONCAT(dname,_devclass);		\
+							\
+  Static device_method_t __CONCAT(dname,_methods)[] = {	\
+    DEVMETHOD(device_probe, __CONCAT(dname,_match)),	\
+    DEVMETHOD(device_attach, __CONCAT(dname,_attach)),	\
+    DEVMETHOD(device_detach, __CONCAT(dname,_detach)),	\
+    init,						\
+    {0,0}						\
+  };							\
+							\
+  Static driver_t __CONCAT(dname,_driver) = {		\
+      #dname,						\
+      __CONCAT(dname,_methods),				\
+      sizeof(struct __CONCAT(dname,_softc))		\
+  };							\
+  MODULE_DEPEND(dname, usb, 1, 1, 1)
+
+#define METHODS_NONE				\
+	{0,0}
+
+#define USB_DECLARE_DRIVER(dname)			\
+	USB_DECLARE_DRIVER_INIT(dname, METHODS_NONE)
+
+#define USB_MATCH(dname)			\
+	Static int				\
+	__CONCAT(dname,_match)(device_t self)
+
+#define USB_MATCH_START(dname, uaa) \
+        struct usb_attach_arg *uaa = device_get_ivars(self)
+
+#define USB_MATCH_SETUP \
+	sc->sc_dev = self
+
+#define USB_ATTACH(dname)			\
+	Static int				\
+	__CONCAT(dname,_attach)(device_t self)
+
+#define USB_ATTACH_START(dname, sc, uaa)				\
+        struct __CONCAT(dname,_softc) *sc = device_get_softc(self);	\
+        struct usb_attach_arg *uaa = device_get_ivars(self)
+
+#define USB_ATTACH_SETUP			\
+	sc->sc_dev = self;			\
+	device_set_desc_copy(self, devinfo)
+
+#define USB_ATTACH_ERROR_RETURN			\
+	return ENXIO
+
+#define USB_ATTACH_SUCCESS_RETURN		\
+	return 0
+
+#define USB_DETACH(dname)			\
+	Static int				\
+	__CONCAT(dname,_detach)(device_t self)
+
+#define USB_DETACH_START(dname, sc)					\
+	struct __CONCAT(dname,_softc) *sc = device_get_softc(self)
+
+#define USB_GET_SC_OPEN(dname, unit, sc)				\
+	(sc) = devclass_get_softc(__CONCAT(dname,_devclass), unit);	\
+	if ((sc) == NULL)						\
+	     return (ENXIO)
+
+#define USB_GET_SC(dname, unit, sc)					\
+	(sc) = devclass_get_softc(__CONCAT(dname,_devclass), unit)
+
+#define USBD_IN_PROGRESS USBD_NORMAL_COMPLETION
+#define USBD_NO_COPY 0
+#define USBD_EXCLUSIVE_USE 0
+#define USBD_SHOW_INTERFACE_CLASS 0
+#define splusb splbio
+#define usb_find_desc(udev, type, subtype) usbd_find_descriptor(usbd_get_config_descriptor(udev), type, subtype)
+#define usbd_get_desc usbreq_get_desc
+#define usbd_get_string(udev, si, ptr) usbreq_get_string_any(udev, si, ptr, USB_MAX_STRING_LEN)
+#define usbd_get_string_desc usbreq_get_string_desc
+#define usbd_get_config_desc usbreq_get_config_desc
+#define usbd_get_config_desc_full usbreq_get_config_desc_full
+#define usbd_get_device_desc usbreq_get_device_desc
+#define usbd_get_interface(iface,args...) usbreq_get_interface((iface)->udev, (iface) - &(iface)->udev->ifaces[0], args)
+#define usbd_set_interface(iface,args...) usbreq_set_interface((iface)->udev, (iface) - &(iface)->udev->ifaces[0], args)
+#define usbd_get_device_status usbreq_get_device_status
+#define usbd_get_hub_descriptor usbreq_get_hub_descriptor
+#define usbd_get_hub_status usbreq_get_hub_status
+#define usbd_set_address usbreq_set_address
+#define usbd_get_port_status usbreq_get_port_status
+#define usbd_clear_hub_feature usbreq_clear_hub_feature
+#define usbd_set_hub_feature usbreq_set_hub_feature
+#define usbd_clear_port_feature usbreq_clear_port_feature
+#define usbd_set_port_feature usbreq_set_port_feature
+#define usbd_set_protocol(iface,args...) usbreq_set_protocol((iface)->udev, (iface) - &(iface)->udev->ifaces[0], args)
+#define usbd_set_report(iface,args...) usbreq_set_report((iface)->udev, (iface) - &(iface)->udev->ifaces[0], args)
+#define usbd_set_report_async(iface,args...) usbreq_set_report_async((iface)->udev, (iface) - &(iface)->udev->ifaces[0], args)
+#define usbd_get_report(iface,args...) usbreq_get_report((iface)->udev, (iface) - &(iface)->udev->ifaces[0], args)
+#define usbd_set_idle(iface,args...) usbreq_set_idle((iface)->udev, (iface) - &(iface)->udev->ifaces[0], args)
+#define usbd_get_report_descriptor usbreq_get_report_descriptor
+#define usbd_read_report_desc(iface,args...) usbreq_read_report_desc((iface)->udev, (iface) - &(iface)->udev->ifaces[0], args)
+#define usbd_set_config usbreq_set_config
+#define usbd_get_config usbreq_get_config
+#define usbd_dopoll(iface) usbd_do_poll((iface)->udev)
+#define ifaceno iface_index /* umass.c */
+#define usbd_do_request_async(udev, req, data) \
+usbd_do_request_flags(udev, req, data, USBD_USE_POLLING, 0, 500 /* ms */)
+
+/*
+ * depreciated Giant locked task-queue
+ * (only used by if_udav.c)
+ */
+struct usb_task  {
+
+#ifdef __FreeBSD__
+	struct task task;
+#endif
+	void (*func)(void *);
+	void *arg;
+};
+
+void
+usb_call_task(void *arg, int count);
+
+#define usb_init_task(_task, _func, _arg) \
+{ (_task)->func = (_func); (_task)->arg = (_arg); \
+  TASK_INIT(&(_task)->task, 0, &usb_call_task, (_task)); }
+#define usb_add_task(udev, _task) \
+taskqueue_enqueue(taskqueue_swi_giant, &(_task)->task)
+#define usb_rem_task(udev, _task) \
+taskqueue_drain(taskqueue_swi_giant, &(_task)->task)
+
+#endif /* USB_COMPAT_OLD */
+#endif /* _USB_PORT_H */
diff -rubN /usr/src1/src/sys/dev/usb2/usb_quirks.h /usr/src/sys/dev/usb2/usb_quirks.h
--- /usr/src1/src/sys/dev/usb2/usb_quirks.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/usb_quirks.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1 @@
+#include <dev/usb/usb_quirks.h>
diff -rubN /usr/src1/src/sys/dev/usb2/usb_subr.h /usr/src/sys/dev/usb2/usb_subr.h
--- /usr/src1/src/sys/dev/usb2/usb_subr.h	Thu Jan  1 00:00:00 1970
+++ /usr/src/sys/dev/usb2/usb_subr.h	Thu Jun  8 21:13:08 2006
@@ -0,0 +1,869 @@
+/*-
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _USB_SUBR_H_
+#define _USB_SUBR_H_
+
+#define USBD_STATUS_DESC(enum,value) #enum
+#define USBD_STATUS(m)\
+m(USBD_NORMAL_COMPLETION,=0 /* must be zero*/)\
+/* errors */\
+m(USBD_PENDING_REQUESTS,)\
+m(USBD_NOT_STARTED,)\
+m(USBD_INVAL,)\
+m(USBD_NOMEM,)\
+m(USBD_CANCELLED,)\
+m(USBD_BAD_ADDRESS,)\
+m(USBD_BAD_BUFSIZE,)\
+m(USBD_BAD_FLAG,)\
+m(USBD_NO_CALLBACK,)\
+m(USBD_SYNC_TRANSFER_MUST_USE_DEFAULT_CALLBACK,)\
+m(USBD_IN_USE,)\
+m(USBD_NO_ADDR,)\
+m(USBD_NO_PIPE,)\
+m(USBD_ZERO_FRAMES_IN_ISOC_MODE,)\
+m(USBD_SET_ADDR_FAILED,)\
+m(USBD_NO_POWER,)\
+m(USBD_TOO_DEEP,)\
+m(USBD_IOERROR,)\
+m(USBD_NOT_CONFIGURED,)\
+m(USBD_TIMEOUT,)\
+m(USBD_SHORT_XFER,)\
+m(USBD_STALLED,)\
+m(USBD_INTERRUPTED,)\
+/**/
+
+MAKE_ENUM(USBD_STATUS,
+	N_USBD_STATUS);
+
+struct usbd_xfer;
+struct usbd_pipe;
+struct usbd_bus;
+struct usbd_config;
+struct usbd_device;
+struct usbd_interface;
+struct usbd_memory_info;
+struct __callout;
+struct module;
+struct bus_dma_tag;
+
+typedef u_int8_t usbd_status;
+
+typedef void (*usbd_callback_t)(struct usbd_xfer *);
+#ifdef USB_COMPAT_OLD
+typedef void (*usbd_callback)(struct usbd_xfer *, void *, usbd_status);
+typedef struct usbd_xfer *usbd_xfer_handle;
+typedef struct usbd_device *usbd_device_handle;
+typedef struct usbd_pipe *usbd_pipe_handle;
+typedef struct usbd_interface *usbd_interface_handle;
+typedef void *usbd_private_handle;
+#endif
+
+struct usbd_bus_methods {
+	void (*pipe_init)(struct usbd_device *udev, 
+			  usb_endpoint_descriptor_t *edesc, 
+			  struct usbd_pipe *pipe);
+	void (*do_poll)(struct usbd_bus *);
+
+	usbd_status (*xfer_setup)(struct usbd_device *udev,
+				  u_int8_t iface_index, 
+				  struct usbd_xfer **pxfer, 
+				  const struct usbd_config *setup_start, 
+				  const struct usbd_config *setup_end);
+};
+
+struct usbd_pipe_methods {
+	void (*open)(struct usbd_xfer *xfer);
+	void (*close)(struct usbd_xfer *xfer);
+	void (*enter)(struct usbd_xfer *xfer);
+	void (*start)(struct usbd_xfer *xfer);
+};
+
+struct usbd_port {
+	usb_port_status_t	status;
+	u_int16_t		power;	/* mA of current on port */
+	u_int8_t		portno;
+	u_int8_t		restartcnt;
+	u_int8_t		last_refcount;
+#define USBD_RESTART_MAX 5
+	struct usbd_device     *device;	/* connected device */
+	struct usbd_device     *parent;	/* the ports hub */
+};
+
+struct usbd_hub {
+	usbd_status	      (*explore)(struct usbd_device *hub);
+	void		       *hubsoftc;
+	usb_hub_descriptor_t	hubdesc;
+	struct usbd_port        ports[0];
+};
+
+/*****/
+
+struct usbd_bus {
+	/* filled by HC driver */
+	device_t                bdev; /* base device, host adapter */
+	struct usbd_bus_methods	*methods;
+
+	/* filled by USB driver */
+	struct usbd_port	root_port; /* dummy port for root hub */
+	struct usbd_device *	devices[USB_MAX_DEVICES];
+	u_int8_t		is_exploring;
+	u_int8_t		wait_explore;
+	u_int8_t		needs_explore;/* a hub signalled a change
+					       * this variable is protected by
+					       * "usb_global_lock"
+					       */
+	u_int8_t		use_polling;
+	u_int8_t		usbrev;	/* USB revision */
+#define USBREV_UNKNOWN	0
+#define USBREV_PRE_1_0	1
+#define USBREV_1_0	2
+#define USBREV_1_1	3
+#define USBREV_2_0	4
+#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1", "2.0" }
+
+ 	struct usb_device_stats	stats;
+	struct mtx		mtx;
+ 	struct proc *		event_thread;
+ 	u_int			no_intrs;
+};
+
+struct usbd_interface {
+#ifdef USB_COMPAT_OLD
+	struct usbd_device	   *udev;
+#endif
+	usb_interface_descriptor_t *idesc;
+	u_int8_t		    alt_index;
+};
+
+#define usbd_clear_endpoint_toggle(pipe) { \
+(pipe)->clearstall = 0; (pipe)->toggle_next = 0; }
+
+struct usbd_pipe {
+#ifdef USB_COMPAT_OLD
+	struct usbd_device *	  udev;
+	struct usbd_xfer *	  alloc_xfer;
+#endif
+	usb_endpoint_descriptor_t *edesc;
+	LIST_HEAD(, usbd_xfer)	  list_head;
+	u_int16_t		  isoc_next;
+	u_int8_t		  toggle_next;
+	u_int8_t		  refcount;
+	u_int8_t		  clearstall;
+	u_int8_t		  iface_index;
+	/* default pipe does not use ``iface_index'' */
+
+	/* filled by HC driver */
+	struct usbd_pipe_methods  *methods;
+};
+
+struct usbd_device {
+	struct usbd_bus	       *bus;           /* our controller */
+	struct usbd_pipe        default_pipe;  /* pipe 0 */
+	usb_endpoint_descriptor_t default_ep_desc; /* for pipe 0 */
+	u_int8_t		address;       /* device addess */
+	u_int8_t		config;	       /* current configuration # */
+	u_int8_t		depth;         /* distance from root hub */
+	u_int8_t		speed;         /* low/full/high speed */
+	u_int8_t		self_powered;  /* flag for self powered */
+	u_int16_t		power;         /* mA the device uses */
+	int16_t			langid;	       /* language for strings */
+#define USBD_NOLANG (-1)
+	usb_event_cookie_t	cookie;	       /* unique connection id */
+	struct usbd_port *	powersrc;      /* upstream hub port, or 0 */
+	struct usbd_port *	myhsport;       /* closest high speed port */
+	struct usbd_device *	myhub;	       /* upstream hub */
+
+	usb_device_descriptor_t ddesc;         /* device descriptor */
+
+	usb_config_descriptor_t *cdesc;	       /* full config descr */
+	const struct usbd_quirks *quirks;  /* device quirks, always set */
+	struct usbd_hub	*	hub;           /* only if this is a hub */
+
+	device_t                subdevs[USB_MAX_ENDPOINTS]; /* array of all sub-devices */
+	device_t                subdevs_end[0];
+	struct usbd_interface   ifaces[USB_MAX_ENDPOINTS]; /* array of all interfaces */
+	struct usbd_interface   ifaces_end[0];
+	struct usbd_pipe        pipes[USB_MAX_ENDPOINTS]; /* array of all pipes */
+	struct usbd_pipe        pipes_end[0];
+
+	u_int8_t                ifaces_no_probe[(USB_MAX_ENDPOINTS + 7) / 8];
+#define USBD_SET_IFACE_NO_PROBE(udev, ii) \
+  { (udev)->ifaces_no_probe[(ii) >> 3] |= (1 << ((ii) & 7)); }
+#define USBD_CLR_IFACE_NO_PROBE(udev, ii) \
+  { (udev)->ifaces_no_probe[(ii) >> 3] &= ~(1 << ((ii) & 7)); }
+#define USBD_GET_IFACE_NO_PROBE(udev, ii) \
+  ((udev)->ifaces_no_probe[(ii) >> 3] & (1 << ((ii) & 7)))
+
+	u_int8_t                probed; /* probe state */
+#define USBD_PROBED_NOTHING              0 /* default value */
+#define USBD_PROBED_SPECIFIC_AND_FOUND   1
+#define USBD_PROBED_IFACE_AND_FOUND      2
+#define USBD_PROBED_GENERIC_AND_FOUND    3
+
+	u_int8_t		serial[32];
+ };
+
+struct usbd_config {
+	u_int8_t	type;		/* pipe type */
+	u_int8_t	endpoint;	/* pipe number */
+
+	u_int8_t	direction;	/* pipe direction */
+	u_int8_t	interval;	/* interrupt interval in milliseconds;
+					 * used by interrupt pipes
+					 */
+#define USBD_DEFAULT_INTERVAL	0
+
+	u_int16_t	timeout;	/* milliseconds */
+
+	u_int8_t	frames;		/* number of frames
+					 * used in isochronous
+					 * mode
+					 */
+
+	u_int8_t	index;	/* pipe index to use, if more
+				 * than one descriptor matches
+				 * type, address, direction ...
+				 */
+
+	u_int32_t	flags;	/* flags */
+#define USBD_SYNCHRONOUS         0x0001 /* wait for completion */
+#define USBD_FORCE_SHORT_XFER    0x0002 /* force a short packet last */
+#if (USBD_SHORT_XFER_OK != 0x0004)
+#define USBD_SHORT_XFER_OK       0x0004 /* allow short reads 
+					 * NOTE: existing software
+					 * expects USBD_SHORT_XFER_OK
+					 * to have a value of 0x4. This
+					 * flag is also exported by usb.h
+					 */
+#endif
+#ifdef USB_COMPAT_OLD
+#define USBD_CUSTOM_CLEARSTALL   0x0008 /* used to disable automatic clear-stall
+					 * when a device reset request is needed
+					 * in addition to the clear stall request
+					 */
+#endif
+#define USBD_DEV_OPEN            0x0010
+#define USBD_DEV_RECURSED_1      0x0020
+#define USBD_DEV_RECURSED_2      0x0040
+#define USBD_DEV_TRANSFERRING    0x0080
+#define USBD_BANDWIDTH_RECLAIMED 0x0100
+#define USBD_USE_POLLING         0x0200 /* used to make synchronous transfers
+					 * use polling instead of sleep/wakeup
+					 */
+#define USBD_SELF_DESTRUCT       0x0400 /* set if callback is allowed to unsetup itself */
+#define USBD_UNUSED_3            0x0800
+#define USBD_UNUSED_4            0x1000
+#define USBD_UNUSED_5            0x2000
+#define USBD_UNUSED_6            0x4000
+#define USBD_UNUSED_7            0x8000
+
+	u_int32_t	bufsize;       	/* total pipe buffer size in bytes */
+	usbd_callback_t	callback;
+};
+
+#define USBD_TRANSFER_IN_PROGRESS(xfer)		\
+	((xfer)->flags & USBD_DEV_TRANSFERRING)
+
+struct usbd_xfer {
+	struct usbd_pipe *	pipe;
+	struct usbd_device *	udev;
+	void *			buffer;
+ 	void *			priv_sc;
+	void *			priv_fifo;
+	struct mtx *		priv_mtx;
+	struct usbd_xfer *	clearstall_xfer;
+	u_int32_t		length; /* bytes */
+	u_int32_t		actlen; /* bytes */
+
+	u_int32_t		flags;
+
+	u_int32_t		timeout; /* milliseconds */
+#define USBD_NO_TIMEOUT 0
+#define USBD_DEFAULT_TIMEOUT 5000 /* 5000 ms = 5 seconds */
+
+	usbd_status		error;
+	usbd_callback_t		callback;
+
+	/* for isochronous transfers */
+	u_int16_t *		frlengths;
+	u_int32_t		nframes;
+
+	/*
+	 * used by HC driver
+	 */
+
+	void *			usb_sc;
+	struct mtx *		usb_mtx;
+	struct usbd_memory_info *usb_root;
+	struct thread *		usb_thread;
+	u_int32_t		usb_refcount;
+
+	/* pipe_list is used to start next transfer */
+
+	LIST_ENTRY(usbd_xfer)	pipe_list; 
+
+	/* interrupt_list is used to check
+	 * for finished transfers
+	 */
+
+	LIST_ENTRY(usbd_xfer)	interrupt_list;
+
+	struct __callout	timeout_handle;
+
+	u_int8_t		address;
+	u_int8_t		endpoint;
+	u_int8_t		interval; /* milliseconds */
+
+	u_int16_t		max_packet_size;
+
+	u_int32_t		physbuffer;
+
+	void *			td_start;
+	void *			td_end;
+
+	void *			td_transfer_first;
+	void *			td_transfer_last;
+
+	void *			qh_start;
+	void *			qh_end;
+
+	u_int16_t		qh_pos;
+#ifdef USB_COMPAT_OLD
+	struct usbd_xfer *	alloc_xfer; /* the real transfer */
+	void *			alloc_ptr;
+	u_int32_t		alloc_len;
+	void *			d_copy_ptr;
+	void *			d_copy_src;
+	void *			d_copy_dst;
+	u_int32_t		d_copy_len;
+	usbd_callback		d_callback;
+
+	void *			f_copy_ptr;
+	void *			f_copy_src;
+	void *			f_copy_dst;
+	u_int32_t		f_copy_len;
+#endif
+};
+
+typedef void (usbd_unsetup_callback_t)(struct usbd_memory_info *info);
+
+struct usbd_memory_info {
+    void *         memory_base;
+    u_int32_t      memory_size;
+    u_int32_t      memory_refcount;
+    void *         priv_sc;
+    struct mtx *   priv_mtx;
+    struct mtx *   usb_mtx;
+    usbd_unsetup_callback_t *priv_func;
+};
+
+struct usbd_callback_info {
+    struct usbd_xfer *xfer;
+    u_int32_t refcount;
+};
+
+/*---------------------------------------------------------------------------*
+ * structures used by probe and attach
+ *---------------------------------------------------------------------------*/
+struct usb_devno {
+    u_int16_t ud_vendor;
+    u_int16_t ud_product;
+} __packed;
+
+#define usb_lookup(tbl, vendor, product) usb_match_device			\
+	((const struct usb_devno *)(tbl), (sizeof (tbl) / sizeof ((tbl)[0])),	\
+	 sizeof ((tbl)[0]), (vendor), (product))				\
+/**/
+
+#define	USB_PRODUCT_ANY		0xffff
+
+struct usb_attach_arg
+{
+	int			port;
+	int			configno;
+	int			iface_index;
+	int			vendor;
+	int			product;
+	int			release;
+	int			matchlvl;
+	struct usbd_device     *device;	/* current device */
+	struct usbd_interface  *iface; /* current interface */
+	int			usegeneric;
+	struct usbd_interface  *ifaces_start; /* all interfaces */
+	struct usbd_interface  *ifaces_end; /* exclusive */
+#ifdef USB_COMPAT_OLD
+	int			nifaces;
+	struct usbd_interface * ifaces[USB_MAX_ENDPOINTS];
+#endif
+};
+
+/* return values for device_probe() method: */
+
+#define UMATCH_VENDOR_PRODUCT_REV			(-10)
+#define UMATCH_VENDOR_PRODUCT				(-20)
+#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			(-30)
+#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		(-40)
+#define UMATCH_DEVCLASS_DEVSUBCLASS			(-50)
+#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		(-60)
+#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		(-70)
+#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		(-80)
+#define UMATCH_VENDOR_IFACESUBCLASS			(-90)
+#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	(-100)
+#define UMATCH_IFACECLASS_IFACESUBCLASS			(-110)
+#define UMATCH_IFACECLASS				(-120)
+#define UMATCH_IFACECLASS_GENERIC			(-130)
+#define UMATCH_GENERIC					(-140)
+#define UMATCH_NONE					(ENXIO)
+
+/*---------------------------------------------------------------------------*
+ * prototypes
+ *---------------------------------------------------------------------------*/
+
+/* routines from usb_subr.c */
+
+void
+usbd_devinfo(struct usbd_device *udev, int showclass, char *cp);
+
+const char *
+usbd_errstr(usbd_status err);
+
+void
+usb_delay_ms(struct usbd_bus *bus, u_int ms);
+
+void
+usbd_delay_ms(struct usbd_device *udev, u_int ms);
+
+struct usb_hid_descriptor;
+struct usb_hid_descriptor *
+usbd_get_hdesc(usb_config_descriptor_t *cd, usb_interface_descriptor_t *id);
+
+usb_interface_descriptor_t *
+usbd_find_idesc(usb_config_descriptor_t *cd, int iface_index, int alt_index);
+
+usb_endpoint_descriptor_t *
+usbd_find_edesc(usb_config_descriptor_t *cd, int iface_index, int alt_index,
+		int endptidx);
+
+usb_descriptor_t *
+usbd_find_descriptor(usb_config_descriptor_t *cd, int type, int subtype);
+
+#define USBD_SUBTYPE_ANY (-1)
+
+int
+usbd_get_no_alts(usb_config_descriptor_t *cd, int ifaceno);
+
+usbd_status
+usbd_search_and_set_config(struct usbd_device *udev, int no, int msg);
+
+usbd_status
+usbd_set_config_index(struct usbd_device *udev, int index, int msg);
+
+int
+usbd_fill_deviceinfo(struct usbd_device *udev, struct usb_device_info *di,
+		     int usedev);
+
+usbd_status
+usbd_fill_iface_data(struct usbd_device *udev, int iface_index, int alt_index);
+
+usbd_status
+usbd_probe_and_attach(device_t parent, 
+		      int port, struct usbd_port *up);
+
+usbd_status
+usbd_new_device(device_t parent, struct usbd_bus *bus, int depth,
+		int speed, int port, struct usbd_port *up);
+
+void
+usbd_free_device(struct usbd_port *up, u_int8_t free_subdev);
+
+void
+usb_detach_wait(device_t dv);
+
+void
+usb_detach_wakeup(device_t dv);
+
+struct usbd_interface *
+usbd_get_iface(struct usbd_device *udev, u_int8_t iface_index);
+
+void
+usbd_set_desc(device_t dev, struct usbd_device *udev);
+
+/* routines from usb.c */
+
+#if 0
+extern struct mtx usb_global_lock;
+#else
+/* XXX currently only the Giant lock can sleep */
+#define usb_global_lock Giant
+#endif
+
+void
+usbd_add_dev_event(int type, struct usbd_device *udev);
+
+void
+usbd_add_drv_event(int type, struct usbd_device *udev, device_t dev);
+
+void
+usb_needs_explore(struct usbd_device *udev);
+
+extern u_int8_t usb_driver_added_refcount;
+
+void
+usb_needs_probe_and_attach(void);
+
+#ifdef __FreeBSD__
+#define device_get_dma_tag(dev) NULL
+
+void *
+usb_alloc_mem(struct bus_dma_tag *tag, u_int32_t size, u_int8_t align_power);
+
+bus_size_t
+usb_vtophys(void *ptr, u_int32_t size);
+
+void
+usb_free_mem(void *ptr, u_int32_t size);
+#endif
+
+/* routines from usb_transfer.c */
+
+#ifdef USB_DEBUG
+
+void
+usbd_dump_iface(struct usbd_interface *iface);
+
+void
+usbd_dump_device(struct usbd_device *udev);
+
+void
+usbd_dump_queue(struct usbd_pipe *pipe);
+
+void
+usbd_dump_pipe(struct usbd_pipe *pipe);
+
+void
+usbd_dump_xfer(struct usbd_xfer *xfer);
+
+#endif
+
+u_int32_t
+usb_get_devid(device_t dev);
+
+struct usbd_pipe *
+usbd_get_pipe(struct usbd_device *udev, u_int8_t iface_index,
+	      const struct usbd_config *setup);
+
+usbd_status
+usbd_interface_count(struct usbd_device *udev, u_int8_t *count);
+
+usbd_status
+usbd_transfer_setup(struct usbd_device *udev,
+		    u_int8_t iface_index,
+		    struct usbd_xfer **pxfer,
+		    const struct usbd_config *setup_start,
+		    u_int16_t n_setup,
+		    void *priv_sc,
+		    struct mtx *priv_mtx,
+		    usbd_unsetup_callback_t *priv_func);
+
+void
+usbd_transfer_unsetup(struct usbd_xfer **pxfer, u_int16_t n_setup);
+
+void
+usbd_start_hardware(struct usbd_xfer *xfer);
+
+void
+usbd_transfer_start_safe(struct usbd_xfer *xfer);
+
+void
+usbd_transfer_start(struct usbd_xfer *xfer);
+
+void
+usbd_transfer_stop(struct usbd_xfer *xfer);
+
+void
+__usbd_callback(struct usbd_xfer *xfer);
+
+void
+usbd_do_callback(struct usbd_callback_info *ptr, 
+		 struct usbd_callback_info *limit);
+void
+usbd_transfer_done(struct usbd_xfer *xfer, usbd_status error);
+
+void
+usbd_transfer_enqueue(struct usbd_xfer *xfer);
+
+void
+usbd_transfer_dequeue(struct usbd_xfer *xfer);
+
+void
+usbd_default_callback(struct usbd_xfer *xfer);
+
+usbd_status
+usbd_do_request(struct usbd_device *udev, usb_device_request_t *req, void *data);
+
+usbd_status
+usbd_do_request_flags(struct usbd_device *udev, usb_device_request_t *req,
+		      void *data, u_int32_t flags, int *actlen,
+		      u_int32_t timeout);
+
+void
+usbd_clearstall_callback(struct usbd_xfer *xfer);
+
+void
+usbd_do_poll(struct usbd_device *udev);
+
+void
+usbd_set_polling(struct usbd_device *udev, int on);
+
+int
+usbd_ratecheck(struct timeval *last);
+
+const struct usb_devno *
+usb_match_device(const struct usb_devno *tbl, u_int nentries, u_int size,
+		 u_int16_t vendor, u_int16_t product);
+
+int
+usbd_driver_load(struct module *mod, int what, void *arg);
+
+#ifdef USB_COMPAT_OLD
+usbd_status
+usbd_transfer(struct usbd_xfer *xfer);
+
+usbd_status
+usbd_sync_transfer(struct usbd_xfer *xfer);
+
+void *
+usbd_alloc_buffer(struct usbd_xfer *xfer, u_int32_t size);
+
+void
+usbd_free_buffer(struct usbd_xfer *xfer);
+
+void
+usbd_get_xfer_status(struct usbd_xfer *xfer, void **priv,
+		     void **buffer, u_int32_t *count, usbd_status *status);
+
+struct usbd_xfer *
+usbd_alloc_xfer(struct usbd_device *dev);
+
+usbd_status 
+usbd_free_xfer(struct usbd_xfer *xfer);
+
+usbd_status 
+usbd_open_pipe(struct usbd_interface *iface, u_int8_t address,
+               u_int8_t flags, struct usbd_pipe **pipe);
+
+usbd_status 
+usbd_open_pipe_intr(struct usbd_interface *iface, u_int8_t address,
+                    u_int8_t flags, struct usbd_pipe **pipe,
+                    void *priv, void *buffer, u_int32_t len,
+                    usbd_callback callback, int ival);
+
+usbd_status
+usbd_setup_xfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
+                void *priv, void *buffer, u_int32_t length,
+                u_int32_t flags, u_int32_t timeout,
+                usbd_callback callback);
+
+usbd_status
+usbd_setup_default_xfer(struct usbd_xfer *xfer, struct usbd_device *dev,
+                        void *priv, u_int32_t timeout,
+                        usb_device_request_t *req, void *buffer,
+                        u_int32_t length, u_int16_t flags,
+                        usbd_callback callback);
+
+usbd_status
+usbd_setup_isoc_xfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
+                     void *priv, u_int16_t *frlengths, u_int32_t nframes, 
+		     u_int16_t flags, usbd_callback callback);
+
+usbd_status
+usbd_bulk_transfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
+                   u_int16_t flags, u_int32_t timeout, void *buf,
+                   u_int32_t *size, char *lbl);
+
+#define usbd_intr_transfer usbd_bulk_transfer
+
+usbd_status 
+usbd_abort_pipe(struct usbd_pipe *pipe);
+
+usbd_status 
+usbd_abort_default_pipe(struct usbd_device *udev);
+
+usbd_status
+usbd_close_pipe(struct usbd_pipe *pipe);
+
+usbd_status 
+usbd_clear_endpoint_stall(struct usbd_pipe *pipe);
+
+usbd_status 
+usbd_clear_endpoint_stall_async(struct usbd_pipe *pipe);
+
+usbd_status 
+usbd_endpoint_count(struct usbd_interface *iface, u_int8_t *count);
+
+void
+usbd_interface2device_handle(struct usbd_interface *iface,
+                             struct usbd_device **udev);
+
+struct usbd_device *
+usbd_pipe2device_handle(struct usbd_pipe *pipe);
+
+usbd_status 
+usbd_device2interface_handle(struct usbd_device *udev,
+                             u_int8_t iface_index, struct usbd_interface **iface);
+
+usb_endpoint_descriptor_t *
+usbd_interface2endpoint_descriptor(struct usbd_interface *iface, u_int8_t index);
+
+usb_endpoint_descriptor_t *
+usbd_get_endpoint_descriptor(struct usbd_interface *iface, u_int8_t address);
+
+#endif /* USB_COMPAT_OLD */
+
+/* routines from usb_requests.c */
+
+usbd_status
+usbreq_reset_port(struct usbd_device *udev, int port, usb_port_status_t *ps);
+
+usbd_status
+usbreq_get_desc(struct usbd_device *udev, int type, int index,
+		int len, void *desc, int timeout);
+
+usbd_status
+usbreq_get_string_any(struct usbd_device *udev, int si, char *buf, int len);
+
+usbd_status
+usbreq_get_string_desc(struct usbd_device *udev, int sindex, int langid,
+		       usb_string_descriptor_t *sdesc, int *plen);
+
+usbd_status
+usbreq_get_config_desc(struct usbd_device *udev, int confidx,
+		       usb_config_descriptor_t *d);
+
+usbd_status
+usbreq_get_config_desc_full(struct usbd_device *udev, int conf, void *d, int size);
+
+usbd_status
+usbreq_get_device_desc(struct usbd_device *udev, usb_device_descriptor_t *d);
+
+usbd_status
+usbreq_get_interface(struct usbd_device *udev, u_int8_t iface_index,
+		     u_int8_t *aiface);
+
+usbd_status
+usbreq_set_interface(struct usbd_device *udev, u_int8_t iface_index,
+		     u_int8_t altno);
+
+usbd_status
+usbreq_get_device_status(struct usbd_device *udev, usb_status_t *st);
+
+usbd_status
+usbreq_get_hub_descriptor(struct usbd_device *udev, usb_hub_descriptor_t *hd);
+
+usbd_status
+usbreq_get_hub_status(struct usbd_device *udev, usb_hub_status_t *st);
+
+usbd_status
+usbreq_set_address(struct usbd_device *udev, int addr);
+
+usbd_status
+usbreq_get_port_status(struct usbd_device *udev, int port, usb_port_status_t *ps);
+
+usbd_status
+usbreq_clear_hub_feature(struct usbd_device *udev, int sel);
+
+usbd_status
+usbreq_set_hub_feature(struct usbd_device *udev, int sel);
+
+usbd_status
+usbreq_clear_port_feature(struct usbd_device *udev, int port, int sel);
+
+usbd_status
+usbreq_set_port_feature(struct usbd_device *udev, int port, int sel);
+
+usbd_status
+usbreq_set_protocol(struct usbd_device *udev, u_int8_t iface_index,
+		    u_int16_t report);
+
+#ifdef USB_COMPAT_OLD
+usbd_status
+usbreq_set_report_async(struct usbd_device *udev, u_int8_t iface_index,
+			u_int8_t type, u_int8_t id, void *data, int len);
+#endif
+
+usbd_status
+usbreq_set_report(struct usbd_device *udev, u_int8_t iface_index,
+		  u_int8_t type, u_int8_t id, void *data, int len);
+
+usbd_status
+usbreq_get_report(struct usbd_device *udev, u_int8_t iface_index,
+		  u_int8_t type, u_int8_t id, void *data, int len);
+
+usbd_status
+usbreq_set_idle(struct usbd_device *udev, u_int8_t iface_index,
+		int duration, int id);
+
+usbd_status
+usbreq_get_report_descriptor(struct usbd_device *udev, int ifcno,
+			     int size, void *d);
+
+usbd_status
+usbreq_read_report_desc(struct usbd_device *udev, u_int8_t iface_index,
+ 			void **descp, int *sizep, usb_malloc_type mem);
+
+usbd_status
+usbreq_set_config(struct usbd_device *udev, int conf);
+
+usbd_status
+usbreq_get_config(struct usbd_device *udev, u_int8_t *conf);
+
+/**/
+#define usbd_get_device_descriptor(udev) (&(udev)->ddesc)
+#define usbd_get_config_descriptor(udev) ((udev)->cdesc)
+#define usbd_get_interface_descriptor(iface) ((iface)->idesc)
+#define usbd_get_interface_altindex(iface) ((iface)->alt_index)
+#define usbd_get_quirks(udev) ((udev)->quirks)
+#define usbd_get_speed(udev) ((udev)->speed)
+#define usbd_get_hid_descriptor usbd_get_hdesc
+#define usbd_set_config_no usbd_search_and_set_config
+
+/* helper for computing offsets */
+#define POINTER_TO_UNSIGNED(ptr) \
+  (((u_int8_t *)(ptr)) - ((u_int8_t *)0))
+
+#endif /* _USB_SUBR_H_ */
diff -rubN /usr/src1/src/sys/modules/ugen/Makefile /usr/src/sys/modules/ugen/Makefile
--- /usr/src1/src/sys/modules/ugen/Makefile	Sat Jun  4 10:58:38 2005
+++ /usr/src/sys/modules/ugen/Makefile	Thu Jun  8 21:13:08 2006
@@ -1,8 +1,10 @@
-# $FreeBSD: src/sys/modules/ugen/Makefile,v 1.14 2005/06/04 10:58:38 schweikh Exp $
+# $FreeBSD: src/sys/modules/ugen/Makefile,v 1.12 2004/06/27 12:33:18 imp Exp $ 
 
-.PATH: ${.CURDIR}/../../dev/usb
+MAINTAINER=	n_hibma@freebsd.org
+
+.PATH: ${.CURDIR}/../../dev/usb ${.CURDIR}/../../dev/usb2
 
 KMOD=	ugen
-SRCS=	bus_if.h device_if.h opt_usb.h ugen.c usbdevs.h
+SRCS=	bus_if.h device_if.h vnode_if.h opt_usb.h _ugen.c usbdevs.h
 
 .include <bsd.kmod.mk>
diff -rubN /usr/src1/src/sys/modules/usb/Makefile /usr/src/sys/modules/usb/Makefile
--- /usr/src1/src/sys/modules/usb/Makefile	Sat Jun  4 10:58:39 2005
+++ /usr/src/sys/modules/usb/Makefile	Thu Jun  8 21:13:08 2006
@@ -1,27 +1,28 @@
-# $FreeBSD: src/sys/modules/usb/Makefile,v 1.18 2005/06/04 10:58:39 schweikh Exp $
+# $FreeBSD: src/sys/modules/usb/Makefile,v 1.15 2004/07/12 21:59:06 imp Exp $ 
+
+MAINTAINER=	n_hibma@freebsd.org
 
 S=	${.CURDIR}/../..
 
-.PATH: $S/dev/usb $S/pci
+.PATH: $S/dev/usb $S/dev/usb2 $S/pci
 
 KMOD=	usb
 SRCS=	bus_if.h device_if.h usb_if.h usb_if.c \
+	vnode_if.h \
 	opt_usb.h \
 	hid.c hid.h usbhid.h \
-	uhub.c \
-	usb.c usb.h \
-	usb_mem.c usb_mem.h \
-	usb_port.h \
-	usb_quirks.c usb_quirks.h \
-	usb_subr.c \
-	usbdevs.h usbdevs_data.h \
-	usbdi.c usbdi.h usbdivar.h \
-	usbdi_util.c usbdi_util.h \
-	usb_ethersubr.c usbdevs.h
+	usb_quirks.c ../usb/usb_quirks.h \
+	usb_ethersubr.c usbdevs.h \
+	_uhub.c \
+	_usb.c ../usb2/usb.h \
+	_usb_requests.c \
+	_usb_subr.c ../usb2/usb_subr.h \
+	_usb_transfer.c \
+	../usb2/usb_port.h
 
-SRCS+=	uhci_pci.c uhci.c uhcireg.h uhcivar.h
-SRCS+=	ohci_pci.c ohci.c ohcireg.h ohcivar.h
-SRCS+=	ehci_pci.c ehci.c ehcireg.h ehcivar.h
+SRCS+=	_uhci_pci.c _uhci.c ../usb2/uhci.h
+SRCS+=	_ohci_pci.c _ohci.c ../usb2/ohci.h
+SRCS+=	_ehci_pci.c _ehci.c ../usb2/ehci.h
 SRCS+=	opt_bus.h pci_if.h
 
 .include <bsd.kmod.mk>
diff -rubN /usr/src1/src/sys/tools/usbdevs2h.awk /usr/src/sys/tools/usbdevs2h.awk
--- /usr/src1/src/sys/tools/usbdevs2h.awk	Fri Jan  7 02:29:25 2005
+++ /usr/src/sys/tools/usbdevs2h.awk	Thu Jun  8 21:13:08 2006
@@ -1,7 +1,6 @@
 #! /usr/bin/awk -f
-#-
 #	$NetBSD: usb/devlist2h.awk,v 1.9 2001/01/18 20:28:22 jdolecek Exp $
-#  $FreeBSD: src/sys/tools/usbdevs2h.awk,v 1.7 2005/01/07 02:29:25 imp Exp $
+#  $FreeBSD: src/sys/tools/usbdevs2h.awk,v 1.3 2004/04/16 05:22:11 obrien Exp $
 #
 # Copyright (c) 1995, 1996 Christopher G. Demetriou
 # All rights reserved.
@@ -31,142 +30,157 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
-
-function usage()
-{
-	print "usage: usbdevs2h.awk <srcfile> [-d|-h]";
-	exit 1;
+BEGIN {
+	nproducts = nvendors = 0
+	dfile="usbdevs_data.h"
+	hfile="usbdevs.h"
 }
+NR == 1 {
+	VERSION = $0
+	gsub("\\$", "", VERSION)
 
-function header(file)
-{
 	if (os == "NetBSD")
-		printf("/*\t\$NetBSD\$\t*/\n\n") > file
+		printf("/*\t\$NetBSD\$\t*/\n\n") > dfile
 	else if (os == "FreeBSD")
-		printf("/* \$FreeBSD\$ */\n\n") > file
+		printf("/* \$FreeBSD\$ */\n\n") > dfile
 	else if (os == "OpenBSD")
-		printf("/*\t\$OpenBSD\$\t*/\n\n") > file
+		printf("/*\t\$OpenBSD\$\t*/\n\n") > dfile
 	else
-		printf("/* ??? */\n\n") > file
-	printf("/*\n") > file
+		printf("/* ??? */\n\n") > dfile
+	printf("/*\n") > dfile
 	printf(" * THIS FILE IS AUTOMATICALLY GENERATED.  DO NOT EDIT.\n") \
-	    > file
-	printf(" *\n") > file
-	printf(" * generated from:\n") > file
-	printf(" *\t%s\n", VERSION) > file
-	printf(" */\n") > file
-}
+	    > dfile
+	printf(" *\n") > dfile
+	printf(" * generated from:\n") > dfile
+	printf(" *\t%s\n", VERSION) > dfile
+	printf(" */\n") > dfile
 
-function vendor(hfile)
-{
+	if (os == "NetBSD")
+		printf("/*\t\$NetBSD\$\t*/\n\n") > hfile
+	else if (os == "FreeBSD")
+		printf("/* \$FreeBSD\$ */\n\n") > hfile
+	else if (os == "OpenBSD")
+		printf("/*\t\$OpenBSD\$\t*/\n\n") > hfile
+	else
+		printf("/* ??? */\n\n") > hfile
+	printf("/*\n") > hfile
+	printf(" * THIS FILE IS AUTOMATICALLY GENERATED.  DO NOT EDIT.\n") \
+	    > hfile
+	printf(" *\n") > hfile
+	printf(" * generated from:\n") > hfile
+	printf(" *\t%s\n", VERSION) > hfile
+	printf(" */\n") > hfile
+
+	next
+}
+$1 == "vendor" {
 	nvendors++
 
 	vendorindex[$2] = nvendors;		# record index for this name, for later.
 	vendors[nvendors, 1] = $2;		# name
 	vendors[nvendors, 2] = $3;		# id
-	if (hfile)
 		printf("#define\tUSB_VENDOR_%s\t%s\t", vendors[nvendors, 1],
 		    vendors[nvendors, 2]) > hfile
+
 	i = 3; f = 4;
 
 	# comments
 	ocomment = oparen = 0
 	if (f <= NF) {
-		if (hfile)
 			printf("\t/* ") > hfile
 		ocomment = 1;
 	}
 	while (f <= NF) {
 		if ($f == "#") {
-			if (hfile)
 				printf("(") > hfile
 			oparen = 1
 			f++
 			continue
 		}
 		if (oparen) {
-			if (hfile)
 				printf("%s", $f) > hfile
-			if (f < NF && hfile)
+			if (f < NF)
 				printf(" ") > hfile
 			f++
 			continue
 		}
 		vendors[nvendors, i] = $f
-		if (hfile)
 			printf("%s", vendors[nvendors, i]) > hfile
-		if (f < NF && hfile)
+		if (f < NF)
 			printf(" ") > hfile
 		i++; f++;
 	}
-	if (oparen && hfile)
+	if (oparen)
 		printf(")") > hfile
-	if (ocomment && hfile)
+	if (ocomment)
 		printf(" */") > hfile
-	if (hfile)
 		printf("\n") > hfile
-}
 
-function product(hfile)
-{
+	next
+}
+$1 == "product" {
 	nproducts++
 
 	products[nproducts, 1] = $2;		# vendor name
 	products[nproducts, 2] = $3;		# product id
 	products[nproducts, 3] = $4;		# id
-	if (hfile)
-		printf("#define\tUSB_PRODUCT_%s_%s\t%s\t", \
-		  products[nproducts, 1], products[nproducts, 2], \
-		  products[nproducts, 3]) > hfile
+	printf("#define\tUSB_PRODUCT_%s_%s\t%s\t", products[nproducts, 1],
+	    products[nproducts, 2], products[nproducts, 3]) > hfile
 
 	i=4; f = 5;
 
 	# comments
 	ocomment = oparen = 0
 	if (f <= NF) {
-		if (hfile)
 			printf("\t/* ") > hfile
 		ocomment = 1;
 	}
 	while (f <= NF) {
 		if ($f == "#") {
-			if (hfile)
 				printf("(") > hfile
 			oparen = 1
 			f++
 			continue
 		}
 		if (oparen) {
-			if (hfile)
 				printf("%s", $f) > hfile
-			if (f < NF && hfile)
+			if (f < NF)
 				printf(" ") > hfile
 			f++
 			continue
 		}
 		products[nproducts, i] = $f
-		if (hfile)
 			printf("%s", products[nproducts, i]) > hfile
-		if (f < NF && hfile)
+		if (f < NF)
 			printf(" ") > hfile
 		i++; f++;
 	}
-	if (oparen && hfile)
+	if (oparen)
 		printf(")") > hfile
-	if (ocomment && hfile)
+	if (ocomment)
 		printf(" */") > hfile
-	if (hfile)
 		printf("\n") > hfile
-}
 
-function dump_dfile(dfile)
+	next
+}
 {
+	if ($0 == "")
+		blanklines++
+	print $0 > hfile
+	if (blanklines < 2)
+		print $0 > dfile
+}
+END {
+	# print out the match tables
+
 	printf("\n") > dfile
+
 	printf("const struct usb_knowndev usb_knowndevs[] = {\n") > dfile
 	for (i = 1; i <= nproducts; i++) {
 		printf("\t{\n") > dfile
 		printf("\t    USB_VENDOR_%s, USB_PRODUCT_%s_%s,\n",
-		    products[i, 1], products[i, 1], products[i, 2]) > dfile
+		    products[i, 1], products[i, 1], products[i, 2]) \
+		    > dfile
 		printf("\t    ") > dfile
 		printf("0") > dfile
 		printf(",\n") > dfile
@@ -199,8 +213,10 @@
 	}
 	for (i = 1; i <= nvendors; i++) {
 		printf("\t{\n") > dfile
-		printf("\t    USB_VENDOR_%s, 0,\n", vendors[i, 1]) > dfile
-		printf("\t    USB_KNOWNDEV_NOPROD,\n") > dfile
+		printf("\t    USB_VENDOR_%s, 0,\n", vendors[i, 1]) \
+		    > dfile
+		printf("\t    USB_KNOWNDEV_NOPROD,\n") \
+		    > dfile
 		printf("\t    \"") > dfile
 		j = 3;
 		needspace = 0;
@@ -217,55 +233,4 @@
 	}
 	printf("\t{ 0, 0, 0, NULL, NULL, }\n") > dfile
 	printf("};\n") > dfile
-}
-
-BEGIN {
-
-nproducts = nvendors = 0
-# Process the command line
-for (i = 1; i < ARGC; i++) {
-	arg = ARGV[i];
-	if (arg !~ /^-[dh]+$/ && arg !~ /devs$/)
-		usage();
-	if (arg ~ /^-.*d/)
-		dfile="usbdevs_data.h"
-	if (arg ~ /^-.*h/)
-		hfile="usbdevs.h"
-	if (arg ~ /devs$/)
-		srcfile = arg;
-}
-ARGC = 1;
-line=0;
-
-while ((getline < srcfile) > 0) {
-	line++;
-	if (line == 1) {
-		VERSION = $0
-		gsub("\\$", "", VERSION)
-		if (dfile)
-			header(dfile)
-		if (hfile)
-			header(hfile)
-		continue;
-	}
-	if ($1 == "vendor") {
-		vendor(hfile)
-		continue
-	}
-	if ($1 == "product") {
-		product(hfile)
-		continue
-	}
-	if ($0 == "")
-		blanklines++
-	if (hfile)
-		print $0 > hfile
-	if (blanklines < 2 && dfile)
-	    print $0 > dfile
-}
-
-# print out the match tables
-
-if (dfile)
-	dump_dfile(dfile)
 }
