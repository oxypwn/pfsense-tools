diff -I '.*' -Naur releng8/gnu/lib/libgcc/Makefile svn/mips/gnu/lib/libgcc/Makefile
--- releng8/src/gnu/lib/libgcc/Makefile	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/gnu/lib/libgcc/Makefile	2009-08-04 11:23:42.000000000 -0700
@@ -115,6 +115,10 @@
 #	_fixsfsi _fixunssfsi _floatdidf _floatdisf
 .endif
 
+.if ${TARGET_ARCH} == "mips"
+LIB2FUNCS_EXTRA = floatunsidf.c floatunsisf.c
+.endif
+
 .if ${TARGET_ARCH} == "ia64"
 #	from config/ia64/t-ia64
 LIB1ASMSRC   = lib1funcs.asm
@@ -179,7 +183,7 @@
 #
 # Floating point emulation functions
 #
-.if ${TARGET_ARCH} == "armNOT_YET" || ${TARGET_ARCH} == "mips" || \
+.if ${TARGET_ARCH} == "armNOT_YET" || \
     ${TARGET_ARCH} == "powerpc" || ${TARGET_ARCH} == "sparc64"
 
 FPBIT_CFLAGS =	-DFINE_GRAINED_LIBRARIES -DFLOAT
diff -I '.*' -Naur releng8/gnu/usr.bin/binutils/Makefile.inc0 svn/mips/gnu/usr.bin/binutils/Makefile.inc0
--- releng8/src/gnu/usr.bin/binutils/Makefile.inc0	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/gnu/usr.bin/binutils/Makefile.inc0	2009-07-02 18:44:05.000000000 -0700
@@ -22,7 +22,8 @@
 RELSRC=	${RELTOP}/../../../contrib/binutils
 SRCDIR=	${.CURDIR}/${RELSRC}
 
-.if ${TARGET_ARCH} == "arm" || ${TARGET_ARCH} == "i386" || ${TARGET_ARCH} == "powerpc"
+.if ${TARGET_ARCH} == "arm" || ${TARGET_ARCH} == "i386" || \
+	${TARGET_ARCH} == "powerpc" || ${TARGET_ARCH} == "mips"
 CFLAGS+= -DBFD_DEFAULT_TARGET_SIZE=32
 .else
 CFLAGS+= -DBFD_DEFAULT_TARGET_SIZE=64
diff -I '.*' -Naur releng8/gnu/usr.bin/binutils/ld/Makefile.mips svn/mips/gnu/usr.bin/binutils/ld/Makefile.mips
--- releng8/src/gnu/usr.bin/binutils/ld/Makefile.mips	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/gnu/usr.bin/binutils/ld/Makefile.mips	2009-08-04 10:46:46.000000000 -0700
@@ -10,15 +10,22 @@
 NATIVE_EMULATION=elf${_sz}ltsmip_fbsd
 .endif
 
-SRCS+=	e${NATIVE_EMULATION}.c 
-CLEANFILES+=	e${NATIVE_EMULATION}.c
-
+MIPS_ABIS=elf32btsmip_fbsd elf32ltsmip_fbsd elf64btsmip_fbsd elf64ltsmip_fbsd
+.for abi in ${MIPS_ABIS}
+#.if (${abi} != ${NATIVE_EMULATION})
+EMS+= ${abi}
+#.endif
+.for ext in ${ELF_SCR_EXT}
+LDSCRIPTS+= ${abi}.${ext}
+.endfor
+SRCS+=	e${abi}.c 
+CLEANFILES+=	e${abi}.c
 # nb: elf32 handles both elf32 and elf64 targets
-e${NATIVE_EMULATION}.c:	${.CURDIR}/${NATIVE_EMULATION}.sh emultempl/elf32.em \
+e${abi}.c:	${.CURDIR}/${abi}.sh emultempl/elf32.em \
     scripttempl/elf.sc genscripts.sh stringify.sed
 	sh ${.CURDIR}/genscripts.sh ${SRCDIR}/ld ${LIBSERACHPATH} \
 	    ${TOOLS_PREFIX}/usr \
 	    ${HOST} ${TARGET_TUPLE} ${TARGET_TUPLE} \
-	    ${NATIVE_EMULATION} ""  no ${NATIVE_EMULATION} ${TARGET_TUPLE} \
-	    ${.CURDIR}/${NATIVE_EMULATION}.sh
-
+	    ${abi} ""  no ${abi} ${TARGET_TUPLE} \
+	    ${.CURDIR}/${abi}.sh
+.endfor
diff -I '.*' -Naur releng8/gnu/usr.bin/cc/Makefile.tgt svn/mips/gnu/usr.bin/cc/Makefile.tgt
--- releng8/src/gnu/usr.bin/cc/Makefile.tgt	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/gnu/usr.bin/cc/Makefile.tgt	2009-08-04 10:46:46.000000000 -0700
@@ -15,9 +15,6 @@
 .if ${TARGET_ARCH} == "ia64"
 TARGET_CPU_DEFAULT= MASK_GNU_AS|MASK_GNU_LD
 .endif
-.if ${TARGET_ARCH} == "mips"
-TARGET_CPU_DEFAULT= 16
-.endif
 .if ${TARGET_ARCH} == "sparc64"
 TARGET_CPU_DEFAULT= TARGET_CPU_ultrasparc
 .endif
diff -I '.*' -Naur releng8/lib/libc/Makefile svn/mips/lib/libc/Makefile
--- releng8/src/lib/libc/Makefile	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libc/Makefile	2009-08-04 11:24:17.000000000 -0700
@@ -64,7 +64,7 @@
 .include "${.CURDIR}/rpc/Makefile.inc"
 .include "${.CURDIR}/uuid/Makefile.inc"
 .include "${.CURDIR}/xdr/Makefile.inc"
-.if ${MACHINE_ARCH} == "arm"
+.if ${MACHINE_ARCH} == "arm" || ${MACHINE_ARCH} == "mips"
 .include "${.CURDIR}/softfloat/Makefile.inc"
 .endif
 .if ${MK_NIS} != "no"
diff -I '.*' -Naur releng8/lib/libc/mips/Symbol.map svn/mips/lib/libc/mips/Symbol.map
--- releng8/src/lib/libc/mips/Symbol.map	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libc/mips/Symbol.map	2009-07-02 18:44:18.000000000 -0700
@@ -61,4 +61,22 @@
 	minbrk;
 	_brk;
 	_sbrk;
+
+	/* softfloat */
+	__addsf3;
+	__adddf3;
+	__subsf3;
+	__subdf3;
+	__mulsf3;
+	__muldf3;
+	__divsf3;
+	__divdf3;
+	__floatsisf;
+	__floatsidf;
+	__fixsfsi;
+	__fixdfsi;
+	__fixunssfsi;
+	__fixunsdfsi;
+	__extendsfdf2;
+	__truncdfsf2;
 };
diff -I '.*' -Naur releng8/lib/libc/mips/gen/fpgetmask.c svn/mips/lib/libc/mips/gen/fpgetmask.c
--- releng8/src/lib/libc/mips/gen/fpgetmask.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libc/mips/gen/fpgetmask.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,29 +0,0 @@
-/*	$NetBSD: fpgetmask.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
-
-/*
- * Written by J.T. Conklin, Apr 11, 1995
- * Public domain.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libc/mips/gen/fpgetmask.c,v 1.4.2.1 2009/08/03 08:13:06 kensmith Exp $");
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: fpgetmask.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include "namespace.h"
-
-#include <ieeefp.h>
-
-#ifdef __weak_alias
-__weak_alias(fpgetmask,_fpgetmask)
-#endif
-
-fp_except_t
-fpgetmask()
-{
-	int x;
-
-	__asm("cfc1 %0,$31" : "=r" (x));
-	return (x >> 7) & 0x1f;
-}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/fpgetround.c svn/mips/lib/libc/mips/gen/fpgetround.c
--- releng8/src/lib/libc/mips/gen/fpgetround.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libc/mips/gen/fpgetround.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,29 +0,0 @@
-/*	$NetBSD: fpgetround.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
-
-/*
- * Written by J.T. Conklin, Apr 11, 1995
- * Public domain.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libc/mips/gen/fpgetround.c,v 1.4.2.1 2009/08/03 08:13:06 kensmith Exp $");
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: fpgetround.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include "namespace.h"
-
-#include <ieeefp.h>
-
-#ifdef __weak_alias
-__weak_alias(fpgetround,_fpgetround)
-#endif
-
-fp_rnd_t
-fpgetround()
-{
-	int x;
-
-	__asm("cfc1 %0,$31" : "=r" (x));
-	return x & 0x03;
-}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/fpgetsticky.c svn/mips/lib/libc/mips/gen/fpgetsticky.c
--- releng8/src/lib/libc/mips/gen/fpgetsticky.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libc/mips/gen/fpgetsticky.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,29 +0,0 @@
-/*	$NetBSD: fpgetsticky.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
-
-/*
- * Written by J.T. Conklin, Apr 11, 1995
- * Public domain.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libc/mips/gen/fpgetsticky.c,v 1.4.2.1 2009/08/03 08:13:06 kensmith Exp $");
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: fpgetsticky.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include "namespace.h"
-
-#include <ieeefp.h>
-
-#ifdef __weak_alias
-__weak_alias(fpgetsticky,_fpgetsticky)
-#endif
-
-fp_except_t
-fpgetsticky()
-{
-	int x;
-
-	__asm("cfc1 %0,$31" : "=r" (x));
-	return (x >> 2) & 0x1f;
-}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/fpsetmask.c svn/mips/lib/libc/mips/gen/fpsetmask.c
--- releng8/src/lib/libc/mips/gen/fpsetmask.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libc/mips/gen/fpsetmask.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,38 +0,0 @@
-/*	$NetBSD: fpsetmask.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
-
-/*
- * Written by J.T. Conklin, Apr 11, 1995
- * Public domain.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libc/mips/gen/fpsetmask.c,v 1.4.2.1 2009/08/03 08:13:06 kensmith Exp $");
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: fpsetmask.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include "namespace.h"
-
-#include <ieeefp.h>
-
-#ifdef __weak_alias
-__weak_alias(fpsetmask,_fpsetmask)
-#endif
-
-fp_except_t
-fpsetmask(mask)
-	fp_except_t mask;
-{
-	fp_except_t old;
-	fp_except_t new;
-
-	__asm("cfc1 %0,$31" : "=r" (old));
-
-	new = old;
-	new &= ~(0x1f << 7); 
-	new |= ((mask & 0x1f) << 7);
-
-	__asm("ctc1 %0,$31" : : "r" (new));
-
-	return (old >> 7) & 0x1f;
-}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/fpsetround.c svn/mips/lib/libc/mips/gen/fpsetround.c
--- releng8/src/lib/libc/mips/gen/fpsetround.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libc/mips/gen/fpsetround.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,37 +0,0 @@
-/*	$NetBSD: fpsetround.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
-
-/*
- * Written by J.T. Conklin, Apr 11, 1995
- * Public domain.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libc/mips/gen/fpsetround.c,v 1.4.2.1 2009/08/03 08:13:06 kensmith Exp $");
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: fpsetround.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include "namespace.h"
-
-#include <ieeefp.h>
-
-#ifdef __weak_alias
-__weak_alias(fpsetround,_fpsetround)
-#endif
-
-fp_rnd_t
-fpsetround(fp_rnd_t rnd_dir)
-{
-	fp_rnd_t old;
-	fp_rnd_t new;
-
-	__asm("cfc1 %0,$31" : "=r" (old));
-
-	new = old;
-	new &= ~0x03;
-	new |= (rnd_dir & 0x03);
-
-	__asm("ctc1 %0,$31" : : "r" (new));
-
-	return old & 0x03;
-}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/fpsetsticky.c svn/mips/lib/libc/mips/gen/fpsetsticky.c
--- releng8/src/lib/libc/mips/gen/fpsetsticky.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libc/mips/gen/fpsetsticky.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,38 +0,0 @@
-/*	$NetBSD: fpsetsticky.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
-
-/*
- * Written by J.T. Conklin, Apr 11, 1995
- * Public domain.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libc/mips/gen/fpsetsticky.c,v 1.3.2.1 2009/08/03 08:13:06 kensmith Exp $");
-#if defined(LIBC_SCCS) && !defined(lint)
-__RCSID("$NetBSD: fpsetsticky.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
-#endif /* LIBC_SCCS and not lint */
-
-#include "namespace.h"
-
-#include <ieeefp.h>
-
-#ifdef __weak_alias
-__weak_alias(fpsetsticky,_fpsetsticky)
-#endif
-
-fp_except
-fpsetsticky(sticky)
-	fp_except sticky;
-{
-	fp_except old;
-	fp_except new;
-
-	__asm("cfc1 %0,$31" : "=r" (old));
-
-	new = old;
-	new &= ~(0x1f << 2); 
-	new |= ((sticky & 0x1f) << 2);
-
-	__asm("ctc1 %0,$31" : : "r" (new));
-
-	return (old >> 2) & 0x1f;
-}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/hardfloat/fpgetmask.c svn/mips/lib/libc/mips/gen/hardfloat/fpgetmask.c
--- releng8/src/lib/libc/mips/gen/hardfloat/fpgetmask.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/lib/libc/mips/gen/hardfloat/fpgetmask.c	2009-07-02 18:44:18.000000000 -0700
@@ -0,0 +1,29 @@
+/*	$NetBSD: fpgetmask.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
+
+/*
+ * Written by J.T. Conklin, Apr 11, 1995
+ * Public domain.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/lib/libc/mips/gen/hardfloat/fpgetmask.c 195025 2009-06-26 01:01:50Z gonzo $");
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: fpgetmask.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <ieeefp.h>
+
+#ifdef __weak_alias
+__weak_alias(fpgetmask,_fpgetmask)
+#endif
+
+fp_except_t
+fpgetmask()
+{
+	int x;
+
+	__asm("cfc1 %0,$31" : "=r" (x));
+	return (x >> 7) & 0x1f;
+}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/hardfloat/fpgetround.c svn/mips/lib/libc/mips/gen/hardfloat/fpgetround.c
--- releng8/src/lib/libc/mips/gen/hardfloat/fpgetround.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/lib/libc/mips/gen/hardfloat/fpgetround.c	2009-07-02 18:44:18.000000000 -0700
@@ -0,0 +1,29 @@
+/*	$NetBSD: fpgetround.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
+
+/*
+ * Written by J.T. Conklin, Apr 11, 1995
+ * Public domain.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/lib/libc/mips/gen/hardfloat/fpgetround.c 195025 2009-06-26 01:01:50Z gonzo $");
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: fpgetround.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <ieeefp.h>
+
+#ifdef __weak_alias
+__weak_alias(fpgetround,_fpgetround)
+#endif
+
+fp_rnd_t
+fpgetround()
+{
+	int x;
+
+	__asm("cfc1 %0,$31" : "=r" (x));
+	return x & 0x03;
+}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/hardfloat/fpgetsticky.c svn/mips/lib/libc/mips/gen/hardfloat/fpgetsticky.c
--- releng8/src/lib/libc/mips/gen/hardfloat/fpgetsticky.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/lib/libc/mips/gen/hardfloat/fpgetsticky.c	2009-07-02 18:44:18.000000000 -0700
@@ -0,0 +1,29 @@
+/*	$NetBSD: fpgetsticky.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
+
+/*
+ * Written by J.T. Conklin, Apr 11, 1995
+ * Public domain.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/lib/libc/mips/gen/hardfloat/fpgetsticky.c 195025 2009-06-26 01:01:50Z gonzo $");
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: fpgetsticky.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <ieeefp.h>
+
+#ifdef __weak_alias
+__weak_alias(fpgetsticky,_fpgetsticky)
+#endif
+
+fp_except_t
+fpgetsticky()
+{
+	int x;
+
+	__asm("cfc1 %0,$31" : "=r" (x));
+	return (x >> 2) & 0x1f;
+}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/hardfloat/fpsetmask.c svn/mips/lib/libc/mips/gen/hardfloat/fpsetmask.c
--- releng8/src/lib/libc/mips/gen/hardfloat/fpsetmask.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/lib/libc/mips/gen/hardfloat/fpsetmask.c	2009-07-02 18:44:18.000000000 -0700
@@ -0,0 +1,38 @@
+/*	$NetBSD: fpsetmask.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
+
+/*
+ * Written by J.T. Conklin, Apr 11, 1995
+ * Public domain.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/lib/libc/mips/gen/hardfloat/fpsetmask.c 195025 2009-06-26 01:01:50Z gonzo $");
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: fpsetmask.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <ieeefp.h>
+
+#ifdef __weak_alias
+__weak_alias(fpsetmask,_fpsetmask)
+#endif
+
+fp_except_t
+fpsetmask(mask)
+	fp_except_t mask;
+{
+	fp_except_t old;
+	fp_except_t new;
+
+	__asm("cfc1 %0,$31" : "=r" (old));
+
+	new = old;
+	new &= ~(0x1f << 7); 
+	new |= ((mask & 0x1f) << 7);
+
+	__asm("ctc1 %0,$31" : : "r" (new));
+
+	return (old >> 7) & 0x1f;
+}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/hardfloat/fpsetround.c svn/mips/lib/libc/mips/gen/hardfloat/fpsetround.c
--- releng8/src/lib/libc/mips/gen/hardfloat/fpsetround.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/lib/libc/mips/gen/hardfloat/fpsetround.c	2009-07-02 18:44:18.000000000 -0700
@@ -0,0 +1,37 @@
+/*	$NetBSD: fpsetround.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
+
+/*
+ * Written by J.T. Conklin, Apr 11, 1995
+ * Public domain.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/lib/libc/mips/gen/hardfloat/fpsetround.c 195025 2009-06-26 01:01:50Z gonzo $");
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: fpsetround.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <ieeefp.h>
+
+#ifdef __weak_alias
+__weak_alias(fpsetround,_fpsetround)
+#endif
+
+fp_rnd_t
+fpsetround(fp_rnd_t rnd_dir)
+{
+	fp_rnd_t old;
+	fp_rnd_t new;
+
+	__asm("cfc1 %0,$31" : "=r" (old));
+
+	new = old;
+	new &= ~0x03;
+	new |= (rnd_dir & 0x03);
+
+	__asm("ctc1 %0,$31" : : "r" (new));
+
+	return old & 0x03;
+}
diff -I '.*' -Naur releng8/lib/libc/mips/gen/hardfloat/fpsetsticky.c svn/mips/lib/libc/mips/gen/hardfloat/fpsetsticky.c
--- releng8/src/lib/libc/mips/gen/hardfloat/fpsetsticky.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/lib/libc/mips/gen/hardfloat/fpsetsticky.c	2009-07-02 18:44:18.000000000 -0700
@@ -0,0 +1,38 @@
+/*	$NetBSD: fpsetsticky.c,v 1.5 2005/12/24 23:10:08 perry Exp $	*/
+
+/*
+ * Written by J.T. Conklin, Apr 11, 1995
+ * Public domain.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/lib/libc/mips/gen/hardfloat/fpsetsticky.c 195025 2009-06-26 01:01:50Z gonzo $");
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: fpsetsticky.c,v 1.5 2005/12/24 23:10:08 perry Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <ieeefp.h>
+
+#ifdef __weak_alias
+__weak_alias(fpsetsticky,_fpsetsticky)
+#endif
+
+fp_except
+fpsetsticky(sticky)
+	fp_except sticky;
+{
+	fp_except old;
+	fp_except new;
+
+	__asm("cfc1 %0,$31" : "=r" (old));
+
+	new = old;
+	new &= ~(0x1f << 2); 
+	new |= ((sticky & 0x1f) << 2);
+
+	__asm("ctc1 %0,$31" : : "r" (new));
+
+	return (old >> 2) & 0x1f;
+}
diff -I '.*' -Naur releng8/lib/libthr/arch/mips/include/pthread_md.h svn/mips/lib/libthr/arch/mips/include/pthread_md.h
--- releng8/src/lib/libthr/arch/mips/include/pthread_md.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/lib/libthr/arch/mips/include/pthread_md.h	2009-07-02 18:44:18.000000000 -0700
@@ -60,7 +60,8 @@
 static __inline void
 _tcb_set(struct tcb *tcb)
 {
-	mips_tcb_set(tcb);
+
+	sysarch(MIPS_SET_TLS, tcb);
 }
 
 /*
@@ -69,7 +70,10 @@
 static __inline struct tcb *
 _tcb_get(void)
 {
-	return (mips_tcb_get());
+	void *tcb;
+
+	sysarch(MIPS_GET_TLS, &tcb);
+	return tcb;
 }
 
 extern struct pthread *_thr_initial;
diff -I '.*' -Naur releng8/sys/conf/Makefile.mips svn/mips/sys/conf/Makefile.mips
--- releng8/src/sys/conf/Makefile.mips	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/conf/Makefile.mips	2009-09-30 19:27:09.000000000 -0700
@@ -28,35 +28,83 @@
 .endif
 .include "$S/conf/kern.pre.mk"
 
+LDSCRIPT_NAME?=ldscript.$M
+SYSTEM_LD:= ${SYSTEM_LD:$S/conf/${LDSCRIPT_NAME}=${LDSCRIPT_NAME}}
+SYSTEM_DEP:= ${SYSTEM_DEP:$S/conf/${LDSCRIPT_NAME}=${LDSCRIPT_NAME}}
+
 # XXX: Such sweeping assumptions...
 MACHINE=mips
 MACHINE_ARCH=mips
+KERNLOADADDR?=0x80001000
+# This obscure value is defined by CFE for WR160N
+# To be changed later
+TRAMPLOADADDR?=0x807963c0
 
 MKMODULESENV+=	MACHINE=${MACHINE} MACHINE_ARCH=${MACHINE_ARCH}
 
 # We default to the MIPS32 ISA, if none specified in the
 # kernel configuration file.
 ARCH_FLAGS?=-march=mips32
+EXTRA_FLAGS=-fno-pic -mno-abicalls -G0
 
 HACK_EXTRA_FLAGS=-shared
 .if defined(TARGET_BIG_ENDIAN)
 CFLAGS+=-EB
 SYSTEM_LD+=-EB
+EXTRA_FLAGS+=-EB 
+TRAMP_LDFLAGS+=-Wl,-EB 
 HACK_EXTRA_FLAGS+=-EB -Wl,-EB
+.if defined(TARGET_64BIT)
+SYSTEM_LD+=-m elf64btsmip_fbsd
+HACK_EXTRA_FLAGS+=-Wl,-m,elf64btsmip_fbsd
+.endif
 .else
 CFLAGS+=-EL
 SYSTEM_LD+=-EL
+EXTRA_FLAGS+=-EL
+TRAMP_LDFLAGS+=-Wl,-EL
 HACK_EXTRA_FLAGS+=-EL -Wl,-EL
+.if defined(TARGET_64BIT)
+SYSTEM_LD+=-m elf64ltsmip_fbsd
+HACK_EXTRA_FLAGS+=-Wl,-m,elf64ltsmip_fbsd
+.endif
 .endif
 
+
 # We add the -fno-pic flag to kernels because otherwise performance
 # is extremely poor, as well as -mno-abicalls to force no ABI usage.
-CFLAGS+=-fno-pic -mno-abicalls -G0 $(ARCH_FLAGS)
-HACK_EXTRA_FLAGS+=-fno-pic -mno-abicalls -G0 $(ARCH_FLAGS)
+CFLAGS+=${EXTRA_FLAGS} $(ARCH_FLAGS)
+HACK_EXTRA_FLAGS+=${EXTRA_FLAGS} $(ARCH_FLAGS)
 
 # XXX hardcoded kernel entry point
 ASM_CFLAGS+=${CFLAGS} -D_LOCORE -DLOCORE
 
+KERNEL_EXTRA=trampoline
+trampoline: ${KERNEL_KO}.tramp.bin
+${KERNEL_KO}.tramp.bin: ${KERNEL_KO} $S/$M/$M/elf_trampoline.c \
+	$S/$M/$M/inckern.S 
+	${OBJCOPY} --strip-symbol '$$d' --strip-symbol '$$a' \
+	-g --strip-symbol '$$t' ${FULLKERNEL} ${KERNEL_KO}.tmp
+	sed s/${KERNLOADADDR}/${TRAMPLOADADDR}/ ${LDSCRIPT_NAME} | \
+		sed s/" + SIZEOF_HEADERS"//  > ${LDSCRIPT_NAME}.tramp.noheader
+	# Generate .S file that setups stack and jumps to trampoline
+	echo "#include <machine/asm.h>" >tmphack.S
+	echo "ENTRY(_start)" >>tmphack.S
+	echo "PTR_LA t0, kernel_end" >>tmphack.S
+	echo "move sp, t0" >>tmphack.S
+	echo "add sp, 0x2000" >>tmphack.S
+	echo "and sp, ~0x7" >>tmphack.S
+	echo "PTR_LA t0, _startC" >>tmphack.S
+	echo "j t0" >>tmphack.S
+	echo "END(_start)" >>tmphack.S
+	echo "#define KERNNAME \"${KERNEL_KO}.tmp\""  >opt_kernname.h 
+	${CC} -O -nostdlib -I. -I$S ${HACK_EXTRA_FLAGS} ${TRAMP_LDFLAGS} -Xlinker \
+		-T -Xlinker ${LDSCRIPT_NAME}.tramp.noheader tmphack.S \
+		$S/$M/$M/elf_trampoline.c $S/$M/$M/inckern.S \
+		-o ${KERNEL_KO}.tramp.noheader 
+	${OBJCOPY} -S -O binary ${KERNEL_KO}.tramp.noheader \
+		${KERNEL_KO}.tramp.bin \
+
 %BEFORE_DEPEND
 
 %OBJS
@@ -69,6 +117,12 @@
 
 %CLEAN
 
+CLEAN+=	${LDSCRIPT_NAME} ${LDSCRIPT_NAME}.tramp.noheader \
+	${KERNEL_KO}.tramp.noheader ${KERNEL_KO}.tramp.bin
+
+${LDSCRIPT_NAME}: $S/conf/${LDSCRIPT_NAME}
+	cat $S/conf/${LDSCRIPT_NAME}|sed s/KERNLOADADDR/${KERNLOADADDR}/g \
+		> ${LDSCRIPT_NAME}
 %RULES
 
 .include "$S/conf/kern.post.mk"
diff -I '.*' -Naur releng8/sys/conf/files svn/mips/sys/conf/files
--- releng8/src/sys/conf/files	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/conf/files	2009-10-01 13:42:41.000000000 -0700
@@ -91,8 +91,8 @@
 	no-obj no-implicit-rule before-depend				   \
 	clean		"pccarddevs.h"
 teken_state.h		optional sc					   \
-	dependency	"$S/dev/syscons/teken/gensequences $S/dev/syscons/teken/sequences" \
-	compile-with	"${AWK} -f $S/dev/syscons/teken/gensequences $S/dev/syscons/teken/sequences > teken_state.h" \
+	dependency	"$S/teken/gensequences $S/teken/sequences" \
+	compile-with	"${AWK} -f $S/teken/gensequences $S/teken/sequences > teken_state.h" \
 	no-obj no-implicit-rule before-depend				   \
 	clean		"teken_state.h"
 usbdevs.h			optional usb				   \
@@ -220,6 +220,7 @@
 contrib/dev/acpica/namespace/nsobject.c	optional acpi
 contrib/dev/acpica/namespace/nsparse.c	optional acpi
 contrib/dev/acpica/namespace/nspredef.c	optional acpi
+contrib/dev/acpica/namespace/nsrepair.c	optional acpi
 contrib/dev/acpica/namespace/nssearch.c	optional acpi
 contrib/dev/acpica/namespace/nsutils.c	optional acpi
 contrib/dev/acpica/namespace/nswalk.c	optional acpi
@@ -260,6 +261,7 @@
 contrib/dev/acpica/utilities/utdelete.c	optional acpi
 contrib/dev/acpica/utilities/uteval.c	optional acpi
 contrib/dev/acpica/utilities/utglobal.c	optional acpi
+contrib/dev/acpica/utilities/utids.c	optional acpi
 contrib/dev/acpica/utilities/utinit.c	optional acpi
 contrib/dev/acpica/utilities/utlock.c	optional acpi
 contrib/dev/acpica/utilities/utmath.c	optional acpi
@@ -845,8 +847,10 @@
 dev/drm/r128_state.c		optional r128drm \
 	compile-with "${NORMAL_C} -finline-limit=13500"
 dev/drm/r300_cmdbuf.c		optional radeondrm
+dev/drm/r600_blit.c		optional radeondrm
 dev/drm/r600_cp.c		optional radeondrm
 dev/drm/radeon_cp.c		optional radeondrm
+dev/drm/radeon_cs.c		optional radeondrm
 dev/drm/radeon_drv.c		optional radeondrm
 dev/drm/radeon_irq.c		optional radeondrm
 dev/drm/radeon_mem.c		optional radeondrm
@@ -926,6 +930,7 @@
 dev/firewire/sbp.c		optional sbp
 dev/firewire/sbp_targ.c		optional sbp_targ
 dev/flash/at45d.c		optional at45d
+dev/flash/mx25l.c		optional mx25l
 dev/fxp/if_fxp.c		optional fxp inet
 dev/gem/if_gem.c		optional gem
 dev/gem/if_gem_pci.c		optional gem pci
@@ -1295,6 +1300,7 @@
 dev/pst/pst-iop.c		optional pst
 dev/pst/pst-pci.c		optional pst pci
 dev/pst/pst-raid.c		optional pst
+dev/pty/pty.c			optional pty
 dev/puc/puc.c			optional puc
 dev/puc/puc_cfg.c		optional puc
 dev/puc/puc_pccard.c		optional puc pccard
@@ -1638,6 +1644,7 @@
 dev/usb/serial/uark.c		optional uark
 dev/usb/serial/ubsa.c		optional ubsa
 dev/usb/serial/ubser.c		optional ubser
+dev/usb/serial/uch341.c		optional uch341
 dev/usb/serial/uchcom.c		optional uchcom
 dev/usb/serial/ucycom.c		optional ucycom
 dev/usb/serial/ufoma.c		optional ufoma
@@ -1653,7 +1660,7 @@
 dev/usb/serial/uvisor.c		optional uvisor
 dev/usb/serial/uvscom.c		optional uvscom
 dev/usb/serial/usb_serial.c 	optional ucom | \
-	(u3g | uark | ubsa | ubser | uchcom | ucycom | ufoma | uftdi | ugensa | uipaq | ulpt | umct | umodem | umoscom | uplcom | uslcom | uvisor | uvscom)
+	(u3g | uark | ubsa | ubser | uch341 | uchcom | ucycom | ufoma | uftdi | ugensa | uipaq | ulpt | umct | umodem | umoscom | uplcom | uslcom | uvisor | uvscom)
 #
 # USB misc drivers
 #
@@ -1787,6 +1794,7 @@
 fs/procfs/procfs_map.c		optional procfs
 fs/procfs/procfs_mem.c		optional procfs
 fs/procfs/procfs_note.c		optional procfs
+fs/procfs/procfs_osrel.c	optional procfs
 fs/procfs/procfs_regs.c		optional procfs
 fs/procfs/procfs_rlimit.c	optional procfs
 fs/procfs/procfs_status.c	optional procfs
@@ -2004,6 +2012,7 @@
 kern/serdev_if.m		standard
 kern/stack_protector.c		standard \
 	compile-with "${NORMAL_C:N-fstack-protector*}"
+kern/subr_acl_nfs4.c		standard
 kern/subr_acl_posix1e.c		standard
 kern/subr_autoconf.c		standard
 kern/subr_blist.c		standard
@@ -2057,7 +2066,6 @@
 kern/tty_inq.c			standard
 kern/tty_outq.c			standard
 kern/tty_pts.c			standard
-kern/tty_pty.c			optional pty
 kern/tty_tty.c			standard
 kern/tty_ttydisc.c		standard
 kern/uipc_accf.c		optional inet
@@ -2614,6 +2622,7 @@
 security/mac_seeotheruids/mac_seeotheruids.c optional mac_seeotheruids
 security/mac_stub/mac_stub.c	optional mac_stub
 security/mac_test/mac_test.c	optional mac_test
+teken/teken.c			optional sc
 ufs/ffs/ffs_alloc.c		optional ffs
 ufs/ffs/ffs_balloc.c		optional ffs
 ufs/ffs/ffs_inode.c		optional ffs
@@ -2628,7 +2637,7 @@
 ufs/ufs/ufs_bmap.c		optional ffs
 ufs/ufs/ufs_dirhash.c		optional ffs
 ufs/ufs/ufs_extattr.c		optional ffs
-ufs/ufs/ufs_gjournal.c		optional ffs
+ufs/ufs/ufs_gjournal.c		optional ffs UFS_GJOURNAL
 ufs/ufs/ufs_inode.c		optional ffs
 ufs/ufs/ufs_lookup.c		optional ffs
 ufs/ufs/ufs_quota.c		optional ffs
@@ -2823,4 +2832,3 @@
 dev/xen/xenpci/xenpci.c		optional xenpci
 dev/xen/xenpci/evtchn.c         optional xenpci
 dev/xen/xenpci/machine_reboot.c optional xenpci
-
diff -I '.*' -Naur releng8/sys/conf/files.mips svn/mips/sys/conf/files.mips
--- releng8/src/sys/conf/files.mips	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/conf/files.mips	2009-09-08 11:01:49.000000000 -0700
@@ -38,7 +38,7 @@
 mips/mips/elf_machdep.c		standard
 mips/mips/exception.S		standard
 mips/mips/gdb_machdep.c		standard
-mips/mips/mainbus.c		standard
+# mips/mips/mainbus.c		standard
 mips/mips/pmap.c		standard
 mips/mips/trap.c		standard
 mips/mips/vm_machdep.c		standard
@@ -54,6 +54,7 @@
 mips/mips/swtch.S		standard
 mips/mips/tlb.S			standard
 
+mips/mips/bus_space_generic.c 	standard
 mips/mips/busdma_machdep.c 	standard
 mips/mips/cache.c		standard
 mips/mips/cache_mipsNN.c	standard
@@ -69,24 +70,27 @@
 mips/mips/nexus.c		standard
 mips/mips/stack_machdep.c	optional	ddb | stack
 mips/mips/support.S		standard
+mips/mips/sys_machdep.c		standard
 mips/mips/swtch.S		standard
 mips/mips/uio_machdep.c		standard
+crypto/blowfish/bf_enc.c	optional	crypto | ipsec 
+crypto/des/des_enc.c		optional	crypto | ipsec | netsmb
 geom/geom_bsd.c			optional	geom_bsd
 geom/geom_bsd_enc.c		optional	geom_bsd
 geom/geom_mbr.c			optional	geom_mbr
 geom/geom_mbr_enc.c		optional	geom_mbr
 libkern/ashldi3.c		standard
 libkern/ashrdi3.c		standard
-libkern/divdi3.c		standard
+libkern/divdi3.c		optional	isa_mips32
 libkern/ffsl.c			standard
 libkern/fls.c			standard
 libkern/flsl.c			standard
 libkern/lshrdi3.c		standard
 libkern/memmove.c		standard
-libkern/moddi3.c		standard
-libkern/qdivrem.c		standard
-libkern/udivdi3.c		standard
-libkern/umoddi3.c		standard
+libkern/moddi3.c		optional	isa_mips32
+libkern/qdivrem.c		optional	isa_mips32
+libkern/udivdi3.c		optional	isa_mips32
+libkern/umoddi3.c		optional	isa_mips32
 
 #XXX: We can't use these versions, as strcmp.c is included conf/files
 #libkern/mips/strcmp.S		standard
@@ -94,5 +98,10 @@
 
 dev/cfe/cfe_api.c		optional	cfe
 dev/cfe/cfe_console.c		optional	cfe_console
+dev/cfe/cfe_env.c		optional	cfe_env
 #dev/cfe/cfe_resource.c		optional	cfe	# not yet needed
 
+dev/siba/siba.c			optional	siba
+dev/siba/siba_pcib.c		optional	siba pci
+dev/siba/siba_cc.c		optional	siba
+#mips/sentry5/siba_mips.c			optional siba # not yet
diff -I '.*' -Naur releng8/sys/conf/kern.mk svn/mips/sys/conf/kern.mk
--- releng8/src/sys/conf/kern.mk	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/conf/kern.mk	2009-08-04 10:46:57.000000000 -0700
@@ -90,7 +90,7 @@
 # disable MIPS DSP ASE Instruction set.
 #
 .if ${MACHINE_ARCH} == "mips"
-CFLAGS+=	-msoft-float -mno-dsp
+CFLAGS+=	-msoft-float
 INLINE_LIMIT?=	8000
 .endif
 
diff -I '.*' -Naur releng8/sys/conf/ldscript.mips svn/mips/sys/conf/ldscript.mips
--- releng8/src/sys/conf/ldscript.mips	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/conf/ldscript.mips	2009-04-14 15:53:59.000000000 -0700
@@ -43,7 +43,7 @@
 SECTIONS
 {
   /* Read-only sections, merged into text segment: */
-  . = 0x80100000 + SIZEOF_HEADERS;
+  . = KERNLOADADDR + SIZEOF_HEADERS;
   .interp     : { *(.interp) 	}
   .hash          : { *(.hash)		}
   .dynsym        : { *(.dynsym)		}
diff -I '.*' -Naur releng8/sys/conf/ldscript.mips.mips64 svn/mips/sys/conf/ldscript.mips.mips64
--- releng8/src/sys/conf/ldscript.mips.mips64	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/conf/ldscript.mips.mips64	2009-09-30 19:27:09.000000000 -0700
@@ -0,0 +1,303 @@
+/*-
+ * Copyright (c) 2001, 2004, 2008, Juniper Networks, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Juniper Networks, Inc. nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY JUNIPER NETWORKS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL JUNIPER NETWORKS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	JNPR: ldscript.mips,v 1.3 2006/10/11 06:12:04
+ * $FreeBSD: projects/mips/sys/conf/ldscript.mips 191079 2009-04-14 22:53:22Z gonzo $
+ */
+
+OUTPUT_FORMAT("elf64-tradbigmips", "elf64-tradbigmips", 
+		"elf64-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SEARCH_DIR(/usr/lib);
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;
+PROVIDE (_DYNAMIC = 0);
+*/
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  . = KERNLOADADDR + SIZEOF_HEADERS;
+  .interp     : { *(.interp) 	}
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .gnu.version   : { *(.gnu.version)	}
+  .gnu.version_d   : { *(.gnu.version_d)	}
+  .gnu.version_r   : { *(.gnu.version_r)	}
+  .rel.init      : { *(.rel.init)	}
+  .rela.init     : { *(.rela.init)	}
+  .rel.text      :
+    {
+      *(.rel.text)
+      *(.rel.text.*)
+      *(.rel.gnu.linkonce.t.*)
+    }
+  .rela.text     :
+    {
+      *(.rela.text)
+      *(.rela.text.*)
+      *(.rela.gnu.linkonce.t.*)
+    }
+  .rel.fini      : { *(.rel.fini)	}
+  .rela.fini     : { *(.rela.fini)	}
+  .rel.rodata    :
+    {
+      *(.rel.rodata)
+      *(.rel.rodata.*)
+      *(.rel.gnu.linkonce.r.*)
+    }
+  .rela.rodata   :
+    {
+      *(.rela.rodata)
+      *(.rela.rodata.*)
+      *(.rela.gnu.linkonce.r.*)
+    }
+  .rel.data      :
+    {
+      *(.rel.data)
+      *(.rel.data.*)
+      *(.rel.gnu.linkonce.d.*)
+    }
+  .rela.data     :
+    {
+      *(.rela.data)
+      *(.rela.data.*)
+      *(.rela.gnu.linkonce.d.*)
+    }
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.sdata     :
+    {
+      *(.rel.sdata)
+      *(.rel.sdata.*)
+      *(.rel.gnu.linkonce.s.*)
+    }
+  .rela.sdata     :
+    {
+      *(.rela.sdata)
+      *(.rela.sdata.*)
+      *(.rela.gnu.linkonce.s.*)
+    }
+  .rel.sbss      :
+    { 
+      *(.rel.sbss)
+      *(.rel.sbss.*)
+      *(.rel.gnu.linkonce.sb.*)
+    }
+  .rela.sbss     :
+    {
+      *(.rela.sbss)
+      *(.rela.sbss.*)
+      *(.rel.gnu.linkonce.sb.*)
+    }
+  .rel.sdata2    : 
+    { 
+      *(.rel.sdata2)
+      *(.rel.sdata2.*)
+      *(.rel.gnu.linkonce.s2.*)
+    }
+  .rela.sdata2   : 
+    {
+      *(.rela.sdata2)
+      *(.rela.sdata2.*)
+      *(.rela.gnu.linkonce.s2.*)
+    }
+  .rel.sbss2     : 
+    { 
+      *(.rel.sbss2)	
+      *(.rel.sbss2.*)
+      *(.rel.gnu.linkonce.sb2.*)
+    }
+  .rela.sbss2    : 
+    { 
+      *(.rela.sbss2)	
+      *(.rela.sbss2.*)
+      *(.rela.gnu.linkonce.sb2.*)
+    }
+  .rel.bss       : 
+    { 
+      *(.rel.bss)
+      *(.rel.bss.*)
+      *(.rel.gnu.linkonce.b.*)
+    }
+  .rela.bss      : 
+    { 
+      *(.rela.bss)
+      *(.rela.bss.*)
+      *(.rela.gnu.linkonce.b.*)
+    }
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : 
+  { 
+    KEEP (*(.init))
+  } =0x1000000
+  .text      :
+  {
+    *(.trap)
+    *(.text)
+    *(.text.*)
+    *(.stub)
+    /* .gnu.warning sections are handled specially by elf64.em.  */
+    *(.gnu.warning)
+    *(.gnu.linkonce.t.*)
+  } =0x1000000
+  .fini      :
+  {
+    KEEP (*(.fini))
+  } =0x1000000
+  PROVIDE (__etext = .);
+  PROVIDE (_etext = .);
+  PROVIDE (etext = .);
+  .rodata   : { *(.rodata) *(.rodata.*) *(.gnu.linkonce.r.*) }
+  .rodata1   : { *(.rodata1) }
+  .reginfo : { *(.reginfo) }
+  .sdata2   : { *(.sdata2) *(.sdata2.*) *(.gnu.linkonce.s2.*) }
+  .sbss2   : { *(.sbss2) *(.sbss2.*) *(.gnu.linkonce.sb2.*) }
+  . = ALIGN(0x2000) + (. & (0x2000 - 1));
+  .data    :
+  {
+    *(.data)
+    *(.data.*)
+    *(.gnu.linkonce.d.*)
+    SORT(CONSTRUCTORS)
+  }
+  .data1   : { *(.data1) }
+  .eh_frame : { KEEP (*(.eh_frame)) }
+  .gcc_except_table : { *(.gcc_except_table) }
+  .ctors   : 
+  {
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE (*crtend.o ) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+  }
+   .dtors         :
+  {
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend.o ) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+  }
+  .plt      : { *(.plt)	}
+  _gp = ALIGN(16) + 0x7ff0;
+  .got		  : { *(.got.plt) *(.got) }
+  .dynamic       : { *(.dynamic) }
+  /* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata     : 
+  {
+    *(.sdata) 
+    *(.sdata.*)
+    *(.gnu.linkonce.s.*)
+  }
+  _edata = .;
+  PROVIDE (edata = .);
+  __bss_start = .;
+  .sbss      :
+  {
+    PROVIDE (__sbss_start = .);
+    PROVIDE (___sbss_start = .);
+    *(.dynsbss)
+    *(.sbss)
+    *(.sbss.*)
+    *(.gnu.linkonce.sb.*)
+    *(.scommon)
+    PROVIDE (__sbss_end = .);
+    PROVIDE (___sbss_end = .);
+  }
+  .bss       :
+  {
+   *(.dynbss)
+   *(.bss)
+   *(.bss.*)
+   *(.gnu.linkonce.b.*)
+   *(COMMON)
+   /* Align here to ensure that the .bss section occupies space up to
+      _end.  Align after .bss to ensure correct alignment even if the
+      .bss section disappears because there are no input sections.  */
+   . = ALIGN(64 / 8);
+  }
+  . = ALIGN(64 / 8);
+  _end = .;
+  PROVIDE (end = .);
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info) *(.gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+  /* These must appear regardless of  .  */
+}
diff -I '.*' -Naur releng8/sys/conf/options.mips svn/mips/sys/conf/options.mips
--- releng8/src/sys/conf/options.mips	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/conf/options.mips	2009-08-04 10:46:57.000000000 -0700
@@ -31,8 +31,8 @@
 CPU_MIPS4KC	opt_global.h
 CPU_MIPS32	opt_global.h
 CPU_MIPS64	opt_global.h
-CPU_NOFPU	opt_global.h
 CPU_SENTRY5	opt_global.h
+CPU_HAVEFPU	opt_global.h
 
 ISA_MIPS1	opt_cputype.h
 ISA_MIPS3	opt_cputype.h
@@ -44,11 +44,12 @@
 YAMON		opt_global.h
 CFE		opt_global.h
 CFE_CONSOLE	opt_global.h
+CFE_ENV		opt_global.h
+CFE_ENV_SIZE	opt_global.h
 
 KERNPHYSADDR	opt_global.h
 KERNVIRTADDR	opt_global.h
 PHYSADDR	opt_global.h
-SOFTFLOAT	opt_global.h
 
 TARGET_OCTEON	opt_global.h
 TARGET_EMULATOR	opt_ddb.h
diff -I '.*' -Naur releng8/sys/dev/cfe/cfe_api.c svn/mips/sys/dev/cfe/cfe_api.c
--- releng8/src/sys/dev/cfe/cfe_api.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/dev/cfe/cfe_api.c	2009-08-04 10:47:08.000000000 -0700
@@ -160,7 +160,7 @@
 {
     cfe_xiocb_t xiocb;
 
-    xiocb.xiocb_fcode = CFE_CMD_ENV_SET;
+    xiocb.xiocb_fcode = CFE_CMD_ENV_ENUM;
     xiocb.xiocb_status = 0;
     xiocb.xiocb_handle = 0;
     xiocb.xiocb_flags = 0;
diff -I '.*' -Naur releng8/sys/dev/cfe/cfe_console.c svn/mips/sys/dev/cfe/cfe_console.c
--- releng8/src/sys/dev/cfe/cfe_console.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/dev/cfe/cfe_console.c	2009-08-04 10:47:08.000000000 -0700
@@ -84,14 +84,12 @@
 static void
 cn_drvinit(void *unused)
 {
-	char output[32];
 	struct tty *tp;
 
 	if (cfe_consdev.cn_pri != CN_DEAD &&
 	    cfe_consdev.cn_name[0] != '\0') {
 		tp = tty_alloc(&cfe_ttydevsw, NULL);
-		tty_makedev(tp, NULL, "%s", output);
-		tty_makealias(tp, "cfecons");
+		tty_makedev(tp, NULL, "cfecons");
 	}
 }
 
@@ -117,15 +115,21 @@
 static void
 cfe_tty_outwakeup(struct tty *tp)
 {
-	int len;
+	int len, written, rc;
 	u_char buf[CFEBURSTLEN];
 
 	for (;;) {
 		len = ttydisc_getc(tp, buf, sizeof buf);
 		if (len == 0)
 			break;
-		while (cfe_write(conhandle, buf, len) == 0)
-			continue;
+
+		written = 0;
+		while (written < len) {
+			rc = cfe_write(conhandle, &buf[written], len - written);
+			if (rc < 0)
+				break;
+			written += rc;
+		}
 	}
 }
 
@@ -184,13 +188,9 @@
 static int
 cfe_cngetc(struct consdev *cp)
 {
-	int result;
 	unsigned char ch;
 
-	while ((result = cfe_read(conhandle, &ch, 1)) == 0)
-		continue;
-
-	if (result > 0) {
+	if (cfe_read(conhandle, &ch, 1) == 1) {
 #if defined(KDB) && defined(ALT_BREAK_TO_DEBUGGER)
 		int kdb_brk;
 
diff -I '.*' -Naur releng8/sys/dev/cfe/cfe_env.c svn/mips/sys/dev/cfe/cfe_env.c
--- releng8/src/sys/dev/cfe/cfe_env.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/dev/cfe/cfe_env.c	2009-08-04 10:47:08.000000000 -0700
@@ -0,0 +1,74 @@
+/*-
+ * Copyright (c) 2009 Neelkanth Natu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+
+#include <dev/cfe/cfe_api.h>
+
+__FBSDID("$FreeBSD: projects/mips/sys/dev/cfe/cfe_env.c 195331 2009-07-04 02:49:17Z imp $");
+
+#ifndef	CFE_ENV_SIZE
+#define	CFE_ENV_SIZE	PAGE_SIZE	/* default is one page */
+#endif
+
+extern void cfe_env_init(void);
+
+static char cfe_env_buf[CFE_ENV_SIZE];
+
+void
+cfe_env_init(void)
+{
+	int idx, len;
+	char name[64], val[128], *cp, *cplim;
+
+	cp = cfe_env_buf;
+	cplim = cp + CFE_ENV_SIZE;
+
+	idx = 0;
+	while (1) {
+		if (cfe_enumenv(idx, name, sizeof(name), val, sizeof(val)) != 0)
+			break;
+
+		if (bootverbose)
+			printf("Importing CFE env: \"%s=%s\"\n", name, val);
+
+		/*
+		 * name=val\0\0
+		 */
+		len = strlen(name) + 1 + strlen(val) + 1 + 1;
+		if (cplim - cp < len)
+			printf("No space to store CFE env: \"%s=%s\"\n",
+				name, val);
+		else
+			cp += sprintf(cp, "%s=%s", name, val) + 1;
+		++idx;
+	}
+	*cp++ = '\0';
+
+	kern_envp = cfe_env_buf;
+}
diff -I '.*' -Naur releng8/sys/dev/flash/mx25l.c svn/mips/sys/dev/flash/mx25l.c
--- releng8/src/sys/dev/flash/mx25l.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/dev/flash/mx25l.c	2009-05-26 09:40:44.000000000 -0700
@@ -0,0 +1,313 @@
+/*-
+ * Copyright (c) 2006 M. Warner Losh.  All rights reserved.
+ * Copyright (c) 2009 Oleksandr Tymoshenko.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bio.h>
+#include <sys/bus.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/kthread.h>
+#include <sys/lock.h>
+#include <sys/mbuf.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/mutex.h>
+#include <geom/geom_disk.h>
+
+#include <dev/spibus/spi.h>
+#include "spibus_if.h"
+
+#include <dev/flash/mx25lreg.h>
+
+struct mx25l_flash_ident
+{
+	const char	*name;
+	uint8_t		manufacturer_id;
+	uint16_t	device_id;
+	unsigned int	sectorsize;
+	unsigned int	sectorcount;
+};
+
+struct mx25l_softc 
+{
+	device_t	sc_dev;
+	uint8_t		sc_manufacturer_id;
+	uint16_t	sc_device_id;
+	struct mtx	sc_mtx;
+	struct disk	*sc_disk;
+	struct proc	*sc_p;
+	struct bio_queue_head sc_bio_queue;
+};
+
+#define M25PXX_LOCK(_sc)		mtx_lock(&(_sc)->sc_mtx)
+#define	M25PXX_UNLOCK(_sc)		mtx_unlock(&(_sc)->sc_mtx)
+#define M25PXX_LOCK_INIT(_sc) \
+	mtx_init(&_sc->sc_mtx, device_get_nameunit(_sc->sc_dev), \
+	    "mx25l", MTX_DEF)
+#define M25PXX_LOCK_DESTROY(_sc)	mtx_destroy(&_sc->sc_mtx);
+#define M25PXX_ASSERT_LOCKED(_sc)	mtx_assert(&_sc->sc_mtx, MA_OWNED);
+#define M25PXX_ASSERT_UNLOCKED(_sc) mtx_assert(&_sc->sc_mtx, MA_NOTOWNED);
+
+/* disk routines */
+static int mx25l_open(struct disk *dp);
+static int mx25l_close(struct disk *dp);
+static int mx25l_ioctl(struct disk *, u_long, void *, int, struct thread *);
+static void mx25l_strategy(struct bio *bp);
+static void mx25l_task(void *arg);
+
+struct mx25l_flash_ident flash_devices[] = {
+	{ "mx25ll32",  0xc2, 0x2016, 64 * 1024,  64 },
+	{ "mx25ll64",  0xc2, 0x2017, 64 * 1024, 128 },
+	{ "mx25ll128", 0xc2, 0x2018, 64 * 1024, 256 },
+};
+
+static uint8_t
+mx25l_get_status(device_t dev)
+{
+	uint8_t txBuf[2], rxBuf[2];
+	struct spi_command cmd;
+	int err;
+
+	memset(&cmd, 0, sizeof(cmd));
+	memset(txBuf, 0, sizeof(txBuf));
+	memset(rxBuf, 0, sizeof(rxBuf));
+
+	txBuf[0] = CMD_READ_STATUS;
+	cmd.tx_cmd = txBuf;
+	cmd.rx_cmd = rxBuf;
+	cmd.rx_cmd_sz = 2;
+	cmd.tx_cmd_sz = 2;
+	err = SPIBUS_TRANSFER(device_get_parent(dev), dev, &cmd);
+	return (rxBuf[1]);
+}
+
+static void
+mx25l_wait_for_device_ready(device_t dev)
+{
+	while ((mx25l_get_status(dev) & STATUS_WIP))
+		continue;
+}
+
+static struct mx25l_flash_ident*
+mx25l_get_device_ident(struct mx25l_softc *sc)
+{
+	device_t dev = sc->sc_dev;
+	uint8_t txBuf[8], rxBuf[8];
+	struct spi_command cmd;
+	uint8_t manufacturer_id;
+	uint16_t dev_id;
+	int err, i;
+
+	memset(&cmd, 0, sizeof(cmd));
+	memset(txBuf, 0, sizeof(txBuf));
+	memset(rxBuf, 0, sizeof(rxBuf));
+
+	txBuf[0] = CMD_READ_IDENT;
+	cmd.tx_cmd = &txBuf;
+	cmd.rx_cmd = &rxBuf;
+	/*
+	 * Some compatible devices has extended two-bytes ID
+	 * We'll use only manufacturer/deviceid atm
+	 */
+	cmd.tx_cmd_sz = 4;
+	cmd.rx_cmd_sz = 4;
+	err = SPIBUS_TRANSFER(device_get_parent(dev), dev, &cmd);
+	if (err)
+		return (NULL);
+
+	manufacturer_id = rxBuf[1];
+	dev_id = (rxBuf[2] << 8) | (rxBuf[3]);
+
+	for (i = 0; 
+	    i < sizeof(flash_devices)/sizeof(struct mx25l_flash_ident); i++) {
+		if ((flash_devices[i].manufacturer_id == manufacturer_id) &&
+		    (flash_devices[i].device_id == dev_id))
+			return &flash_devices[i];
+	}
+
+	printf("Unknown SPI flash device. Vendor: %02x, device id: %04x\n",
+	    manufacturer_id, dev_id);
+	return (NULL);
+}
+
+static int
+mx25l_probe(device_t dev)
+{
+	device_set_desc(dev, "M25Pxx Flash Family");
+	return (0);
+}
+
+static int
+mx25l_attach(device_t dev)
+{
+	struct mx25l_softc *sc;
+	struct mx25l_flash_ident *ident;
+
+	sc = device_get_softc(dev);
+	sc->sc_dev = dev;
+	M25PXX_LOCK_INIT(sc);
+
+	ident = mx25l_get_device_ident(sc);
+	if (ident == NULL)
+		return (ENXIO);
+
+	mx25l_wait_for_device_ready(sc->sc_dev);
+
+	sc->sc_disk = disk_alloc();
+	sc->sc_disk->d_open = mx25l_open;
+	sc->sc_disk->d_close = mx25l_close;
+	sc->sc_disk->d_strategy = mx25l_strategy;
+	sc->sc_disk->d_ioctl = mx25l_ioctl;
+	sc->sc_disk->d_name = "flash/spi";
+	sc->sc_disk->d_drv1 = sc;
+	sc->sc_disk->d_maxsize = DFLTPHYS;
+	sc->sc_disk->d_sectorsize = ident->sectorsize;
+	sc->sc_disk->d_mediasize = ident->sectorsize * ident->sectorcount;
+	sc->sc_disk->d_unit = device_get_unit(sc->sc_dev);
+	sc->sc_disk->d_dump = NULL;		/* NB: no dumps */
+
+        /* NB: use stripesize to hold the erase/region size for RedBoot */
+	sc->sc_disk->d_stripesize = ident->sectorsize;
+
+	disk_create(sc->sc_disk, DISK_VERSION);
+	bioq_init(&sc->sc_bio_queue);
+
+	kproc_create(&mx25l_task, sc, &sc->sc_p, 0, 0, "task: mx25l flash");
+	device_printf(sc->sc_dev, "%s, sector %d bytes, %d sectors\n", 
+	    ident->name, ident->sectorsize, ident->sectorcount);
+
+	return (0);
+}
+
+static int
+mx25l_detach(device_t dev)
+{
+
+	return (EIO);
+}
+
+static int
+mx25l_open(struct disk *dp)
+{
+	return (0);
+}
+
+static int
+mx25l_close(struct disk *dp)
+{
+
+	return (0);
+}
+
+static int
+mx25l_ioctl(struct disk *dp, u_long cmd, void *data, int fflag,
+	struct thread *td)
+{
+
+	return (EINVAL);
+}
+
+
+static void
+mx25l_strategy(struct bio *bp)
+{
+	struct mx25l_softc *sc;
+
+	sc = (struct mx25l_softc *)bp->bio_disk->d_drv1;
+	M25PXX_LOCK(sc);
+	bioq_disksort(&sc->sc_bio_queue, bp);
+	wakeup(sc);
+	M25PXX_UNLOCK(sc);
+}
+
+static void
+mx25l_task(void *arg)
+{
+	struct mx25l_softc *sc = (struct mx25l_softc*)arg;
+	struct bio *bp;
+	uint8_t txBuf[8], rxBuf[8];
+	struct spi_command cmd;
+	device_t dev, pdev;
+
+	for (;;) {
+		dev = sc->sc_dev;
+		pdev = device_get_parent(dev);
+		M25PXX_LOCK(sc);
+		do {
+			bp = bioq_first(&sc->sc_bio_queue);
+			if (bp == NULL)
+				msleep(sc, &sc->sc_mtx, PRIBIO, "jobqueue", 0);
+		} while (bp == NULL);
+		bioq_remove(&sc->sc_bio_queue, bp);
+		M25PXX_UNLOCK(sc);
+
+		if (bp->bio_cmd == BIO_READ) {
+			txBuf[0] = CMD_FAST_READ;
+			cmd.tx_cmd_sz = 5;
+			cmd.rx_cmd_sz = 5;
+
+			txBuf[1] = (((bp->bio_offset) >> 16) & 0xff);
+			txBuf[2] = (((bp->bio_offset) >> 8) & 0xff);
+			txBuf[3] = ((bp->bio_offset) & 0xff);
+			/* Dummy byte */
+			txBuf[4] = 0;
+
+			cmd.tx_cmd = txBuf;
+			cmd.rx_cmd = rxBuf;
+			cmd.tx_data = bp->bio_data;
+			cmd.tx_data_sz = bp->bio_bcount;
+			cmd.rx_data = bp->bio_data;
+			cmd.rx_data_sz = bp->bio_bcount;
+			bp->bio_error = SPIBUS_TRANSFER(pdev, dev, &cmd);
+		}
+		else
+			bp->bio_error = EINVAL;
+
+		biodone(bp);
+	}
+}
+
+static devclass_t mx25l_devclass;
+
+static device_method_t mx25l_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		mx25l_probe),
+	DEVMETHOD(device_attach,	mx25l_attach),
+	DEVMETHOD(device_detach,	mx25l_detach),
+
+	{ 0, 0 }
+};
+
+static driver_t mx25l_driver = {
+	"mx25l",
+	mx25l_methods,
+	sizeof(struct mx25l_softc),
+};
+
+DRIVER_MODULE(mx25l, spibus, mx25l_driver, mx25l_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/dev/flash/mx25lreg.h svn/mips/sys/dev/flash/mx25lreg.h
--- releng8/src/sys/dev/flash/mx25lreg.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/dev/flash/mx25lreg.h	2009-05-26 09:40:44.000000000 -0700
@@ -0,0 +1,56 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __MX25LREG_H__
+#define __MX25LREG_H__
+
+/*
+ * Commands 
+ */
+#define CMD_WRITE_ENABLE	0x06
+#define CMD_WRITE_DISABLE	0x04
+#define CMD_READ_IDENT		0x9F
+#define CMD_READ_STATUS		0x05
+#define CMD_WRITE_STATUS	0x01
+#define CMD_READ		0x03
+#define CMD_FAST_READ		0x0B
+#define CMD_PAGE_PROGRAM	0x02
+#define CMD_SECTOR_ERASE	0xD8
+#define CMD_BULK_ERASE		0xC7
+
+/*
+ * Status register flags
+ */
+#define	STATUS_SRWD	(1 << 7)
+#define	STATUS_BP2	(1 << 4)
+#define	STATUS_BP1	(1 << 3)
+#define	STATUS_BP0	(1 << 2)
+#define	STATUS_WEL	(1 << 1)
+#define	STATUS_WIP	(1 << 0)
+
+#endif /* __MX25LREG_H__ */
+
diff -I '.*' -Naur releng8/sys/dev/siba/siba_cc.c svn/mips/sys/dev/siba/siba_cc.c
--- releng8/src/sys/dev/siba/siba_cc.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/dev/siba/siba_cc.c	2009-04-14 15:53:59.000000000 -0700
@@ -0,0 +1,154 @@
+/*-
+ * Copyright (c) 2007 Bruce M. Simpson.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Child driver for ChipCommon core.
+ * This is not MI code at the moment.
+ * Two 16C550 compatible UARTs live here. On the WGT634U, uart1 is the
+ * system console, and uart0 is not pinned out.
+ *  Because their presence is conditional, they should probably
+ *  be attached from here.
+ * GPIO lives here.
+ * The hardware watchdog lives here.
+ * Clock control registers live here.
+ *  You don't need to read them to determine the clock speed on the 5365,
+ *  which is always 200MHz and thus may be hardcoded (for now).
+ * Flash config registers live here. There may or may not be system flash.
+ * The external interface bus lives here (conditionally).
+ * There is a JTAG interface here which may be used to attach probes to
+ * the SoC for debugging.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/dev/siba/siba_cc.c 191079 2009-04-14 22:53:22Z gonzo $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h>
+
+#include <dev/siba/sibavar.h>
+#include <dev/siba/sibareg.h>
+#include <dev/siba/siba_ids.h>
+
+static int	siba_cc_attach(device_t);
+static int	siba_cc_probe(device_t);
+static void	siba_cc_intr(void *v);
+
+static int
+siba_cc_probe(device_t dev)
+{
+
+	if (siba_get_vendor(dev) == SIBA_VID_BROADCOM &&
+	    siba_get_device(dev) == SIBA_DEVID_CHIPCOMMON) {
+		device_set_desc(dev, "ChipCommon core");
+		return (BUS_PROBE_DEFAULT);
+	}
+
+	return (ENXIO);
+}
+
+struct siba_cc_softc {
+	void *notused;
+};
+
+static int
+siba_cc_attach(device_t dev)
+{
+	//struct siba_cc_softc *sc = device_get_softc(dev);
+	struct resource *mem;
+	struct resource *irq;
+	int rid;
+
+	/*
+	 * Allocate the resources which the parent bus has already
+	 * determined for us.
+	 * TODO: interrupt routing
+	 */
+#define MIPS_MEM_RID 0x20
+	rid = MIPS_MEM_RID;
+	mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid, RF_ACTIVE);
+	if (mem == NULL) {
+		device_printf(dev, "unable to allocate memory\n");
+		return (ENXIO);
+	}
+
+	rid = 0;
+	irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid, 0);
+	if (irq == NULL) {
+		device_printf(dev, "unable to allocate irq\n");
+		return (ENXIO);
+	}
+
+	/* now setup the interrupt */
+	/* may be fast, exclusive or mpsafe at a later date */
+
+	/*
+	 * XXX is this interrupt line in ChipCommon used for anything
+	 * other than the uart? in that case we shouldn't hog it ourselves
+	 * and let uart claim it to avoid polled mode.
+	 */
+	int err;
+	void *cookie;
+	err = bus_setup_intr(dev, irq, INTR_TYPE_TTY, NULL, siba_cc_intr, NULL,
+	    &cookie);
+	if (err != 0) {
+		device_printf(dev, "unable to setup intr\n");
+		return (ENXIO);
+	}
+
+	/* TODO: attach uart child */
+
+	return (0);
+}
+
+static void
+siba_cc_intr(void *v)
+{
+
+}
+
+static device_method_t siba_cc_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_attach,	siba_cc_attach),
+	DEVMETHOD(device_probe,		siba_cc_probe),
+
+	{0, 0},
+};
+
+static driver_t siba_cc_driver = {
+	"siba_cc",
+	siba_cc_methods,
+	sizeof(struct siba_softc),
+};
+static devclass_t siba_cc_devclass;
+
+DRIVER_MODULE(siba_cc, siba, siba_cc_driver, siba_cc_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/dev/siba/siba_mips.c svn/mips/sys/dev/siba/siba_mips.c
--- releng8/src/sys/dev/siba/siba_mips.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/dev/siba/siba_mips.c	2009-04-14 15:53:59.000000000 -0700
@@ -0,0 +1,113 @@
+/*-
+ * Copyright (c) 2007 Bruce M. Simpson.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Child driver for MIPS 3302 core.
+ * Interrupt controller registers live here. Interrupts may not be routed
+ * to the MIPS core if they are masked out.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/dev/siba/siba_mips.c 191079 2009-04-14 22:53:22Z gonzo $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h>
+
+#include <dev/siba/sibavar.h>
+#include <dev/siba/sibareg.h>
+#include <dev/siba/siba_ids.h>
+
+static int	siba_mips_attach(device_t);
+static int	siba_mips_probe(device_t);
+
+static int
+siba_mips_probe(device_t dev)
+{
+
+	if (siba_get_vendor(dev) == SIBA_VID_BROADCOM &&
+	    siba_get_device(dev) == SIBA_DEVID_MIPS_3302) {
+		device_set_desc(dev, "MIPS 3302 processor");
+		return (BUS_PROBE_DEFAULT);
+	}
+
+	return (ENXIO);
+}
+
+struct siba_mips_softc {
+	void *notused;
+};
+
+static int
+siba_mips_attach(device_t dev)
+{
+	//struct siba_mips_softc *sc = device_get_softc(dev);
+	struct resource *mem;
+	int rid;
+
+	/*
+	 * Allocate the resources which the parent bus has already
+	 * determined for us.
+	 * TODO: interrupt routing
+	 */
+#define MIPS_MEM_RID 0x20
+	rid = MIPS_MEM_RID;
+	mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid,
+	    RF_ACTIVE);
+	if (mem == NULL) {
+		device_printf(dev, "unable to allocate memory\n");
+		return (ENXIO);
+	}
+#if 0
+	device_printf(dev, "start %08lx size %04lx\n",
+	    rman_get_start(mem), rman_get_size(mem));
+#endif
+
+	return (0);
+}
+
+static device_method_t siba_mips_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_attach,	siba_mips_attach),
+	DEVMETHOD(device_probe,		siba_mips_probe),
+
+	{0, 0},
+};
+
+static driver_t siba_mips_driver = {
+	"siba_mips",
+	siba_mips_methods,
+	sizeof(struct siba_softc),
+};
+static devclass_t siba_mips_devclass;
+
+DRIVER_MODULE(siba_mips, siba, siba_mips_driver, siba_mips_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/dev/siba/siba_sdram.c svn/mips/sys/dev/siba/siba_sdram.c
--- releng8/src/sys/dev/siba/siba_sdram.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/dev/siba/siba_sdram.c	2009-04-14 15:53:59.000000000 -0700
@@ -0,0 +1,114 @@
+/*-
+ * Copyright (c) 2007 Bruce M. Simpson.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Child driver for SDRAM/DDR controller core.
+ * Generally the OS should not need to access this device unless the
+ * firmware has not configured the SDRAM controller.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/dev/siba/siba_sdram.c 191079 2009-04-14 22:53:22Z gonzo $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h>
+
+#include <dev/siba/sibavar.h>
+#include <dev/siba/sibareg.h>
+#include <dev/siba/siba_ids.h>
+
+static int	siba_sdram_attach(device_t);
+static int	siba_sdram_probe(device_t);
+
+static int
+siba_sdram_probe(device_t dev)
+{
+
+	if (siba_get_vendor(dev) == SIBA_VID_BROADCOM &&
+	    siba_get_device(dev) == SIBA_DEVID_SDRAMDDR) {
+		device_set_desc(dev, "SDRAM/DDR core");
+		return (BUS_PROBE_DEFAULT);
+	}
+
+	return (ENXIO);
+}
+
+struct siba_sdram_softc {
+	void *notused;
+};
+
+static int
+siba_sdram_attach(device_t dev)
+{
+	//struct siba_sdram_softc *sc = device_get_softc(dev);
+	struct resource *mem;
+	int rid;
+
+	/*
+	 * Allocate the resources which the parent bus has already
+	 * determined for us.
+	 * TODO: interrupt routing
+	 */
+#define MIPS_MEM_RID 0x20
+	rid = MIPS_MEM_RID;
+	mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid,
+	    RF_ACTIVE);
+	if (mem == NULL) {
+		device_printf(dev, "unable to allocate memory\n");
+		return (ENXIO);
+	}
+
+#if 0
+	device_printf(dev, "start %08lx size %04lx\n",
+	    rman_get_start(mem), rman_get_size(mem));
+#endif
+
+	return (0);
+}
+
+static device_method_t siba_sdram_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_attach,	siba_sdram_attach),
+	DEVMETHOD(device_probe,		siba_sdram_probe),
+
+	{0, 0},
+};
+
+static driver_t siba_sdram_driver = {
+	"siba_sdram",
+	siba_sdram_methods,
+	sizeof(struct siba_softc),
+};
+static devclass_t siba_sdram_devclass;
+
+DRIVER_MODULE(siba_sdram, siba, siba_sdram_driver, siba_sdram_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/adm5120/obio.c svn/mips/sys/mips/adm5120/obio.c
--- releng8/src/sys/mips/adm5120/obio.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/adm5120/obio.c	2009-05-26 09:40:41.000000000 -0700
@@ -120,6 +120,39 @@
 static int	obio_teardown_intr(device_t, device_t, struct resource *,
 		    void *);
 
+
+static void 
+obio_mask_irq(void *source)
+{
+	int irq;
+	uint32_t irqmask;
+	uint32_t reg;
+
+	irq = (int)source;
+	irqmask = 1 << irq;
+
+	/* disable IRQ */
+	reg = REG_READ(ICU_DISABLE_REG);
+	REG_WRITE(ICU_DISABLE_REG, (reg | irqmask));
+}
+
+static void 
+obio_unmask_irq(void *source)
+{
+	int irq;
+	uint32_t irqmask;
+	uint32_t reg;
+
+	irq = (int)source;
+	irqmask = 1 << irq;
+
+	/* disable IRQ */
+	reg = REG_READ(ICU_DISABLE_REG);
+	REG_WRITE(ICU_DISABLE_REG, (reg & ~irqmask));
+
+}
+
+
 static int
 obio_probe(device_t dev)
 {
@@ -269,7 +302,7 @@
 
 		vaddr = (void *)MIPS_PHYS_TO_KSEG1((intptr_t)rman_get_start(r));
 		rman_set_virtual(r, vaddr);
-		rman_set_bustag(r, MIPS_BUS_SPACE_MEM);
+		rman_set_bustag(r, mips_bus_space_generic);
 		rman_set_bushandle(r, (bus_space_handle_t)vaddr);
 	}
 
@@ -321,7 +354,7 @@
 	event = sc->sc_eventstab[irq];
 	if (event == NULL) {
 		error = intr_event_create(&event, (void *)irq, 0, irq,
-		    (mask_fn)mips_mask_irq, (mask_fn)mips_unmask_irq,
+		    obio_mask_irq, obio_unmask_irq,
 		    NULL, NULL, "obio intr%d:", irq);
 
 		sc->sc_eventstab[irq] = event;
@@ -343,6 +376,8 @@
 	/* enable */
 	REG_WRITE(ICU_ENABLE_REG, irqmask);
 
+	obio_unmask_irq((void*)irq);
+
 	return (0);
 }
 
@@ -351,7 +386,7 @@
     void *cookie)
 {
 	struct obio_softc *sc = device_get_softc(dev);
-	int irq, result;
+	int irq, result, priority;
 	uint32_t irqmask;
 
 	irq = rman_get_start(ires);
@@ -361,10 +396,18 @@
 	if (sc->sc_eventstab[irq] == NULL)
 		panic("Trying to teardown unoccupied IRQ");
 
-	irqmask = 1 << irq;     /* only used as a mask from here on */
+	irqmask = (1 << irq);
+	priority = irq_priorities[irq];
 
-	/* disable this irq in HW */
-	REG_WRITE(ICU_DISABLE_REG, irqmask);
+	if (priority == INTR_FIQ)
+		REG_WRITE(ICU_MODE_REG, REG_READ(ICU_MODE_REG) & ~irqmask);
+	else
+		REG_WRITE(ICU_MODE_REG, REG_READ(ICU_MODE_REG) | irqmask);
+
+	/* disable */
+	irqmask = REG_READ(ICU_ENABLE_REG);
+	irqmask &= ~(1 << irq);
+	REG_WRITE(ICU_ENABLE_REG, irqmask);
 
 	result = intr_event_remove_handler(cookie);
 	if (!result) {
diff -I '.*' -Naur releng8/sys/mips/adm5120/uart_cpu_adm5120.c svn/mips/sys/mips/adm5120/uart_cpu_adm5120.c
--- releng8/src/sys/mips/adm5120/uart_cpu_adm5120.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/adm5120/uart_cpu_adm5120.c	2009-05-06 14:57:15.000000000 -0700
@@ -67,7 +67,7 @@
 
 	di->ops = uart_getops(&uart_adm5120_uart_class);
 	di->bas.chan = 0;
-	di->bas.bst = 0;
+	di->bas.bst = mips_bus_space_generic;
 	di->bas.regshft = 0;
 	di->bas.rclk = 0;
 	di->baudrate = 115200;
@@ -76,7 +76,7 @@
 	di->parity = UART_PARITY_NONE;
 
 	uart_bus_space_io = 0;
-	uart_bus_space_mem = MIPS_PHYS_TO_KSEG1(ADM5120_BASE_UART0);
+	uart_bus_space_mem = mips_bus_space_generic;
 	di->bas.bsh = MIPS_PHYS_TO_KSEG1(ADM5120_BASE_UART0);
 
 	return (0);
diff -I '.*' -Naur releng8/sys/mips/alchemy/alchemy_machdep.c svn/mips/sys/mips/alchemy/alchemy_machdep.c
--- releng8/src/sys/mips/alchemy/alchemy_machdep.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/alchemy/alchemy_machdep.c	2009-04-14 15:53:59.000000000 -0700
@@ -0,0 +1,157 @@
+/*-
+ * Copyright (C) 2007 by Oleksandr Tymoshenko. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/alchemy/alchemy_machdep.c 191079 2009-04-14 22:53:22Z gonzo $");
+
+#include "opt_ddb.h"
+
+#include <sys/param.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/imgact.h>
+#include <sys/bio.h>
+#include <sys/buf.h>
+#include <sys/bus.h>
+#include <sys/cpu.h>
+#include <sys/cons.h>
+#include <sys/exec.h>
+#include <sys/ucontext.h>
+#include <sys/proc.h>
+#include <sys/kdb.h>
+#include <sys/ptrace.h>
+#include <sys/reboot.h>
+#include <sys/signalvar.h>
+#include <sys/sysent.h>
+#include <sys/sysproto.h>
+#include <sys/user.h>
+
+#include <vm/vm.h>
+#include <vm/vm_object.h>
+#include <vm/vm_page.h>
+#include <vm/vm_pager.h>
+
+#include <machine/cache.h>
+#include <machine/clock.h>
+#include <machine/cpu.h>
+#include <machine/cpuinfo.h>
+#include <machine/cpufunc.h>
+#include <machine/cpuregs.h>
+#include <machine/hwfunc.h>
+#include <machine/intr_machdep.h>
+#include <machine/locore.h>
+#include <machine/md_var.h>
+#include <machine/pte.h>
+#include <machine/sigframe.h>
+#include <machine/trap.h>
+#include <machine/vmparam.h>
+
+extern int	*edata;
+extern int	*end;
+
+static void
+mips_init(void)
+{
+	int i;
+
+	printf("entry: mips_init()\n");
+
+	bootverbose = 1;
+	realmem = btoc(16 << 20);
+
+	for (i = 0; i < 10; i++) {
+		phys_avail[i] = 0;
+	}
+
+	/* phys_avail regions are in bytes */
+	phys_avail[0] = MIPS_KSEG0_TO_PHYS((vm_offset_t)&end);
+	phys_avail[1] = ctob(realmem);
+
+	physmem = realmem;
+
+	init_param1();
+	init_param2(physmem);
+	mips_cpu_init();
+	pmap_bootstrap();
+	mips_proc0_init();
+	mutex_init();
+#ifdef DDB
+	kdb_init();
+#endif
+}
+
+void
+platform_halt(void)
+{
+
+}
+
+
+void
+platform_identify(void)
+{
+
+}
+
+void
+platform_reset(void)
+{
+
+	__asm __volatile("li	$25, 0xbfc00000");
+	__asm __volatile("j	$25");
+}
+
+void
+platform_trap_enter(void)
+{
+
+}
+
+void
+platform_trap_exit(void)
+{
+
+}
+
+void
+platform_start(__register_t a0 __unused, __register_t a1 __unused, 
+    __register_t a2 __unused, __register_t a3 __unused)
+{
+	vm_offset_t kernend;
+	uint64_t platform_counter_freq = 175 * 1000 * 1000;
+
+	/* clear the BSS and SBSS segments */
+	kernend = round_page((vm_offset_t)&end);
+	memset(&edata, 0, kernend - (vm_offset_t)(&edata));
+
+	cninit();
+	mips_init();
+	/* Set counter_freq for tick_init_params() */
+	platform_counter_freq = 175 * 1000 * 1000;
+
+	mips_timer_init_params(platform_counter_freq, 0);
+}
diff -I '.*' -Naur releng8/sys/mips/alchemy/aureg.h svn/mips/sys/mips/alchemy/aureg.h
--- releng8/src/sys/mips/alchemy/aureg.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/alchemy/aureg.h	2009-04-14 15:39:43.000000000 -0700
@@ -0,0 +1,373 @@
+/* $NetBSD: aureg.h,v 1.18 2006/10/02 06:44:00 gdamore Exp $ */
+
+/*
+ * Copyright 2002 Wasabi Systems, Inc.
+ * All rights reserved.
+ *
+ * Written by Simon Burge for Wasabi Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed for the NetBSD Project by
+ *      Wasabi Systems, Inc.
+ * 4. The name of Wasabi Systems, Inc. may not be used to endorse
+ *    or promote products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	_MIPS_ALCHEMY_AUREG_H
+#define	_MIPS_ALCHEMY_AUREG_H
+
+/************************************************************************/
+/********************   AC97 Controller registers   *********************/
+/************************************************************************/
+#define	AC97_BASE		0x10000000
+
+/************************************************************************/
+/***********************   USB Host registers   *************************/
+/************************************************************************/
+#define	USBH_BASE		0x10100000
+#define	AU1550_USBH_BASE	0x14020000
+
+#define	USBH_ENABLE		0x7fffc
+#define	USBH_SIZE		0x100000
+
+#define	AU1550_USBH_ENABLE	0x7ffc
+#define AU1550_USBH_SIZE	0x60000
+
+/************************************************************************/
+/**********************   USB Device registers   ************************/
+/************************************************************************/
+#define	USBD_BASE		0x10200000
+
+/************************************************************************/
+/*************************   IRDA registers   ***************************/
+/************************************************************************/
+#define	IRDA_BASE		0x10300000
+
+/************************************************************************/
+/******************   Interrupt Controller registers   ******************/
+/************************************************************************/
+
+#define	IC0_BASE		0x10400000
+#define	IC1_BASE		0x11800000
+
+/*
+ * The *_READ registers read the current value of the register
+ * The *_SET registers set to 1 all bits that are written 1
+ * The *_CLEAR registers clear to zero all bits that are written as 1
+ */
+#define	IC_CONFIG0_READ			0x40	/* See table below */
+#define	IC_CONFIG0_SET			0x40
+#define	IC_CONFIG0_CLEAR		0x44
+
+#define	IC_CONFIG1_READ			0x48	/* See table below */
+#define	IC_CONFIG1_SET			0x48
+#define	IC_CONFIG1_CLEAR		0x4c
+
+#define	IC_CONFIG2_READ			0x50	/* See table below */
+#define	IC_CONFIG2_SET			0x50
+#define	IC_CONFIG2_CLEAR		0x54
+
+#define	IC_REQUEST0_INT			0x54	/* Show active interrupts on request 0 */
+
+#define	IC_SOURCE_READ			0x58	/* Interrupt source */
+#define	IC_SOURCE_SET			0x58	/*  0 - test bit used as source */
+#define	IC_SOURCE_CLEAR			0x5c	/*  1 - peripheral/GPIO used as source */
+
+#define	IC_REQUEST1_INT			0x5c	/* Show active interrupts on request 1 */
+
+#define	IC_ASSIGN_REQUEST_READ		0x60	/* Assigns the interrupt to one of the */
+#define	IC_ASSIGN_REQUEST_SET		0x60	/* CPU requests (0 - assign to request 1, */
+#define	IC_ASSIGN_REQUEST_CLEAR		0x64	/* 1 - assign to request 0) */
+
+#define	IC_WAKEUP_READ			0x68	/* Controls whether the interrupt can */
+#define	IC_WAKEUP_SET			0x68	/* cause a wakeup from IDLE */
+#define	IC_WAKEUP_CLEAR			0x6c
+
+#define	IC_MASK_READ			0x70	/* Enables/Disables the interrupt */
+#define	IC_MASK_SET			0x70
+#define	IC_MASK_CLEAR			0x74
+
+#define	IC_RISING_EDGE			0x78	/* Check/clear rising edge */
+
+#define	IC_FALLING_EDGE			0x7c	/* Check/clear falling edge */
+
+#define	IC_TEST_BIT			0x80	/* single bit source select */
+
+/*
+ *	Interrupt Configuration Register Functions
+ *
+ *	Cfg2[n]	Cfg1[n]	Cfg0[n]		Function
+ *	   0	   0	   0		Interrupts Disabled
+ *	   0	   0	   1		Rising Edge Enabled
+ *	   0	   1	   0		Falling Edge Enabled
+ *	   0	   1	   1		Rising and Falling Edge Enabled
+ *	   1	   0	   0		Interrupts Disabled
+ *	   1	   0	   1		High Level Enabled
+ *	   1	   1	   0		Low Level Enabled
+ *	   1	   1	   1		Both Levels and Both Edges Enabled
+ */
+
+/************************************************************************/
+/*************   Programable Serial Controller registers   **************/
+/************************************************************************/
+
+#define	PSC0_BASE		0x11A00000
+#define	PSC1_BASE		0x11B00000
+#define	PSC2_BASE		0x10A00000
+#define	PSC3_BASE		0x10B00000
+
+
+/************************************************************************/
+/**********************   Ethernet MAC registers   **********************/
+/************************************************************************/
+
+#define	MAC0_BASE		0x10500000
+#define	MAC1_BASE		0x10510000
+#define	MACx_SIZE		0x28
+
+#define	AU1500_MAC0_BASE	0x11500000	/* Grr, different on Au1500 */
+#define	AU1500_MAC1_BASE	0x11510000	/* Grr, different on Au1500 */
+
+#define	MAC0_ENABLE		0x10520000
+#define	MAC1_ENABLE		0x10520004
+#define	MACENx_SIZE		0x04
+
+#define	AU1500_MAC0_ENABLE	0x11520000	/* Grr, different on Au1500 */
+#define	AU1500_MAC1_ENABLE	0x11520004	/* Grr, different on Au1500 */
+
+#define	MAC0_DMA_BASE		0x14004000
+#define	MAC1_DMA_BASE		0x14004200
+#define	MACx_DMA_SIZE		0x140
+
+/************************************************************************/
+/**********************   Static Bus registers   ************************/
+/************************************************************************/
+#define	STATIC_BUS_BASE		0x14001000
+
+/************************************************************************/
+/********************   Secure Digital registers   **********************/
+/************************************************************************/
+#define	SD0_BASE		0x10600000
+#define	SD1_BASE		0x10680000
+
+/************************************************************************/
+/*************************   I^2S registers   ***************************/
+/************************************************************************/
+#define	I2S_BASE		0x11000000
+
+/************************************************************************/
+/**************************   UART registers   **************************/
+/************************************************************************/
+
+#define	UART0_BASE		0x11100000
+#define	UART1_BASE		0x11200000
+#define	UART2_BASE		0x11300000
+#define	UART3_BASE		0x11400000
+
+/************************************************************************/
+/*************************   SSI registers   ****************************/
+/************************************************************************/
+#define	SSI0_BASE		0x11600000
+#define	SSI1_BASE		0x11680000
+
+/************************************************************************/
+/************************   GPIO2 registers   ***************************/
+/************************************************************************/
+#define	GPIO_BASE		0x11900100
+
+/************************************************************************/
+/************************   GPIO2 registers   ***************************/
+/************************************************************************/
+#define	GPIO2_BASE		0x11700000
+
+/************************************************************************/
+/*************************   PCI registers   ****************************/
+/************************************************************************/
+#define	PCI_BASE		0x14005000
+#define	PCI_HEADER		0x14005100
+#define	PCI_MEM_BASE		0x400000000ULL
+#define	PCI_IO_BASE		0x500000000ULL
+#define	PCI_CONFIG_BASE		0x600000000ULL
+
+/************************************************************************/
+/***********************   PCMCIA registers   ***************************/
+/************************************************************************/
+#define	PCMCIA_BASE		0xF00000000ULL
+
+/************************************************************************/
+/******************   Programmable Counter registers   ******************/
+/************************************************************************/
+
+#define	SYS_BASE		0x11900000
+
+#define	PC_BASE			SYS_BASE
+
+#define	PC_TRIM0		0x00		/* PC0 Divide (16 bits) */
+#define	PC_COUNTER_WRITE0	0x04		/* set PC0 */
+#define	PC_MATCH0_0		0x08		/* match counter & interrupt */
+#define	PC_MATCH1_0		0x0c		/* match counter & interrupt */
+#define	PC_MATCH2_0		0x10		/* match counter & interrupt */
+#define	PC_COUNTER_CONTROL	0x14		/* Programmable Counter Control */
+#define	  CC_E1S		  0x00800000	/* Enable PC1 write status */
+#define	  CC_T1S		  0x00100000	/* Trim PC1 write status */
+#define	  CC_M21		  0x00080000	/* Match 2 of PC1 write status */
+#define	  CC_M11		  0x00040000	/* Match 1 of PC1 write status */
+#define	  CC_M01		  0x00020000	/* Match 0 of PC1 write status */
+#define	  CC_C1S		  0x00010000	/* PC1 write status */
+#define	  CC_BP			  0x00004000	/* Bypass OSC (use GPIO1) */
+#define	  CC_EN1		  0x00002000	/* Enable PC1 */
+#define	  CC_BT1		  0x00001000	/* Bypass Trim on PC1 */
+#define	  CC_EN0		  0x00000800	/* Enable PC0 */
+#define	  CC_BT0		  0x00000400	/* Bypass Trim on PC0 */
+#define	  CC_EO			  0x00000100	/* Enable Oscillator */
+#define	  CC_E0S		  0x00000080	/* Enable PC0 write status */
+#define	  CC_32S		  0x00000020	/* 32.768kHz OSC status */
+#define	  CC_T0S		  0x00000010	/* Trim PC0 write status */
+#define	  CC_M20		  0x00000008	/* Match 2 of PC0 write status */
+#define	  CC_M10		  0x00000004	/* Match 1 of PC0 write status */
+#define	  CC_M00		  0x00000002	/* Match 0 of PC0 write status */
+#define	  CC_C0S		  0x00000001	/* PC0 write status */
+#define	PC_COUNTER_READ_0	0x40		/* get PC0 */
+#define	PC_TRIM1		0x44		/* PC1 Divide (16 bits) */
+#define	PC_COUNTER_WRITE1	0x48		/* set PC1 */
+#define	PC_MATCH0_1		0x4c		/* match counter & interrupt */
+#define	PC_MATCH1_1		0x50		/* match counter & interrupt */
+#define	PC_MATCH2_1		0x54		/* match counter & interrupt */
+#define	PC_COUNTER_READ_1	0x58		/* get PC1 */
+
+#define	PC_SIZE			0x5c		/* size of register set */
+#define	PC_RATE			32768		/* counter rate is 32.768kHz */
+
+/************************************************************************/
+/*******************   Frequency Generator Registers   ******************/
+/************************************************************************/
+
+#define SYS_FREQCTRL0		(SYS_BASE + 0x20)
+#define SFC_FRDIV2(f)		(f<<22)		/* 29:22. Freq Divider 2 */
+#define SFC_FE2			(1<<21)		/* Freq generator output enable 2 */
+#define SFC_FS2			(1<<20)		/* Freq generator source 2 */
+#define SFC_FRDIV1(f)		(f<<12)		/* 19:12. Freq Divider 1 */
+#define SFC_FE1			(1<<11)		/* Freq generator output enable 1 */
+#define SFC_FS1			(1<<10)		/* Freq generator source 1 */
+#define SFC_FRDIV0(f)		(f<<2)		/* 9:2. Freq Divider 0 */
+#define SFC_FE0			2		/* Freq generator output enable 0 */
+#define SFC_FS0			1		/* Freq generator source 0 */
+
+#define SYS_FREQCTRL1		(SYS_BASE + 0x24)
+#define SFC_FRDIV5(f)		(f<<22)		/* 29:22. Freq Divider 5 */
+#define SFC_FE5			(1<<21)		/* Freq generator output enable 5 */
+#define SFC_FS5			(1<<20)		/* Freq generator source 5 */
+#define SFC_FRDIV4(f)		(f<<12)		/* 19:12. Freq Divider 4 */
+#define SFC_FE4			(1<<11)		/* Freq generator output enable 4 */
+#define SFC_FS4			(1<<10)		/* Freq generator source 4 */
+#define SFC_FRDIV3(f)		(f<<2)		/* 9:2. Freq Divider 3 */
+#define SFC_FE3			2		/* Freq generator output enable 3 */
+#define SFC_FS3			1		/* Freq generator source 3 */
+
+/************************************************************************/
+/******************   Clock Source Control Registers   ******************/
+/************************************************************************/
+
+#define SYS_CLKSRC		(SYS_BASE + 0x28)
+#define  SCS_ME1(n)		(n<<27)		/* EXTCLK1 Clock Mux input select */
+#define  SCS_ME0(n)		(n<<22)		/* EXTCLK0 Clock Mux input select */
+#define  SCS_MPC(n)		(n<<17)		/* PCI clock mux input select */
+#define  SCS_MUH(n)		(n<<12)		/* USB Host clock mux input select */
+#define  SCS_MUD(n)		(n<<7)		/* USB Device clock mux input select */
+#define   SCS_MEx_AUX		0x1		/* Aux clock */
+#define   SCS_MEx_FREQ0		0x2		/* FREQ0 */
+#define   SCS_MEx_FREQ1		0x3		/* FREQ1 */
+#define   SCS_MEx_FREQ2		0x4		/* FREQ2 */
+#define   SCS_MEx_FREQ3		0x5		/* FREQ3 */
+#define   SCS_MEx_FREQ4		0x6		/* FREQ4 */
+#define   SCS_MEx_FREQ5		0x7		/* FREQ5 */
+#define  SCS_DE1		(1<<26)		/* EXTCLK1 clock divider select */
+#define  SCS_CE1		(1<<25)		/* EXTCLK1 clock select */
+#define  SCS_DE0		(1<<21)		/* EXTCLK0 clock divider select */
+#define  SCS_CE0		(1<<20)		/* EXTCLK0 clock select */
+#define  SCS_DPC		(1<<16)		/* PCI clock divider select */
+#define  SCS_CPC		(1<<15)		/* PCI clock select */
+#define  SCS_DUH		(1<<11)		/* USB Host clock divider select */
+#define  SCS_CUH		(1<<10)		/* USB Host clock select */
+#define  SCS_DUD		(1<<6)		/* USB Device clock divider select */
+#define  SCS_CUD		(1<<5)		/* USB Device clock select */
+/*
+ * Au1550 bits, needed for PSCs. Note that some bits collide with
+ * earlier parts.  On Au1550, USB clocks (both device and host) are
+ * shared with PSC2, and must be configured for 48MHz.  DBAU1550 YAMON
+ * does this by default.  Also, EXTCLK0 is shared with PSC3.  DBAU1550
+ * YAMON does not configure any clocks besides PSC2.
+ */
+#define  SCS_MP3(n)		(n<<22)		/* psc3_intclock mux */
+#define	 SCS_DP3		(1<<21)		/* psc3_intclock divider */
+#define	 SCS_CP3		(1<<20)		/* psc3_intclock select */
+#define  SCS_MP1(n)		(n<<12)		/* psc1_intclock mux */
+#define	 SCS_DP1		(1<<11)		/* psc1_intclock divider */
+#define	 SCS_CP1		(1<<10)		/* psc1_intclock select */
+#define	 SCS_MP0(n)		(n<<7)		/* psc0_intclock mux */
+#define  SCS_DP0		(1<<6)		/* psc0_intclock divider */
+#define	 SCS_CP0		(1<<5)		/* psc0_intclock seelct */
+#define	 SCS_MP2(n)		(n<<2)		/* psc2_intclock mux */
+#define	 SCS_DP2		(1<<1)		/* psc2_intclock divider */
+#define	 SCS_CP2		(1<<0)		/* psc2_intclock select */
+
+/************************************************************************/
+/***************************  PIN Function  *****************************/
+/************************************************************************/
+
+#define	SYS_PINFUNC		(SYS_BASE + 0x2c)
+#define	 SPF_PSC3_MASK		(7<<20)
+#define	 SPF_PSC3_AC97		(0<<17)		/* select AC97/SPI */
+#define	 SPF_PSC3_I2S		(1<<17)		/* select I2S */
+#define	 SPF_PSC3_SMBUS		(3<<17)		/* select SMbus */
+#define	 SPF_PSC3_GPIO		(7<<17)		/* select gpio215:211 */
+#define  SPF_PSC2_MASK		(7<<17)
+#define	 SPF_PSC2_AC97		(0<<17)		/* select AC97/SPI */
+#define	 SPF_PSC2_I2S		(1<<17)		/* select I2S */
+#define	 SPF_PSC2_SMBUS		(3<<17)		/* select SMbus */
+#define	 SPF_PSC2_GPIO		(7<<17)		/* select gpio210:206*/
+#define	 SPF_CS			(1<<16)		/* extclk0 or 32kHz osc */
+#define	 SPF_USB		(1<<15)		/* host or device usb otg */
+#define	 SPF_U3T		(1<<14)		/* uart3 tx or gpio23 */
+#define	 SPF_U1R		(1<<13)		/* uart1 rx or gpio22 */
+#define	 SPF_U1T		(1<<12)		/* uart1 tx or gpio21 */
+#define	 SPF_EX1		(1<<10)		/* gpio3 or extclk1 */
+#define	 SPF_EX0		(1<<9)		/* gpio2 or extclk0/32kHz osc*/
+#define	 SPF_U3			(1<<7)		/* gpio14:9 or uart3 */
+#define	 SPF_MBSa		(1<<5)		/* must be set */
+#define	 SPF_NI2		(1<<4)		/* enet1 or gpio28:24 */
+#define	 SPF_U0			(1<<3)		/* uart0 or gpio20 */
+#define	 SPF_MBSb		(1<<2)		/* must be set */
+#define	 SPF_S1			(1<<1)		/* gpio17 or psc1_sync1 */
+#define	 SPF_S0			(1<<0)		/* gpio16 or psc0_sync1 */
+
+/************************************************************************/
+/***************************   PLL Control  *****************************/
+/************************************************************************/
+
+#define SYS_CPUPLL		(SYS_BASE + 0x60)
+#define SYS_AUXPLL              (SYS_BASE + 0x64)
+
+#endif	/* _MIPS_ALCHEMY_AUREG_H */
diff -I '.*' -Naur releng8/sys/mips/alchemy/files.alchemy svn/mips/sys/mips/alchemy/files.alchemy
--- releng8/src/sys/mips/alchemy/files.alchemy	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/alchemy/files.alchemy	2009-04-14 15:39:43.000000000 -0700
@@ -0,0 +1,7 @@
+# $FreeBSD$
+# Alchmy on-board devices
+# mips/alchemy/console.c		standard
+mips/alchemy/alchemy_machdep.c	standard
+mips/alchemy/obio.c		standard
+mips/alchemy/uart_bus_alchemy.c	optional uart
+mips/alchemy/uart_cpu_alchemy.c	optional uart
diff -I '.*' -Naur releng8/sys/mips/alchemy/obio.c svn/mips/sys/mips/alchemy/obio.c
--- releng8/src/sys/mips/alchemy/obio.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/alchemy/obio.c	2009-05-06 14:57:15.000000000 -0700
@@ -0,0 +1,501 @@
+/*	$NetBSD: obio.c,v 1.11 2003/07/15 00:25:05 lukem Exp $	*/
+
+/*-
+ * Copyright (c) 2001, 2002, 2003 Wasabi Systems, Inc.
+ * All rights reserved.
+ *
+ * Written by Jason R. Thorpe for Wasabi Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed for the NetBSD Project by
+ *	Wasabi Systems, Inc.
+ * 4. The name of Wasabi Systems, Inc. may not be used to endorse
+ *    or promote products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/alchemy/obio.c 191282 2009-04-19 22:02:14Z gonzo $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/interrupt.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h>
+
+#include <mips/adm5120/adm5120reg.h>
+#include <mips/adm5120/obiovar.h>
+
+/* MIPS HW interrupts of IRQ/FIQ respectively */
+#define ADM5120_INTR		0
+#define ADM5120_FAST_INTR	1
+
+/* Interrupt levels */
+#define INTR_IRQ 0
+#define INTR_FIQ 1
+
+int irq_priorities[NIRQS] = {
+	INTR_IRQ,	/* flash */
+	INTR_FIQ,	/* uart0 */
+	INTR_FIQ,	/* uart1 */
+	INTR_IRQ,	/* ahci  */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* admsw */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+	INTR_IRQ,	/* unknown */
+};
+
+
+#define REG_READ(o) *((volatile uint32_t *)MIPS_PHYS_TO_KSEG1(ADM5120_BASE_ICU + (o)))
+#define REG_WRITE(o,v) (REG_READ(o)) = (v)
+
+static int	obio_activate_resource(device_t, device_t, int, int,
+		    struct resource *);
+static device_t	obio_add_child(device_t, int, const char *, int);
+static struct resource *
+		obio_alloc_resource(device_t, device_t, int, int *, u_long,
+		    u_long, u_long, u_int);
+static int	obio_attach(device_t);
+static int	obio_deactivate_resource(device_t, device_t, int, int,
+		    struct resource *);
+static struct resource_list *
+		obio_get_resource_list(device_t, device_t);
+static void	obio_hinted_child(device_t, const char *, int);
+static int	obio_intr(void *);
+static int	obio_probe(device_t);
+static int	obio_release_resource(device_t, device_t, int, int,
+		    struct resource *);
+static int	obio_setup_intr(device_t, device_t, struct resource *, int,
+		    driver_filter_t *, driver_intr_t *, void *, void **);
+static int	obio_teardown_intr(device_t, device_t, struct resource *,
+		    void *);
+
+static int
+obio_probe(device_t dev)
+{
+
+	return (0);
+}
+
+static int
+obio_attach(device_t dev)
+{
+	struct obio_softc *sc = device_get_softc(dev);
+	int rid;
+
+	sc->oba_mem_rman.rm_type = RMAN_ARRAY;
+	sc->oba_mem_rman.rm_descr = "OBIO memeory";
+	if (rman_init(&sc->oba_mem_rman) != 0 ||
+	    rman_manage_region(&sc->oba_mem_rman, OBIO_MEM_START,
+	        OBIO_MEM_START + OBIO_MEM_SIZE) != 0)
+		panic("obio_attach: failed to set up I/O rman");
+
+	sc->oba_irq_rman.rm_type = RMAN_ARRAY;
+	sc->oba_irq_rman.rm_descr = "OBIO IRQ";
+
+	if (rman_init(&sc->oba_irq_rman) != 0 ||
+	    rman_manage_region(&sc->oba_irq_rman, 0, NIRQS-1) != 0)
+		panic("obio_attach: failed to set up IRQ rman");
+
+	/* Hook up our interrupt handler. */
+	if ((sc->sc_irq = bus_alloc_resource(dev, SYS_RES_IRQ, &rid,
+	    ADM5120_INTR, ADM5120_INTR, 1,
+	    RF_SHAREABLE | RF_ACTIVE)) == NULL) {
+		device_printf(dev, "unable to allocate IRQ resource\n");
+		return (ENXIO);
+	}
+
+	if ((bus_setup_intr(dev, sc->sc_irq, INTR_TYPE_MISC, obio_intr, NULL,
+	    sc, &sc->sc_ih))) {
+		device_printf(dev,
+		    "WARNING: unable to register interrupt handler\n");
+		return (ENXIO);
+	}
+
+	/* Hook up our FAST interrupt handler. */
+	if ((sc->sc_fast_irq = bus_alloc_resource(dev, SYS_RES_IRQ, &rid,
+	    ADM5120_FAST_INTR, ADM5120_FAST_INTR, 1,
+	    RF_SHAREABLE | RF_ACTIVE)) == NULL) {
+		device_printf(dev, "unable to allocate IRQ resource\n");
+		return (ENXIO);
+	}
+
+	if ((bus_setup_intr(dev, sc->sc_fast_irq, INTR_TYPE_MISC, obio_intr,
+	    NULL, sc, &sc->sc_fast_ih))) {
+		device_printf(dev,
+		    "WARNING: unable to register interrupt handler\n");
+		return (ENXIO);
+	}
+
+	/* disable all interrupts */
+	REG_WRITE(ICU_ENABLE_REG, ICU_INT_MASK);
+
+	bus_generic_probe(dev);
+	bus_enumerate_hinted_children(dev);
+	bus_generic_attach(dev);
+
+	return (0);
+}
+
+static struct resource *
+obio_alloc_resource(device_t bus, device_t child, int type, int *rid,
+    u_long start, u_long end, u_long count, u_int flags)
+{
+	struct obio_softc		*sc = device_get_softc(bus);
+	struct obio_ivar		*ivar = device_get_ivars(child);
+	struct resource			*rv;
+	struct resource_list_entry	*rle;
+	struct rman			*rm;
+	int				 isdefault, needactivate, passthrough;
+
+	isdefault = (start == 0UL && end == ~0UL && count == 1);
+	needactivate = flags & RF_ACTIVE;
+	passthrough = (device_get_parent(child) != bus);
+	rle = NULL;
+
+	if (passthrough)
+		return (BUS_ALLOC_RESOURCE(device_get_parent(bus), child, type,
+		    rid, start, end, count, flags));
+
+	/*
+	 * If this is an allocation of the "default" range for a given RID,
+	 * and we know what the resources for this device are (ie. they aren't
+	 * maintained by a child bus), then work out the start/end values.
+	 */
+	if (isdefault) {
+		rle = resource_list_find(&ivar->resources, type, *rid);
+		if (rle == NULL)
+			return (NULL);
+		if (rle->res != NULL) {
+			panic("%s: resource entry is busy", __func__);
+		}
+		start = rle->start;
+		end = rle->end;
+		count = rle->count;
+	}
+
+	switch (type) {
+	case SYS_RES_IRQ:
+		rm = &sc->oba_irq_rman;
+		break;
+	case SYS_RES_MEMORY:
+		rm = &sc->oba_mem_rman;
+		break;
+	default:
+		printf("%s: unknown resource type %d\n", __func__, type);
+		return (0);
+	}
+
+	rv = rman_reserve_resource(rm, start, end, count, flags, child);
+	if (rv == 0) {
+		printf("%s: could not reserve resource\n", __func__);
+		return (0);
+	}
+
+	rman_set_rid(rv, *rid);
+
+	if (needactivate) {
+		if (bus_activate_resource(child, type, *rid, rv)) {
+			printf("%s: could not activate resource\n", __func__);
+			rman_release_resource(rv);
+			return (0);
+		}
+	}
+
+	return (rv);
+}
+
+static int
+obio_activate_resource(device_t bus, device_t child, int type, int rid,
+    struct resource *r)
+{
+
+	/*
+	 * If this is a memory resource, track the direct mapping
+	 * in the uncached MIPS KSEG1 segment.
+	 */
+	if (type == SYS_RES_MEMORY) {
+		void *vaddr;
+
+		vaddr = (void *)MIPS_PHYS_TO_KSEG1((intptr_t)rman_get_start(r));
+		rman_set_virtual(r, vaddr);
+		rman_set_bustag(r, mips_bus_space_generic);
+		rman_set_bushandle(r, (bus_space_handle_t)vaddr);
+	}
+
+	return (rman_activate_resource(r));
+}
+
+static int
+obio_deactivate_resource(device_t bus, device_t child, int type, int rid,
+    struct resource *r)
+{
+
+	return (rman_deactivate_resource(r));
+}
+
+static int
+obio_release_resource(device_t dev, device_t child, int type,
+    int rid, struct resource *r)
+{
+	struct resource_list *rl;
+	struct resource_list_entry *rle;
+
+	rl = obio_get_resource_list(dev, child);
+	if (rl == NULL)
+		return (EINVAL);
+	rle = resource_list_find(rl, type, rid);
+	if (rle == NULL)
+		return (EINVAL);
+	rman_release_resource(r);
+	rle->res = NULL;
+
+	return (0);
+}
+
+static int
+obio_setup_intr(device_t dev, device_t child, struct resource *ires,
+		int flags, driver_filter_t *filt, driver_intr_t *handler,
+		void *arg, void **cookiep)
+{
+	struct obio_softc *sc = device_get_softc(dev);
+	struct intr_event *event;
+	int irq, error, priority;
+	uint32_t irqmask;
+
+	irq = rman_get_start(ires);
+
+	if (irq >= NIRQS)
+		panic("%s: bad irq %d", __func__, irq);
+
+	event = sc->sc_eventstab[irq];
+	if (event == NULL) {
+		error = intr_event_create(&event, (void *)irq, 0, irq,
+		    (mask_fn)mips_mask_irq, (mask_fn)mips_unmask_irq,
+		    NULL, NULL, "obio intr%d:", irq);
+
+		sc->sc_eventstab[irq] = event;
+	}
+	else
+		panic("obio: Can't share IRQs");
+
+	intr_event_add_handler(event, device_get_nameunit(child), filt,
+	    handler, arg, intr_priority(flags), flags, cookiep);
+
+	irqmask = 1 << irq;
+	priority = irq_priorities[irq];
+
+	if (priority == INTR_FIQ)
+		REG_WRITE(ICU_MODE_REG, REG_READ(ICU_MODE_REG) | irqmask);
+	else
+		REG_WRITE(ICU_MODE_REG, REG_READ(ICU_MODE_REG) & ~irqmask);
+
+	/* enable */
+	REG_WRITE(ICU_ENABLE_REG, irqmask);
+
+	return (0);
+}
+
+static int
+obio_teardown_intr(device_t dev, device_t child, struct resource *ires,
+    void *cookie)
+{
+	struct obio_softc *sc = device_get_softc(dev);
+	int irq, result;
+	uint32_t irqmask;
+
+	irq = rman_get_start(ires);
+	if (irq >= NIRQS)
+		panic("%s: bad irq %d", __func__, irq);
+
+	if (sc->sc_eventstab[irq] == NULL)
+		panic("Trying to teardown unoccupied IRQ");
+
+	irqmask = 1 << irq;     /* only used as a mask from here on */
+
+	/* disable this irq in HW */
+	REG_WRITE(ICU_DISABLE_REG, irqmask);
+
+	result = intr_event_remove_handler(cookie);
+	if (!result) {
+		sc->sc_eventstab[irq] = NULL;
+	}
+
+	return (result);
+}
+
+static int
+obio_intr(void *arg)
+{
+	struct obio_softc *sc = arg;
+	struct intr_event *event;
+	uint32_t irqstat;
+	int irq;
+
+	irqstat = REG_READ(ICU_FIQ_STATUS_REG);
+	irqstat |= REG_READ(ICU_STATUS_REG);
+
+	irq = 0;
+	while (irqstat != 0) {
+		if ((irqstat & 1) == 1) {
+			event = sc->sc_eventstab[irq];
+			if (!event || TAILQ_EMPTY(&event->ie_handlers))
+				continue;
+
+			/* TODO: pass frame as an argument*/
+			/* TODO: log stray interrupt */
+			intr_event_handle(event, NULL);
+		}
+
+		irq++;
+		irqstat >>= 1;
+	}
+
+	return (FILTER_HANDLED);
+}
+
+static void
+obio_hinted_child(device_t bus, const char *dname, int dunit)
+{
+	device_t		child;
+	long			maddr;
+	int			msize;
+	int			irq;
+	int			result;
+
+	child = BUS_ADD_CHILD(bus, 0, dname, dunit);
+
+	/*
+	 * Set hard-wired resources for hinted child using
+	 * specific RIDs.
+	 */
+	resource_long_value(dname, dunit, "maddr", &maddr);
+	resource_int_value(dname, dunit, "msize", &msize);
+
+
+	result = bus_set_resource(child, SYS_RES_MEMORY, 0,
+	    maddr, msize);
+	if (result != 0)
+		device_printf(bus, "warning: bus_set_resource() failed\n");
+
+	if (resource_int_value(dname, dunit, "irq", &irq) == 0) {
+		result = bus_set_resource(child, SYS_RES_IRQ, 0, irq, 1);
+		if (result != 0)
+			device_printf(bus,
+			    "warning: bus_set_resource() failed\n");
+	}
+}
+
+static device_t
+obio_add_child(device_t bus, int order, const char *name, int unit)
+{
+	device_t		child;
+	struct obio_ivar	*ivar;
+
+	ivar = malloc(sizeof(struct obio_ivar), M_DEVBUF, M_WAITOK | M_ZERO);
+	if (ivar == NULL) {
+		printf("Failed to allocate ivar\n");
+		return (0);
+	}
+	resource_list_init(&ivar->resources);
+
+	child = device_add_child_ordered(bus, order, name, unit);
+	if (child == NULL) {
+		printf("Can't add child %s%d ordered\n", name, unit);
+		return (0);
+	}
+
+	device_set_ivars(child, ivar);
+
+	return (child);
+}
+
+/*
+ * Helper routine for bus_generic_rl_get_resource/bus_generic_rl_set_resource
+ * Provides pointer to resource_list for these routines
+ */
+static struct resource_list *
+obio_get_resource_list(device_t dev, device_t child)
+{
+	struct obio_ivar *ivar;
+
+	ivar = device_get_ivars(child);
+	return (&(ivar->resources));
+}
+
+static device_method_t obio_methods[] = {
+	DEVMETHOD(bus_activate_resource,	obio_activate_resource),
+	DEVMETHOD(bus_add_child,		obio_add_child),
+	DEVMETHOD(bus_alloc_resource,		obio_alloc_resource),
+	DEVMETHOD(bus_deactivate_resource,	obio_deactivate_resource),
+	DEVMETHOD(bus_get_resource_list,	obio_get_resource_list),
+	DEVMETHOD(bus_hinted_child,		obio_hinted_child),
+	DEVMETHOD(bus_release_resource,		obio_release_resource),
+	DEVMETHOD(bus_setup_intr,		obio_setup_intr),
+	DEVMETHOD(bus_teardown_intr,		obio_teardown_intr),
+	DEVMETHOD(device_attach,		obio_attach),
+	DEVMETHOD(device_probe,			obio_probe),
+        DEVMETHOD(bus_get_resource,		bus_generic_rl_get_resource),
+        DEVMETHOD(bus_set_resource,		bus_generic_rl_set_resource),
+
+	{0, 0},
+};
+
+static driver_t obio_driver = {
+	"obio",
+	obio_methods,
+	sizeof(struct obio_softc),
+};
+static devclass_t obio_devclass;
+
+DRIVER_MODULE(obio, nexus, obio_driver, obio_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/alchemy/std.alchemy svn/mips/sys/mips/alchemy/std.alchemy
--- releng8/src/sys/mips/alchemy/std.alchemy	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/alchemy/std.alchemy	2009-04-14 15:39:43.000000000 -0700
@@ -0,0 +1,8 @@
+# $FreeBSD$
+# Standard include file for Alchemy Au1xxx CPUs: 
+# Au1000, Au1200, Au1250, Au1500 and Au1550
+
+files	"../alchemy/files.alchemy"
+
+cpu		CPU_MIPS4KC
+options		ISA_MIPS32
diff -I '.*' -Naur releng8/sys/mips/alchemy/uart_bus_alchemy.c svn/mips/sys/mips/alchemy/uart_bus_alchemy.c
--- releng8/src/sys/mips/alchemy/uart_bus_alchemy.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/alchemy/uart_bus_alchemy.c	2009-04-14 15:53:59.000000000 -0700
@@ -0,0 +1,87 @@
+/*-
+ * Copyright (c) 2007 Bruce M. Simpson.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * $Id$
+ */
+/*
+ * Skeleton of this file was based on respective code for ARM
+ * code written by Olivier Houchard.
+ */
+
+#include "opt_uart.h"
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/alchemy/uart_bus_alchemy.c 191079 2009-04-14 22:53:22Z gonzo $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <machine/bus.h>
+#include <sys/rman.h>
+#include <machine/resource.h>
+
+#include <dev/pci/pcivar.h>
+
+#include <dev/uart/uart.h>
+#include <dev/uart/uart_bus.h>
+#include <dev/uart/uart_cpu.h>
+
+#include <mips/alchemy/aureg.h>
+
+#include "uart_if.h"
+
+static int uart_alchemy_probe(device_t dev);
+
+static device_method_t uart_alchemy_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		uart_alchemy_probe),
+	DEVMETHOD(device_attach,	uart_bus_attach),
+	DEVMETHOD(device_detach,	uart_bus_detach),
+	{ 0, 0 }
+};
+
+static driver_t uart_alchemy_driver = {
+	uart_driver_name,
+	uart_alchemy_methods,
+	sizeof(struct uart_softc),
+};
+
+extern SLIST_HEAD(uart_devinfo_list, uart_devinfo) uart_sysdevs;
+
+static int
+uart_alchemy_probe(device_t dev)
+{
+	struct uart_softc *sc;
+
+	sc = device_get_softc(dev);
+	sc->sc_sysdev = SLIST_FIRST(&uart_sysdevs);
+	sc->sc_class = &uart_ns8250_class;
+	bcopy(&sc->sc_sysdev->bas, &sc->sc_bas, sizeof(sc->sc_bas));
+
+	return (uart_bus_probe(dev, 0, 0, 0, 0));
+}
+
+DRIVER_MODULE(uart, obio, uart_alchemy_driver, uart_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/alchemy/uart_cpu_alchemy.c svn/mips/sys/mips/alchemy/uart_cpu_alchemy.c
--- releng8/src/sys/mips/alchemy/uart_cpu_alchemy.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/alchemy/uart_cpu_alchemy.c	2009-05-06 14:57:15.000000000 -0700
@@ -0,0 +1,79 @@
+/*-
+ * Copyright (c) 2006 Wojciech A. Koszek <wkoszek@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Id$
+ */
+/*
+ * Skeleton of this file was based on respective code for ARM
+ * code written by Olivier Houchard.
+ */
+
+#include "opt_uart.h"
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/alchemy/uart_cpu_alchemy.c 191282 2009-04-19 22:02:14Z gonzo $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/cons.h>
+
+#include <machine/bus.h>
+
+#include <dev/uart/uart.h>
+#include <dev/uart/uart_cpu.h>
+
+#include <mips/alchemy/aureg.h>
+
+bus_space_tag_t uart_bus_space_io;
+bus_space_tag_t uart_bus_space_mem;
+
+int
+uart_cpu_eqres(struct uart_bas *b1, struct uart_bas *b2)
+{
+
+	return ((b1->bsh == b2->bsh && b1->bst == b2->bst) ? 1 : 0);
+}
+
+int
+uart_cpu_getdev(int devtype, struct uart_devinfo *di)
+{
+
+	di->ops = uart_getops(&uart_ns8250_class);
+	di->bas.chan = 0;
+	di->bas.bst = mips_bus_space_generic;
+	di->bas.regshft = 0;
+	di->bas.rclk = 0;
+	di->baudrate = 115200;
+	di->databits = 8;
+	di->stopbits = 1;
+	di->parity = UART_PARITY_NONE;
+
+	uart_bus_space_io = 0;
+	uart_bus_space_mem = mips_bus_space_generic;
+	di->bas.bsh = MIPS_PHYS_TO_KSEG1(UART0_BASE);
+
+	return (0);
+}
diff -I '.*' -Naur releng8/sys/mips/atheros/apb.c svn/mips/sys/mips/atheros/apb.c
--- releng8/src/sys/mips/atheros/apb.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/apb.c	2009-06-12 04:42:48.000000000 -0700
@@ -0,0 +1,453 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/interrupt.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h>
+
+#include <mips/atheros/apbvar.h>
+#include <mips/atheros/ar71xxreg.h>
+
+#undef APB_DEBUG
+#ifdef APB_DEBUG
+#define dprintf printf
+#else 
+#define dprintf(x, arg...)
+#endif  /* APB_DEBUG */
+
+static int	apb_activate_resource(device_t, device_t, int, int,
+		    struct resource *);
+static device_t	apb_add_child(device_t, int, const char *, int);
+static struct resource *
+		apb_alloc_resource(device_t, device_t, int, int *, u_long,
+		    u_long, u_long, u_int);
+static int	apb_attach(device_t);
+static int	apb_deactivate_resource(device_t, device_t, int, int,
+		    struct resource *);
+static struct resource_list *
+		apb_get_resource_list(device_t, device_t);
+static void	apb_hinted_child(device_t, const char *, int);
+static int	apb_intr(void *);
+static int	apb_probe(device_t);
+static int	apb_release_resource(device_t, device_t, int, int,
+		    struct resource *);
+static int	apb_setup_intr(device_t, device_t, struct resource *, int,
+		    driver_filter_t *, driver_intr_t *, void *, void **);
+static int	apb_teardown_intr(device_t, device_t, struct resource *,
+		    void *);
+
+static void 
+apb_mask_irq(void *source)
+{
+	unsigned int irq = (unsigned int)source;
+	uint32_t reg;
+
+	reg = ATH_READ_REG(AR71XX_MISC_INTR_MASK);
+	ATH_WRITE_REG(AR71XX_MISC_INTR_MASK, reg & ~(1 << irq));
+
+}
+
+static void 
+apb_unmask_irq(void *source)
+{
+	uint32_t reg;
+	unsigned int irq = (unsigned int)source;
+
+	reg = ATH_READ_REG(AR71XX_MISC_INTR_MASK);
+	ATH_WRITE_REG(AR71XX_MISC_INTR_MASK, reg | (1 << irq));
+}
+
+static int
+apb_probe(device_t dev)
+{
+
+	return (0);
+}
+
+static int
+apb_attach(device_t dev)
+{
+	struct apb_softc *sc = device_get_softc(dev);
+	int rid = 0;
+
+	device_set_desc(dev, "APB Bus bridge");
+
+	sc->apb_mem_rman.rm_type = RMAN_ARRAY;
+	sc->apb_mem_rman.rm_descr = "APB memory window";
+
+	if (rman_init(&sc->apb_mem_rman) != 0 ||
+	    rman_manage_region(&sc->apb_mem_rman, 
+			AR71XX_APB_BASE, 
+			AR71XX_APB_BASE + AR71XX_APB_SIZE - 1) != 0)
+		panic("apb_attach: failed to set up memory rman");
+
+	sc->apb_irq_rman.rm_type = RMAN_ARRAY;
+	sc->apb_irq_rman.rm_descr = "APB IRQ";
+
+	if (rman_init(&sc->apb_irq_rman) != 0 ||
+	    rman_manage_region(&sc->apb_irq_rman, 
+			APB_IRQ_BASE, APB_IRQ_END) != 0)
+		panic("apb_attach: failed to set up IRQ rman");
+
+	if ((sc->sc_misc_irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid, 
+	    RF_SHAREABLE | RF_ACTIVE)) == NULL) {
+		device_printf(dev, "unable to allocate IRQ resource\n");
+		return (ENXIO);
+	}
+
+	if ((bus_setup_intr(dev, sc->sc_misc_irq, INTR_TYPE_MISC, 
+	    apb_intr, NULL, sc, &sc->sc_misc_ih))) {
+		device_printf(dev,
+		    "WARNING: unable to register interrupt handler\n");
+		return (ENXIO);
+	}
+
+	bus_generic_probe(dev);
+	bus_enumerate_hinted_children(dev);
+	bus_generic_attach(dev);
+
+	return (0);
+}
+
+static struct resource *
+apb_alloc_resource(device_t bus, device_t child, int type, int *rid,
+    u_long start, u_long end, u_long count, u_int flags)
+{
+	struct apb_softc		*sc = device_get_softc(bus);
+	struct apb_ivar			*ivar = device_get_ivars(child);
+	struct resource			*rv;
+	struct resource_list_entry	*rle;
+	struct rman			*rm;
+	int				 isdefault, needactivate, passthrough;
+
+	isdefault = (start == 0UL && end == ~0UL);
+	needactivate = flags & RF_ACTIVE;
+	/*
+	 * Pass memory requests to nexus device
+	 */
+	passthrough = (device_get_parent(child) != bus);
+	rle = NULL;
+
+	dprintf("%s: entry (%p, %p, %d, %d, %p, %p, %ld, %d)\n",
+	    __func__, bus, child, type, *rid, (void *)(intptr_t)start,
+	    (void *)(intptr_t)end, count, flags);
+
+	if (passthrough)
+		return (BUS_ALLOC_RESOURCE(device_get_parent(bus), child, type,
+		    rid, start, end, count, flags));
+
+	/*
+	 * If this is an allocation of the "default" range for a given RID,
+	 * and we know what the resources for this device are (ie. they aren't
+	 * maintained by a child bus), then work out the start/end values.
+	 */
+
+	if (isdefault) {
+		rle = resource_list_find(&ivar->resources, type, *rid);
+		if (rle == NULL) {
+			return (NULL);
+		}
+
+		if (rle->res != NULL) {
+			panic("%s: resource entry is busy", __func__);
+		}
+		start = rle->start;
+		end = rle->end;
+		count = rle->count;
+
+		dprintf("%s: default resource (%p, %p, %ld)\n",
+		    __func__, (void *)(intptr_t)start,
+		    (void *)(intptr_t)end, count);
+	}
+
+	switch (type) {
+	case SYS_RES_IRQ:
+		rm = &sc->apb_irq_rman;
+		break;
+	case SYS_RES_MEMORY:
+		rm = &sc->apb_mem_rman;
+		break;
+	default:
+		printf("%s: unknown resource type %d\n", __func__, type);
+		return (0);
+	}
+
+	rv = rman_reserve_resource(rm, start, end, count, flags, child);
+	if (rv == 0) {
+		printf("%s: could not reserve resource\n", __func__);
+		return (0);
+	}
+
+	rman_set_rid(rv, *rid);
+
+	if (needactivate) {
+		if (bus_activate_resource(child, type, *rid, rv)) {
+			printf("%s: could not activate resource\n", __func__);
+			rman_release_resource(rv);
+			return (0);
+		}
+	}
+
+	return (rv);
+}
+
+static int
+apb_activate_resource(device_t bus, device_t child, int type, int rid,
+    struct resource *r)
+{
+
+	/* XXX: should we mask/unmask IRQ here? */
+	return (BUS_ACTIVATE_RESOURCE(device_get_parent(bus), child,
+		type, rid, r));
+}
+
+static int
+apb_deactivate_resource(device_t bus, device_t child, int type, int rid,
+    struct resource *r)
+{
+
+	/* XXX: should we mask/unmask IRQ here? */
+	return (BUS_DEACTIVATE_RESOURCE(device_get_parent(bus), child,
+		type, rid, r));
+}
+
+static int
+apb_release_resource(device_t dev, device_t child, int type,
+    int rid, struct resource *r)
+{
+	struct resource_list *rl;
+	struct resource_list_entry *rle;
+
+	rl = apb_get_resource_list(dev, child);
+	if (rl == NULL)
+		return (EINVAL);
+	rle = resource_list_find(rl, type, rid);
+	if (rle == NULL)
+		return (EINVAL);
+	rman_release_resource(r);
+	rle->res = NULL;
+
+	return (0);
+}
+
+static int
+apb_setup_intr(device_t bus, device_t child, struct resource *ires,
+		int flags, driver_filter_t *filt, driver_intr_t *handler,
+		void *arg, void **cookiep)
+{
+	struct apb_softc *sc = device_get_softc(bus);
+	struct intr_event *event;
+	int irq, error;
+
+	irq = rman_get_start(ires);
+
+	if (irq > APB_IRQ_END)
+		panic("%s: bad irq %d", __func__, irq);
+
+	event = sc->sc_eventstab[irq];
+	if (event == NULL) {
+		error = intr_event_create(&event, (void *)irq, 0, irq, 
+		    apb_mask_irq, apb_unmask_irq,
+		    NULL, NULL,
+		    "apb intr%d:", irq);
+
+		sc->sc_eventstab[irq] = event;
+	}
+
+	intr_event_add_handler(event, device_get_nameunit(child), filt,
+	    handler, arg, intr_priority(flags), flags, cookiep);
+
+	apb_unmask_irq((void*)irq);
+
+	return (0);
+}
+
+static int
+apb_teardown_intr(device_t dev, device_t child, struct resource *ires,
+    void *cookie)
+{
+	struct apb_softc *sc = device_get_softc(dev);
+	int irq, result;
+
+	irq = rman_get_start(ires);
+	if (irq > APB_IRQ_END)
+		panic("%s: bad irq %d", __func__, irq);
+
+	if (sc->sc_eventstab[irq] == NULL)
+		panic("Trying to teardown unoccupied IRQ");
+
+	apb_mask_irq((void*)irq);
+
+	result = intr_event_remove_handler(cookie);
+	if (!result)
+		sc->sc_eventstab[irq] = NULL;
+
+	return (result);
+}
+
+static int
+apb_intr(void *arg)
+{
+	struct apb_softc *sc = arg;
+	struct intr_event *event;
+	uint32_t reg, irq;
+
+	reg = ATH_READ_REG(AR71XX_MISC_INTR_STATUS);
+	for (irq = 0; irq < APB_NIRQS; irq++) {
+		if (reg & (1 << irq)) {
+			event = sc->sc_eventstab[irq];
+			if (!event || TAILQ_EMPTY(&event->ie_handlers)) {
+				/* Ignore timer interrupts */
+				if (irq != 0)
+					printf("Stray IRQ %d\n", irq);
+				continue;
+			}
+
+			/* TODO: frame instead of NULL? */
+			intr_event_handle(event, NULL);
+		}
+	}
+
+	return (FILTER_HANDLED);
+}
+
+static void
+apb_hinted_child(device_t bus, const char *dname, int dunit)
+{
+	device_t		child;
+	long			maddr;
+	int			msize;
+	int			irq;
+	int			result;
+	int			mem_hints_count;
+
+	child = BUS_ADD_CHILD(bus, 0, dname, dunit);
+
+	/*
+	 * Set hard-wired resources for hinted child using
+	 * specific RIDs.
+	 */
+	mem_hints_count = 0;
+	if (resource_long_value(dname, dunit, "maddr", &maddr) == 0)
+		mem_hints_count++;
+	if (resource_int_value(dname, dunit, "msize", &msize) == 0)
+		mem_hints_count++;
+
+	/* check if all info for mem resource has been provided */
+	if ((mem_hints_count > 0) && (mem_hints_count < 2)) {
+		printf("Either maddr or msize hint is missing for %s%d\n",
+		    dname, dunit);
+	} else if (mem_hints_count) {
+		result = bus_set_resource(child, SYS_RES_MEMORY, 0,
+		    maddr, msize);
+		if (result != 0)
+			device_printf(bus, 
+			    "warning: bus_set_resource() failed\n");
+	}
+
+	if (resource_int_value(dname, dunit, "irq", &irq) == 0) {
+		result = bus_set_resource(child, SYS_RES_IRQ, 0, irq, 1);
+		if (result != 0)
+			device_printf(bus,
+			    "warning: bus_set_resource() failed\n");
+	}
+}
+
+static device_t
+apb_add_child(device_t bus, int order, const char *name, int unit)
+{
+	device_t		child;
+	struct apb_ivar	*ivar;
+
+	ivar = malloc(sizeof(struct apb_ivar), M_DEVBUF, M_WAITOK | M_ZERO);
+	if (ivar == NULL) {
+		printf("Failed to allocate ivar\n");
+		return (0);
+	}
+	resource_list_init(&ivar->resources);
+
+	child = device_add_child_ordered(bus, order, name, unit);
+	if (child == NULL) {
+		printf("Can't add child %s%d ordered\n", name, unit);
+		return (0);
+	}
+
+	device_set_ivars(child, ivar);
+
+	return (child);
+}
+
+/*
+ * Helper routine for bus_generic_rl_get_resource/bus_generic_rl_set_resource
+ * Provides pointer to resource_list for these routines
+ */
+static struct resource_list *
+apb_get_resource_list(device_t dev, device_t child)
+{
+	struct apb_ivar *ivar;
+
+	ivar = device_get_ivars(child);
+	return (&(ivar->resources));
+}
+
+static device_method_t apb_methods[] = {
+	DEVMETHOD(bus_activate_resource,	apb_activate_resource),
+	DEVMETHOD(bus_add_child,		apb_add_child),
+	DEVMETHOD(bus_alloc_resource,		apb_alloc_resource),
+	DEVMETHOD(bus_deactivate_resource,	apb_deactivate_resource),
+	DEVMETHOD(bus_get_resource_list,	apb_get_resource_list),
+	DEVMETHOD(bus_hinted_child,		apb_hinted_child),
+	DEVMETHOD(bus_print_child,		bus_generic_print_child),
+	DEVMETHOD(bus_release_resource,		apb_release_resource),
+	DEVMETHOD(bus_setup_intr,		apb_setup_intr),
+	DEVMETHOD(bus_teardown_intr,		apb_teardown_intr),
+	DEVMETHOD(device_attach,		apb_attach),
+	DEVMETHOD(device_probe,			apb_probe),
+	DEVMETHOD(bus_get_resource,		bus_generic_rl_get_resource),
+	DEVMETHOD(bus_set_resource,		bus_generic_rl_set_resource),
+
+	{0, 0},
+};
+
+static driver_t apb_driver = {
+	"apb",
+	apb_methods,
+	sizeof(struct apb_softc),
+};
+static devclass_t apb_devclass;
+
+DRIVER_MODULE(apb, nexus, apb_driver, apb_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/atheros/apbvar.h svn/mips/sys/mips/atheros/apbvar.h
--- releng8/src/sys/mips/atheros/apbvar.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/apbvar.h	2009-05-06 14:57:15.000000000 -0700
@@ -0,0 +1,49 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _APBVAR_H_
+#define _APBVAR_H_
+
+#define	APB_IRQ_BASE		0
+#define	APB_IRQ_END		7
+#define	APB_NIRQS		8
+
+struct apb_softc {
+	struct rman		apb_irq_rman;
+	struct rman		apb_mem_rman;
+	/* IRQ events structs for child devices */
+	struct intr_event	*sc_eventstab[APB_NIRQS];	
+	/* Resources and cookies for MIPS CPU INTs */
+	struct resource		*sc_misc_irq;
+	void			*sc_misc_ih;
+};
+
+struct apb_ivar {
+	struct resource_list	resources;
+};
+
+#endif /* _APBVAR_H_ */
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_bus_space_reversed.c svn/mips/sys/mips/atheros/ar71xx_bus_space_reversed.c
--- releng8/src/sys/mips/atheros/ar71xx_bus_space_reversed.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_bus_space_reversed.c	2009-05-06 14:57:15.000000000 -0700
@@ -0,0 +1,181 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+
+#include <machine/bus.h>
+#include <mips/atheros/ar71xx_bus_space_reversed.h>
+
+static bs_r_1_proto(reversed);
+static bs_r_2_proto(reversed);
+static bs_w_1_proto(reversed);
+static bs_w_2_proto(reversed);
+
+/*
+ * Bus space that handles offsets in word for 1/2 bytes read/write access.
+ * Byte order of values is handled by device drivers itself. 
+ */
+static struct bus_space bus_space_reversed = {
+	/* cookie */
+	(void *) 0,
+
+	/* mapping/unmapping */
+	generic_bs_map,
+	generic_bs_unmap,
+	generic_bs_subregion,
+
+	/* allocation/deallocation */
+	NULL,
+	NULL,
+
+	/* barrier */
+	generic_bs_barrier,
+
+	/* read (single) */
+	reversed_bs_r_1,
+	reversed_bs_r_2,
+	generic_bs_r_4,
+	NULL,
+
+	/* read multiple */
+	generic_bs_rm_1,
+	generic_bs_rm_2,
+	generic_bs_rm_4,
+	NULL,
+
+	/* read region */
+	generic_bs_rr_1,
+	generic_bs_rr_2,
+	generic_bs_rr_4,
+	NULL,
+
+	/* write (single) */
+	reversed_bs_w_1,
+	reversed_bs_w_2,
+	generic_bs_w_4,
+	NULL,
+
+	/* write multiple */
+	generic_bs_wm_1,
+	generic_bs_wm_2,
+	generic_bs_wm_4,
+	NULL,
+
+	/* write region */
+	NULL,
+	generic_bs_wr_2,
+	generic_bs_wr_4,
+	NULL,
+
+	/* set multiple */
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+
+	/* set region */
+	NULL,
+	generic_bs_sr_2,
+	generic_bs_sr_4,
+	NULL,
+
+	/* copy */
+	NULL,
+	generic_bs_c_2,
+	NULL,
+	NULL,
+
+	/* read (single) stream */
+	generic_bs_r_1,
+	generic_bs_r_2,
+	generic_bs_r_4,
+	NULL,
+
+	/* read multiple stream */
+	generic_bs_rm_1,
+	generic_bs_rm_2,
+	generic_bs_rm_4,
+	NULL,
+
+	/* read region stream */
+	generic_bs_rr_1,
+	generic_bs_rr_2,
+	generic_bs_rr_4,
+	NULL,
+
+	/* write (single) stream */
+	generic_bs_w_1,
+	generic_bs_w_2,
+	generic_bs_w_4,
+	NULL,
+
+	/* write multiple stream */
+	generic_bs_wm_1,
+	generic_bs_wm_2,
+	generic_bs_wm_4,
+	NULL,
+
+	/* write region stream */
+	NULL,
+	generic_bs_wr_2,
+	generic_bs_wr_4,
+	NULL,
+};
+
+bus_space_tag_t ar71xx_bus_space_reversed = &bus_space_reversed;
+
+static uint8_t
+reversed_bs_r_1(void *t, bus_space_handle_t h, bus_size_t o)
+{
+
+	return readb(h + (o &~ 3) + (3 - (o & 3)));
+}
+
+static void
+reversed_bs_w_1(void *t, bus_space_handle_t h, bus_size_t o, u_int8_t v)
+{
+
+	writeb(h + (o &~ 3) + (3 - (o & 3)), v);
+}
+
+static uint16_t
+reversed_bs_r_2(void *t, bus_space_handle_t h, bus_size_t o)
+{
+
+	return readw(h + (o &~ 3) + (2 - (o & 3)));
+}
+
+static void
+reversed_bs_w_2(void *t, bus_space_handle_t h, bus_size_t o, uint16_t v)
+{
+
+	writew(h + (o &~ 3) + (2 - (o & 3)), v);
+}
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_bus_space_reversed.h svn/mips/sys/mips/atheros/ar71xx_bus_space_reversed.h
--- releng8/src/sys/mips/atheros/ar71xx_bus_space_reversed.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_bus_space_reversed.h	2009-05-06 14:57:15.000000000 -0700
@@ -0,0 +1,33 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __AR71XX_BUS_SPACE_REVERSEDH__
+#define __AR71XX_BUS_SPACE_REVERSEDH__
+
+extern bus_space_tag_t ar71xx_bus_space_reversed;
+
+#endif /* __AR71XX_BUS_SPACE_REVERSEDH__ */
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_ehci.c svn/mips/sys/mips/atheros/ar71xx_ehci.c
--- releng8/src/sys/mips/atheros/ar71xx_ehci.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_ehci.c	2009-09-08 11:01:51.000000000 -0700
@@ -0,0 +1,287 @@
+/*-
+ * Copyright (c) 2008 Sam Leffler.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * AR71XX attachment driver for the USB Enhanced Host Controller.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_bus.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+#include <sys/condvar.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+
+#include <machine/bus.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbdi.h>
+
+#include <dev/usb/usb_core.h>
+#include <dev/usb/usb_busdma.h>
+#include <dev/usb/usb_process.h>
+#include <dev/usb/usb_util.h>
+
+#include <dev/usb/usb_controller.h>
+#include <dev/usb/usb_bus.h>
+#include <dev/usb/controller/ehci.h>
+
+#include <mips/atheros/ar71xx_bus_space_reversed.h>
+
+#define EHCI_HC_DEVSTR		"AR71XX Integrated USB 2.0 controller"
+
+struct ar71xx_ehci_softc {
+	ehci_softc_t		base;	/* storage for EHCI code */
+};
+
+static device_attach_t ar71xx_ehci_attach;
+static device_detach_t ar71xx_ehci_detach;
+static device_shutdown_t ar71xx_ehci_shutdown;
+static device_suspend_t ar71xx_ehci_suspend;
+static device_resume_t ar71xx_ehci_resume;
+
+bs_r_1_proto(reversed);
+bs_w_1_proto(reversed);
+
+static int
+ar71xx_ehci_suspend(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+	int err;
+
+	err = bus_generic_suspend(self);
+	if (err)
+		return (err);
+	ehci_suspend(sc);
+	return (0);
+}
+
+static int
+ar71xx_ehci_resume(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+
+	ehci_resume(sc);
+
+	bus_generic_resume(self);
+
+	return (0);
+}
+
+static int
+ar71xx_ehci_shutdown(device_t self)
+{
+	ehci_softc_t *sc = device_get_softc(self);
+	int err;
+
+	err = bus_generic_shutdown(self);
+	if (err)
+		return (err);
+	ehci_shutdown(sc);
+
+	return (0);
+}
+
+static int
+ar71xx_ehci_probe(device_t self)
+{
+
+	device_set_desc(self, EHCI_HC_DEVSTR);
+
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int
+ar71xx_ehci_attach(device_t self)
+{
+	struct ar71xx_ehci_softc *isc = device_get_softc(self);
+	ehci_softc_t *sc = &isc->base;
+	int err;
+	int rid;
+
+	/* initialise some bus fields */
+	sc->sc_bus.parent = self;
+	sc->sc_bus.devices = sc->sc_devices;
+	sc->sc_bus.devices_max = EHCI_MAX_DEVICES;
+
+	/* get all DMA memory */
+	if (usb_bus_mem_alloc_all(&sc->sc_bus,
+	    USB_GET_DMA_TAG(self), &ehci_iterate_hw_softc)) {
+		return (ENOMEM);
+	}
+
+	sc->sc_bus.usbrev = USB_REV_2_0;
+
+	/* NB: hints fix the memory location and irq */
+
+	rid = 0;
+	sc->sc_io_res = bus_alloc_resource_any(self, SYS_RES_MEMORY, &rid, RF_ACTIVE);
+	if (!sc->sc_io_res) {
+		device_printf(self, "Could not map memory\n");
+		goto error;
+	}
+
+	/*
+	 * Craft special resource for bus space ops that handle
+	 * byte-alignment of non-word addresses.  
+	 */
+	sc->sc_io_tag = ar71xx_bus_space_reversed;
+	sc->sc_io_hdl = rman_get_bushandle(sc->sc_io_res);
+	sc->sc_io_size = rman_get_size(sc->sc_io_res);
+
+	rid = 0;
+	sc->sc_irq_res = bus_alloc_resource_any(self, SYS_RES_IRQ, &rid,
+	    RF_ACTIVE);
+	if (sc->sc_irq_res == NULL) {
+		device_printf(self, "Could not allocate irq\n");
+		goto error;
+	}
+	sc->sc_bus.bdev = device_add_child(self, "usbus", -1);
+	if (!sc->sc_bus.bdev) {
+		device_printf(self, "Could not add USB device\n");
+		goto error;
+	}
+	device_set_ivars(sc->sc_bus.bdev, &sc->sc_bus);
+	device_set_desc(sc->sc_bus.bdev, EHCI_HC_DEVSTR);
+
+	sprintf(sc->sc_vendor, "Atheros");
+
+
+	err = bus_setup_intr(self, sc->sc_irq_res, INTR_TYPE_BIO | INTR_MPSAFE,
+	    NULL, (driver_intr_t *)ehci_interrupt, sc, &sc->sc_intr_hdl);
+	if (err) {
+		device_printf(self, "Could not setup irq, %d\n", err);
+		sc->sc_intr_hdl = NULL;
+		goto error;
+	}
+
+	/*
+	 * Arrange to force Host mode, select big-endian byte alignment,
+	 * and arrange to not terminate reset operations (the adapter
+	 * will ignore it if we do but might as well save a reg write).
+	 * Also, the controller has an embedded Transaction Translator
+	 * which means port speed must be read from the Port Status
+	 * register following a port enable.
+	 */
+	sc->sc_flags = EHCI_SCFLG_SETMODE;
+	(void) ehci_reset(sc);
+
+	err = ehci_init(sc);
+	if (!err) {
+		err = device_probe_and_attach(sc->sc_bus.bdev);
+	}
+	if (err) {
+		device_printf(self, "USB init failed err=%d\n", err);
+		goto error;
+	}
+	return (0);
+
+error:
+	ar71xx_ehci_detach(self);
+	return (ENXIO);
+}
+
+static int
+ar71xx_ehci_detach(device_t self)
+{
+	struct ar71xx_ehci_softc *isc = device_get_softc(self);
+	ehci_softc_t *sc = &isc->base;
+	device_t bdev;
+	int err;
+
+ 	if (sc->sc_bus.bdev) {
+		bdev = sc->sc_bus.bdev;
+		device_detach(bdev);
+		device_delete_child(self, bdev);
+	}
+	/* during module unload there are lots of children leftover */
+	device_delete_all_children(self);
+
+	/*
+	 * disable interrupts that might have been switched on in ehci_init
+	 */
+	if (sc->sc_io_res) {
+		EWRITE4(sc, EHCI_USBINTR, 0);
+	}
+
+ 	if (sc->sc_irq_res && sc->sc_intr_hdl) {
+		/*
+		 * only call ehci_detach() after ehci_init()
+		 */
+		ehci_detach(sc);
+
+		err = bus_teardown_intr(self, sc->sc_irq_res, sc->sc_intr_hdl);
+
+		if (err)
+			/* XXX or should we panic? */
+			device_printf(self, "Could not tear down irq, %d\n",
+			    err);
+		sc->sc_intr_hdl = NULL;
+	}
+
+ 	if (sc->sc_irq_res) {
+		bus_release_resource(self, SYS_RES_IRQ, 0, sc->sc_irq_res);
+		sc->sc_irq_res = NULL;
+	}
+	if (sc->sc_io_res) {
+		bus_release_resource(self, SYS_RES_MEMORY, 0,
+		    sc->sc_io_res);
+		sc->sc_io_res = NULL;
+	}
+	usb_bus_mem_free_all(&sc->sc_bus, &ehci_iterate_hw_softc);
+
+	return (0);
+}
+
+static device_method_t ehci_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe, ar71xx_ehci_probe),
+	DEVMETHOD(device_attach, ar71xx_ehci_attach),
+	DEVMETHOD(device_detach, ar71xx_ehci_detach),
+	DEVMETHOD(device_suspend, ar71xx_ehci_suspend),
+	DEVMETHOD(device_resume, ar71xx_ehci_resume),
+	DEVMETHOD(device_shutdown, ar71xx_ehci_shutdown),
+
+	/* Bus interface */
+	DEVMETHOD(bus_print_child, bus_generic_print_child),
+
+	{0, 0}
+};
+
+static driver_t ehci_driver = {
+	"ehci",
+	ehci_methods,
+	sizeof(struct ar71xx_ehci_softc),
+};
+
+static devclass_t ehci_devclass;
+
+DRIVER_MODULE(ehci, nexus, ehci_driver, ehci_devclass, 0, 0);
+MODULE_DEPEND(ehci, usb, 1, 1, 1);
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_machdep.c svn/mips/sys/mips/atheros/ar71xx_machdep.c
--- releng8/src/sys/mips/atheros/ar71xx_machdep.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_machdep.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,211 @@
+/*-
+ * Copyright (c) 2009 Oleksandr Tymoshenko
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <machine/cpuregs.h>
+
+#include <mips/sentry5/s5reg.h>
+
+#include "opt_ddb.h"
+
+#include <sys/param.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/cons.h>
+#include <sys/kdb.h>
+
+#include <vm/vm.h>
+#include <vm/vm_page.h>
+
+#include <net/ethernet.h>
+
+#include <machine/clock.h>
+#include <machine/cpu.h>
+#include <machine/hwfunc.h>
+#include <machine/md_var.h>
+#include <machine/trap.h>
+#include <machine/vmparam.h>
+
+#include <mips/atheros/ar71xxreg.h>
+
+extern int *edata;
+extern int *end;
+uint32_t ar711_base_mac[ETHER_ADDR_LEN];
+
+void
+platform_halt(void)
+{
+
+}
+
+void
+platform_identify(void)
+{
+
+}
+
+void
+platform_reset(void)
+{
+	uint32_t reg = ATH_READ_REG(AR71XX_RST_RESET);
+
+	ATH_WRITE_REG(AR71XX_RST_RESET, reg | RST_RESET_FULL_CHIP);
+	/* Wait for reset */
+	while(1)
+		;
+}
+
+void
+platform_trap_enter(void)
+{
+
+}
+
+void
+platform_trap_exit(void)
+{
+
+}
+
+void
+platform_start(__register_t a0 __unused, __register_t a1 __unused, 
+    __register_t a2 __unused, __register_t a3 __unused)
+{
+	vm_offset_t kernend;
+	uint64_t platform_counter_freq;
+	uint32_t reg;
+	int argc, i, count = 0;
+	char **argv, **envp;
+
+	/* clear the BSS and SBSS segments */
+	kernend = round_page((vm_offset_t)&end);
+	memset(&edata, 0, kernend - (vm_offset_t)(&edata));
+
+	argc = a0;
+	argv = (char**)a1;
+	envp = (char**)a2;
+	/* 
+	 * Protect ourselves from garbage in registers 
+	 */
+	if (MIPS_IS_VALID_PTR(envp)) {
+		for (i = 0; envp[i]; i += 2)
+		{
+			if (strcmp(envp[i], "memsize") == 0)
+				realmem = btoc(strtoul(envp[i+1], NULL, 16));
+			else if (strcmp(envp[i], "ethaddr") == 0) {
+				count = sscanf(envp[i+1], "%x.%x.%x.%x.%x.%x", 
+				    &ar711_base_mac[0], &ar711_base_mac[1],
+				    &ar711_base_mac[2], &ar711_base_mac[3],
+				    &ar711_base_mac[4], &ar711_base_mac[5]);
+				if (count < 6)
+					memset(ar711_base_mac, 0,
+					    sizeof(ar711_base_mac));
+			}
+		}
+	}
+
+	/*
+	 * Just wild guess. RedBoot let us down and didn't reported 
+	 * memory size
+	 */
+	if (realmem == 0)
+		realmem = btoc(32*1024*1024);
+
+	/* phys_avail regions are in bytes */
+	phys_avail[0] = MIPS_KSEG0_TO_PHYS((vm_offset_t)&end);
+	phys_avail[1] = ctob(realmem);
+
+	physmem = realmem;
+
+	/*
+	 * ns8250 uart code uses DELAY so ticker should be inititalized 
+	 * before cninit. And tick_init_params refers to hz, so * init_param1 
+	 * should be called first.
+	 */
+	init_param1();
+	platform_counter_freq = ar71xx_cpu_freq();
+	mips_timer_init_params(platform_counter_freq, 1);
+	cninit();
+
+	printf("platform frequency: %lld\n", platform_counter_freq);
+	printf("arguments: \n");
+	printf("  a0 = %08x\n", a0);
+	printf("  a1 = %08x\n", a1);
+	printf("  a2 = %08x\n", a2);
+	printf("  a3 = %08x\n", a3);
+
+	printf("Cmd line:");
+	if (MIPS_IS_VALID_PTR(argv)) {
+		for (i = 0; i < argc; i++)
+			printf(" %s", argv[i]);
+	}
+	else
+		printf ("argv is invalid");
+	printf("\n");
+
+	printf("Environment:\n");
+	if (MIPS_IS_VALID_PTR(envp)) {
+		for (i = 0; envp[i]; i+=2)
+			printf("  %s = %s\n", envp[i], envp[i+1]);
+	}
+	else 
+		printf ("envp is invalid\n");
+
+	init_param2(physmem);
+	mips_cpu_init();
+	pmap_bootstrap();
+	mips_proc0_init();
+	mutex_init();
+
+	/*
+	 * Reset USB devices 
+	 */
+	reg = ATH_READ_REG(AR71XX_RST_RESET);
+	reg |= 
+	    RST_RESET_USB_OHCI_DLL | RST_RESET_USB_HOST | RST_RESET_USB_PHY;
+	ATH_WRITE_REG(AR71XX_RST_RESET, reg);
+	DELAY(1000);
+	reg &= 
+	    ~(RST_RESET_USB_OHCI_DLL | RST_RESET_USB_HOST | RST_RESET_USB_PHY);
+	ATH_WRITE_REG(AR71XX_RST_RESET, reg);
+	
+	ATH_WRITE_REG(AR71XX_USB_CTRL_CONFIG,
+	    USB_CTRL_CONFIG_OHCI_DES_SWAP | USB_CTRL_CONFIG_OHCI_BUF_SWAP |
+	    USB_CTRL_CONFIG_EHCI_DES_SWAP | USB_CTRL_CONFIG_EHCI_BUF_SWAP);
+
+	ATH_WRITE_REG(AR71XX_USB_CTRL_FLADJ, 
+	    (32 << USB_CTRL_FLADJ_HOST_SHIFT) | (3 << USB_CTRL_FLADJ_A5_SHIFT));
+	DELAY(1000);
+
+#ifdef DDB
+	kdb_init();
+#endif
+}
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_ohci.c svn/mips/sys/mips/atheros/ar71xx_ohci.c
--- releng8/src/sys/mips/atheros/ar71xx_ohci.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_ohci.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,214 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+#include <sys/condvar.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbdi.h>
+
+#include <dev/usb/usb_core.h>
+#include <dev/usb/usb_busdma.h>
+#include <dev/usb/usb_process.h>
+#include <dev/usb/usb_util.h>
+
+#include <dev/usb/usb_controller.h>
+#include <dev/usb/usb_bus.h>
+#include <dev/usb/controller/ohci.h>
+
+#include <sys/rman.h>
+
+static int ar71xx_ohci_attach(device_t dev);
+static int ar71xx_ohci_detach(device_t dev);
+static int ar71xx_ohci_probe(device_t dev);
+
+struct ar71xx_ohci_softc
+{
+	struct ohci_softc sc_ohci;
+};
+
+static int
+ar71xx_ohci_probe(device_t dev)
+{
+	device_set_desc(dev, "AR71XX integrated OHCI controller");
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int
+ar71xx_ohci_attach(device_t dev)
+{
+	struct ar71xx_ohci_softc *sc = device_get_softc(dev);
+	int err;
+	int rid;
+
+	/* initialise some bus fields */
+	sc->sc_ohci.sc_bus.parent = dev;
+	sc->sc_ohci.sc_bus.devices = sc->sc_ohci.sc_devices;
+	sc->sc_ohci.sc_bus.devices_max = OHCI_MAX_DEVICES;
+
+	/* get all DMA memory */
+	if (usb_bus_mem_alloc_all(&sc->sc_ohci.sc_bus,
+	    USB_GET_DMA_TAG(dev), &ohci_iterate_hw_softc)) {
+		return (ENOMEM);
+	}
+
+	sc->sc_ohci.sc_dev = dev;
+
+	rid = 0;
+	sc->sc_ohci.sc_io_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid,
+	    RF_ACTIVE);
+	if (sc->sc_ohci.sc_io_res == NULL) {
+		err = ENOMEM;
+		goto error;
+	}
+	sc->sc_ohci.sc_io_tag = rman_get_bustag(sc->sc_ohci.sc_io_res);
+	sc->sc_ohci.sc_io_hdl = rman_get_bushandle(sc->sc_ohci.sc_io_res);
+	sc->sc_ohci.sc_io_size = rman_get_size(sc->sc_ohci.sc_io_res);
+
+	rid = 0;
+	sc->sc_ohci.sc_irq_res = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid,
+	    RF_ACTIVE);
+	if (sc->sc_ohci.sc_irq_res == NULL) {
+		err = ENOMEM;
+		goto error;
+	}
+	sc->sc_ohci.sc_bus.bdev = device_add_child(dev, "usbus", -1);
+	if (sc->sc_ohci.sc_bus.bdev == NULL) {
+		err = ENOMEM;
+		goto error;
+	}
+	device_set_ivars(sc->sc_ohci.sc_bus.bdev, &sc->sc_ohci.sc_bus);
+
+	err = bus_setup_intr(dev, sc->sc_ohci.sc_irq_res, 
+	    INTR_TYPE_BIO | INTR_MPSAFE, NULL, 
+	    (driver_intr_t *)ohci_interrupt, sc, &sc->sc_ohci.sc_intr_hdl);
+	if (err) {
+		err = ENXIO;
+		goto error;
+	}
+
+	strlcpy(sc->sc_ohci.sc_vendor, "Atheros", sizeof(sc->sc_ohci.sc_vendor));
+
+	bus_space_write_4(sc->sc_ohci.sc_io_tag, sc->sc_ohci.sc_io_hdl, OHCI_CONTROL, 0);
+
+	err = ohci_init(&sc->sc_ohci);
+	if (!err)
+		err = device_probe_and_attach(sc->sc_ohci.sc_bus.bdev);
+
+	if (err)
+		goto error;
+	return (0);
+
+error:
+	if (err) {
+		ar71xx_ohci_detach(dev);
+		return (err);
+	}
+	return (err);
+}
+
+static int
+ar71xx_ohci_detach(device_t dev)
+{
+	struct ar71xx_ohci_softc *sc = device_get_softc(dev);
+	device_t bdev;
+
+	if (sc->sc_ohci.sc_bus.bdev) {
+		bdev = sc->sc_ohci.sc_bus.bdev;
+		device_detach(bdev);
+		device_delete_child(dev, bdev);
+	}
+	/* during module unload there are lots of children leftover */
+	device_delete_all_children(dev);
+
+	/*
+	 * Put the controller into reset, then disable clocks and do
+	 * the MI tear down.  We have to disable the clocks/hardware
+	 * after we do the rest of the teardown.  We also disable the
+	 * clocks in the opposite order we acquire them, but that
+	 * doesn't seem to be absolutely necessary.  We free up the
+	 * clocks after we disable them, so the system could, in
+	 * theory, reuse them.
+	 */
+	bus_space_write_4(sc->sc_ohci.sc_io_tag, sc->sc_ohci.sc_io_hdl,
+	    OHCI_CONTROL, 0);
+
+	if (sc->sc_ohci.sc_intr_hdl) {
+		bus_teardown_intr(dev, sc->sc_ohci.sc_irq_res, sc->sc_ohci.sc_intr_hdl);
+		sc->sc_ohci.sc_intr_hdl = NULL;
+	}
+
+	if (sc->sc_ohci.sc_irq_res && sc->sc_ohci.sc_intr_hdl) {
+		/*
+		 * only call ohci_detach() after ohci_init()
+		 */
+		ohci_detach(&sc->sc_ohci);
+
+		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->sc_ohci.sc_irq_res);
+		sc->sc_ohci.sc_irq_res = NULL;
+	}
+	if (sc->sc_ohci.sc_io_res) {
+		bus_release_resource(dev, SYS_RES_MEMORY, 0, sc->sc_ohci.sc_io_res);
+		sc->sc_ohci.sc_io_res = NULL;
+		sc->sc_ohci.sc_io_tag = 0;
+		sc->sc_ohci.sc_io_hdl = 0;
+	}
+	usb_bus_mem_free_all(&sc->sc_ohci.sc_bus, &ohci_iterate_hw_softc);
+
+	return (0);
+}
+
+static device_method_t ohci_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe, ar71xx_ohci_probe),
+	DEVMETHOD(device_attach, ar71xx_ohci_attach),
+	DEVMETHOD(device_detach, ar71xx_ohci_detach),
+	DEVMETHOD(device_shutdown, bus_generic_shutdown),
+
+	/* Bus interface */
+	DEVMETHOD(bus_print_child, bus_generic_print_child),
+
+	{0, 0}
+};
+
+static driver_t ohci_driver = {
+	"ohci",
+	ohci_methods,
+	sizeof(struct ar71xx_ohci_softc),
+};
+
+static devclass_t ohci_devclass;
+
+DRIVER_MODULE(ohci, apb, ohci_driver, ohci_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_pci.c svn/mips/sys/mips/atheros/ar71xx_pci.c
--- releng8/src/sys/mips/atheros/ar71xx_pci.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_pci.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,559 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+
+#include <sys/bus.h>
+#include <sys/interrupt.h>
+#include <sys/malloc.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+
+#include <vm/vm.h>
+#include <vm/pmap.h>
+#include <vm/vm_extern.h>
+
+#include <machine/bus.h>
+#include <machine/cpu.h>
+#include <machine/pmap.h>
+
+#include <dev/pci/pcivar.h>
+#include <dev/pci/pcireg.h>
+
+#include <dev/pci/pcib_private.h>
+#include "pcib_if.h"
+
+#include <mips/atheros/ar71xxreg.h>
+#include <mips/atheros/ar71xx_pci_bus_space.h>
+
+#undef AR71XX_PCI_DEBUG
+#ifdef AR71XX_PCI_DEBUG
+#define dprintf printf
+#else
+#define dprintf(x, arg...)
+#endif
+
+struct ar71xx_pci_softc {
+	device_t		sc_dev;
+
+	int			sc_busno;
+	struct rman		sc_mem_rman;
+	struct rman		sc_irq_rman;
+
+	struct intr_event	*sc_eventstab[AR71XX_PCI_NIRQS];	
+	struct resource		*sc_irq;
+	void			*sc_ih;
+};
+
+static int ar71xx_pci_setup_intr(device_t, device_t, struct resource *, int, 
+		    driver_filter_t *, driver_intr_t *, void *, void **);
+static int ar71xx_pci_teardown_intr(device_t, device_t, struct resource *,
+		    void *);
+static int ar71xx_pci_intr(void *);
+
+static void 
+ar71xx_pci_mask_irq(void *source)
+{
+	uint32_t reg;
+	unsigned int irq = (unsigned int)source;
+
+	reg = ATH_READ_REG(AR71XX_PCI_INTR_MASK);
+	/* flush */
+	reg = ATH_READ_REG(AR71XX_PCI_INTR_MASK);
+	ATH_WRITE_REG(AR71XX_PCI_INTR_MASK, reg & ~(1 << irq));
+}
+
+static void 
+ar71xx_pci_unmask_irq(void *source)
+{
+	uint32_t reg;
+	unsigned int irq = (unsigned int)source;
+
+	reg = ATH_READ_REG(AR71XX_PCI_INTR_MASK);
+	ATH_WRITE_REG(AR71XX_PCI_INTR_MASK, reg | (1 << irq));
+	/* flush */
+	reg = ATH_READ_REG(AR71XX_PCI_INTR_MASK);
+}
+
+/* 
+ * get bitmask for bytes of interest: 
+ *   0 - we want this byte, 1 - ignore it. e.g: we read 1 byte 
+ *   from register 7. Bitmask would be: 0111
+ */
+static uint32_t
+ar71xx_get_bytes_to_read(int reg, int bytes)
+{
+	uint32_t bytes_to_read = 0;
+	if ((bytes % 4) == 0)
+		bytes_to_read = 0;
+	else if ((bytes % 4) == 1)
+		bytes_to_read = (~(1 << (reg % 4))) & 0xf;
+	else if ((bytes % 4) == 2)
+		bytes_to_read = (~(3 << (reg % 4))) & 0xf;
+	else
+		panic("%s: wrong combination", __func__);
+
+	return (bytes_to_read);
+}
+
+static int 
+ar71xx_pci_check_bus_error(void)
+{
+	uint32_t error, addr, has_errors = 0;
+	error = ATH_READ_REG(AR71XX_PCI_ERROR) & 0x3;
+	dprintf("%s: PCI error = %02x\n", __func__, error);
+	if (error) {
+		addr = ATH_READ_REG(AR71XX_PCI_ERROR_ADDR);
+
+		/* Do not report it yet */
+#if 0
+		printf("PCI bus error %d at addr 0x%08x\n", error, addr);
+#endif
+		ATH_WRITE_REG(AR71XX_PCI_ERROR, error);
+		has_errors = 1;
+	}
+
+	error = ATH_READ_REG(AR71XX_PCI_AHB_ERROR) & 0x1;
+	dprintf("%s: AHB error = %02x\n", __func__, error);
+	if (error) {
+		addr = ATH_READ_REG(AR71XX_PCI_AHB_ERROR_ADDR);
+		/* Do not report it yet */
+#if 0
+		printf("AHB bus error %d at addr 0x%08x\n", error, addr);
+#endif
+		ATH_WRITE_REG(AR71XX_PCI_AHB_ERROR, error);
+		has_errors = 1;
+	}
+
+	return (has_errors);
+}
+
+static uint32_t
+ar71xx_pci_make_addr(int bus, int slot, int func, int reg)
+{
+	if (bus == 0) {
+		return ((1 << slot) | (func << 8) | (reg & ~3));
+	} else {
+		return ((bus << 16) | (slot << 11) | (func << 8) 
+		    | (reg  & ~3) | 1);
+	}
+}
+
+static int
+ar71xx_pci_conf_setup(int bus, int slot, int func, int reg, int bytes, 
+    uint32_t cmd)
+{
+	uint32_t addr = ar71xx_pci_make_addr(bus, slot, func, (reg & ~3));
+	cmd |= (ar71xx_get_bytes_to_read(reg, bytes) << 4);
+	
+	ATH_WRITE_REG(AR71XX_PCI_CONF_ADDR, addr);
+	ATH_WRITE_REG(AR71XX_PCI_CONF_CMD, cmd);
+
+	dprintf("%s: tag (%x, %x, %x) %d/%d addr=%08x, cmd=%08x\n", __func__, 
+	    bus, slot, func, reg, bytes, addr, cmd);
+
+	return ar71xx_pci_check_bus_error();
+}
+
+static uint32_t
+ar71xx_pci_read_config(device_t dev, u_int bus, u_int slot, u_int func, 
+    u_int reg, int bytes)
+{
+	uint32_t data;
+	uint32_t cmd, shift, mask;
+
+	/* register access is 32-bit aligned */
+	shift = (reg & 3) * 8;
+	if (shift)
+		mask = (1 << shift) - 1;
+	else
+		mask = 0xffffffff;
+
+	dprintf("%s: tag (%x, %x, %x) reg %d(%d)\n", __func__, bus, slot, 
+	    func, reg, bytes);
+
+	if ((bus == 0) && (slot == 0) && (func == 0)) {
+		cmd = PCI_LCONF_CMD_READ | (reg & ~3);
+		ATH_WRITE_REG(AR71XX_PCI_LCONF_CMD, cmd);
+		data = ATH_READ_REG(AR71XX_PCI_LCONF_READ_DATA);
+	} else {
+		 if (ar71xx_pci_conf_setup(bus, slot, func, reg, bytes, 
+		     PCI_CONF_CMD_READ) == 0)
+			 data = ATH_READ_REG(AR71XX_PCI_CONF_READ_DATA);
+		 else
+			 data = -1;
+	}
+
+	/* get request bytes from 32-bit word */
+	data = (data >> shift) & mask;
+
+ 	dprintf("%s: read 0x%x\n", __func__, data);
+
+	return (data);
+}
+
+static void
+ar71xx_pci_write_config(device_t dev, u_int bus, u_int slot, u_int func, 
+    u_int reg, uint32_t data, int bytes)
+{
+	uint32_t cmd;
+
+	dprintf("%s: tag (%x, %x, %x) reg %d(%d)\n", __func__, bus, slot, 
+	    func, reg, bytes);
+
+	data = data << (8*(reg % 4));
+
+	if ((bus == 0) && (slot == 0) && (func == 0)) {
+		cmd = PCI_LCONF_CMD_WRITE | (reg & ~3);
+		cmd |= ar71xx_get_bytes_to_read(reg, bytes) << 20;
+		ATH_WRITE_REG(AR71XX_PCI_LCONF_CMD, cmd);
+		ATH_WRITE_REG(AR71XX_PCI_LCONF_WRITE_DATA, data);
+	} else {
+		 if (ar71xx_pci_conf_setup(bus, slot, func, reg, bytes, 
+		     PCI_CONF_CMD_WRITE) == 0)
+			 ATH_WRITE_REG(AR71XX_PCI_CONF_WRITE_DATA, data);
+	}
+}
+
+static int
+ar71xx_pci_probe(device_t dev)
+{
+
+	return (0);
+}
+
+static int
+ar71xx_pci_attach(device_t dev)
+{
+	int busno = 0;
+	int rid = 0;
+	uint32_t reset;
+	struct ar71xx_pci_softc *sc = device_get_softc(dev);
+
+	sc->sc_mem_rman.rm_type = RMAN_ARRAY;
+	sc->sc_mem_rman.rm_descr = "ar71xx PCI memory window";
+	if (rman_init(&sc->sc_mem_rman) != 0 || 
+	    rman_manage_region(&sc->sc_mem_rman, AR71XX_PCI_MEM_BASE, 
+		AR71XX_PCI_MEM_BASE + AR71XX_PCI_MEM_SIZE - 1) != 0) {
+		panic("ar71xx_pci_attach: failed to set up I/O rman");
+	}
+
+	sc->sc_irq_rman.rm_type = RMAN_ARRAY;
+	sc->sc_irq_rman.rm_descr = "ar71xx PCI IRQs";
+	if (rman_init(&sc->sc_irq_rman) != 0 ||
+	    rman_manage_region(&sc->sc_irq_rman, AR71XX_PCI_IRQ_START, 
+	        AR71XX_PCI_IRQ_END) != 0)
+		panic("ar71xx_pci_attach: failed to set up IRQ rman");
+
+
+	ATH_WRITE_REG(AR71XX_PCI_INTR_STATUS, 0);
+	ATH_WRITE_REG(AR71XX_PCI_INTR_MASK, 0);
+
+	/* Hook up our interrupt handler. */
+	if ((sc->sc_irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid,
+	    RF_SHAREABLE | RF_ACTIVE)) == NULL) {
+		device_printf(dev, "unable to allocate IRQ resource\n");
+		return ENXIO;
+	}
+
+	if ((bus_setup_intr(dev, sc->sc_irq, INTR_TYPE_MISC,
+			    ar71xx_pci_intr, NULL, sc, &sc->sc_ih))) {
+		device_printf(dev, 
+		    "WARNING: unable to register interrupt handler\n");
+		return ENXIO;
+	}
+
+	/* reset PCI core and PCI bus */
+	reset = ATH_READ_REG(AR71XX_RST_RESET);
+	reset |= (RST_RESET_PCI_CORE | RST_RESET_PCI_BUS);
+	ATH_WRITE_REG(AR71XX_RST_RESET, reset);
+	ATH_READ_REG(AR71XX_RST_RESET);
+	DELAY(1000);
+
+	reset &= ~(RST_RESET_PCI_CORE | RST_RESET_PCI_BUS);
+	ATH_WRITE_REG(AR71XX_RST_RESET, reset);
+	ATH_READ_REG(AR71XX_RST_RESET);
+	DELAY(1000);
+
+	/* Init PCI windows */
+	ATH_WRITE_REG(AR71XX_PCI_WINDOW0, PCI_WINDOW0_ADDR);
+	ATH_WRITE_REG(AR71XX_PCI_WINDOW1, PCI_WINDOW1_ADDR);
+	ATH_WRITE_REG(AR71XX_PCI_WINDOW2, PCI_WINDOW2_ADDR);
+	ATH_WRITE_REG(AR71XX_PCI_WINDOW3, PCI_WINDOW3_ADDR);
+	ATH_WRITE_REG(AR71XX_PCI_WINDOW4, PCI_WINDOW4_ADDR);
+	ATH_WRITE_REG(AR71XX_PCI_WINDOW5, PCI_WINDOW5_ADDR);
+	ATH_WRITE_REG(AR71XX_PCI_WINDOW6, PCI_WINDOW6_ADDR);
+	ATH_WRITE_REG(AR71XX_PCI_WINDOW7, PCI_WINDOW7_CONF_ADDR);
+	DELAY(1000);
+
+	ar71xx_pci_check_bus_error();
+
+	/* Fixup internal PCI bridge */
+	ar71xx_pci_write_config(dev, 0, 0, 0, PCIR_COMMAND, 
+            PCIM_CMD_BUSMASTEREN | PCIM_CMD_MEMEN 
+	    | PCIM_CMD_SERRESPEN | PCIM_CMD_BACKTOBACK
+	    | PCIM_CMD_PERRESPEN | PCIM_CMD_MWRICEN, 2);
+
+	device_add_child(dev, "pci", busno);
+	return (bus_generic_attach(dev));
+}
+
+static int
+ar71xx_pci_read_ivar(device_t dev, device_t child, int which, uintptr_t *result)
+{
+	struct ar71xx_pci_softc *sc = device_get_softc(dev);
+
+	switch (which) {
+	case PCIB_IVAR_DOMAIN:
+		*result = 0;
+		return (0);
+	case PCIB_IVAR_BUS:
+		*result = sc->sc_busno;
+		return (0);
+	}
+
+	return (ENOENT);
+}
+
+static int
+ar71xx_pci_write_ivar(device_t dev, device_t child, int which, uintptr_t result)
+{
+	struct ar71xx_pci_softc * sc = device_get_softc(dev);
+
+	switch (which) {
+	case PCIB_IVAR_BUS:
+		sc->sc_busno = result;
+		return (0);
+	}
+
+	return (ENOENT);
+}
+
+static struct resource *
+ar71xx_pci_alloc_resource(device_t bus, device_t child, int type, int *rid,
+    u_long start, u_long end, u_long count, u_int flags)
+{
+
+	struct ar71xx_pci_softc *sc = device_get_softc(bus);	
+	struct resource *rv;
+	struct rman *rm;
+
+	switch (type) {
+	case SYS_RES_IRQ:
+		rm = &sc->sc_irq_rman;
+		break;
+	case SYS_RES_MEMORY:
+		rm = &sc->sc_mem_rman;
+		break;
+	default:
+		return (NULL);
+	}
+
+	rv = rman_reserve_resource(rm, start, end, count, flags, child);
+
+	if (rv == NULL)
+		return (NULL);
+
+	rman_set_rid(rv, *rid);
+
+	if (flags & RF_ACTIVE) {
+		if (bus_activate_resource(child, type, *rid, rv)) {
+			rman_release_resource(rv);
+			return (NULL);
+		}
+	} 
+
+
+	return (rv);
+}
+
+
+static int
+ar71xx_pci_activate_resource(device_t bus, device_t child, int type, int rid,
+    struct resource *r)
+{
+	int res = (BUS_ACTIVATE_RESOURCE(device_get_parent(bus),
+	    child, type, rid, r));
+
+	if (!res) {
+		switch(type) {
+		case SYS_RES_MEMORY:
+		case SYS_RES_IOPORT:
+			rman_set_bustag(r, ar71xx_bus_space_pcimem);
+			break;
+		}
+	}
+
+	return (res);
+}
+
+
+
+static int
+ar71xx_pci_setup_intr(device_t bus, device_t child, struct resource *ires,
+		int flags, driver_filter_t *filt, driver_intr_t *handler,
+		void *arg, void **cookiep)
+{
+	struct ar71xx_pci_softc *sc = device_get_softc(bus);
+	struct intr_event *event;
+	int irq, error;
+
+	irq = rman_get_start(ires);
+
+	if (irq > AR71XX_PCI_IRQ_END)
+		panic("%s: bad irq %d", __func__, irq);
+
+	event = sc->sc_eventstab[irq];
+	if (event == NULL) {
+		error = intr_event_create(&event, (void *)irq, 0, irq, 
+		    ar71xx_pci_mask_irq, ar71xx_pci_unmask_irq, NULL, NULL,
+		    "ar71xx_pci intr%d:", irq);
+
+		sc->sc_eventstab[irq] = event;
+	}
+
+	intr_event_add_handler(event, device_get_nameunit(child), filt,
+	    handler, arg, intr_priority(flags), flags, cookiep);
+
+	ar71xx_pci_unmask_irq((void*)irq);
+
+	return (0);
+}
+
+static int
+ar71xx_pci_teardown_intr(device_t dev, device_t child, struct resource *ires,
+    void *cookie)
+{
+	struct ar71xx_pci_softc *sc = device_get_softc(dev);
+	int irq, result;
+
+	irq = rman_get_start(ires);
+	if (irq > AR71XX_PCI_IRQ_END)
+		panic("%s: bad irq %d", __func__, irq);
+
+	if (sc->sc_eventstab[irq] == NULL)
+		panic("Trying to teardown unoccupied IRQ");
+
+	ar71xx_pci_mask_irq((void*)irq);
+
+	result = intr_event_remove_handler(cookie);
+	if (!result)
+		sc->sc_eventstab[irq] = NULL;
+
+	return (result);
+}
+
+static int
+ar71xx_pci_intr(void *arg)
+{
+	struct ar71xx_pci_softc *sc = arg;
+	struct intr_event *event;
+	uint32_t reg, irq, mask;
+
+	reg = ATH_READ_REG(AR71XX_PCI_INTR_STATUS);
+	mask = ATH_READ_REG(AR71XX_PCI_INTR_MASK);
+	/*
+	 * Handle only unmasked interrupts
+	 */
+	reg &= mask;
+	for (irq = AR71XX_PCI_IRQ_START; irq <= AR71XX_PCI_IRQ_END; irq++) {
+		if (reg & (1 << irq)) {
+			event = sc->sc_eventstab[irq];
+			if (!event || TAILQ_EMPTY(&event->ie_handlers)) {
+				/* Ignore timer interrupts */
+				if (irq != 0)
+					printf("Stray IRQ %d\n", irq);
+				continue;
+			}
+
+			/* TODO: frame instead of NULL? */
+			intr_event_handle(event, NULL);
+		}
+	}
+
+	return (FILTER_HANDLED);
+}
+
+static int
+ar71xx_pci_maxslots(device_t dev)
+{
+
+	return (PCI_SLOTMAX);
+}
+
+static int
+ar71xx_pci_route_interrupt(device_t pcib, device_t device, int pin)
+{
+	if (pci_get_slot(device) < AR71XX_PCI_BASE_SLOT)
+		panic("%s: PCI slot %d is less then AR71XX_PCI_BASE_SLOT",
+		    __func__, pci_get_slot(device));
+
+	return (pci_get_slot(device) - AR71XX_PCI_BASE_SLOT);
+}
+
+static device_method_t ar71xx_pci_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		ar71xx_pci_probe),
+	DEVMETHOD(device_attach,	ar71xx_pci_attach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+	DEVMETHOD(device_suspend,	bus_generic_suspend),
+	DEVMETHOD(device_resume,	bus_generic_resume),
+
+	/* Bus interface */
+	DEVMETHOD(bus_print_child,	bus_generic_print_child),
+	DEVMETHOD(bus_read_ivar,	ar71xx_pci_read_ivar),
+	DEVMETHOD(bus_write_ivar,	ar71xx_pci_write_ivar),
+	DEVMETHOD(bus_alloc_resource,	ar71xx_pci_alloc_resource),
+	DEVMETHOD(bus_release_resource,	bus_generic_release_resource),
+	DEVMETHOD(bus_activate_resource, ar71xx_pci_activate_resource),
+	DEVMETHOD(bus_deactivate_resource, bus_generic_deactivate_resource),
+	DEVMETHOD(bus_setup_intr,	ar71xx_pci_setup_intr),
+	DEVMETHOD(bus_teardown_intr,	ar71xx_pci_teardown_intr),
+
+	/* pcib interface */
+	DEVMETHOD(pcib_maxslots,	ar71xx_pci_maxslots),
+	DEVMETHOD(pcib_read_config,	ar71xx_pci_read_config),
+	DEVMETHOD(pcib_write_config,	ar71xx_pci_write_config),
+	DEVMETHOD(pcib_route_interrupt,	ar71xx_pci_route_interrupt),
+
+	{0, 0}
+};
+
+static driver_t ar71xx_pci_driver = {
+	"pcib",
+	ar71xx_pci_methods,
+	sizeof(struct ar71xx_pci_softc),
+};
+
+static devclass_t ar71xx_pci_devclass;
+
+DRIVER_MODULE(ar71xx_pci, nexus, ar71xx_pci_driver, ar71xx_pci_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_pci_bus_space.c svn/mips/sys/mips/atheros/ar71xx_pci_bus_space.c
--- releng8/src/sys/mips/atheros/ar71xx_pci_bus_space.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_pci_bus_space.c	2009-05-26 09:40:41.000000000 -0700
@@ -0,0 +1,198 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/endian.h>
+
+#include <machine/bus.h>
+#include <mips/atheros/ar71xx_pci_bus_space.h>
+
+static bs_r_1_s_proto(pcimem);
+static bs_r_2_s_proto(pcimem);
+static bs_r_4_s_proto(pcimem);
+static bs_w_1_s_proto(pcimem);
+static bs_w_2_s_proto(pcimem);
+static bs_w_4_s_proto(pcimem);
+
+/*
+ * Bus space that handles offsets in word for 1/2 bytes read/write access.
+ * Byte order of values is handled by device drivers itself. 
+ */
+static struct bus_space bus_space_pcimem = {
+	/* cookie */
+	(void *) 0,
+
+	/* mapping/unmapping */
+	generic_bs_map,
+	generic_bs_unmap,
+	generic_bs_subregion,
+
+	/* allocation/deallocation */
+	NULL,
+	NULL,
+
+	/* barrier */
+	generic_bs_barrier,
+
+	/* read (single) */
+	generic_bs_r_1,
+	generic_bs_r_2,
+	generic_bs_r_4,
+	NULL,
+
+	/* read multiple */
+	generic_bs_rm_1,
+	generic_bs_rm_2,
+	generic_bs_rm_4,
+	NULL,
+
+	/* read region */
+	generic_bs_rr_1,
+	generic_bs_rr_2,
+	generic_bs_rr_4,
+	NULL,
+
+	/* write (single) */
+	generic_bs_w_1,
+	generic_bs_w_2,
+	generic_bs_w_4,
+	NULL,
+
+	/* write multiple */
+	generic_bs_wm_1,
+	generic_bs_wm_2,
+	generic_bs_wm_4,
+	NULL,
+
+	/* write region */
+	NULL,
+	generic_bs_wr_2,
+	generic_bs_wr_4,
+	NULL,
+
+	/* set multiple */
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+
+	/* set region */
+	NULL,
+	generic_bs_sr_2,
+	generic_bs_sr_4,
+	NULL,
+
+	/* copy */
+	NULL,
+	generic_bs_c_2,
+	NULL,
+	NULL,
+
+	/* read (single) stream */
+	pcimem_bs_r_1_s,
+	pcimem_bs_r_2_s,
+	pcimem_bs_r_4_s,
+	NULL,
+
+	/* read multiple stream */
+	generic_bs_rm_1,
+	generic_bs_rm_2,
+	generic_bs_rm_4,
+	NULL,
+
+	/* read region stream */
+	generic_bs_rr_1,
+	generic_bs_rr_2,
+	generic_bs_rr_4,
+	NULL,
+
+	/* write (single) stream */
+	pcimem_bs_w_1_s,
+	pcimem_bs_w_2_s,
+	pcimem_bs_w_4_s,
+	NULL,
+
+	/* write multiple stream */
+	generic_bs_wm_1,
+	generic_bs_wm_2,
+	generic_bs_wm_4,
+	NULL,
+
+	/* write region stream */
+	NULL,
+	generic_bs_wr_2,
+	generic_bs_wr_4,
+	NULL,
+};
+
+bus_space_tag_t ar71xx_bus_space_pcimem = &bus_space_pcimem;
+
+static uint8_t
+pcimem_bs_r_1_s(void *t, bus_space_handle_t h, bus_size_t o)
+{
+
+	return readb(h + (o &~ 3) + (3 - (o & 3)));
+}
+
+static void
+pcimem_bs_w_1_s(void *t, bus_space_handle_t h, bus_size_t o, u_int8_t v)
+{
+
+	writeb(h + (o &~ 3) + (3 - (o & 3)), v);
+}
+
+static uint16_t
+pcimem_bs_r_2_s(void *t, bus_space_handle_t h, bus_size_t o)
+{
+
+	return readw(h + (o &~ 3) + (2 - (o & 3)));
+}
+
+static void
+pcimem_bs_w_2_s(void *t, bus_space_handle_t h, bus_size_t o, uint16_t v)
+{
+
+	writew(h + (o &~ 3) + (2 - (o & 3)), v);
+}
+
+static uint32_t
+pcimem_bs_r_4_s(void *t, bus_space_handle_t h, bus_size_t o)
+{
+	
+	return le32toh(readl(h + o));
+}
+
+static void
+pcimem_bs_w_4_s(void *t, bus_space_handle_t h, bus_size_t o, uint32_t v)
+{
+
+	writel(h + o, htole32(v));
+}
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_pci_bus_space.h svn/mips/sys/mips/atheros/ar71xx_pci_bus_space.h
--- releng8/src/sys/mips/atheros/ar71xx_pci_bus_space.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_pci_bus_space.h	2009-05-26 09:40:41.000000000 -0700
@@ -0,0 +1,33 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __AR71XX_PCI_BUS_SPACEH__
+#define __AR71XX_PCI_BUS_SPACEH__
+
+extern bus_space_tag_t ar71xx_bus_space_pcimem;
+
+#endif /* __AR71XX_PCI_BUS_SPACEH__ */
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_spi.c svn/mips/sys/mips/atheros/ar71xx_spi.c
--- releng8/src/sys/mips/atheros/ar71xx_spi.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_spi.c	2009-05-26 09:40:41.000000000 -0700
@@ -0,0 +1,228 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+
+#include <sys/bus.h>
+#include <sys/interrupt.h>
+#include <sys/malloc.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+
+#include <vm/vm.h>
+#include <vm/pmap.h>
+#include <vm/vm_extern.h>
+
+#include <machine/bus.h>
+#include <machine/cpu.h>
+#include <machine/pmap.h>
+
+#include <dev/spibus/spi.h>
+#include <dev/spibus/spibusvar.h>
+#include "spibus_if.h"
+
+#include <mips/atheros/ar71xxreg.h>
+
+#undef AR71XX_SPI_DEBUG
+#ifdef AR71XX_SPI_DEBUG
+#define dprintf printf
+#else
+#define dprintf(x, arg...)
+#endif
+
+/*
+ * register space access macros
+ */
+#define SPI_WRITE(sc, reg, val)	do {	\
+		bus_write_4(sc->sc_mem_res, (reg), (val)); \
+	} while (0)
+
+#define SPI_READ(sc, reg)	 bus_read_4(sc->sc_mem_res, (reg))
+
+#define SPI_SET_BITS(sc, reg, bits)	\
+	SPI_WRITE(sc, reg, SPI_READ(sc, (reg)) | (bits))
+
+#define SPI_CLEAR_BITS(sc, reg, bits)	\
+	SPI_WRITE(sc, reg, SPI_READ(sc, (reg)) & ~(bits))
+
+struct ar71xx_spi_softc {
+	device_t		sc_dev;
+	struct resource		*sc_mem_res;
+	uint32_t		sc_reg_ioctrl;
+};
+
+static int
+ar71xx_spi_probe(device_t dev)
+{
+	device_set_desc(dev, "AR71XX SPI");
+	return (0);
+}
+
+static int
+ar71xx_spi_attach(device_t dev)
+{
+	struct ar71xx_spi_softc *sc = device_get_softc(dev);
+	int rid;
+
+	sc->sc_dev = dev;
+        rid = 0;
+	sc->sc_mem_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid, 
+	    RF_ACTIVE);
+	if (!sc->sc_mem_res) {
+		device_printf(dev, "Could not map memory\n");
+		return (ENXIO);
+	}
+
+	sc->sc_reg_ioctrl  = SPI_READ(sc, AR71XX_SPI_IO_CTRL);
+
+	SPI_WRITE(sc, AR71XX_SPI_IO_CTRL, SPI_IO_CTRL_CS0 | SPI_IO_CTRL_CS1 |
+	    SPI_IO_CTRL_CS2);
+	SPI_WRITE(sc, AR71XX_SPI_CTRL, sc->sc_reg_ioctrl);
+	SPI_WRITE(sc, AR71XX_SPI_FS, 0);
+
+	device_add_child(dev, "spibus", 0);
+	return (bus_generic_attach(dev));
+}
+
+static void
+ar71xx_spi_chip_activate(struct ar71xx_spi_softc *sc, int cs)
+{
+	uint32_t ioctrl = SPI_IO_CTRL_CS0 |SPI_IO_CTRL_CS1 | SPI_IO_CTRL_CS2;
+	/*
+	 * Put respective CSx to low
+	 */
+	ioctrl &= ~(SPI_IO_CTRL_CS0 << cs);
+
+	SPI_WRITE(sc, AR71XX_SPI_FS, 1);
+	SPI_WRITE(sc, AR71XX_SPI_CTRL, 0x43);
+	SPI_WRITE(sc, AR71XX_SPI_IO_CTRL, ioctrl);
+}
+
+static void
+ar71xx_spi_chip_deactivate(struct ar71xx_spi_softc *sc, int cs)
+{
+	/*
+	 * Put all CSx to high
+	 */
+	SPI_WRITE(sc, AR71XX_SPI_IO_CTRL, SPI_IO_CTRL_CS0 | SPI_IO_CTRL_CS1 |
+	    SPI_IO_CTRL_CS2);
+	SPI_WRITE(sc, AR71XX_SPI_CTRL, sc->sc_reg_ioctrl);
+	SPI_WRITE(sc, AR71XX_SPI_FS, 0);
+}
+
+static uint8_t
+ar71xx_spi_txrx(struct ar71xx_spi_softc *sc, uint8_t data)
+{
+	int bit;
+	/* CS0 */
+	uint32_t ioctrl = SPI_IO_CTRL_CS1 | SPI_IO_CTRL_CS2;
+
+	uint32_t iod, rds;
+	for (bit = 7; bit >=0; bit--) {
+		if (data & (1 << bit))
+			iod = ioctrl | SPI_IO_CTRL_DO;
+		else
+			iod = ioctrl & ~SPI_IO_CTRL_DO;
+		SPI_WRITE(sc, AR71XX_SPI_IO_CTRL, iod);
+		SPI_WRITE(sc, AR71XX_SPI_IO_CTRL, iod | SPI_IO_CTRL_CLK);
+	}
+
+	rds = SPI_READ(sc, AR71XX_SPI_RDS);
+
+	return (rds & 0xff);
+}
+
+static int
+ar71xx_spi_transfer(device_t dev, device_t child, struct spi_command *cmd)
+{
+	struct ar71xx_spi_softc *sc;
+	uint8_t *buf_in, *buf_out;
+	struct spibus_ivar *devi = SPIBUS_IVAR(child);
+	int i;
+
+	sc = device_get_softc(dev);
+
+	ar71xx_spi_chip_activate(sc, devi->cs);
+
+	KASSERT(cmd->tx_cmd_sz == cmd->rx_cmd_sz, 
+	    ("TX/RX command sizes should be equal"));
+	KASSERT(cmd->tx_data_sz == cmd->rx_data_sz, 
+	    ("TX/RX data sizes should be equal"));
+
+	/*
+	 * Transfer command
+	 */
+	buf_out = (uint8_t *)cmd->tx_cmd;
+	buf_in = (uint8_t *)cmd->rx_cmd;
+	for (i = 0; i < cmd->tx_cmd_sz; i++)
+		buf_in[i] = ar71xx_spi_txrx(sc, buf_out[i]);
+
+	/*
+	 * Receive/transmit data (depends on  command)
+	 */
+	buf_out = (uint8_t *)cmd->tx_data;
+	buf_in = (uint8_t *)cmd->rx_data;
+	for (i = 0; i < cmd->tx_data_sz; i++)
+		buf_in[i] = ar71xx_spi_txrx(sc, buf_out[i]);
+
+	ar71xx_spi_chip_deactivate(sc, devi->cs);
+
+	return (0);
+}
+
+static int
+ar71xx_spi_detach(device_t dev)
+{
+
+	return (EBUSY);	/* XXX */
+}
+
+static device_method_t ar71xx_spi_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		ar71xx_spi_probe),
+	DEVMETHOD(device_attach,	ar71xx_spi_attach),
+	DEVMETHOD(device_detach,	ar71xx_spi_detach),
+
+	DEVMETHOD(spibus_transfer,	ar71xx_spi_transfer),
+
+	{0, 0}
+};
+
+static driver_t ar71xx_spi_driver = {
+	"spi",
+	ar71xx_spi_methods,
+	sizeof(struct ar71xx_spi_softc),
+};
+
+static devclass_t ar71xx_spi_devclass;
+
+DRIVER_MODULE(ar71xx_spi, nexus, ar71xx_spi_driver, ar71xx_spi_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xx_wdog.c svn/mips/sys/mips/atheros/ar71xx_wdog.c
--- releng8/src/sys/mips/atheros/ar71xx_wdog.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xx_wdog.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,118 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Watchdog driver for AR71xx 
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/watchdog.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+
+#include <mips/atheros/ar71xxreg.h>
+
+struct ar71xx_wdog_softc {
+	device_t dev;
+	int armed;
+};
+
+static void
+ar71xx_wdog_watchdog_fn(void *private, u_int cmd, int *error)
+{
+	struct ar71xx_wdog_softc *sc = private;
+	uint64_t timer_val;
+
+	cmd &= WD_INTERVAL;
+	if (cmd > 0) {
+		timer_val = (uint64_t)(1ULL << cmd) * ar71xx_ahb_freq() /
+		    1000000000;
+		/*
+		 * Load timer with large enough value to prevent spurious
+		 * reset
+		 */
+		ATH_WRITE_REG(AR71XX_RST_WDOG_TIMER, 
+		    ar71xx_ahb_freq() * 10);
+		ATH_WRITE_REG(AR71XX_RST_WDOG_CONTROL, 
+		    RST_WDOG_ACTION_RESET);
+		ATH_WRITE_REG(AR71XX_RST_WDOG_TIMER, 
+		    (timer_val & 0xffffffff));
+		sc->armed = 1;
+		*error = 0;
+	} else {
+		if (sc->armed) {
+			ATH_WRITE_REG(AR71XX_RST_WDOG_CONTROL, 
+			    RST_WDOG_ACTION_NOACTION);
+			sc->armed = 0;
+		}
+	}
+}
+
+static int
+ar71xx_wdog_probe(device_t dev)
+{
+
+	device_set_desc(dev, "Atheros AR71XX watchdog timer");
+	return (0);
+}
+
+static int
+ar71xx_wdog_attach(device_t dev)
+{
+	struct ar71xx_wdog_softc *sc = device_get_softc(dev);
+	
+	if (ATH_READ_REG(AR71XX_RST_WDOG_CONTROL) & RST_WDOG_LAST)
+		device_printf (dev, 
+		    "Previous reset was due to watchdog timeout\n");
+
+	ATH_WRITE_REG(AR71XX_RST_WDOG_CONTROL, RST_WDOG_ACTION_NOACTION);
+
+	sc->dev = dev;
+	EVENTHANDLER_REGISTER(watchdog_list, ar71xx_wdog_watchdog_fn, sc, 0);
+
+	return (0);
+}
+
+static device_method_t ar71xx_wdog_methods[] = {
+	DEVMETHOD(device_probe, ar71xx_wdog_probe),
+	DEVMETHOD(device_attach, ar71xx_wdog_attach),
+	{0, 0},
+};
+
+static driver_t ar71xx_wdog_driver = {
+	"ar71xx_wdog",
+	ar71xx_wdog_methods,
+	sizeof(struct ar71xx_wdog_softc),
+};
+static devclass_t ar71xx_wdog_devclass;
+
+DRIVER_MODULE(ar71xx_wdog, nexus, ar71xx_wdog_driver, ar71xx_wdog_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/atheros/ar71xxreg.h svn/mips/sys/mips/atheros/ar71xxreg.h
--- releng8/src/sys/mips/atheros/ar71xxreg.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/ar71xxreg.h	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,464 @@
+/*-
+ * Copyright (c) 2009 Oleksandr Tymoshenko
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#ifndef _AR71XX_REG_H_
+#define _AR71XX_REG_H_
+
+/* PCI region */
+#define AR71XX_PCI_MEM_BASE		0x10000000
+/* 
+ * PCI mem windows is 0x08000000 bytes long but we exclude control 
+ * region from the resource manager
+ */
+#define AR71XX_PCI_MEM_SIZE		0x07000000
+#define AR71XX_PCI_IRQ_START		0
+#define AR71XX_PCI_IRQ_END		2
+#define AR71XX_PCI_NIRQS		3
+/*
+ * PCI devices slots are starting from this number
+ */
+#define	AR71XX_PCI_BASE_SLOT		17
+
+/* PCI config registers */
+#define	AR71XX_PCI_LCONF_CMD		0x17010000
+#define			PCI_LCONF_CMD_READ	0x00000000
+#define			PCI_LCONF_CMD_WRITE	0x00010000
+#define	AR71XX_PCI_LCONF_WRITE_DATA	0x17010004
+#define	AR71XX_PCI_LCONF_READ_DATA	0x17010008
+#define	AR71XX_PCI_CONF_ADDR		0x1701000C
+#define	AR71XX_PCI_CONF_CMD		0x17010010
+#define			PCI_CONF_CMD_READ	0x0000000A
+#define			PCI_CONF_CMD_WRITE	0x0000000B
+#define	AR71XX_PCI_CONF_WRITE_DATA	0x17010014
+#define	AR71XX_PCI_CONF_READ_DATA	0x17010018
+#define	AR71XX_PCI_ERROR		0x1701001C
+#define	AR71XX_PCI_ERROR_ADDR		0x17010020
+#define	AR71XX_PCI_AHB_ERROR		0x17010024
+#define	AR71XX_PCI_AHB_ERROR_ADDR	0x17010028
+
+/* APB region */
+/*
+ * Size is not really true actual APB window size is 
+ * 0x01000000 but it should handle OHCI memory as well
+ * because this controller's interrupt is routed through 
+ * APB. 
+ */
+#define AR71XX_APB_BASE         0x18000000
+#define AR71XX_APB_SIZE         0x06000000
+
+/* DDR registers */
+#define AR71XX_DDR_CONFIG		0x18000000
+#define AR71XX_DDR_CONFIG2		0x18000004
+#define AR71XX_DDR_MODE_REGISTER	0x18000008
+#define AR71XX_DDR_EXT_MODE_REGISTER	0x1800000C
+#define AR71XX_DDR_CONTROL		0x18000010
+#define AR71XX_DDR_REFRESH		0x18000014
+#define AR71XX_DDR_RD_DATA_THIS_CYCLE	0x18000018
+#define AR71XX_TAP_CONTROL0		0x1800001C
+#define AR71XX_TAP_CONTROL1		0x18000020
+#define AR71XX_TAP_CONTROL2		0x18000024
+#define AR71XX_TAP_CONTROL3		0x18000028
+#define AR71XX_PCI_WINDOW0		0x1800007C
+#define AR71XX_PCI_WINDOW1		0x18000080
+#define AR71XX_PCI_WINDOW2		0x18000084
+#define AR71XX_PCI_WINDOW3		0x18000088
+#define AR71XX_PCI_WINDOW4		0x1800008C
+#define AR71XX_PCI_WINDOW5		0x18000090
+#define AR71XX_PCI_WINDOW6		0x18000094
+#define AR71XX_PCI_WINDOW7		0x18000098
+#define AR71XX_WB_FLUSH_GE0		0x1800009C
+#define AR71XX_WB_FLUSH_GE1		0x180000A0
+#define AR71XX_WB_FLUSH_USB		0x180000A4
+#define AR71XX_WB_FLUSH_PCI		0x180000A8
+
+/*
+ * Values for PCI_WINDOW_X registers 
+ */
+#define PCI_WINDOW0_ADDR		0x10000000
+#define PCI_WINDOW1_ADDR		0x11000000
+#define PCI_WINDOW2_ADDR		0x12000000
+#define PCI_WINDOW3_ADDR		0x13000000
+#define PCI_WINDOW4_ADDR		0x14000000
+#define PCI_WINDOW5_ADDR		0x15000000
+#define PCI_WINDOW6_ADDR		0x16000000
+#define PCI_WINDOW7_ADDR		0x17000000
+/* This value enables acces to PCI config registers */
+#define PCI_WINDOW7_CONF_ADDR		0x07000000
+
+#define	AR71XX_UART_ADDR		0x18020000
+
+#define	AR71XX_USB_CTRL_FLADJ		0x18030000
+#define		USB_CTRL_FLADJ_HOST_SHIFT	12
+#define		USB_CTRL_FLADJ_A5_SHIFT		10
+#define		USB_CTRL_FLADJ_A4_SHIFT		8
+#define		USB_CTRL_FLADJ_A3_SHIFT		6
+#define		USB_CTRL_FLADJ_A2_SHIFT		4
+#define		USB_CTRL_FLADJ_A1_SHIFT		2
+#define		USB_CTRL_FLADJ_A0_SHIFT		0
+#define	AR71XX_USB_CTRL_CONFIG		0x18030004
+#define		USB_CTRL_CONFIG_OHCI_DES_SWAP	(1 << 19)
+#define		USB_CTRL_CONFIG_OHCI_BUF_SWAP	(1 << 18)
+#define		USB_CTRL_CONFIG_EHCI_DES_SWAP	(1 << 17)
+#define		USB_CTRL_CONFIG_EHCI_BUF_SWAP	(1 << 16)
+#define		USB_CTRL_CONFIG_DISABLE_XTL	(1 << 13)
+#define		USB_CTRL_CONFIG_OVERRIDE_XTL	(1 << 12)
+#define		USB_CTRL_CONFIG_CLK_SEL_SHIFT	4
+#define		USB_CTRL_CONFIG_CLK_SEL_MASK	3
+#define		USB_CTRL_CONFIG_CLK_SEL_12	0
+#define		USB_CTRL_CONFIG_CLK_SEL_24	1
+#define		USB_CTRL_CONFIG_CLK_SEL_48	2
+#define		USB_CTRL_CONFIG_OVER_CURRENT_AS_GPIO	(1 << 8)
+#define		USB_CTRL_CONFIG_SS_SIMULATION_MODE	(1 << 2)
+#define		USB_CTRL_CONFIG_RESUME_UTMI_PLS_DIS	(1 << 1)
+#define		USB_CTRL_CONFIG_UTMI_BACKWARD_ENB	(1 << 0)
+
+#define	AR71XX_BASE_FREQ		40000000
+#define	AR71XX_PLL_CPU_CONFIG		0x18050000
+#define		PLL_SW_UPDATE			(1 << 31)
+#define		PLL_LOCKED			(1 << 30)
+#define		PLL_AHB_DIV_SHIFT		20
+#define		PLL_AHB_DIV_MASK		7
+#define		PLL_DDR_DIV_SEL_SHIFT		18
+#define		PLL_DDR_DIV_SEL_MASK		3
+#define		PLL_CPU_DIV_SEL_SHIFT		16
+#define		PLL_CPU_DIV_SEL_MASK		2
+#define		PLL_LOOP_BW_SHIFT		12
+#define		PLL_LOOP_BW_MASK		0xf
+#define		PLL_DIV_IN_SHIFT		10
+#define		PLL_DIV_IN_MASK			3
+#define		PLL_DIV_OUT_SHIFT		8
+#define		PLL_DIV_OUT_MASK		3
+#define		PLL_FB_SHIFT			3
+#define		PLL_FB_MASK			0x1f
+#define		PLL_BYPASS			(1 << 1)
+#define		PLL_POWER_DOWN			(1 << 0)
+#define	AR71XX_PLL_SEC_CONFIG		0x18050004
+#define	AR71XX_PLL_CPU_CLK_CTRL		0x18050008
+#define	AR71XX_PLL_ETH_INT0_CLK		0x18050010
+#define	AR71XX_PLL_ETH_INT1_CLK		0x18050014
+#define		XPLL_ETH_INT_CLK_10		0x00991099
+#define		XPLL_ETH_INT_CLK_100		0x00441011
+#define		XPLL_ETH_INT_CLK_1000		0x13110000
+#define		XPLL_ETH_INT_CLK_1000_GMII	0x14110000
+#define		PLL_ETH_INT_CLK_10		0x00991099
+#define		PLL_ETH_INT_CLK_100		0x00001099
+#define		PLL_ETH_INT_CLK_1000		0x00110000
+#define	AR71XX_PLL_ETH_EXT_CLK		0x18050018
+#define	AR71XX_PLL_PCI_CLK		0x1805001C
+
+#define AR71XX_RST_WDOG_CONTROL	0x18060008
+#define		RST_WDOG_LAST			(1 << 31)
+#define		RST_WDOG_ACTION_MASK		3
+#define		RST_WDOG_ACTION_RESET		3
+#define		RST_WDOG_ACTION_NMI		2
+#define		RST_WDOG_ACTION_GP_INTR		1
+#define		RST_WDOG_ACTION_NOACTION	0
+
+#define AR71XX_RST_WDOG_TIMER	0x1806000C
+/* 
+ * APB interrupt status and mask register and interrupt bit numbers for 
+ */
+#define AR71XX_MISC_INTR_STATUS	0x18060010
+#define AR71XX_MISC_INTR_MASK	0x18060014
+#define		MISC_INTR_TIMER		0
+#define		MISC_INTR_ERROR		1
+#define		MISC_INTR_GPIO		2
+#define		MISC_INTR_UART		3
+#define		MISC_INTR_WATCHDOG	4
+#define		MISC_INTR_PERF		5
+#define		MISC_INTR_OHCI		6
+#define		MISC_INTR_DMA		7
+
+#define AR71XX_PCI_INTR_STATUS	0x18060018
+#define AR71XX_PCI_INTR_MASK	0x1806001C
+#define		PCI_INTR_CORE		(1 << 4)
+
+#define AR71XX_RST_RESET	0x18060024
+#define		RST_RESET_FULL_CHIP	(1 << 24) /* Same as pulling
+							     the reset pin */
+#define		RST_RESET_CPU_COLD	(1 << 20) /* Cold reset */
+#define		RST_RESET_GE1_MAC	(1 << 13)
+#define		RST_RESET_GE1_PHY	(1 << 12)
+#define		RST_RESET_GE0_MAC	(1 <<  9)
+#define		RST_RESET_GE0_PHY	(1 <<  8)
+#define		RST_RESET_USB_OHCI_DLL	(1 <<  6)
+#define		RST_RESET_USB_HOST	(1 <<  5)
+#define		RST_RESET_USB_PHY	(1 <<  4)
+#define		RST_RESET_PCI_BUS	(1 <<  1)
+#define		RST_RESET_PCI_CORE	(1 <<  0)
+
+/*
+ * GigE adapters region
+ */
+#define AR71XX_MAC0_BASE	0x19000000
+#define AR71XX_MAC1_BASE	0x1A000000
+
+#define		AR71XX_MAC_CFG1			0x00
+#define			MAC_CFG1_SOFT_RESET		(1 << 31)
+#define			MAC_CFG1_SIMUL_RESET		(1 << 30)
+#define			MAC_CFG1_MAC_RX_BLOCK_RESET	(1 << 19)
+#define			MAC_CFG1_MAC_TX_BLOCK_RESET	(1 << 18)
+#define			MAC_CFG1_RX_FUNC_RESET		(1 << 17)
+#define			MAC_CFG1_TX_FUNC_RESET		(1 << 16)
+#define			MAC_CFG1_LOOPBACK		(1 <<  8)
+#define			MAC_CFG1_RXFLOW_CTRL		(1 <<  5)
+#define			MAC_CFG1_TXFLOW_CTRL		(1 <<  4)
+#define			MAC_CFG1_SYNC_RX		(1 <<  3)
+#define			MAC_CFG1_RX_ENABLE		(1 <<  2)
+#define			MAC_CFG1_SYNC_TX		(1 <<  1)
+#define			MAC_CFG1_TX_ENABLE		(1 <<  0)
+#define		AR71XX_MAC_CFG2			0x04
+#define			MAC_CFG2_PREAMBLE_LEN_MASK	0xf
+#define			MAC_CFG2_PREAMBLE_LEN_SHIFT	12
+#define			MAC_CFG2_IFACE_MODE_1000	(2 << 8)
+#define			MAC_CFG2_IFACE_MODE_10_100	(1 << 8)
+#define			MAC_CFG2_IFACE_MODE_SHIFT	8
+#define			MAC_CFG2_IFACE_MODE_MASK	3
+#define			MAC_CFG2_HUGE_FRAME		(1 << 5)
+#define			MAC_CFG2_LENGTH_FIELD		(1 << 4)
+#define			MAC_CFG2_ENABLE_PADCRC		(1 << 2)
+#define			MAC_CFG2_ENABLE_CRC		(1 << 1)
+#define			MAC_CFG2_FULL_DUPLEX		(1 << 0)
+#define		AR71XX_MAC_IFG			0x08
+#define		AR71XX_MAC_HDUPLEX		0x0C
+#define		AR71XX_MAC_MAX_FRAME_LEN	0x10
+#define		AR71XX_MAC_MII_CFG		0x20
+#define			MAC_MII_CFG_RESET		(1 << 31)
+#define			MAC_MII_CFG_SCAN_AUTO_INC	(1 <<  5)
+#define			MAC_MII_CFG_PREAMBLE_SUP	(1 <<  4)
+#define			MAC_MII_CFG_CLOCK_SELECT_MASK	0x7
+#define			MAC_MII_CFG_CLOCK_DIV_4		0
+#define			MAC_MII_CFG_CLOCK_DIV_6		2
+#define			MAC_MII_CFG_CLOCK_DIV_8		3
+#define			MAC_MII_CFG_CLOCK_DIV_10	4
+#define			MAC_MII_CFG_CLOCK_DIV_14	5
+#define			MAC_MII_CFG_CLOCK_DIV_20	6
+#define			MAC_MII_CFG_CLOCK_DIV_28	7
+#define		AR71XX_MAC_MII_CMD		0x24
+#define			MAC_MII_CMD_SCAN_CYCLE		(1 << 1)
+#define			MAC_MII_CMD_READ		1
+#define			MAC_MII_CMD_WRITE		0
+#define		AR71XX_MAC_MII_ADDR		0x28
+#define			MAC_MII_PHY_ADDR_SHIFT		8
+#define			MAC_MII_PHY_ADDR_MASK		0xff
+#define			MAC_MII_REG_MASK		0x1f
+#define		AR71XX_MAC_MII_CONTROL		0x2C
+#define			MAC_MII_CONTROL_MASK		0xffff
+#define		AR71XX_MAC_MII_STATUS		0x30
+#define			MAC_MII_STATUS_MASK		0xffff
+#define		AR71XX_MAC_MII_INDICATOR	0x34
+#define			MAC_MII_INDICATOR_NOT_VALID	(1 << 2)
+#define			MAC_MII_INDICATOR_SCANNING	(1 << 1)
+#define			MAC_MII_INDICATOR_BUSY		(1 << 0)
+#define		AR71XX_MAC_IFCONTROL		0x38
+#define			MAC_IFCONTROL_SPEED	(1 << 16)
+#define		AR71XX_MAC_STA_ADDR1		0x40
+#define		AR71XX_MAC_STA_ADDR2		0x44
+#define		AR71XX_MAC_FIFO_CFG0		0x48
+#define			FIFO_CFG0_TX_FABRIC		(1 << 4)
+#define			FIFO_CFG0_TX_SYSTEM		(1 << 3)
+#define			FIFO_CFG0_RX_FABRIC		(1 << 2)
+#define			FIFO_CFG0_RX_SYSTEM		(1 << 1)
+#define			FIFO_CFG0_WATERMARK		(1 << 0)
+#define			FIFO_CFG0_ALL			((1 << 5) - 1)
+#define			FIFO_CFG0_ENABLE_SHIFT		8
+#define		AR71XX_MAC_FIFO_CFG1		0x4C
+#define		AR71XX_MAC_FIFO_CFG2		0x50
+#define		AR71XX_MAC_FIFO_TX_THRESHOLD	0x54
+#define		AR71XX_MAC_FIFO_RX_FILTMATCH	0x58
+/* 
+ * These flags applicable both to AR71XX_MAC_FIFO_RX_FILTMASK and
+ * to AR71XX_MAC_FIFO_RX_FILTMATCH
+ */
+#define			FIFO_RX_MATCH_UNICAST		(1 << 17)
+#define			FIFO_RX_MATCH_TRUNC_FRAME	(1 << 16)
+#define			FIFO_RX_MATCH_VLAN_TAG		(1 << 15)
+#define			FIFO_RX_MATCH_UNSUP_OPCODE	(1 << 14)
+#define			FIFO_RX_MATCH_PAUSE_FRAME	(1 << 13)
+#define			FIFO_RX_MATCH_CTRL_FRAME	(1 << 12)
+#define			FIFO_RX_MATCH_LONG_EVENT	(1 << 11)
+#define			FIFO_RX_MATCH_DRIBBLE_NIBBLE	(1 << 10)
+#define			FIFO_RX_MATCH_BCAST		(1 <<  9)
+#define			FIFO_RX_MATCH_MCAST		(1 <<  8)
+#define			FIFO_RX_MATCH_OK		(1 <<  7)
+#define			FIFO_RX_MATCH_OORANGE		(1 <<  6)
+#define			FIFO_RX_MATCH_LEN_MSMTCH	(1 <<  5)
+#define			FIFO_RX_MATCH_CRC_ERROR		(1 <<  4)
+#define			FIFO_RX_MATCH_CODE_ERROR	(1 <<  3)
+#define			FIFO_RX_MATCH_FALSE_CARRIER	(1 <<  2)
+#define			FIFO_RX_MATCH_RX_DV_EVENT	(1 <<  1)
+#define			FIFO_RX_MATCH_DROP_EVENT	(1 <<  0)
+/*
+ * Exclude unicast and truncated frames from matching
+ */
+#define			FIFO_RX_FILTMATCH_DEFAULT		\
+				(FIFO_RX_MATCH_VLAN_TAG		| \
+				FIFO_RX_MATCH_UNSUP_OPCODE	| \
+				FIFO_RX_MATCH_PAUSE_FRAME	| \
+				FIFO_RX_MATCH_CTRL_FRAME	| \
+				FIFO_RX_MATCH_LONG_EVENT	| \
+				FIFO_RX_MATCH_DRIBBLE_NIBBLE	| \
+				FIFO_RX_MATCH_BCAST		| \
+				FIFO_RX_MATCH_MCAST		| \
+				FIFO_RX_MATCH_OK		| \
+				FIFO_RX_MATCH_OORANGE		| \
+				FIFO_RX_MATCH_LEN_MSMTCH	| \
+				FIFO_RX_MATCH_CRC_ERROR		| \
+				FIFO_RX_MATCH_CODE_ERROR	| \
+				FIFO_RX_MATCH_FALSE_CARRIER	| \
+				FIFO_RX_MATCH_RX_DV_EVENT	| \
+				FIFO_RX_MATCH_DROP_EVENT)
+#define		AR71XX_MAC_FIFO_RX_FILTMASK	0x5C
+#define			FIFO_RX_MASK_BYTE_MODE		(1 << 19)
+#define			FIFO_RX_MASK_NO_SHORT_FRAME	(1 << 18)
+#define			FIFO_RX_MASK_BIT17		(1 << 17)
+#define			FIFO_RX_MASK_BIT16		(1 << 16)
+#define			FIFO_RX_MASK_TRUNC_FRAME	(1 << 15)
+#define			FIFO_RX_MASK_LONG_EVENT		(1 << 14)
+#define			FIFO_RX_MASK_VLAN_TAG		(1 << 13)
+#define			FIFO_RX_MASK_UNSUP_OPCODE	(1 << 12)
+#define			FIFO_RX_MASK_PAUSE_FRAME	(1 << 11)
+#define			FIFO_RX_MASK_CTRL_FRAME		(1 << 10)
+#define			FIFO_RX_MASK_DRIBBLE_NIBBLE	(1 <<  9)
+#define			FIFO_RX_MASK_BCAST		(1 <<  8)
+#define			FIFO_RX_MASK_MCAST		(1 <<  7)
+#define			FIFO_RX_MASK_OK			(1 <<  6)
+#define			FIFO_RX_MASK_OORANGE		(1 <<  5)
+#define			FIFO_RX_MASK_LEN_MSMTCH		(1 <<  4)
+#define			FIFO_RX_MASK_CODE_ERROR		(1 <<  3)
+#define			FIFO_RX_MASK_FALSE_CARRIER	(1 <<  2)
+#define			FIFO_RX_MASK_RX_DV_EVENT	(1 <<  1)
+#define			FIFO_RX_MASK_DROP_EVENT		(1 <<  0)
+
+/*
+ *  Len. mismatch, unsup. opcode and short frmae bits excluded
+ */
+#define			FIFO_RX_FILTMASK_DEFAULT \
+				(FIFO_RX_MASK_NO_SHORT_FRAME	| \
+				FIFO_RX_MASK_BIT17		| \
+				FIFO_RX_MASK_BIT16		| \
+				FIFO_RX_MASK_TRUNC_FRAME	| \
+				FIFO_RX_MASK_LONG_EVENT		| \
+				FIFO_RX_MASK_VLAN_TAG		| \
+				FIFO_RX_MASK_PAUSE_FRAME	| \
+				FIFO_RX_MASK_CTRL_FRAME		| \
+				FIFO_RX_MASK_DRIBBLE_NIBBLE	| \
+				FIFO_RX_MASK_BCAST		| \
+				FIFO_RX_MASK_MCAST		| \
+				FIFO_RX_MASK_OK			| \
+				FIFO_RX_MASK_OORANGE		| \
+				FIFO_RX_MASK_CODE_ERROR		| \
+				FIFO_RX_MASK_FALSE_CARRIER	| \
+				FIFO_RX_MASK_RX_DV_EVENT	| \
+				FIFO_RX_MASK_DROP_EVENT)
+
+#define		AR71XX_MAC_FIFO_RAM0		0x60
+#define		AR71XX_MAC_FIFO_RAM1		0x64
+#define		AR71XX_MAC_FIFO_RAM2		0x68
+#define		AR71XX_MAC_FIFO_RAM3		0x6C
+#define		AR71XX_MAC_FIFO_RAM4		0x70
+#define		AR71XX_MAC_FIFO_RAM5		0x74
+#define		AR71XX_MAC_FIFO_RAM6		0x78
+#define		AR71XX_DMA_TX_CONTROL		0x180
+#define			DMA_TX_CONTROL_EN		(1 << 0)
+#define		AR71XX_DMA_TX_DESC		0x184
+#define		AR71XX_DMA_TX_STATUS		0x188
+#define			DMA_TX_STATUS_PCOUNT_MASK	0xff
+#define			DMA_TX_STATUS_PCOUNT_SHIFT	16
+#define			DMA_TX_STATUS_BUS_ERROR		(1 << 3) 
+#define			DMA_TX_STATUS_UNDERRUN		(1 << 1) 
+#define			DMA_TX_STATUS_PKT_SENT		(1 << 0) 
+#define		AR71XX_DMA_RX_CONTROL		0x18C
+#define			DMA_RX_CONTROL_EN		(1 << 0)
+#define		AR71XX_DMA_RX_DESC		0x190
+#define		AR71XX_DMA_RX_STATUS		0x194
+#define			DMA_RX_STATUS_PCOUNT_MASK	0xff
+#define			DMA_RX_STATUS_PCOUNT_SHIFT	16
+#define			DMA_RX_STATUS_BUS_ERROR		(1 << 3) 
+#define			DMA_RX_STATUS_OVERFLOW		(1 << 1) 
+#define			DMA_RX_STATUS_PKT_RECVD		(1 << 0) 
+#define		AR71XX_DMA_INTR				0x198
+#define		AR71XX_DMA_INTR_STATUS			0x19C
+#define			DMA_INTR_ALL			((1 << 8) - 1)
+#define			DMA_INTR_RX_BUS_ERROR		(1 << 7)
+#define			DMA_INTR_RX_OVERFLOW		(1 << 6)
+#define			DMA_INTR_RX_PKT_RCVD		(1 << 4)
+#define			DMA_INTR_TX_BUS_ERROR		(1 << 3)
+#define			DMA_INTR_TX_UNDERRUN		(1 << 1)
+#define			DMA_INTR_TX_PKT_SENT		(1 << 0)
+
+#define	AR71XX_SPI_BASE	0x1f000000
+#define		AR71XX_SPI_FS		0x00
+#define		AR71XX_SPI_CTRL		0x04
+#define			SPI_CTRL_REMAP_DISABLE		(1 << 6)
+#define			SPI_CTRL_CLOCK_DIVIDER_MASK	((1 << 6) - 1)
+#define		AR71XX_SPI_IO_CTRL	0x08
+#define			SPI_IO_CTRL_CS2			(1 << 18)
+#define			SPI_IO_CTRL_CS1			(1 << 17)
+#define			SPI_IO_CTRL_CS0			(1 << 16)
+#define			SPI_IO_CTRL_CLK			(1 << 8)
+#define			SPI_IO_CTRL_DO			1
+#define		AR71XX_SPI_RDS		0x0C
+
+#define ATH_READ_REG(reg) \
+    *((volatile uint32_t *)MIPS_PHYS_TO_KSEG1((reg)))
+
+#define ATH_WRITE_REG(reg, val) \
+    *((volatile uint32_t *)MIPS_PHYS_TO_KSEG1((reg))) = (val)
+
+static inline uint64_t
+ar71xx_cpu_freq(void)
+{
+        uint32_t pll_config, div;
+        uint64_t freq;
+
+        /* PLL freq */
+        pll_config = ATH_READ_REG(AR71XX_PLL_CPU_CONFIG);
+        div = ((pll_config >> PLL_FB_SHIFT) & PLL_FB_MASK) + 1;
+        freq = div * AR71XX_BASE_FREQ;
+        /* CPU freq */
+        div = ((pll_config >> PLL_CPU_DIV_SEL_SHIFT) & PLL_CPU_DIV_SEL_MASK)
+            + 1;
+        freq = freq / div;
+
+	return (freq);
+}
+
+static inline uint64_t
+ar71xx_ahb_freq(void)
+{
+        uint32_t pll_config, div;
+        uint64_t freq;
+
+        /* PLL freq */
+        pll_config = ATH_READ_REG(AR71XX_PLL_CPU_CONFIG);
+        /* AHB freq */
+        div = (((pll_config >> PLL_AHB_DIV_SHIFT) & PLL_AHB_DIV_MASK) + 1) * 2;
+        freq = ar71xx_cpu_freq() / div;
+	return (freq);
+}
+
+
+#endif /* _AR71XX_REG_H_ */
diff -I '.*' -Naur releng8/sys/mips/atheros/files.ar71xx svn/mips/sys/mips/atheros/files.ar71xx
--- releng8/src/sys/mips/atheros/files.ar71xx	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/files.ar71xx	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,14 @@
+# $FreeBSD$
+
+mips/atheros/apb.c		standard
+mips/atheros/ar71xx_machdep.c	standard
+mips/atheros/ar71xx_ehci.c	optional ehci
+mips/atheros/ar71xx_ohci.c	optional ohci
+mips/atheros/ar71xx_pci.c	optional pci
+mips/atheros/ar71xx_pci_bus_space.c	optional pci
+mips/atheros/ar71xx_spi.c	optional ar71xx_spi
+mips/atheros/ar71xx_wdog.c	optional ar71xx_wdog
+mips/atheros/if_arge.c		optional arge
+mips/atheros/uart_bus_ar71xx.c	optional uart
+mips/atheros/uart_cpu_ar71xx.c	optional uart
+mips/atheros/ar71xx_bus_space_reversed.c	standard
diff -I '.*' -Naur releng8/sys/mips/atheros/if_arge.c svn/mips/sys/mips/atheros/if_arge.c
--- releng8/src/sys/mips/atheros/if_arge.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/if_arge.c	2009-09-08 11:01:51.000000000 -0700
@@ -0,0 +1,1652 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * AR71XX gigabit ethernet driver
+ */
+#ifdef HAVE_KERNEL_OPTION_HEADERS
+#include "opt_device_polling.h"
+#endif
+
+#include <sys/param.h>
+#include <sys/endian.h>
+#include <sys/systm.h>
+#include <sys/sockio.h>
+#include <sys/mbuf.h>
+#include <sys/malloc.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/socket.h>
+#include <sys/taskqueue.h>
+
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <net/ethernet.h>
+#include <net/if_dl.h>
+#include <net/if_media.h>
+#include <net/if_types.h>
+
+#include <net/bpf.h>
+
+#include <machine/bus.h>
+#include <machine/cache.h>
+#include <machine/resource.h>
+#include <vm/vm_param.h>
+#include <vm/vm.h>
+#include <vm/pmap.h>
+#include <machine/pmap.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+
+#include <dev/mii/mii.h>
+#include <dev/mii/miivar.h>
+
+#include <dev/pci/pcireg.h>
+#include <dev/pci/pcivar.h>
+
+MODULE_DEPEND(arge, ether, 1, 1, 1);
+MODULE_DEPEND(arge, miibus, 1, 1, 1);
+
+#include "miibus_if.h"
+
+#include <mips/atheros/ar71xxreg.h>
+#include <mips/atheros/if_argevar.h>
+
+#undef ARGE_DEBUG
+#ifdef ARGE_DEBUG
+#define dprintf printf
+#else
+#define dprintf(x, arg...)
+#endif
+
+static int arge_attach(device_t);
+static int arge_detach(device_t);
+static void arge_flush_ddr(struct arge_softc *);
+static int arge_ifmedia_upd(struct ifnet *);
+static void arge_ifmedia_sts(struct ifnet *, struct ifmediareq *);
+static int arge_ioctl(struct ifnet *, u_long, caddr_t);
+static void arge_init(void *);
+static void arge_init_locked(struct arge_softc *);
+static void arge_link_task(void *, int);
+static int arge_miibus_readreg(device_t, int, int);
+static void arge_miibus_statchg(device_t);
+static int arge_miibus_writereg(device_t, int, int, int);
+static int arge_probe(device_t);
+static void arge_reset_dma(struct arge_softc *);
+static int arge_resume(device_t);
+static int arge_rx_ring_init(struct arge_softc *);
+static int arge_tx_ring_init(struct arge_softc *);
+#ifdef DEVICE_POLLING
+static void arge_poll(struct ifnet *, enum poll_cmd, int);
+#endif
+static int arge_shutdown(device_t);
+static void arge_start(struct ifnet *);
+static void arge_start_locked(struct ifnet *);
+static void arge_stop(struct arge_softc *);
+static int arge_suspend(device_t);
+
+static void arge_rx_locked(struct arge_softc *);
+static void arge_tx_locked(struct arge_softc *);
+static void arge_intr(void *);
+static int arge_intr_filter(void *);
+static void arge_tick(void *);
+
+static void arge_dmamap_cb(void *, bus_dma_segment_t *, int, int);
+static int arge_dma_alloc(struct arge_softc *);
+static void arge_dma_free(struct arge_softc *);
+static int arge_newbuf(struct arge_softc *, int);
+static __inline void arge_fixup_rx(struct mbuf *);
+
+static device_method_t arge_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		arge_probe),
+	DEVMETHOD(device_attach,	arge_attach),
+	DEVMETHOD(device_detach,	arge_detach),
+	DEVMETHOD(device_suspend,	arge_suspend),
+	DEVMETHOD(device_resume,	arge_resume),
+	DEVMETHOD(device_shutdown,	arge_shutdown),
+
+	/* bus interface */
+	DEVMETHOD(bus_print_child,	bus_generic_print_child),
+	DEVMETHOD(bus_driver_added,	bus_generic_driver_added),
+
+	/* MII interface */
+	DEVMETHOD(miibus_readreg,	arge_miibus_readreg),
+	DEVMETHOD(miibus_writereg,	arge_miibus_writereg),
+	DEVMETHOD(miibus_statchg,	arge_miibus_statchg),
+
+	{ 0, 0 }
+};
+
+static driver_t arge_driver = {
+	"arge",
+	arge_methods,
+	sizeof(struct arge_softc)
+};
+
+static devclass_t arge_devclass;
+
+DRIVER_MODULE(arge, nexus, arge_driver, arge_devclass, 0, 0);
+DRIVER_MODULE(miibus, arge, miibus_driver, miibus_devclass, 0, 0);
+
+/*
+ * RedBoot passes MAC address to entry point as environment 
+ * variable. platfrom_start parses it and stores in this variable
+ */
+extern uint32_t ar711_base_mac[ETHER_ADDR_LEN];
+
+/*
+ * Flushes all 
+ */
+static void
+arge_flush_ddr(struct arge_softc *sc)
+{
+
+	ATH_WRITE_REG(sc->arge_ddr_flush_reg, 1);
+	while (ATH_READ_REG(sc->arge_ddr_flush_reg) & 1)
+		;
+
+	ATH_WRITE_REG(sc->arge_ddr_flush_reg, 1);
+	while (ATH_READ_REG(sc->arge_ddr_flush_reg) & 1)
+		;
+}
+
+static int 
+arge_probe(device_t dev)
+{
+
+	device_set_desc(dev, "Atheros AR71xx built-in ethernet interface");
+	return (0);
+}
+
+static int
+arge_attach(device_t dev)
+{
+	uint8_t			eaddr[ETHER_ADDR_LEN];
+	struct ifnet		*ifp;
+	struct arge_softc	*sc;
+	int			error = 0, rid, phynum;
+	uint32_t		reg, rnd;
+	int			is_base_mac_empty, i;
+
+	sc = device_get_softc(dev);
+	sc->arge_dev = dev;
+	sc->arge_mac_unit = device_get_unit(dev);
+
+	KASSERT(((sc->arge_mac_unit == 0) || (sc->arge_mac_unit == 1)), 
+	    ("if_arge: Only MAC0 and MAC1 supported"));
+	if (sc->arge_mac_unit == 0) {
+		sc->arge_ddr_flush_reg = AR71XX_WB_FLUSH_GE0;
+		sc->arge_pll_reg = AR71XX_PLL_ETH_INT0_CLK;
+	} else {
+		sc->arge_ddr_flush_reg = AR71XX_WB_FLUSH_GE1;
+		sc->arge_pll_reg = AR71XX_PLL_ETH_INT1_CLK;
+	}
+
+	/*
+	 *  Get which PHY of 5 available we should use for this unit
+	 */
+	if (resource_int_value(device_get_name(dev), device_get_unit(dev), 
+	    "phy", &phynum) != 0) {
+		/*
+		 * Use port 4 (WAN) for GE0. For any other port use 
+		 * its PHY the same as its unit number 
+		 */
+		if (sc->arge_mac_unit == 0)
+			phynum = 4;
+		else
+			phynum = sc->arge_mac_unit;
+
+		device_printf(dev, "No PHY specified, using %d\n", phynum);
+	}
+
+	sc->arge_phy_num = phynum;
+
+
+	mtx_init(&sc->arge_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,
+	    MTX_DEF);
+	callout_init_mtx(&sc->arge_stat_callout, &sc->arge_mtx, 0);
+	TASK_INIT(&sc->arge_link_task, 0, arge_link_task, sc);
+
+	/* Map control/status registers. */
+	sc->arge_rid = 0;
+	sc->arge_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY, 
+	    &sc->arge_rid, RF_ACTIVE);
+
+	if (sc->arge_res == NULL) {
+		device_printf(dev, "couldn't map memory\n");
+		error = ENXIO;
+		goto fail;
+	}
+
+	/* Allocate interrupts */
+	rid = 0;
+	sc->arge_irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid, 
+	    RF_SHAREABLE | RF_ACTIVE);
+
+	if (sc->arge_irq == NULL) {
+		device_printf(dev, "couldn't map interrupt\n");
+		error = ENXIO;
+		goto fail;
+	}
+
+	/* Allocate ifnet structure. */
+	ifp = sc->arge_ifp = if_alloc(IFT_ETHER);
+
+	if (ifp == NULL) {
+		device_printf(dev, "couldn't allocate ifnet structure\n");
+		error = ENOSPC;
+		goto fail;
+	}
+
+	ifp->if_softc = sc;
+	if_initname(ifp, device_get_name(dev), device_get_unit(dev));
+	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
+	ifp->if_ioctl = arge_ioctl;
+	ifp->if_start = arge_start;
+	ifp->if_init = arge_init;
+
+	/* XXX: add real size */
+	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
+	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
+	IFQ_SET_READY(&ifp->if_snd);
+
+	ifp->if_capenable = ifp->if_capabilities;
+#ifdef DEVICE_POLLING
+	ifp->if_capabilities |= IFCAP_POLLING;
+#endif
+
+	is_base_mac_empty = 1;
+	for (i = 0; i < ETHER_ADDR_LEN; i++) {
+		eaddr[i] = ar711_base_mac[i] & 0xff;
+		if (eaddr[i] != 0)
+			is_base_mac_empty = 0;
+	}
+
+	if (is_base_mac_empty) {
+		/*
+		 * No MAC address configured. Generate the random one.
+		 */
+                if  (bootverbose)
+			device_printf(dev, 
+			    "Generating random ethernet address.\n");
+
+		rnd = arc4random();
+		eaddr[0] = 'b';
+		eaddr[1] = 's';
+		eaddr[2] = 'd';
+		eaddr[3] = (rnd >> 24) & 0xff;
+		eaddr[4] = (rnd >> 16) & 0xff;
+		eaddr[5] = (rnd >> 8) & 0xff;
+	}
+
+	if (arge_dma_alloc(sc) != 0) {
+		error = ENXIO;
+		goto fail;
+	}
+
+	/* Initialize the MAC block */
+	
+	/* Step 1. Soft-reset MAC */
+	ARGE_SET_BITS(sc, AR71XX_MAC_CFG1, MAC_CFG1_SOFT_RESET);
+	DELAY(20);
+
+	/* Step 2. Punt the MAC core from the central reset register */
+	reg = ATH_READ_REG(AR71XX_RST_RESET);
+	if (sc->arge_mac_unit == 0) 
+		reg |= RST_RESET_GE0_MAC;
+	else if (sc->arge_mac_unit == 1) 
+		reg |= RST_RESET_GE1_MAC;
+	ATH_WRITE_REG(AR71XX_RST_RESET, reg);
+	DELAY(100);
+	reg = ATH_READ_REG(AR71XX_RST_RESET);
+	if (sc->arge_mac_unit == 0) 
+		reg &= ~RST_RESET_GE0_MAC;
+	else if (sc->arge_mac_unit == 1) 
+		reg &= ~RST_RESET_GE1_MAC;
+	ATH_WRITE_REG(AR71XX_RST_RESET, reg);
+
+	/* Step 3. Reconfigure MAC block */
+	ARGE_WRITE(sc, AR71XX_MAC_CFG1, 
+		MAC_CFG1_SYNC_RX | MAC_CFG1_RX_ENABLE |
+		MAC_CFG1_SYNC_TX | MAC_CFG1_TX_ENABLE);
+
+	reg = ARGE_READ(sc, AR71XX_MAC_CFG2);
+	reg |= MAC_CFG2_ENABLE_PADCRC | MAC_CFG2_LENGTH_FIELD ;
+	ARGE_WRITE(sc, AR71XX_MAC_CFG2, reg);
+
+	ARGE_WRITE(sc, AR71XX_MAC_MAX_FRAME_LEN, 1536);
+
+	/* Reset MII bus */
+	ARGE_WRITE(sc, AR71XX_MAC_MII_CFG, MAC_MII_CFG_RESET);
+	DELAY(100);
+	ARGE_WRITE(sc, AR71XX_MAC_MII_CFG, MAC_MII_CFG_CLOCK_DIV_28);
+	DELAY(100);
+
+	/* 
+	 * Set all Ethernet address registers to the same initial values
+	 * set all four addresses to 66-88-aa-cc-dd-ee 
+	 */
+	ARGE_WRITE(sc, AR71XX_MAC_STA_ADDR1, 
+	    (eaddr[2] << 24) | (eaddr[3] << 16) | (eaddr[4] << 8)  | eaddr[5]);
+	ARGE_WRITE(sc, AR71XX_MAC_STA_ADDR2, (eaddr[0] << 8) | eaddr[1]);
+
+	ARGE_WRITE(sc, AR71XX_MAC_FIFO_CFG0, 
+	    FIFO_CFG0_ALL << FIFO_CFG0_ENABLE_SHIFT);
+	ARGE_WRITE(sc, AR71XX_MAC_FIFO_CFG1, 0x0fff0000);
+	ARGE_WRITE(sc, AR71XX_MAC_FIFO_CFG2, 0x00001fff);
+
+	ARGE_WRITE(sc, AR71XX_MAC_FIFO_RX_FILTMATCH, 
+	    FIFO_RX_FILTMATCH_DEFAULT);
+
+	ARGE_WRITE(sc, AR71XX_MAC_FIFO_RX_FILTMASK, 
+	    FIFO_RX_FILTMASK_DEFAULT);
+
+	/* Do MII setup. */
+	if (mii_phy_probe(dev, &sc->arge_miibus,
+	    arge_ifmedia_upd, arge_ifmedia_sts)) {
+		device_printf(dev, "MII without any phy!\n");
+		error = ENXIO;
+		goto fail;
+	}
+
+	/* Call MI attach routine. */
+	ether_ifattach(ifp, eaddr);
+
+	/* Hook interrupt last to avoid having to lock softc */
+	error = bus_setup_intr(dev, sc->arge_irq, INTR_TYPE_NET | INTR_MPSAFE,
+	    arge_intr_filter, arge_intr, sc, &sc->arge_intrhand);
+
+	if (error) {
+		device_printf(dev, "couldn't set up irq\n");
+		ether_ifdetach(ifp);
+		goto fail;
+	}
+
+fail:
+	if (error) 
+		arge_detach(dev);
+
+	return (error);
+}
+
+static int
+arge_detach(device_t dev)
+{
+	struct arge_softc	*sc = device_get_softc(dev);
+	struct ifnet		*ifp = sc->arge_ifp;
+
+	KASSERT(mtx_initialized(&sc->arge_mtx), ("arge mutex not initialized"));
+
+	/* These should only be active if attach succeeded */
+	if (device_is_attached(dev)) {
+		ARGE_LOCK(sc);
+		sc->arge_detach = 1;
+#ifdef DEVICE_POLLING
+		if (ifp->if_capenable & IFCAP_POLLING)
+			ether_poll_deregister(ifp);
+#endif
+
+		arge_stop(sc);
+		ARGE_UNLOCK(sc);
+		taskqueue_drain(taskqueue_swi, &sc->arge_link_task);
+		ether_ifdetach(ifp);
+	}
+
+	if (sc->arge_miibus)
+		device_delete_child(dev, sc->arge_miibus);
+	bus_generic_detach(dev);
+
+	if (sc->arge_intrhand)
+		bus_teardown_intr(dev, sc->arge_irq, sc->arge_intrhand);
+
+	if (sc->arge_res)
+		bus_release_resource(dev, SYS_RES_MEMORY, sc->arge_rid, 
+		    sc->arge_res);
+
+	if (ifp)
+		if_free(ifp);
+
+	arge_dma_free(sc);
+
+	mtx_destroy(&sc->arge_mtx);
+
+	return (0);
+
+}
+
+static int
+arge_suspend(device_t dev)
+{
+
+	panic("%s", __func__);
+	return 0;
+}
+
+static int
+arge_resume(device_t dev)
+{
+
+	panic("%s", __func__);
+	return 0;
+}
+
+static int
+arge_shutdown(device_t dev)
+{
+	struct arge_softc	*sc;
+
+	sc = device_get_softc(dev);
+
+	ARGE_LOCK(sc);
+	arge_stop(sc);
+	ARGE_UNLOCK(sc);
+
+	return (0);
+}
+
+static int
+arge_miibus_readreg(device_t dev, int phy, int reg)
+{
+	struct arge_softc * sc = device_get_softc(dev);
+	int i, result;
+	uint32_t addr = (phy << MAC_MII_PHY_ADDR_SHIFT) 
+	    | (reg & MAC_MII_REG_MASK);
+
+	if (phy != sc->arge_phy_num)
+		return (0);
+
+	ARGE_WRITE(sc, AR71XX_MAC_MII_CMD, MAC_MII_CMD_WRITE);
+	ARGE_WRITE(sc, AR71XX_MAC_MII_ADDR, addr);
+	ARGE_WRITE(sc, AR71XX_MAC_MII_CMD, MAC_MII_CMD_READ);
+
+	i = ARGE_MII_TIMEOUT;
+	while ((ARGE_READ(sc, AR71XX_MAC_MII_INDICATOR) & 
+	    MAC_MII_INDICATOR_BUSY) && (i--))
+		DELAY(5);
+
+	if (i < 0) {
+		dprintf("%s timedout\n", __func__);
+		/* XXX: return ERRNO istead? */
+		return (-1);
+	}
+
+	result = ARGE_READ(sc, AR71XX_MAC_MII_STATUS) & MAC_MII_STATUS_MASK;
+	ARGE_WRITE(sc, AR71XX_MAC_MII_CMD, MAC_MII_CMD_WRITE);
+	dprintf("%s: phy=%d, reg=%02x, value[%08x]=%04x\n", __func__, 
+		 phy, reg, addr, result);
+
+	return (result);
+}
+
+static int
+arge_miibus_writereg(device_t dev, int phy, int reg, int data)
+{
+	struct arge_softc * sc = device_get_softc(dev);
+	int i;
+	uint32_t addr = 
+	    (phy << MAC_MII_PHY_ADDR_SHIFT) | (reg & MAC_MII_REG_MASK);
+
+	dprintf("%s: phy=%d, reg=%02x, value=%04x\n", __func__, 
+	    phy, reg, data);
+
+	ARGE_WRITE(sc, AR71XX_MAC_MII_ADDR, addr);
+	ARGE_WRITE(sc, AR71XX_MAC_MII_CONTROL, data);
+
+	i = ARGE_MII_TIMEOUT;
+	while ((ARGE_READ(sc, AR71XX_MAC_MII_INDICATOR) & 
+	    MAC_MII_INDICATOR_BUSY) && (i--))
+		DELAY(5);
+
+	if (i < 0) {
+		dprintf("%s timedout\n", __func__);
+		/* XXX: return ERRNO istead? */
+		return (-1);
+	}
+
+	return (0);
+}
+
+static void
+arge_miibus_statchg(device_t dev)
+{
+	struct arge_softc		*sc;
+
+	sc = device_get_softc(dev);
+	taskqueue_enqueue(taskqueue_swi, &sc->arge_link_task);
+}
+
+static void
+arge_link_task(void *arg, int pending)
+{
+	struct arge_softc	*sc;
+	struct mii_data		*mii;
+	struct ifnet		*ifp;
+	uint32_t		media;
+	uint32_t		cfg, ifcontrol, rx_filtmask, pll, sec_cfg;
+
+	sc = (struct arge_softc *)arg;
+
+	ARGE_LOCK(sc);
+	mii = device_get_softc(sc->arge_miibus);
+	ifp = sc->arge_ifp;
+	if (mii == NULL || ifp == NULL ||
+	    (ifp->if_drv_flags & IFF_DRV_RUNNING) == 0) {
+		ARGE_UNLOCK(sc);
+		return;
+	}
+
+	if (mii->mii_media_status & IFM_ACTIVE) {
+
+		media = IFM_SUBTYPE(mii->mii_media_active);
+
+		if (media != IFM_NONE) {
+			sc->arge_link_status = 1;
+
+			cfg = ARGE_READ(sc, AR71XX_MAC_CFG2);
+			cfg &= ~(MAC_CFG2_IFACE_MODE_1000 
+			    | MAC_CFG2_IFACE_MODE_10_100 
+			    | MAC_CFG2_FULL_DUPLEX);
+
+			if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
+				cfg |= MAC_CFG2_FULL_DUPLEX;
+
+			ifcontrol = ARGE_READ(sc, AR71XX_MAC_IFCONTROL);
+			ifcontrol &= ~MAC_IFCONTROL_SPEED;
+			rx_filtmask = 
+			    ARGE_READ(sc, AR71XX_MAC_FIFO_RX_FILTMASK);
+			rx_filtmask &= ~FIFO_RX_MASK_BYTE_MODE;
+
+			switch(media) {
+			case IFM_10_T:
+				cfg |= MAC_CFG2_IFACE_MODE_10_100;
+				pll = PLL_ETH_INT_CLK_10;
+				break;
+			case IFM_100_TX:
+				cfg |= MAC_CFG2_IFACE_MODE_10_100;
+				ifcontrol |= MAC_IFCONTROL_SPEED;
+				pll = PLL_ETH_INT_CLK_100;
+				break;
+			case IFM_1000_T:
+			case IFM_1000_SX:
+				cfg |= MAC_CFG2_IFACE_MODE_1000;
+				rx_filtmask |= FIFO_RX_MASK_BYTE_MODE;
+				pll = PLL_ETH_INT_CLK_1000;
+				break;
+			default:
+				pll = PLL_ETH_INT_CLK_100;
+				device_printf(sc->arge_dev, 
+				    "Unknown media %d\n", media);
+			}
+
+			ARGE_WRITE(sc, AR71XX_MAC_FIFO_TX_THRESHOLD,
+			    0x008001ff);
+
+			ARGE_WRITE(sc, AR71XX_MAC_CFG2, cfg);
+			ARGE_WRITE(sc, AR71XX_MAC_IFCONTROL, ifcontrol);
+			ARGE_WRITE(sc, AR71XX_MAC_FIFO_RX_FILTMASK, 
+			    rx_filtmask);
+
+			/* set PLL registers */
+			sec_cfg = ATH_READ_REG(AR71XX_PLL_CPU_CONFIG);
+			sec_cfg &= ~(3 << 17);
+			sec_cfg |= (2 << 17);
+
+			ATH_WRITE_REG(AR71XX_PLL_CPU_CONFIG, sec_cfg);
+			DELAY(100);
+
+			ATH_WRITE_REG(sc->arge_pll_reg, pll);
+
+			sec_cfg |= (3 << 17);
+			ATH_WRITE_REG(AR71XX_PLL_CPU_CONFIG, sec_cfg);
+			DELAY(100);
+
+			sec_cfg &= ~(3 << 17);
+			ATH_WRITE_REG(AR71XX_PLL_CPU_CONFIG, sec_cfg);
+			DELAY(100);
+		}
+	} else
+		sc->arge_link_status = 0;
+
+	ARGE_UNLOCK(sc);
+}
+
+static void
+arge_reset_dma(struct arge_softc *sc)
+{
+	ARGE_WRITE(sc, AR71XX_DMA_RX_CONTROL, 0);
+	ARGE_WRITE(sc, AR71XX_DMA_TX_CONTROL, 0);
+
+	ARGE_WRITE(sc, AR71XX_DMA_RX_DESC, 0);
+	ARGE_WRITE(sc, AR71XX_DMA_TX_DESC, 0);
+
+	/* Clear all possible RX interrupts */
+	while(ARGE_READ(sc, AR71XX_DMA_RX_STATUS) & DMA_RX_STATUS_PKT_RECVD)
+		ARGE_WRITE(sc, AR71XX_DMA_RX_STATUS, DMA_RX_STATUS_PKT_RECVD);
+
+	/* 
+	 * Clear all possible TX interrupts
+	 */
+	while(ARGE_READ(sc, AR71XX_DMA_TX_STATUS) & DMA_TX_STATUS_PKT_SENT)
+		ARGE_WRITE(sc, AR71XX_DMA_TX_STATUS, DMA_TX_STATUS_PKT_SENT);
+
+	/* 
+	 * Now Rx/Tx errors
+	 */
+	ARGE_WRITE(sc, AR71XX_DMA_RX_STATUS, 
+	    DMA_RX_STATUS_BUS_ERROR | DMA_RX_STATUS_OVERFLOW);
+	ARGE_WRITE(sc, AR71XX_DMA_TX_STATUS, 
+	    DMA_TX_STATUS_BUS_ERROR | DMA_TX_STATUS_UNDERRUN);
+}
+
+
+
+static void
+arge_init(void *xsc)
+{
+	struct arge_softc	 *sc = xsc;
+
+	ARGE_LOCK(sc);
+	arge_init_locked(sc);
+	ARGE_UNLOCK(sc);
+}
+
+static void
+arge_init_locked(struct arge_softc *sc)
+{
+	struct ifnet		*ifp = sc->arge_ifp;
+	struct mii_data		*mii;
+
+	ARGE_LOCK_ASSERT(sc);
+
+	mii = device_get_softc(sc->arge_miibus);
+
+	arge_stop(sc);
+
+	/* Init circular RX list. */
+	if (arge_rx_ring_init(sc) != 0) {
+		device_printf(sc->arge_dev,
+		    "initialization failed: no memory for rx buffers\n");
+		arge_stop(sc);
+		return;
+	}
+
+	/* Init tx descriptors. */
+	arge_tx_ring_init(sc);
+
+	arge_reset_dma(sc);
+
+	sc->arge_link_status = 0;
+	mii_mediachg(mii);
+
+	ifp->if_drv_flags |= IFF_DRV_RUNNING;
+	ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+
+	callout_reset(&sc->arge_stat_callout, hz, arge_tick, sc);
+
+	ARGE_WRITE(sc, AR71XX_DMA_TX_DESC, ARGE_TX_RING_ADDR(sc, 0));
+	ARGE_WRITE(sc, AR71XX_DMA_RX_DESC, ARGE_RX_RING_ADDR(sc, 0));
+
+	/* Start listening */
+	ARGE_WRITE(sc, AR71XX_DMA_RX_CONTROL, DMA_RX_CONTROL_EN);
+
+	/* Enable interrupts */
+	ARGE_WRITE(sc, AR71XX_DMA_INTR, DMA_INTR_ALL);
+}
+
+/*
+ * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
+ * pointers to the fragment pointers.
+ */
+static int
+arge_encap(struct arge_softc *sc, struct mbuf **m_head)
+{
+	struct arge_txdesc	*txd;
+	struct arge_desc	*desc, *prev_desc;
+	bus_dma_segment_t	txsegs[ARGE_MAXFRAGS];
+	int			error, i, nsegs, prod, prev_prod;
+	struct mbuf		*m;
+
+	ARGE_LOCK_ASSERT(sc);
+
+	/*
+	 * Fix mbuf chain, all fragments should be 4 bytes aligned and
+	 * even 4 bytes
+	 */
+	m = *m_head;
+	if((mtod(m, intptr_t) & 3) != 0) {
+		m = m_defrag(*m_head, M_DONTWAIT);
+		if (m == NULL) {
+			*m_head = NULL;
+			return (ENOBUFS);
+		}
+		*m_head = m;
+	}
+
+	prod = sc->arge_cdata.arge_tx_prod;
+	txd = &sc->arge_cdata.arge_txdesc[prod];
+	error = bus_dmamap_load_mbuf_sg(sc->arge_cdata.arge_tx_tag, 
+	    txd->tx_dmamap, *m_head, txsegs, &nsegs, BUS_DMA_NOWAIT);
+
+	if (error == EFBIG) {
+		panic("EFBIG");
+	} else if (error != 0)
+		return (error);
+
+	if (nsegs == 0) {
+		m_freem(*m_head);
+		*m_head = NULL;
+		return (EIO);
+	}
+
+	/* Check number of available descriptors. */
+	if (sc->arge_cdata.arge_tx_cnt + nsegs >= (ARGE_TX_RING_COUNT - 1)) {
+		bus_dmamap_unload(sc->arge_cdata.arge_tx_tag, txd->tx_dmamap);
+		return (ENOBUFS);
+	}
+
+	txd->tx_m = *m_head;
+	bus_dmamap_sync(sc->arge_cdata.arge_tx_tag, txd->tx_dmamap,
+	    BUS_DMASYNC_PREWRITE);
+
+	/* 
+	 * Make a list of descriptors for this packet. DMA controller will
+	 * walk through it while arge_link is not zero.
+	 */
+	prev_prod = prod;
+	desc = prev_desc = NULL;
+	for (i = 0; i < nsegs; i++) {
+		desc = &sc->arge_rdata.arge_tx_ring[prod];
+		desc->packet_ctrl = ARGE_DMASIZE(txsegs[i].ds_len);
+
+		if (txsegs[i].ds_addr & 3)
+			panic("TX packet address unaligned\n");
+
+		desc->packet_addr = txsegs[i].ds_addr;
+		
+		/* link with previous descriptor */
+		if (prev_desc)
+			prev_desc->packet_ctrl |= ARGE_DESC_MORE;
+
+		sc->arge_cdata.arge_tx_cnt++;
+		prev_desc = desc;
+		ARGE_INC(prod, ARGE_TX_RING_COUNT);
+	}
+
+	/* Update producer index. */
+	sc->arge_cdata.arge_tx_prod = prod;
+
+	/* Sync descriptors. */
+	bus_dmamap_sync(sc->arge_cdata.arge_tx_ring_tag,
+	    sc->arge_cdata.arge_tx_ring_map,
+	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
+
+	/* Start transmitting */
+	ARGE_WRITE(sc, AR71XX_DMA_TX_CONTROL, DMA_TX_CONTROL_EN);
+	return (0);
+}
+
+static void
+arge_start(struct ifnet *ifp)
+{
+	struct arge_softc	 *sc;
+
+	sc = ifp->if_softc;
+
+	ARGE_LOCK(sc);
+	arge_start_locked(ifp);
+	ARGE_UNLOCK(sc);
+}
+
+static void
+arge_start_locked(struct ifnet *ifp)
+{
+	struct arge_softc	*sc;
+	struct mbuf		*m_head;
+	int			enq;
+
+	sc = ifp->if_softc;
+
+	ARGE_LOCK_ASSERT(sc);
+
+	if ((ifp->if_drv_flags & (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=
+	    IFF_DRV_RUNNING || sc->arge_link_status == 0 )
+		return;
+
+	arge_flush_ddr(sc);
+
+	for (enq = 0; !IFQ_DRV_IS_EMPTY(&ifp->if_snd) &&
+	    sc->arge_cdata.arge_tx_cnt < ARGE_TX_RING_COUNT - 2; ) {
+		IFQ_DRV_DEQUEUE(&ifp->if_snd, m_head);
+		if (m_head == NULL)
+			break;
+
+
+		/*
+		 * Pack the data into the transmit ring.
+		 */
+		if (arge_encap(sc, &m_head)) {
+			if (m_head == NULL)
+				break;
+			IFQ_DRV_PREPEND(&ifp->if_snd, m_head);
+			ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+			break;
+		}
+
+		enq++;
+		/*
+		 * If there's a BPF listener, bounce a copy of this frame
+		 * to him.
+		 */
+		ETHER_BPF_MTAP(ifp, m_head);
+	}
+}
+
+static void
+arge_stop(struct arge_softc *sc)
+{
+	struct ifnet	    *ifp;
+
+	ARGE_LOCK_ASSERT(sc);
+
+	ifp = sc->arge_ifp;
+	ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
+	callout_stop(&sc->arge_stat_callout);
+
+	/* mask out interrupts */
+	ARGE_WRITE(sc, AR71XX_DMA_INTR, 0);
+
+	arge_reset_dma(sc);
+}
+
+
+static int
+arge_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
+{
+	struct arge_softc		*sc = ifp->if_softc;
+	struct ifreq		*ifr = (struct ifreq *) data;
+	struct mii_data		*mii;
+	int			error;
+#ifdef DEVICE_POLLING
+	int			mask;
+#endif
+
+	switch (command) {
+	case SIOCSIFFLAGS:
+		printf("Implement me: SIOCSIFFLAGS\n");
+		error = 0;
+		break;
+	case SIOCADDMULTI:
+	case SIOCDELMULTI:
+		printf("Implement me: SIOCDELMULTI\n");
+		error = 0;
+		break;
+	case SIOCGIFMEDIA:
+	case SIOCSIFMEDIA:
+		printf("Implement me: SIOCSIFMEDIA\n");
+		mii = device_get_softc(sc->arge_miibus);
+		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
+		break;
+        case SIOCSIFCAP:
+		printf("Implement me: SIOCSIFCAP\n");
+#ifdef DEVICE_POLLING
+                mask = ifp->if_capenable ^ ifr->ifr_reqcap;
+		error  = 0;
+                if (mask & IFCAP_POLLING) {
+                        if (ifr->ifr_reqcap & IFCAP_POLLING) {
+				ARGE_WRITE(sc, AR71XX_DMA_INTR, 0);
+                                error = ether_poll_register(arge_poll, ifp);
+                                if (error)
+                                        return error;
+                                ARGE_LOCK(sc);
+                                ifp->if_capenable |= IFCAP_POLLING;
+                                ARGE_UNLOCK(sc);
+                        } else {
+				ARGE_WRITE(sc, AR71XX_DMA_INTR, DMA_INTR_ALL);
+                                error = ether_poll_deregister(ifp);
+                                ARGE_LOCK(sc);
+                                ifp->if_capenable &= ~IFCAP_POLLING;
+                                ARGE_UNLOCK(sc);
+                        }
+                }
+                break;
+#endif
+	default:
+		error = ether_ioctl(ifp, command, data);
+		break;
+	}
+
+	return (error);
+}
+
+/*
+ * Set media options.
+ */
+static int
+arge_ifmedia_upd(struct ifnet *ifp)
+{
+	struct arge_softc		*sc;
+	struct mii_data		*mii;
+	struct mii_softc	*miisc;
+	int			error;
+
+	sc = ifp->if_softc;
+	ARGE_LOCK(sc);
+	mii = device_get_softc(sc->arge_miibus);
+	if (mii->mii_instance) {
+		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
+			mii_phy_reset(miisc);
+	}
+	error = mii_mediachg(mii);
+	ARGE_UNLOCK(sc);
+
+	return (error);
+}
+
+/*
+ * Report current media status.
+ */
+static void
+arge_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
+{
+	struct arge_softc		*sc = ifp->if_softc;
+	struct mii_data		*mii;
+
+	mii = device_get_softc(sc->arge_miibus);
+	ARGE_LOCK(sc);
+	mii_pollstat(mii);
+	ARGE_UNLOCK(sc);
+	ifmr->ifm_active = mii->mii_media_active;
+	ifmr->ifm_status = mii->mii_media_status;
+}
+
+struct arge_dmamap_arg {
+	bus_addr_t	arge_busaddr;
+};
+
+static void
+arge_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error)
+{
+	struct arge_dmamap_arg	*ctx;
+
+	if (error != 0)
+		return;
+	ctx = arg;
+	ctx->arge_busaddr = segs[0].ds_addr;
+}
+
+static int
+arge_dma_alloc(struct arge_softc *sc)
+{
+	struct arge_dmamap_arg	ctx;
+	struct arge_txdesc	*txd;
+	struct arge_rxdesc	*rxd;
+	int			error, i;
+
+	/* Create parent DMA tag. */
+	error = bus_dma_tag_create(
+	    bus_get_dma_tag(sc->arge_dev),	/* parent */
+	    1, 0,			/* alignment, boundary */
+	    BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */
+	    BUS_SPACE_MAXADDR,		/* highaddr */
+	    NULL, NULL,			/* filter, filterarg */
+	    BUS_SPACE_MAXSIZE_32BIT,	/* maxsize */
+	    0,				/* nsegments */
+	    BUS_SPACE_MAXSIZE_32BIT,	/* maxsegsize */
+	    0,				/* flags */
+	    NULL, NULL,			/* lockfunc, lockarg */
+	    &sc->arge_cdata.arge_parent_tag);
+	if (error != 0) {
+		device_printf(sc->arge_dev, "failed to create parent DMA tag\n");
+		goto fail;
+	}
+	/* Create tag for Tx ring. */
+	error = bus_dma_tag_create(
+	    sc->arge_cdata.arge_parent_tag,	/* parent */
+	    ARGE_RING_ALIGN, 0,		/* alignment, boundary */
+	    BUS_SPACE_MAXADDR,		/* lowaddr */
+	    BUS_SPACE_MAXADDR,		/* highaddr */
+	    NULL, NULL,			/* filter, filterarg */
+	    ARGE_TX_DMA_SIZE,		/* maxsize */
+	    1,				/* nsegments */
+	    ARGE_TX_DMA_SIZE,		/* maxsegsize */
+	    0,				/* flags */
+	    NULL, NULL,			/* lockfunc, lockarg */
+	    &sc->arge_cdata.arge_tx_ring_tag);
+	if (error != 0) {
+		device_printf(sc->arge_dev, "failed to create Tx ring DMA tag\n");
+		goto fail;
+	}
+
+	/* Create tag for Rx ring. */
+	error = bus_dma_tag_create(
+	    sc->arge_cdata.arge_parent_tag,	/* parent */
+	    ARGE_RING_ALIGN, 0,		/* alignment, boundary */
+	    BUS_SPACE_MAXADDR,		/* lowaddr */
+	    BUS_SPACE_MAXADDR,		/* highaddr */
+	    NULL, NULL,			/* filter, filterarg */
+	    ARGE_RX_DMA_SIZE,		/* maxsize */
+	    1,				/* nsegments */
+	    ARGE_RX_DMA_SIZE,		/* maxsegsize */
+	    0,				/* flags */
+	    NULL, NULL,			/* lockfunc, lockarg */
+	    &sc->arge_cdata.arge_rx_ring_tag);
+	if (error != 0) {
+		device_printf(sc->arge_dev, "failed to create Rx ring DMA tag\n");
+		goto fail;
+	}
+
+	/* Create tag for Tx buffers. */
+	error = bus_dma_tag_create(
+	    sc->arge_cdata.arge_parent_tag,	/* parent */
+	    sizeof(uint32_t), 0,	/* alignment, boundary */
+	    BUS_SPACE_MAXADDR,		/* lowaddr */
+	    BUS_SPACE_MAXADDR,		/* highaddr */
+	    NULL, NULL,			/* filter, filterarg */
+	    MCLBYTES * ARGE_MAXFRAGS,	/* maxsize */
+	    ARGE_MAXFRAGS,		/* nsegments */
+	    MCLBYTES,			/* maxsegsize */
+	    0,				/* flags */
+	    NULL, NULL,			/* lockfunc, lockarg */
+	    &sc->arge_cdata.arge_tx_tag);
+	if (error != 0) {
+		device_printf(sc->arge_dev, "failed to create Tx DMA tag\n");
+		goto fail;
+	}
+
+	/* Create tag for Rx buffers. */
+	error = bus_dma_tag_create(
+	    sc->arge_cdata.arge_parent_tag,	/* parent */
+	    ARGE_RX_ALIGN, 0,		/* alignment, boundary */
+	    BUS_SPACE_MAXADDR,		/* lowaddr */
+	    BUS_SPACE_MAXADDR,		/* highaddr */
+	    NULL, NULL,			/* filter, filterarg */
+	    MCLBYTES,			/* maxsize */
+	    ARGE_MAXFRAGS,		/* nsegments */
+	    MCLBYTES,			/* maxsegsize */
+	    0,				/* flags */
+	    NULL, NULL,			/* lockfunc, lockarg */
+	    &sc->arge_cdata.arge_rx_tag);
+	if (error != 0) {
+		device_printf(sc->arge_dev, "failed to create Rx DMA tag\n");
+		goto fail;
+	}
+
+	/* Allocate DMA'able memory and load the DMA map for Tx ring. */
+	error = bus_dmamem_alloc(sc->arge_cdata.arge_tx_ring_tag,
+	    (void **)&sc->arge_rdata.arge_tx_ring, BUS_DMA_WAITOK |
+	    BUS_DMA_COHERENT | BUS_DMA_ZERO, &sc->arge_cdata.arge_tx_ring_map);
+	if (error != 0) {
+		device_printf(sc->arge_dev,
+		    "failed to allocate DMA'able memory for Tx ring\n");
+		goto fail;
+	}
+
+	ctx.arge_busaddr = 0;
+	error = bus_dmamap_load(sc->arge_cdata.arge_tx_ring_tag,
+	    sc->arge_cdata.arge_tx_ring_map, sc->arge_rdata.arge_tx_ring,
+	    ARGE_TX_DMA_SIZE, arge_dmamap_cb, &ctx, 0);
+	if (error != 0 || ctx.arge_busaddr == 0) {
+		device_printf(sc->arge_dev,
+		    "failed to load DMA'able memory for Tx ring\n");
+		goto fail;
+	}
+	sc->arge_rdata.arge_tx_ring_paddr = ctx.arge_busaddr;
+
+	/* Allocate DMA'able memory and load the DMA map for Rx ring. */
+	error = bus_dmamem_alloc(sc->arge_cdata.arge_rx_ring_tag,
+	    (void **)&sc->arge_rdata.arge_rx_ring, BUS_DMA_WAITOK |
+	    BUS_DMA_COHERENT | BUS_DMA_ZERO, &sc->arge_cdata.arge_rx_ring_map);
+	if (error != 0) {
+		device_printf(sc->arge_dev,
+		    "failed to allocate DMA'able memory for Rx ring\n");
+		goto fail;
+	}
+
+	ctx.arge_busaddr = 0;
+	error = bus_dmamap_load(sc->arge_cdata.arge_rx_ring_tag,
+	    sc->arge_cdata.arge_rx_ring_map, sc->arge_rdata.arge_rx_ring,
+	    ARGE_RX_DMA_SIZE, arge_dmamap_cb, &ctx, 0);
+	if (error != 0 || ctx.arge_busaddr == 0) {
+		device_printf(sc->arge_dev,
+		    "failed to load DMA'able memory for Rx ring\n");
+		goto fail;
+	}
+	sc->arge_rdata.arge_rx_ring_paddr = ctx.arge_busaddr;
+
+	/* Create DMA maps for Tx buffers. */
+	for (i = 0; i < ARGE_TX_RING_COUNT; i++) {
+		txd = &sc->arge_cdata.arge_txdesc[i];
+		txd->tx_m = NULL;
+		txd->tx_dmamap = NULL;
+		error = bus_dmamap_create(sc->arge_cdata.arge_tx_tag, 0,
+		    &txd->tx_dmamap);
+		if (error != 0) {
+			device_printf(sc->arge_dev,
+			    "failed to create Tx dmamap\n");
+			goto fail;
+		}
+	}
+	/* Create DMA maps for Rx buffers. */
+	if ((error = bus_dmamap_create(sc->arge_cdata.arge_rx_tag, 0,
+	    &sc->arge_cdata.arge_rx_sparemap)) != 0) {
+		device_printf(sc->arge_dev,
+		    "failed to create spare Rx dmamap\n");
+		goto fail;
+	}
+	for (i = 0; i < ARGE_RX_RING_COUNT; i++) {
+		rxd = &sc->arge_cdata.arge_rxdesc[i];
+		rxd->rx_m = NULL;
+		rxd->rx_dmamap = NULL;
+		error = bus_dmamap_create(sc->arge_cdata.arge_rx_tag, 0,
+		    &rxd->rx_dmamap);
+		if (error != 0) {
+			device_printf(sc->arge_dev,
+			    "failed to create Rx dmamap\n");
+			goto fail;
+		}
+	}
+
+fail:
+	return (error);
+}
+
+static void
+arge_dma_free(struct arge_softc *sc)
+{
+	struct arge_txdesc	*txd;
+	struct arge_rxdesc	*rxd;
+	int			i;
+
+	/* Tx ring. */
+	if (sc->arge_cdata.arge_tx_ring_tag) {
+		if (sc->arge_cdata.arge_tx_ring_map)
+			bus_dmamap_unload(sc->arge_cdata.arge_tx_ring_tag,
+			    sc->arge_cdata.arge_tx_ring_map);
+		if (sc->arge_cdata.arge_tx_ring_map &&
+		    sc->arge_rdata.arge_tx_ring)
+			bus_dmamem_free(sc->arge_cdata.arge_tx_ring_tag,
+			    sc->arge_rdata.arge_tx_ring,
+			    sc->arge_cdata.arge_tx_ring_map);
+		sc->arge_rdata.arge_tx_ring = NULL;
+		sc->arge_cdata.arge_tx_ring_map = NULL;
+		bus_dma_tag_destroy(sc->arge_cdata.arge_tx_ring_tag);
+		sc->arge_cdata.arge_tx_ring_tag = NULL;
+	}
+	/* Rx ring. */
+	if (sc->arge_cdata.arge_rx_ring_tag) {
+		if (sc->arge_cdata.arge_rx_ring_map)
+			bus_dmamap_unload(sc->arge_cdata.arge_rx_ring_tag,
+			    sc->arge_cdata.arge_rx_ring_map);
+		if (sc->arge_cdata.arge_rx_ring_map &&
+		    sc->arge_rdata.arge_rx_ring)
+			bus_dmamem_free(sc->arge_cdata.arge_rx_ring_tag,
+			    sc->arge_rdata.arge_rx_ring,
+			    sc->arge_cdata.arge_rx_ring_map);
+		sc->arge_rdata.arge_rx_ring = NULL;
+		sc->arge_cdata.arge_rx_ring_map = NULL;
+		bus_dma_tag_destroy(sc->arge_cdata.arge_rx_ring_tag);
+		sc->arge_cdata.arge_rx_ring_tag = NULL;
+	}
+	/* Tx buffers. */
+	if (sc->arge_cdata.arge_tx_tag) {
+		for (i = 0; i < ARGE_TX_RING_COUNT; i++) {
+			txd = &sc->arge_cdata.arge_txdesc[i];
+			if (txd->tx_dmamap) {
+				bus_dmamap_destroy(sc->arge_cdata.arge_tx_tag,
+				    txd->tx_dmamap);
+				txd->tx_dmamap = NULL;
+			}
+		}
+		bus_dma_tag_destroy(sc->arge_cdata.arge_tx_tag);
+		sc->arge_cdata.arge_tx_tag = NULL;
+	}
+	/* Rx buffers. */
+	if (sc->arge_cdata.arge_rx_tag) {
+		for (i = 0; i < ARGE_RX_RING_COUNT; i++) {
+			rxd = &sc->arge_cdata.arge_rxdesc[i];
+			if (rxd->rx_dmamap) {
+				bus_dmamap_destroy(sc->arge_cdata.arge_rx_tag,
+				    rxd->rx_dmamap);
+				rxd->rx_dmamap = NULL;
+			}
+		}
+		if (sc->arge_cdata.arge_rx_sparemap) {
+			bus_dmamap_destroy(sc->arge_cdata.arge_rx_tag,
+			    sc->arge_cdata.arge_rx_sparemap);
+			sc->arge_cdata.arge_rx_sparemap = 0;
+		}
+		bus_dma_tag_destroy(sc->arge_cdata.arge_rx_tag);
+		sc->arge_cdata.arge_rx_tag = NULL;
+	}
+
+	if (sc->arge_cdata.arge_parent_tag) {
+		bus_dma_tag_destroy(sc->arge_cdata.arge_parent_tag);
+		sc->arge_cdata.arge_parent_tag = NULL;
+	}
+}
+
+/*
+ * Initialize the transmit descriptors.
+ */
+static int
+arge_tx_ring_init(struct arge_softc *sc)
+{
+	struct arge_ring_data	*rd;
+	struct arge_txdesc	*txd;
+	bus_addr_t		addr;
+	int			i;
+
+	sc->arge_cdata.arge_tx_prod = 0;
+	sc->arge_cdata.arge_tx_cons = 0;
+	sc->arge_cdata.arge_tx_cnt = 0;
+	sc->arge_cdata.arge_tx_pkts = 0;
+
+	rd = &sc->arge_rdata;
+	bzero(rd->arge_tx_ring, sizeof(rd->arge_tx_ring));
+	for (i = 0; i < ARGE_TX_RING_COUNT; i++) {
+		if (i == ARGE_TX_RING_COUNT - 1)
+			addr = ARGE_TX_RING_ADDR(sc, 0);
+		else
+			addr = ARGE_TX_RING_ADDR(sc, i + 1);
+		rd->arge_tx_ring[i].packet_ctrl = ARGE_DESC_EMPTY;
+		rd->arge_tx_ring[i].next_desc = addr;
+		txd = &sc->arge_cdata.arge_txdesc[i];
+		txd->tx_m = NULL;
+	}
+
+	bus_dmamap_sync(sc->arge_cdata.arge_tx_ring_tag,
+	    sc->arge_cdata.arge_tx_ring_map,
+	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
+
+	return (0);
+}
+
+/*
+ * Initialize the RX descriptors and allocate mbufs for them. Note that
+ * we arrange the descriptors in a closed ring, so that the last descriptor
+ * points back to the first.
+ */
+static int
+arge_rx_ring_init(struct arge_softc *sc)
+{
+	struct arge_ring_data	*rd;
+	struct arge_rxdesc	*rxd;
+	bus_addr_t		addr;
+	int			i;
+
+	sc->arge_cdata.arge_rx_cons = 0;
+
+	rd = &sc->arge_rdata;
+	bzero(rd->arge_rx_ring, sizeof(rd->arge_rx_ring));
+	for (i = 0; i < ARGE_RX_RING_COUNT; i++) {
+		rxd = &sc->arge_cdata.arge_rxdesc[i];
+		rxd->rx_m = NULL;
+		rxd->desc = &rd->arge_rx_ring[i];
+		if (i == ARGE_RX_RING_COUNT - 1)
+			addr = ARGE_RX_RING_ADDR(sc, 0);
+		else
+			addr = ARGE_RX_RING_ADDR(sc, i + 1);
+		rd->arge_rx_ring[i].next_desc = addr;
+		if (arge_newbuf(sc, i) != 0) {
+			return (ENOBUFS);
+		}
+	}
+
+	bus_dmamap_sync(sc->arge_cdata.arge_rx_ring_tag,
+	    sc->arge_cdata.arge_rx_ring_map,
+	    BUS_DMASYNC_PREWRITE);
+
+	return (0);
+}
+
+/*
+ * Initialize an RX descriptor and attach an MBUF cluster.
+ */
+static int
+arge_newbuf(struct arge_softc *sc, int idx)
+{
+	struct arge_desc		*desc;
+	struct arge_rxdesc	*rxd;
+	struct mbuf		*m;
+	bus_dma_segment_t	segs[1];
+	bus_dmamap_t		map;
+	int			nsegs;
+
+	m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
+	if (m == NULL)
+		return (ENOBUFS);
+	m->m_len = m->m_pkthdr.len = MCLBYTES;
+	m_adj(m, sizeof(uint64_t));
+
+	if (bus_dmamap_load_mbuf_sg(sc->arge_cdata.arge_rx_tag,
+	    sc->arge_cdata.arge_rx_sparemap, m, segs, &nsegs, 0) != 0) {
+		m_freem(m);
+		return (ENOBUFS);
+	}
+	KASSERT(nsegs == 1, ("%s: %d segments returned!", __func__, nsegs));
+
+	rxd = &sc->arge_cdata.arge_rxdesc[idx];
+	if (rxd->rx_m != NULL) {
+		bus_dmamap_unload(sc->arge_cdata.arge_rx_tag, rxd->rx_dmamap);
+	}
+	map = rxd->rx_dmamap;
+	rxd->rx_dmamap = sc->arge_cdata.arge_rx_sparemap;
+	sc->arge_cdata.arge_rx_sparemap = map;
+	rxd->rx_m = m;
+	desc = rxd->desc;
+	if (segs[0].ds_addr & 3)
+		panic("RX packet address unaligned");
+	desc->packet_addr = segs[0].ds_addr;
+	desc->packet_ctrl = ARGE_DESC_EMPTY | ARGE_DMASIZE(segs[0].ds_len);
+
+	bus_dmamap_sync(sc->arge_cdata.arge_rx_ring_tag,
+	    sc->arge_cdata.arge_rx_ring_map,
+	    BUS_DMASYNC_PREWRITE);
+
+	return (0);
+}
+
+static __inline void
+arge_fixup_rx(struct mbuf *m)
+{
+        int		i;
+        uint16_t	*src, *dst;
+
+	src = mtod(m, uint16_t *);
+	dst = src - 1;
+
+	for (i = 0; i < m->m_len / sizeof(uint16_t); i++) {
+		*dst++ = *src++;
+	}
+
+	if (m->m_len % sizeof(uint16_t))
+		*(uint8_t *)dst = *(uint8_t *)src;
+
+	m->m_data -= ETHER_ALIGN;
+}
+
+#ifdef DEVICE_POLLING
+static void
+arge_poll(struct ifnet *ifp, enum poll_cmd cmd, int count)
+{
+	struct arge_softc *sc = ifp->if_softc;
+
+        if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+		ARGE_LOCK(sc);
+		arge_tx_locked(sc);
+		arge_rx_locked(sc);
+		ARGE_UNLOCK(sc);
+        }
+}
+#endif /* DEVICE_POLLING */
+
+
+static void
+arge_tx_locked(struct arge_softc *sc)
+{
+	struct arge_txdesc	*txd;
+	struct arge_desc	*cur_tx;
+	struct ifnet		*ifp;
+	uint32_t		ctrl;
+	int			cons, prod;
+
+	ARGE_LOCK_ASSERT(sc);
+
+	cons = sc->arge_cdata.arge_tx_cons;
+	prod = sc->arge_cdata.arge_tx_prod;
+	if (cons == prod)
+		return;
+
+	bus_dmamap_sync(sc->arge_cdata.arge_tx_ring_tag,
+	    sc->arge_cdata.arge_tx_ring_map,
+	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
+
+	ifp = sc->arge_ifp;
+	/*
+	 * Go through our tx list and free mbufs for those
+	 * frames that have been transmitted.
+	 */
+	for (; cons != prod; ARGE_INC(cons, ARGE_TX_RING_COUNT)) {
+		cur_tx = &sc->arge_rdata.arge_tx_ring[cons];
+		ctrl = cur_tx->packet_ctrl;
+		/* Check if descriptor has "finished" flag */
+		if ((ctrl & ARGE_DESC_EMPTY) == 0)
+			break;
+
+		ARGE_WRITE(sc, AR71XX_DMA_TX_STATUS, DMA_TX_STATUS_PKT_SENT);
+
+		sc->arge_cdata.arge_tx_cnt--;
+		ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+
+		txd = &sc->arge_cdata.arge_txdesc[cons];
+
+		ifp->if_opackets++;
+
+		bus_dmamap_sync(sc->arge_cdata.arge_tx_tag, txd->tx_dmamap,
+		    BUS_DMASYNC_POSTWRITE);
+		bus_dmamap_unload(sc->arge_cdata.arge_tx_tag, txd->tx_dmamap);
+
+		/* Free only if it's first descriptor in list */
+		if (txd->tx_m)
+			m_freem(txd->tx_m);
+		txd->tx_m = NULL;
+
+		/* reset descriptor */
+		cur_tx->packet_addr = 0;
+	}
+
+	sc->arge_cdata.arge_tx_cons = cons;
+
+	bus_dmamap_sync(sc->arge_cdata.arge_tx_ring_tag,
+	    sc->arge_cdata.arge_tx_ring_map, BUS_DMASYNC_PREWRITE);
+}
+
+
+static void
+arge_rx_locked(struct arge_softc *sc)
+{
+	struct arge_rxdesc	*rxd;
+	struct ifnet		*ifp = sc->arge_ifp;
+	int			cons, prog, packet_len, i;
+	struct arge_desc	*cur_rx;
+	struct mbuf		*m;
+
+	ARGE_LOCK_ASSERT(sc);
+
+	cons = sc->arge_cdata.arge_rx_cons;
+
+	bus_dmamap_sync(sc->arge_cdata.arge_rx_ring_tag,
+	    sc->arge_cdata.arge_rx_ring_map,
+	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
+
+	for (prog = 0; prog < ARGE_RX_RING_COUNT; 
+	    ARGE_INC(cons, ARGE_RX_RING_COUNT)) {
+		cur_rx = &sc->arge_rdata.arge_rx_ring[cons];
+		rxd = &sc->arge_cdata.arge_rxdesc[cons];
+		m = rxd->rx_m;
+
+		if ((cur_rx->packet_ctrl & ARGE_DESC_EMPTY) != 0)
+		       break;	
+
+		ARGE_WRITE(sc, AR71XX_DMA_RX_STATUS, DMA_RX_STATUS_PKT_RECVD);
+
+		prog++;
+
+		packet_len = ARGE_DMASIZE(cur_rx->packet_ctrl);
+		bus_dmamap_sync(sc->arge_cdata.arge_rx_tag, rxd->rx_dmamap,
+		    BUS_DMASYNC_POSTREAD);
+		m = rxd->rx_m;
+
+		arge_fixup_rx(m);
+		m->m_pkthdr.rcvif = ifp;
+		/* Skip 4 bytes of CRC */
+		m->m_pkthdr.len = m->m_len = packet_len - ETHER_CRC_LEN;
+		ifp->if_ipackets++;
+
+		ARGE_UNLOCK(sc);
+		(*ifp->if_input)(ifp, m);
+		ARGE_LOCK(sc);
+		cur_rx->packet_addr = 0;
+	}
+
+	if (prog > 0) {
+
+		i = sc->arge_cdata.arge_rx_cons;
+		for (; prog > 0 ; prog--) {
+			if (arge_newbuf(sc, i) != 0) {
+				device_printf(sc->arge_dev, 
+				    "Failed to allocate buffer\n");
+				break;
+			}
+			ARGE_INC(i, ARGE_RX_RING_COUNT);
+		}
+
+		bus_dmamap_sync(sc->arge_cdata.arge_rx_ring_tag,
+		    sc->arge_cdata.arge_rx_ring_map,
+		    BUS_DMASYNC_PREWRITE);
+
+		sc->arge_cdata.arge_rx_cons = cons;
+	}
+}
+
+static int
+arge_intr_filter(void *arg)
+{
+	struct arge_softc	*sc = arg;
+	uint32_t		status, ints;
+
+	status = ARGE_READ(sc, AR71XX_DMA_INTR_STATUS);
+	ints = ARGE_READ(sc, AR71XX_DMA_INTR);
+
+#if 0
+	dprintf("int mask(filter) = %b\n", ints,
+	    "\20\10RX_BUS_ERROR\7RX_OVERFLOW\5RX_PKT_RCVD"
+	    "\4TX_BUS_ERROR\2TX_UNDERRUN\1TX_PKT_SENT");
+	dprintf("status(filter) = %b\n", status, 
+	    "\20\10RX_BUS_ERROR\7RX_OVERFLOW\5RX_PKT_RCVD"
+	    "\4TX_BUS_ERROR\2TX_UNDERRUN\1TX_PKT_SENT");
+#endif
+
+	if (status & DMA_INTR_ALL) {
+		sc->arge_intr_status |= status;
+		ARGE_WRITE(sc, AR71XX_DMA_INTR, 0);
+		return (FILTER_SCHEDULE_THREAD);
+	} 
+
+	sc->arge_intr_status = 0;
+	return (FILTER_STRAY);
+}
+
+static void
+arge_intr(void *arg)
+{
+	struct arge_softc	*sc = arg;
+	uint32_t		status;
+
+	status = ARGE_READ(sc, AR71XX_DMA_INTR_STATUS);
+	status |= sc->arge_intr_status;
+
+#if 0
+	dprintf("int status(intr) = %b\n", status, 
+	    "\20\10\7RX_OVERFLOW\5RX_PKT_RCVD"
+	    "\4TX_BUS_ERROR\2TX_UNDERRUN\1TX_PKT_SENT");
+#endif
+
+	/* 
+	 * Is it our interrupt at all? 
+	 */
+	if (status == 0)
+		return;
+
+	if (status & DMA_INTR_RX_BUS_ERROR) {
+		ARGE_WRITE(sc, AR71XX_DMA_RX_STATUS, DMA_RX_STATUS_BUS_ERROR);
+		device_printf(sc->arge_dev, "RX bus error");
+		return;
+	}
+
+	if (status & DMA_INTR_TX_BUS_ERROR) {
+		ARGE_WRITE(sc, AR71XX_DMA_TX_STATUS, DMA_TX_STATUS_BUS_ERROR);
+		device_printf(sc->arge_dev, "TX bus error");
+		return;
+	}
+
+	ARGE_LOCK(sc);
+
+	if (status & DMA_INTR_RX_PKT_RCVD)
+		arge_rx_locked(sc);
+
+	/* 
+	 * RX overrun disables the receiver. 
+	 * Clear indication and re-enable rx. 
+	 */
+	if ( status & DMA_INTR_RX_OVERFLOW) {
+		ARGE_WRITE(sc, AR71XX_DMA_RX_STATUS, DMA_RX_STATUS_OVERFLOW);
+		ARGE_WRITE(sc, AR71XX_DMA_RX_CONTROL, DMA_RX_CONTROL_EN);
+	}
+
+	if (status & DMA_INTR_TX_PKT_SENT)
+		arge_tx_locked(sc);
+	/* 
+	 * Underrun turns off TX. Clear underrun indication. 
+	 * If there's anything left in the ring, reactivate the tx. 
+	 */
+	if (status & DMA_INTR_TX_UNDERRUN) {
+		ARGE_WRITE(sc, AR71XX_DMA_TX_STATUS, DMA_TX_STATUS_UNDERRUN);
+		if (sc->arge_cdata.arge_tx_pkts > 0 ) {
+			ARGE_WRITE(sc, AR71XX_DMA_TX_CONTROL, 
+			    DMA_TX_CONTROL_EN);
+		}
+	}
+
+	/*
+	 * We handled all bits, clear status
+	 */
+	sc->arge_intr_status = 0;
+	ARGE_UNLOCK(sc);
+	/*
+	 * re-enable all interrupts 
+	 */
+	ARGE_WRITE(sc, AR71XX_DMA_INTR, DMA_INTR_ALL);
+}
+
+
+static void
+arge_tick(void *xsc)
+{
+	struct arge_softc	*sc = xsc;
+	struct mii_data		*mii;
+
+	ARGE_LOCK_ASSERT(sc);
+
+	mii = device_get_softc(sc->arge_miibus);
+	mii_tick(mii);
+	callout_reset(&sc->arge_stat_callout, hz, arge_tick, sc);
+}
diff -I '.*' -Naur releng8/sys/mips/atheros/if_argevar.h svn/mips/sys/mips/atheros/if_argevar.h
--- releng8/src/sys/mips/atheros/if_argevar.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/if_argevar.h	2009-04-14 15:39:43.000000000 -0700
@@ -0,0 +1,138 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __IF_ARGEVAR_H__
+#define __IF_ARGEVAR_H__
+
+#define	ARGE_TX_RING_COUNT	128
+#define	ARGE_RX_RING_COUNT	128
+#define	ARGE_RX_DMA_SIZE	ARGE_RX_RING_COUNT * sizeof(struct arge_desc)
+#define	ARGE_TX_DMA_SIZE	ARGE_TX_RING_COUNT * sizeof(struct arge_desc)
+#define	ARGE_MAXFRAGS		8
+#define ARGE_RING_ALIGN		sizeof(struct arge_desc)
+#define ARGE_RX_ALIGN		sizeof(uint32_t)
+#define ARGE_MAXFRAGS		8
+#define	ARGE_TX_RING_ADDR(sc, i)	\
+    ((sc)->arge_rdata.arge_tx_ring_paddr + sizeof(struct arge_desc) * (i))
+#define	ARGE_RX_RING_ADDR(sc, i)	\
+    ((sc)->arge_rdata.arge_rx_ring_paddr + sizeof(struct arge_desc) * (i))
+#define	ARGE_INC(x,y)		(x) = (((x) + 1) % y)
+
+
+#define	ARGE_MII_TIMEOUT	1000
+
+#define	ARGE_LOCK(_sc)		mtx_lock(&(_sc)->arge_mtx)
+#define	ARGE_UNLOCK(_sc)	mtx_unlock(&(_sc)->arge_mtx)
+#define	ARGE_LOCK_ASSERT(_sc)	mtx_assert(&(_sc)->arge_mtx, MA_OWNED)
+
+/*
+ * register space access macros
+ */
+#define ARGE_WRITE(sc, reg, val)	do {	\
+		bus_write_4(sc->arge_res, (reg), (val)); \
+	} while (0)
+
+#define ARGE_READ(sc, reg)	 bus_read_4(sc->arge_res, (reg))
+
+#define ARGE_SET_BITS(sc, reg, bits)	\
+	ARGE_WRITE(sc, reg, ARGE_READ(sc, (reg)) | (bits))
+
+#define ARGE_CLEAR_BITS(sc, reg, bits)	\
+	ARGE_WRITE(sc, reg, ARGE_READ(sc, (reg)) & ~(bits))
+
+#define ARGE_DESC_EMPTY		(1 << 31)
+#define ARGE_DESC_MORE		(1 << 24)
+#define ARGE_DESC_SIZE_MASK	((1 << 12) - 1)
+#define	ARGE_DMASIZE(len)	((len) & ARGE_DESC_SIZE_MASK)
+struct arge_desc {
+	uint32_t	packet_addr;
+	uint32_t	packet_ctrl;
+	uint32_t	next_desc;
+	uint32_t	padding;
+};
+
+struct arge_txdesc {
+	struct mbuf	*tx_m;
+	bus_dmamap_t	tx_dmamap;
+};
+
+struct arge_rxdesc {
+	struct mbuf		*rx_m;
+	bus_dmamap_t		rx_dmamap;
+	struct arge_desc	*desc;
+};
+
+struct arge_chain_data {
+	bus_dma_tag_t		arge_parent_tag;
+	bus_dma_tag_t		arge_tx_tag;
+	struct arge_txdesc	arge_txdesc[ARGE_TX_RING_COUNT];
+	bus_dma_tag_t		arge_rx_tag;
+	struct arge_rxdesc	arge_rxdesc[ARGE_RX_RING_COUNT];
+	bus_dma_tag_t		arge_tx_ring_tag;
+	bus_dma_tag_t		arge_rx_ring_tag;
+	bus_dmamap_t		arge_tx_ring_map;
+	bus_dmamap_t		arge_rx_ring_map;
+	bus_dmamap_t		arge_rx_sparemap;
+	int			arge_tx_pkts;
+	int			arge_tx_prod;
+	int			arge_tx_cons;
+	int			arge_tx_cnt;
+	int			arge_rx_cons;
+};
+
+struct arge_ring_data {
+	struct arge_desc	*arge_rx_ring;
+	struct arge_desc	*arge_tx_ring;
+	bus_addr_t		arge_rx_ring_paddr;
+	bus_addr_t		arge_tx_ring_paddr;
+};
+
+struct arge_softc {
+	struct ifnet		*arge_ifp;	/* interface info */
+	device_t		arge_dev;
+	struct resource		*arge_res;
+	int			arge_rid;
+	struct resource		*arge_irq;
+	void			*arge_intrhand;
+	device_t		arge_miibus;
+	bus_dma_tag_t		arge_parent_tag;
+	bus_dma_tag_t		arge_tag;
+	struct mtx		arge_mtx;
+	struct callout		arge_stat_callout;
+	struct task		arge_link_task;
+	struct arge_chain_data	arge_cdata;
+	struct arge_ring_data	arge_rdata;
+	int			arge_link_status;
+	int			arge_detach;
+	uint32_t		arge_intr_status;
+	int			arge_mac_unit;
+	int			arge_phy_num;
+	uint32_t		arge_ddr_flush_reg;
+	uint32_t		arge_pll_reg;
+};
+
+#endif /* __IF_ARGEVAR_H__ */
diff -I '.*' -Naur releng8/sys/mips/atheros/uart_bus_ar71xx.c svn/mips/sys/mips/atheros/uart_bus_ar71xx.c
--- releng8/src/sys/mips/atheros/uart_bus_ar71xx.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/uart_bus_ar71xx.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,88 @@
+/*-
+ * Copyright (c) 2009, Oleksandr Tymoshenko <gonzo@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ */
+#include "opt_uart.h"
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+
+#include <machine/bus.h>
+
+#include <dev/uart/uart.h>
+#include <dev/uart/uart_cpu.h>
+#include <dev/uart/uart_bus.h>
+
+#include <mips/atheros/ar71xxreg.h>
+
+#include "uart_if.h"
+
+static int uart_ar71xx_probe(device_t dev);
+extern struct uart_class uart_ar71xx_uart_class;
+
+static device_method_t uart_ar71xx_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		uart_ar71xx_probe),
+	DEVMETHOD(device_attach,	uart_bus_attach),
+	DEVMETHOD(device_detach,	uart_bus_detach),
+	{ 0, 0 }
+};
+
+static driver_t uart_ar71xx_driver = {
+	uart_driver_name,
+	uart_ar71xx_methods,
+	sizeof(struct uart_softc),
+};
+
+extern SLIST_HEAD(uart_devinfo_list, uart_devinfo) uart_sysdevs;
+
+static int
+uart_ar71xx_probe(device_t dev)
+{
+	struct uart_softc *sc;
+	uint64_t freq;
+
+	freq = ar71xx_ahb_freq();
+
+	sc = device_get_softc(dev);
+	sc->sc_sysdev = SLIST_FIRST(&uart_sysdevs);
+	sc->sc_class = &uart_ns8250_class;
+	bcopy(&sc->sc_sysdev->bas, &sc->sc_bas, sizeof(sc->sc_bas));
+	sc->sc_sysdev->bas.regshft = 2;
+	sc->sc_sysdev->bas.bst = mips_bus_space_generic;
+	sc->sc_sysdev->bas.bsh = MIPS_PHYS_TO_KSEG1(AR71XX_UART_ADDR) + 3;
+	sc->sc_bas.regshft = 2;
+	sc->sc_bas.bst = mips_bus_space_generic;
+	sc->sc_bas.bsh = MIPS_PHYS_TO_KSEG1(AR71XX_UART_ADDR) + 3;
+
+	return (uart_bus_probe(dev, 2, freq, 0, 0));
+}
+
+DRIVER_MODULE(uart, apb, uart_ar71xx_driver, uart_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/atheros/uart_cpu_ar71xx.c svn/mips/sys/mips/atheros/uart_cpu_ar71xx.c
--- releng8/src/sys/mips/atheros/uart_cpu_ar71xx.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/atheros/uart_cpu_ar71xx.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,75 @@
+/*-
+ * Copyright (c) 2009 Oleksandr Tymoshenko
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+#include "opt_uart.h"
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+
+#include <machine/bus.h>
+
+#include <dev/uart/uart.h>
+#include <dev/uart/uart_cpu.h>
+
+#include <mips/atheros/ar71xxreg.h>
+#include <mips/atheros/ar71xx_bus_space_reversed.h>
+
+bus_space_tag_t uart_bus_space_io;
+bus_space_tag_t uart_bus_space_mem;
+
+int
+uart_cpu_eqres(struct uart_bas *b1, struct uart_bas *b2)
+{
+	return ((b1->bsh == b2->bsh && b1->bst == b2->bst) ? 1 : 0);
+}
+
+int
+uart_cpu_getdev(int devtype, struct uart_devinfo *di)
+{
+	uint64_t freq;
+
+	freq = ar71xx_ahb_freq();
+
+	di->ops = uart_getops(&uart_ns8250_class);
+	di->bas.chan = 0;
+	di->bas.bst = ar71xx_bus_space_reversed;
+	di->bas.regshft = 2;
+	di->bas.rclk = freq;
+	di->baudrate = 115200;
+	di->databits = 8;
+	di->stopbits = 1;
+
+	di->parity = UART_PARITY_NONE;
+
+	uart_bus_space_io = NULL;
+	uart_bus_space_mem = ar71xx_bus_space_reversed;
+	di->bas.bsh = MIPS_PHYS_TO_KSEG1(AR71XX_UART_ADDR);
+	return (0);
+}
diff -I '.*' -Naur releng8/sys/mips/conf/ALCHEMY svn/mips/sys/mips/conf/ALCHEMY
--- releng8/src/sys/mips/conf/ALCHEMY	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/conf/ALCHEMY	2009-04-14 15:39:43.000000000 -0700
@@ -0,0 +1,66 @@
+# ALCHEMY -- Generic kernel for Alchemy Au1xxx CPUs.
+#
+# For more information on this file, please read the handbook section on
+# Kernel Configuration Files:
+#
+#    http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
+#
+# The handbook is also available locally in /usr/share/doc/handbook
+# if you've installed the doc distribution, otherwise always see the
+# FreeBSD World Wide Web server (http://www.FreeBSD.org/) for the
+# latest information.
+#
+# An exhaustive list of options and more detailed explanations of the
+# device lines is also present in the ../../conf/NOTES and NOTES files. 
+# If you are in doubt as to the purpose or necessity of a line, check first 
+# in NOTES.
+#
+# $FreeBSD$
+
+ident		ALCHEMY
+
+makeoptions	ARCH_FLAGS=-march=mips32
+makeoptions	MIPS_LITTLE_ENDIAN=defined
+
+# Don't build any modules yet.
+makeoptions	MODULES_OVERRIDE=""
+
+include		"../alchemy/std.alchemy"
+
+hints		"ALCHEMY.hints"		#Default places to look for devices.
+
+makeoptions	DEBUG=-g		#Build kernel with gdb(1) debug symbols
+
+options		DDB
+options		KDB
+
+options		SCHED_4BSD		#4BSD scheduler
+options		INET			#InterNETworking
+options		NFSCLIENT		#Network Filesystem Client
+options		NFS_ROOT		#NFS usable as /, requires NFSCLIENT
+options		PSEUDOFS		#Pseudo-filesystem framework
+# options		_KPOSIX_PRIORITY_SCHEDULING #Posix P1003_1B real-time extensions
+
+options BOOTP
+options BOOTP_NFSROOT
+options BOOTP_NFSV3
+options BOOTP_WIRED_TO=admsw0
+options BOOTP_COMPAT
+
+# options         FFS                     #Berkeley Fast Filesystem
+# options         SOFTUPDATES             #Enable FFS soft updates support
+# options         UFS_ACL                 #Support for access control lists
+# options         UFS_DIRHASH             #Improve performance on big directories
+options		ROOTDEVNAME=\"nfs:10.0.0.1:/mnt/bsd\"
+
+
+# Debugging for use in -current
+options		INVARIANTS		#Enable calls of extra sanity checking
+options		INVARIANT_SUPPORT	#Extra sanity checks of internal structures, required by INVARIANTS
+#options		WITNESS			#Enable checks to detect deadlocks and cycles
+#options		WITNESS_SKIPSPIN	#Don't run witness on spinlocks for speed
+
+device		loop
+device		ether
+device		uart
+# device		md
diff -I '.*' -Naur releng8/sys/mips/conf/AR71XX svn/mips/sys/mips/conf/AR71XX
--- releng8/src/sys/mips/conf/AR71XX	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/conf/AR71XX	2009-09-08 11:01:50.000000000 -0700
@@ -0,0 +1,86 @@
+#
+# $FreeBSD$
+#
+
+ident		AR71XX
+cpu		CPU_MIPS4KC
+options 	ISA_MIPS32
+makeoptions	TARGET_BIG_ENDIAN
+makeoptions	KERNLOADADDR=0x80050000
+options		HZ=1000
+
+files		"../atheros/files.ar71xx"
+hints		"AR71XX.hints"
+
+makeoptions	DEBUG=-g		#Build kernel with gdb(1) debug symbols
+makeoptions	MODULES_OVERRIDE=""
+
+options		DDB
+options		KDB
+
+options		SCHED_4BSD		#4BSD scheduler
+options		INET			#InterNETworking
+options		NFSCLIENT		#Network Filesystem Client
+options		NFS_ROOT		#NFS usable as /, requires NFSCLIENT
+options		PSEUDOFS		#Pseudo-filesystem framework
+options		_KPOSIX_PRIORITY_SCHEDULING #Posix P1003_1B real-time extensions
+
+# options		NFS_LEGACYRPC
+# Debugging for use in -current
+# options		INVARIANTS
+# options		INVARIANT_SUPPORT
+# options		WITNESS
+# options		WITNESS_SKIPSPIN
+options         FFS                     #Berkeley Fast Filesystem
+options         SOFTUPDATES             #Enable FFS soft updates support
+options         UFS_ACL                 #Support for access control lists
+options         UFS_DIRHASH             #Improve performance on big directories
+
+
+options		BOOTP
+options		BOOTP_NFSROOT
+options		BOOTP_NFSV3
+options		BOOTP_WIRED_TO=arge0 
+options		BOOTP_COMPAT
+options		ROOTDEVNAME=\"nfs:192.168.10.1:/mnt/bsd\"
+
+device		pci
+
+# Wireless NIC cards
+options		IEEE80211_DEBUG
+options		IEEE80211_SUPPORT_MESH
+options		IEEE80211_SUPPORT_TDMA
+device		wlan            # 802.11 support
+device		wlan_wep        # 802.11 WEP support
+device		wlan_ccmp       # 802.11 CCMP support
+device		wlan_tkip       # 802.11 TKIP support
+
+device		ath             # Atheros pci/cardbus NIC's
+options 	ATH_DEBUG
+device		ath_hal
+option		AH_SUPPORT_AR5416
+device		ath_rate_sample
+
+device		mii
+device		arge
+
+# device		usb
+# options		USB_EHCI_BIG_ENDIAN_DESC        # handle big-endian byte order
+# options		USB_DEBUG
+# device		ehci
+
+device		spibus
+device		ar71xx_spi
+device		mx25l
+# device		geom_redboot
+
+device		ar71xx_wdog
+
+device		uart
+
+device		loop
+device		ether
+device		md
+device		bpf
+device		random
+device		if_bridge
diff -I '.*' -Naur releng8/sys/mips/conf/AR71XX.hints svn/mips/sys/mips/conf/AR71XX.hints
--- releng8/src/sys/mips/conf/AR71XX.hints	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/conf/AR71XX.hints	2009-09-08 11:01:50.000000000 -0700
@@ -0,0 +1,49 @@
+# $FreeBSD$
+hint.apb.0.at="nexus0"
+hint.apb.0.irq=4
+
+# uart0
+hint.uart.0.at="apb0"
+# see atheros/uart_cpu_ar71xx.c why +3
+hint.uart.0.maddr=0x18020003
+hint.uart.0.msize=0x18
+hint.uart.0.irq=3
+
+#ohci
+hint.ohci.0.at="apb0"
+hint.ohci.0.maddr=0x1c000000
+hint.ohci.0.msize=0x01000000
+hint.ohci.0.irq=6
+
+#ehci
+hint.ehci.0.at="nexus0"
+hint.ehci.0.maddr=0x1b000000
+hint.ehci.0.msize=0x01000000
+hint.ehci.0.irq=1
+
+# pci
+hint.pcib.0.at="nexus0"
+hint.pcib.0.irq=0
+
+hint.arge.0.at="nexus0"
+hint.arge.0.maddr=0x19000000
+hint.arge.0.msize=0x1000
+hint.arge.0.irq=2
+# Uncomment this hint for RS (not PRO)
+# hint.arge.0.phy=20
+
+# hint.arge.1.at="nexus0"
+# hint.arge.1.maddr=0x1A000000
+# hint.arge.1.msize=0x1000
+# hint.arge.1.irq=3
+
+# SPI flash
+hint.spi.0.at="nexus0"
+hint.spi.0.maddr=0x1f000000
+hint.spi.0.msize=0x10
+
+hint.mx25l.0.at="spibus0"
+hint.mx25l.0.cs=0
+
+# Watchdog
+hint.ar71xx_wdog.0.at="nexus0"
diff -I '.*' -Naur releng8/sys/mips/conf/MALTA svn/mips/sys/mips/conf/MALTA
--- releng8/src/sys/mips/conf/MALTA	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/conf/MALTA	2009-08-04 10:46:58.000000000 -0700
@@ -33,6 +33,8 @@
 
 include		"../malta/std.malta"
 
+options		ISA_MIPS32
+
 hints		"MALTA.hints"		#Default places to look for devices.
 
 makeoptions	DEBUG=-g		#Build kernel with gdb(1) debug symbols
diff -I '.*' -Naur releng8/sys/mips/conf/MALTA64 svn/mips/sys/mips/conf/MALTA64
--- releng8/src/sys/mips/conf/MALTA64	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/conf/MALTA64	2009-09-30 19:27:13.000000000 -0700
@@ -0,0 +1,72 @@
+# MALTA -- Kernel config for MALTA boards
+#
+# For more information on this file, please read the handbook section on
+# Kernel Configuration Files:
+#
+#    http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
+#
+# The handbook is also available locally in /usr/share/doc/handbook
+# if you've installed the doc distribution, otherwise always see the
+# FreeBSD World Wide Web server (http://www.FreeBSD.org/) for the
+# latest information.
+#
+# An exhaustive list of options and more detailed explanations of the
+# device lines is also present in the ../../conf/NOTES and NOTES files. 
+# If you are in doubt as to the purpose or necessity of a line, check first 
+# in NOTES.
+#
+# $FreeBSD: projects/mips/sys/mips/conf/MALTA 192819 2009-05-26 17:01:12Z gonzo $
+
+ident		MALTA
+
+makeoptions	ARCH_FLAGS="-march=mips64 -mabi=64"
+makeoptions	MIPS_LITTLE_ENDIAN=defined
+makeoptions	TARGET_64BIT=t
+makeoptions	LDSCRIPT_NAME=	ldscript.mips.mips64
+
+options 	YAMON
+
+# Don't build any modules yet.
+makeoptions	MODULES_OVERRIDE=""
+
+options 	KERNVIRTADDR=0x80100000
+options 	TICK_USE_YAMON_FREQ=defined
+#options 	TICK_USE_MALTA_RTC=defined
+
+include		"../malta/std.malta"
+
+options		ISA_MIPS64
+
+hints		"MALTA.hints"		#Default places to look for devices.
+
+makeoptions	DEBUG=-g		#Build kernel with gdb(1) debug symbols
+
+options 	DDB
+options 	KDB
+
+options 	SCHED_4BSD		#4BSD scheduler
+options 	INET			#InterNETworking
+options 	NFSCLIENT		#Network Filesystem Client
+options 	NFS_ROOT		#NFS usable as /, requires NFSCLIENT
+options 	PSEUDOFS		#Pseudo-filesystem framework
+options 	_KPOSIX_PRIORITY_SCHEDULING #Posix P1003_1B real-time extensions
+
+options 	FFS			#Berkeley Fast Filesystem
+options 	SOFTUPDATES		#Enable FFS soft updates support
+options 	UFS_ACL			#Support for access control lists
+options 	UFS_DIRHASH		#Improve performance on big directories
+options 	ROOTDEVNAME=\"ufs:ad0s1a\"
+
+
+# Debugging for use in -current
+options 	INVARIANTS		#Enable calls of extra sanity checking
+options 	INVARIANT_SUPPORT	#Extra sanity checks of internal structures, required by INVARIANTS
+#options 	WITNESS			#Enable checks to detect deadlocks and cycles
+#options 	WITNESS_SKIPSPIN	#Don't run witness on spinlocks for speed
+
+device		loop
+device		ether
+device		le
+device		miibus
+device		md
+device		uart
diff -I '.*' -Naur releng8/sys/mips/conf/OCTEON.hints svn/mips/sys/mips/conf/OCTEON.hints
--- releng8/src/sys/mips/conf/OCTEON.hints	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/conf/OCTEON.hints	2009-07-02 18:44:21.000000000 -0700
@@ -0,0 +1,13 @@
+# /*
+#  *    This product includes software developed by the University of
+
+#  *    California, Berkeley and its contributors."
+# */
+# device.hints
+hw.uart.console="io:0x1"
+hint.obio.0.at="nexus"
+hint.obio.0.maddr="0x1"
+hint.obio.0.flags="0x1"
+hint.uart.0.at="obio"
+hint.uart.0.maddr="0x1"
+hint.uart.0.flags="0x1"
diff -I '.*' -Naur releng8/sys/mips/conf/OCTEON1 svn/mips/sys/mips/conf/OCTEON1
--- releng8/src/sys/mips/conf/OCTEON1	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/conf/OCTEON1	2009-09-08 11:01:50.000000000 -0700
@@ -0,0 +1,89 @@
+# OCTEON1 -- Configuration kernel for all Octeon1 SoCs from Cavium Networks
+#
+# For more information on this file, please read the handbook section on
+# Kernel Configuration Files:
+#
+#    http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
+#
+# The handbook is also available locally in /usr/share/doc/handbook
+# if you've installed the doc distribution, otherwise always see the
+# FreeBSD World Wide Web server (http://www.FreeBSD.org/) for the
+# latest information.
+#
+# An exhaustive list of options and more detailed explanations of the
+# device lines is also present in the ../../conf/NOTES and NOTES files. 
+# If you are in doubt as to the purpose or necessity of a line, check first 
+# in NOTES.
+#
+# $FreeBSD$
+
+machine		mips
+cpu		CPU_MIPS4KC
+ident		OCTEON1
+
+makeoptions	ARCH_FLAGS="-march=mips64 -mabi=64"
+makeoptions	LDSCRIPT_NAME=	ldscript.mips.mips64
+
+# Don't build any modules yet.
+makeoptions	MODULES_OVERRIDE=""
+makeoptions     TARGET_BIG_ENDIAN=defined
+makeoptions     TARGET_64BIT=defined
+
+options		KERNVIRTADDR=0x80100000
+include		"../octeon1/std.octeon1"
+
+hints		"OCTEON1.hints"		#Default places to look for devices.
+
+makeoptions	DEBUG=-g		#Build kernel with gdb(1) debug symbols
+
+#XXXimp: Need to make work with 64-bit too
+options 	ISA_MIPS64
+
+options		DDB
+options		KDB
+
+options		SCHED_4BSD		#4BSD scheduler
+options		INET			#InterNETworking
+options		NFSCLIENT		#Network Filesystem Client
+#options	NFS_ROOT		#NFS usable as /, requires NFSCLIENT
+options         PSEUDOFS		#Pseudo-filesystem framework
+options		_KPOSIX_PRIORITY_SCHEDULING #Posix P1003_1B real-time extensions
+#options	ROOTDEVNAME=\"ufs:ad0s1a\"	# Original
+options		NO_SWAPPING
+
+
+options         FFS                     #Berkeley Fast Filesystem
+options         SOFTUPDATES             #Enable FFS soft updates support
+options         UFS_ACL                 #Support for access control lists
+options         UFS_DIRHASH             #Improve performance on big directories
+
+
+# Debugging for use in -current
+options		INVARIANTS		#Enable calls of extra sanity checking
+options		INVARIANT_SUPPORT	#Extra sanity checks of internal structures, required by INVARIANTS
+#options		WITNESS			#Enable checks to detect deadlocks and cycles
+#options		WITNESS_SKIPSPIN	#Don't run witness on spinlocks for speed
+
+#XXXimp device		genclock
+device		loop
+device		ether
+device		md
+device		uart
+nodevice	uart_ns8250
+device 		rgmii
+#options 	VERBOSE_SYSINIT
+
+
+#
+# Use the following for  Compact Flash file-system
+device 		cf
+options         ROOTDEVNAME = \"ufs:cf0s2\"	# Unmask if compact flash is needed as RFS
+
+#
+# Use the following for RFS in mem-device
+#options         MD_ROOT
+#options         ROOTDEVNAME = \"ufs:md0\"
+
+#options         MD_ROOT_SIZE = 21264
+#XXX: Bring up UP first, then generalize.
+#options		SMP
diff -I '.*' -Naur releng8/sys/mips/conf/SENTRY5 svn/mips/sys/mips/conf/SENTRY5
--- releng8/src/sys/mips/conf/SENTRY5	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/conf/SENTRY5	2009-06-12 04:42:48.000000000 -0700
@@ -26,9 +26,8 @@
 
 ident		SENTRY5
 cpu		CPU_MIPS4KC
-options 	CPU_NOFPU
 options 	ISA_MIPS32
-options 	CPU_SENTRY5			# XXX should this be a
+options		CPU_SENTRY5			# XXX should this be a
 						# sub-cpu option?
 
 # XXX only siba should be hardwired for now; we will use
@@ -37,50 +36,43 @@
 hints		"SENTRY5.hints"
 
 # sentry5 normally ships with cfe firmware; use the console for now
-options 	CFE
-options 	CFE_CONSOLE
-options 	ALT_BREAK_TO_DEBUGGER
-
-# cfe loader expects kernel at 0x80001000 for mips32 w/o backwards
-# offsets in the linked elf image (see ldscript hack)
-# XXX can we conditionalize the linker stuff on options CFE?
-options 	KERNVIRTADDR=0x80001000
-
-makeoptions	LDSCRIPT_NAME=	ldscript.mips.cfe
+options		CFE
+options		CFE_CONSOLE
+options		ALT_BREAK_TO_DEBUGGER
 
 #makeoptions	ARCH_FLAGS=-march=mips32
 makeoptions	MIPS_LITTLE_ENDIAN=defined
 makeoptions	DEBUG=-g		#Build kernel with gdb(1) debug symbols
 makeoptions	MODULES_OVERRIDE=""
 
-options 	DDB
-options 	KDB
+options		DDB
+options		KDB
 
-options 	SCHED_4BSD		#4BSD scheduler
-options 	INET			#InterNETworking
-options 	NFSCLIENT		#Network Filesystem Client
-options 	NFS_ROOT		#NFS usable as /, requires NFSCLIENT
-options 	PSEUDOFS		#Pseudo-filesystem framework
-options 	_KPOSIX_PRIORITY_SCHEDULING #Posix P1003_1B real-time extensions
+options		SCHED_4BSD		#4BSD scheduler
+options		INET			#InterNETworking
+options		NFSCLIENT		#Network Filesystem Client
+options		NFS_ROOT		#NFS usable as /, requires NFSCLIENT
+options		PSEUDOFS		#Pseudo-filesystem framework
+options		_KPOSIX_PRIORITY_SCHEDULING #Posix P1003_1B real-time extensions
 
 # Debugging for use in -current
-options 	INVARIANTS
-options 	INVARIANT_SUPPORT
+options		INVARIANTS
+options		INVARIANT_SUPPORT
 
-#options 	BUS_DEBUG
+#options		BUS_DEBUG
 #makeoptions	BUS_DEBUG
 
 device		siba			# Sonics SiliconBackplane
 device		pci			# siba_pcib
 
-device		bfe			# XXX will build both pci and siba
-device		miibus			# attachments
+# device		bfe			# XXX will build both pci and siba
+# device		miibus			# attachments
 
 # pci devices
 # notyet:
 #device		ath			# in pci slot
 #device		ath_hal			# pci chip support
-#options 	AH_SUPPORT_AR5416	# enable AR5416 tx/rx descriptors
+#options		AH_SUPPORT_AR5416	# enable AR5416 tx/rx descriptors
 
 device		usb			# USB Bus (required)
 device		uhci			# UHCI PCI->USB interface
diff -I '.*' -Naur releng8/sys/mips/conf/SWARM svn/mips/sys/mips/conf/SWARM
--- releng8/src/sys/mips/conf/SWARM	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/conf/SWARM	2009-08-04 10:46:58.000000000 -0700
@@ -0,0 +1,82 @@
+#
+# $Id: //depot/user/neelnatu/freebsd_sibyte/src/sys/mips/conf/SWARM#7 $
+#
+
+ident		SWARM
+options		CPU_NOFPU
+options		CPU_SB1
+
+files		"../sibyte/files.sibyte"
+hints		"SWARM.hints"
+
+options		PCI_IOSPACE_ADDR=0xFC000000
+options		PCI_IOSPACE_SIZE=0x02000000
+
+#
+# 32-bit kernel cannot deal with physical memory beyond 4GB
+#
+options		MAXMEM=4096*1024
+
+options		CFE
+options		CFE_CONSOLE
+options		CFE_ENV
+options		ALT_BREAK_TO_DEBUGGER
+
+# cfe loader expects kernel at 0x80001000 for mips32 w/o backwards
+# offsets in the linked elf image (see ldscript hack)
+# XXX can we conditionalize the linker stuff on options CFE?
+options		KERNVIRTADDR=0x80001000
+
+makeoptions	LDSCRIPT_NAME=	ldscript.mips.cfe
+
+#cpu		CPU_MIPS64
+#options 	ISA_MIPS64
+#makeoptions	ARCH_FLAGS="-march=mips64 -mgp64 -mabi=o64"
+cpu		CPU_MIPS32
+options 	ISA_MIPS32
+makeoptions	ARCH_FLAGS="-march=mips32"
+
+makeoptions	DEBUG=-g		#Build kernel with gdb(1) debug symbols
+makeoptions	MODULES_OVERRIDE=""
+
+options		DDB
+options		KDB
+
+options		SCHED_4BSD		#4BSD scheduler
+options		INET			#InterNETworking
+options		NFSCLIENT		#Network Filesystem Client
+options		NFS_ROOT		#NFS usable as /, requires NFSCLIENT
+options		PSEUDOFS		#Pseudo-filesystem framework
+options		_KPOSIX_PRIORITY_SCHEDULING #Posix P1003_1B real-time extensions
+
+# Debugging for use in -current
+options		INVARIANTS
+options		INVARIANT_SUPPORT
+options		WITNESS
+
+options		MD_ROOT
+options		MD_ROOT_SIZE=4096
+options 	FFS			#Fast filesystem
+
+device		pci
+device		miibus
+device		bge
+device		loop
+device		ether
+device		md
+
+options		USB_DEBUG
+device usb
+device ohci
+device uhci
+device ehci
+
+device umass
+
+device scbus
+device da
+
+device		ata
+device		atadisk
+device		atapicd
+options		ATA_STATIC_ID
diff -I '.*' -Naur releng8/sys/mips/conf/SWARM.hints svn/mips/sys/mips/conf/SWARM.hints
--- releng8/src/sys/mips/conf/SWARM.hints	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/conf/SWARM.hints	2009-08-04 10:46:58.000000000 -0700
@@ -0,0 +1,17 @@
+# $FreeBSD$
+hint.zbbus.0.at="nexus0"
+hint.zbpci.0.at="zbbus0"
+hint.scd.0.at="zbbus0"
+
+#
+# SWARM IDE interface is on the generic bus at chip select 4.
+# The CS4 region is 64KB in size and starts at 0x100B0000.
+# The IDE interrupt is wired to GPIO4 (intsrc 36 to the interrupt mapper)
+#
+hint.ata.0.at="zbbus0"
+hint.ata.0.maddr=0x100B0000
+hint.ata.0.msize=0x10000
+hint.ata.0.irq=36
+#hint.ata.0.disabled=0
+#hint.ata.0.regoffset=0x1F0
+#hint.ata.0.regshift=5
diff -I '.*' -Naur releng8/sys/mips/idt/obio.c svn/mips/sys/mips/idt/obio.c
--- releng8/src/sys/mips/idt/obio.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/idt/obio.c	2009-07-02 18:44:22.000000000 -0700
@@ -76,8 +76,10 @@
 static int	obio_teardown_intr(device_t, device_t, struct resource *,
 		    void *);
 
-static void obio_mask_irq(unsigned int irq)
+static void 
+obio_mask_irq(void *arg)
 {
+	unsigned int irq = (unsigned int)arg;
 	int ip_bit, mask, mask_register;
 
 	/* mask IRQ */
@@ -88,8 +90,10 @@
 	ICU_REG_WRITE(mask_register, mask | ip_bit);
 }
 
-static void obio_unmask_irq(unsigned int irq)
+static void 
+obio_unmask_irq(void *arg)
 {
+	unsigned int irq = (unsigned int)arg;
 	int ip_bit, mask, mask_register;
 
 	/* unmask IRQ */
@@ -274,7 +278,7 @@
 	event = sc->sc_eventstab[irq];
 	if (event == NULL) {
 		error = intr_event_create(&event, (void *)irq, 0, irq, 
-		    (mask_fn)obio_mask_irq, (mask_fn)obio_unmask_irq,
+		    obio_mask_irq, obio_unmask_irq,
 		    NULL, NULL,
 		    "obio intr%d:", irq);
 
diff -I '.*' -Naur releng8/sys/mips/idt/uart_bus_rc32434.c svn/mips/sys/mips/idt/uart_bus_rc32434.c
--- releng8/src/sys/mips/idt/uart_bus_rc32434.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/idt/uart_bus_rc32434.c	2009-05-06 14:57:15.000000000 -0700
@@ -88,10 +88,10 @@
 	sc->sc_class = &uart_ns8250_class;
 	bcopy(&sc->sc_sysdev->bas, &sc->sc_bas, sizeof(sc->sc_bas));
 	sc->sc_sysdev->bas.regshft = 2;
-	sc->sc_sysdev->bas.bst = 0;
+	sc->sc_sysdev->bas.bst = mips_bus_space_generic;
 	sc->sc_sysdev->bas.bsh = MIPS_PHYS_TO_KSEG1(IDT_BASE_UART0);
 	sc->sc_bas.regshft = 2;
-	sc->sc_bas.bst = 0;
+	sc->sc_bas.bst = mips_bus_space_generic;
 	sc->sc_bas.bsh = MIPS_PHYS_TO_KSEG1(IDT_BASE_UART0);
 
 	return (uart_bus_probe(dev, 2, 330000000UL/2, 0, 0));
diff -I '.*' -Naur releng8/sys/mips/idt/uart_cpu_rc32434.c svn/mips/sys/mips/idt/uart_cpu_rc32434.c
--- releng8/src/sys/mips/idt/uart_cpu_rc32434.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/idt/uart_cpu_rc32434.c	2009-05-06 14:57:15.000000000 -0700
@@ -71,7 +71,7 @@
 	/* Got it. Fill in the instance and return it. */
 	di->ops = uart_getops(&uart_ns8250_class);
 	di->bas.chan = 0;
-	di->bas.bst = 0;
+	di->bas.bst = mips_bus_space_generic;
 	di->bas.regshft = 2;
 	di->bas.rclk = 330000000UL/2; /* IPbus clock */
 	di->baudrate = 115200;
@@ -79,7 +79,7 @@
 	di->stopbits = 1;
 	di->parity = UART_PARITY_NONE;
 	uart_bus_space_io = 0;
-	uart_bus_space_mem = 0;
+	uart_bus_space_mem = mips_bus_space_generic;
 	di->bas.bsh = MIPS_PHYS_TO_KSEG1(maddr);
 	return (0);
 }
diff -I '.*' -Naur releng8/sys/mips/include/_align.h svn/mips/sys/mips/include/_align.h
--- releng8/src/sys/mips/include/_align.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/include/_align.h	2009-10-01 13:42:53.000000000 -0700
@@ -0,0 +1,53 @@
+/*	$OpenBSD: param.h,v 1.11 1998/08/30 22:05:35 millert Exp $ */
+
+/*-
+ * Copyright (c) 1988 University of Utah.
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * the Systems Programming Group of the University of Utah Computer
+ * Science Department and Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	from: Utah Hdr: machparam.h 1.11 89/08/14
+ *	from: @(#)param.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: param.h,v 1.6.2.1 2007/09/10 07:49:36 girish
+ * $FreeBSD: projects/mips/sys/mips/include/_align.h 196994 2009-09-08 20:45:40Z phk $
+ */
+
+#ifndef _MIPS_INCLUDE__ALIGN_H_
+#define	_MIPS_INCLUDE__ALIGN_H_
+
+/*
+ * Round p (pointer or byte index) up to a correctly-aligned value for all
+ * data types (int, long, ...).	  The result is u_int and must be cast to
+ * any desired pointer type.
+ */
+#define	_ALIGNBYTES	7
+#define	_ALIGN(p)	(((u_int)(p) + _ALIGNBYTES) &~ _ALIGNBYTES)
+
+#endif /* !_MIPS_INCLUDE__ALIGN_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/_bus.h svn/mips/sys/mips/include/_bus.h
--- releng8/src/sys/mips/include/_bus.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/_bus.h	2009-07-02 18:44:22.000000000 -0700
@@ -31,9 +31,6 @@
 
 #ifndef MIPS_INCLUDE__BUS_H
 #define	MIPS_INCLUDE__BUS_H
-#ifdef TARGET_OCTEON
-#include "_bus_octeon.h"
-#else
 /*
  * Bus address and size types
  */
@@ -43,7 +40,6 @@
 /*
  * Access methods for bus resources and address space.
  */
-typedef long bus_space_tag_t;
+typedef struct bus_space *bus_space_tag_t;
 typedef u_long bus_space_handle_t;
-#endif
 #endif /* MIPS_INCLUDE__BUS_H */
diff -I '.*' -Naur releng8/sys/mips/include/_types.h svn/mips/sys/mips/include/_types.h
--- releng8/src/sys/mips/include/_types.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/_types.h	2009-08-04 10:46:58.000000000 -0700
@@ -54,7 +54,7 @@
 typedef	int			__int32_t;
 typedef	unsigned int		__uint32_t;
 
-#ifdef __mips64
+#ifdef __mips_n64
 typedef	long			__int64_t;
 typedef	unsigned long		__uint64_t;
 #else
@@ -79,14 +79,14 @@
  */
 typedef	__int32_t	__clock_t;		/* clock()... */
 typedef	unsigned int	__cpumask_t;
-#ifdef __mips64
+#ifdef __mips_n64
 typedef	__int64_t	__critical_t;
 #else
 typedef	__int32_t	__critical_t;
 #endif
 typedef	double		__double_t;
 typedef	double		__float_t;
-#ifdef __mips64
+#ifdef __mips_n64
 typedef	__int64_t	__intfptr_t;
 typedef	__int64_t	__intptr_t;
 #else
@@ -102,14 +102,14 @@
 typedef	__int16_t	__int_least16_t;
 typedef	__int32_t	__int_least32_t;
 typedef	__int64_t	__int_least64_t;
-#if defined(__mips64) || defined(ISA_MIPS64)
+#if defined(__mips_n64) || defined(__mips_n32)
 typedef	__int64_t	__register_t;
 typedef	__int64_t	f_register_t;
 #else
 typedef	__int32_t	__register_t;
 typedef	__int32_t	f_register_t;
 #endif
-#ifdef __mips64
+#ifdef __mips_n64
 typedef	__int64_t	__ptrdiff_t;
 typedef	__int64_t	__segsz_t;
 typedef	__uint64_t	__size_t;
@@ -134,13 +134,16 @@
 typedef	__uint16_t	__uint_least16_t;
 typedef	__uint32_t	__uint_least32_t;
 typedef	__uint64_t	__uint_least64_t;
-#if defined(__mips64) || defined(ISA_MIPS64)
+#if defined(__mips_n64) || defined(__mips_n32)
 typedef	__uint64_t	__u_register_t;
+#else
+typedef	__uint32_t	__u_register_t;
+#endif
+#if defined(__mips_n64)
 typedef	__uint64_t	__vm_offset_t;
 typedef	__uint64_t	__vm_paddr_t;
 typedef	__uint64_t	__vm_size_t;
 #else
-typedef	__uint32_t	__u_register_t;
 typedef	__uint32_t	__vm_offset_t;
 typedef	__uint32_t	__vm_paddr_t;
 typedef	__uint32_t	__vm_size_t;
diff -I '.*' -Naur releng8/sys/mips/include/asm.h svn/mips/sys/mips/include/asm.h
--- releng8/src/sys/mips/include/asm.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/asm.h	2009-08-04 10:46:58.000000000 -0700
@@ -60,6 +60,7 @@
 #include <machine/regdef.h>
 #endif
 #include <machine/endian.h>
+#include <machine/cdefs.h>
 
 #undef __FBSDID
 #if !defined(lint) && !defined(STRIP_FBSDID)
@@ -281,7 +282,7 @@
  * Macros to panic and printf from assembly language.
  */
 #define	PANIC(msg)			\
-	la	a0, 9f;			\
+	PTR_LA	a0, 9f;			\
 	jal	_C_LABEL(panic);	\
 	nop;				\
 	MSG(msg)
@@ -289,7 +290,7 @@
 #define	PANIC_KSEG0(msg, reg)	PANIC(msg)
 
 #define	PRINTF(msg)			\
-	la	a0, 9f;			\
+	PTR_LA	a0, 9f;			\
 	jal	_C_LABEL(printf);	\
 	nop;				\
 	MSG(msg)
@@ -308,23 +309,24 @@
  */
 #define DO_AST				             \
 44:				                     \
-	la	s0, _C_LABEL(disableintr)           ;\
+	PTR_LA	s0, _C_LABEL(disableintr)           ;\
 	jalr	s0                                  ;\
 	nop                                         ;\
+	move	a0, v0                              ;\
 	GET_CPU_PCPU(s1)                            ;\
 	lw	s3, PC_CURPCB(s1)                   ;\
 	lw	s1, PC_CURTHREAD(s1)                ;\
 	lw	s2, TD_FLAGS(s1)                    ;\
 	li	s0, TDF_ASTPENDING | TDF_NEEDRESCHED;\
 	and	s2, s0                              ;\
-	la	s0, _C_LABEL(enableintr)            ;\
+	PTR_LA	s0, _C_LABEL(restoreintr)           ;\
 	jalr	s0                                  ;\
 	nop                                         ;\
 	beq	s2, zero, 4f                        ;\
 	nop                                         ;\
-	la	s0, _C_LABEL(ast)                   ;\
+	PTR_LA	s0, _C_LABEL(ast)                   ;\
 	jalr	s0                                  ;\
-	addu	a0, s3, U_PCB_REGS                  ;\
+	PTR_ADDU a0, s3, U_PCB_REGS                 ;\
 	j 44b			                    ;\
         nop                                         ;\
 4:
@@ -361,12 +363,15 @@
  */
 
 #if !defined(_MIPS_BSD_API) || _MIPS_BSD_API == _MIPS_BSD_API_LP32
+/* #if !defined(__mips_n64) */
 #define	REG_L		lw
 #define	REG_S		sw
 #define	REG_LI		li
 #define	REG_PROLOGUE	.set push
 #define	REG_EPILOGUE	.set pop
 #define	SZREG		4
+#define	PTR_LA		la
+#define	PTR_ADDU	addu
 #else
 #define	REG_L		ld
 #define	REG_S		sd
@@ -374,6 +379,8 @@
 #define	REG_PROLOGUE	.set push ; .set mips3
 #define	REG_EPILOGUE	.set pop
 #define	SZREG		8
+#define	PTR_LA		dla
+#define	PTR_ADDU	daddu
 #endif	/* _MIPS_BSD_API */
 
 #define	mfc0_macro(data, spr)						\
diff -I '.*' -Naur releng8/sys/mips/include/atomic.h svn/mips/sys/mips/include/atomic.h
--- releng8/src/sys/mips/include/atomic.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/atomic.h	2009-08-04 10:46:58.000000000 -0700
@@ -34,6 +34,17 @@
 #error this file needs sys/cdefs.h as a prerequisite
 #endif
 
+/*
+ * Note: All the 64-bit atomic operations are only atomic when running
+ * in 64-bit mode.  It is assumed that code compiled for n32 and n64
+ * fits into this definition and no further safeties are needed.
+ *
+ * It is also assumed that the add, subtract and other arithmetic is
+ * done on numbers not pointers.  The special rules for n32 pointers
+ * do not have atomic operations defined for them, but generally shouldn't
+ * need atomic operations.
+ */
+
 static __inline  void
 mips_sync(void)
 {
@@ -126,7 +137,7 @@
 		"1:\tll	%0, %3\n\t"		/* load old value */
 		"subu	%0, %2\n\t"		/* calculate new value */
 		"sc	%0, %1\n\t"		/* attempt to store */
-		"beqz	%0, 1b\n\t"			/* spin if failed */
+		"beqz	%0, 1b\n\t"		/* spin if failed */
 		: "=&r" (temp), "=m" (*p)
 		: "r" (v), "m" (*p)
 		: "memory");
@@ -166,6 +177,110 @@
 	return result;
 }
 
+#if defined(__mips_n64) || defined(__mips_n32)
+static __inline void
+atomic_set_64(__volatile uint64_t *p, uint64_t v)
+{
+	uint64_t temp;
+
+	__asm __volatile (
+		"1:\n\t"
+		"lld	%0, %3\n\t"		/* load old value */
+		"or	%0, %2, %0\n\t"		/* calculate new value */
+		"scd	%0, %1\n\t"		/* attempt to store */
+		"beqz	%0, 1b\n\t"		/* spin if failed */
+		: "=&r" (temp), "=m" (*p)
+		: "r" (v), "m" (*p)
+		: "memory");
+
+}
+
+static __inline void
+atomic_clear_64(__volatile uint64_t *p, uint64_t v)
+{
+	uint64_t temp;
+	v = ~v;
+
+	__asm __volatile (
+		"1:\n\t"
+		"lld	%0, %3\n\t"		/* load old value */
+		"and	%0, %2, %0\n\t"		/* calculate new value */
+		"scd	%0, %1\n\t"		/* attempt to store */
+		"beqz	%0, 1b\n\t"		/* spin if failed */
+		: "=&r" (temp), "=m" (*p)
+		: "r" (v), "m" (*p)
+		: "memory");
+}
+
+static __inline void
+atomic_add_64(__volatile uint64_t *p, uint64_t v)
+{
+	uint64_t temp;
+
+	__asm __volatile (
+		"1:\n\t"
+		"lld	%0, %3\n\t"		/* load old value */
+		"daddu	%0, %2, %0\n\t"		/* calculate new value */
+		"scd	%0, %1\n\t"		/* attempt to store */
+		"beqz	%0, 1b\n\t"		/* spin if failed */
+		: "=&r" (temp), "=m" (*p)
+		: "r" (v), "m" (*p)
+		: "memory");
+}
+
+static __inline void
+atomic_subtract_64(__volatile uint64_t *p, uint64_t v)
+{
+	uint64_t temp;
+
+	__asm __volatile (
+		"1:\n\t"
+		"lld	%0, %3\n\t"		/* load old value */
+		"dsubu	%0, %2\n\t"		/* calculate new value */
+		"scd	%0, %1\n\t"		/* attempt to store */
+		"beqz	%0, 1b\n\t"		/* spin if failed */
+		: "=&r" (temp), "=m" (*p)
+		: "r" (v), "m" (*p)
+		: "memory");
+}
+
+static __inline uint64_t
+atomic_readandclear_64(__volatile uint64_t *addr)
+{
+	uint64_t result,temp;
+
+	__asm __volatile (
+		"1:\n\t"
+		"lld	 %0, %3\n\t"		/* load old value */
+		"li	 %1, 0\n\t"		/* value to store */
+		"scd	 %1, %2\n\t"		/* attempt to store */
+		"beqz	 %1, 1b\n\t"		/* if the store failed, spin */
+		: "=&r"(result), "=&r"(temp), "=m" (*addr)
+		: "m" (*addr)
+		: "memory");
+
+	return result;
+}
+
+static __inline uint64_t
+atomic_readandset_64(__volatile uint64_t *addr, uint64_t value)
+{
+	uint64_t result,temp;
+
+	__asm __volatile (
+		"1:\n\t"
+		"lld	 %0,%3\n\t"		/* Load old value*/
+		"or      %1,$0,%4\n\t"
+		"scd	 %1,%2\n\t"		/* attempt to store */
+		"beqz	 %1, 1b\n\t"		/* if the store failed, spin */
+		: "=&r"(result), "=&r"(temp), "=m" (*addr)
+		: "m" (*addr), "r" (value)
+		: "memory");
+
+	return result;
+}
+#endif
+
 #define	ATOMIC_ACQ_REL(NAME, WIDTH)					\
 static __inline  void							\
 atomic_##NAME##_acq_##WIDTH(__volatile uint##WIDTH##_t *p, uint##WIDTH##_t v)\
@@ -194,7 +309,7 @@
 ATOMIC_ACQ_REL(clear, 32)
 ATOMIC_ACQ_REL(add, 32)
 ATOMIC_ACQ_REL(subtract, 32)
-#if 0
+#if defined(__mips_n64) || defined(__mips_n32)
 ATOMIC_ACQ_REL(set, 64)
 ATOMIC_ACQ_REL(clear, 64)
 ATOMIC_ACQ_REL(add, 64)
@@ -226,8 +341,22 @@
 
 ATOMIC_STORE_LOAD(32)
 ATOMIC_STORE_LOAD(64)
-void atomic_store_64 (__volatile uint64_t *, uint64_t *);
-void atomic_load_64 (__volatile uint64_t *, uint64_t *);
+#if !defined(__mips_n64) && !defined(__mips_n32)
+void atomic_store_64(__volatile uint64_t *, uint64_t *);
+void atomic_load_64(__volatile uint64_t *, uint64_t *);
+#else
+static __inline void
+atomic_store_64(__volatile uint64_t *p, uint64_t *v)
+{
+	*p = *v;
+}
+
+static __inline void
+atomic_load_64(__volatile uint64_t *p, uint64_t *v)
+{
+	*v = *p;
+}
+#endif
 
 #undef ATOMIC_STORE_LOAD
 
@@ -294,10 +423,82 @@
 		"addu %2, %3, %0\n\t"		/* calculate new value */
 		"sc %2, %1\n\t"			/* attempt to store */
 		"beqz %2, 1b\n\t"		/* spin if failed */
-		: "=&r" (value), "=m" (*p), "=r" (temp)
+		: "=&r" (value), "=m" (*p), "=&r" (temp)
+		: "r" (v), "m" (*p));
+	return (value);
+}
+
+#if defined(__mips_n64) || defined(__mips_n32)
+/*
+ * Atomically compare the value stored at *p with cmpval and if the
+ * two values are equal, update the value of *p with newval. Returns
+ * zero if the compare failed, nonzero otherwise.
+ */
+static __inline uint64_t
+atomic_cmpset_64(__volatile uint64_t* p, uint64_t cmpval, uint64_t newval)
+{
+	uint64_t ret;
+
+	__asm __volatile (
+		"1:\n\t"
+		"lld	%0, %4\n\t"		/* load old value */
+		"bne	%0, %2, 2f\n\t"		/* compare */
+		"move	%0, %3\n\t"		/* value to store */
+		"scd	%0, %1\n\t"		/* attempt to store */
+		"beqz	%0, 1b\n\t"		/* if it failed, spin */
+		"j	3f\n\t"
+		"2:\n\t"
+		"li	%0, 0\n\t"
+		"3:\n"
+		: "=&r" (ret), "=m" (*p)
+		: "r" (cmpval), "r" (newval), "m" (*p)
+		: "memory");
+
+	return ret;
+}
+
+/*
+ * Atomically compare the value stored at *p with cmpval and if the
+ * two values are equal, update the value of *p with newval. Returns
+ * zero if the compare failed, nonzero otherwise.
+ */
+static __inline uint64_t
+atomic_cmpset_acq_64(__volatile uint64_t *p, uint64_t cmpval, uint64_t newval)
+{
+	int retval;
+
+	retval = atomic_cmpset_64(p, cmpval, newval);
+	mips_sync();
+	return (retval);
+}
+
+static __inline uint64_t
+atomic_cmpset_rel_64(__volatile uint64_t *p, uint64_t cmpval, uint64_t newval)
+{
+	mips_sync();
+	return (atomic_cmpset_64(p, cmpval, newval));
+}
+
+/*
+ * Atomically add the value of v to the integer pointed to by p and return
+ * the previous value of *p.
+ */
+static __inline uint64_t
+atomic_fetchadd_64(__volatile uint64_t *p, uint64_t v)
+{
+	uint64_t value, temp;
+
+	__asm __volatile (
+		"1:\n\t"
+		"lld	%0, %1\n\t"		/* load old value */
+		"daddu	%2, %3, %0\n\t"		/* calculate new value */
+		"scd	%2, %1\n\t"		/* attempt to store */
+		"beqz	%2, 1b\n\t"		/* spin if failed */
+		: "=&r" (value), "=m" (*p), "=&r" (temp)
 		: "r" (v), "m" (*p));
 	return (value);
 }
+#endif
 
 /* Operations on chars. */
 #define	atomic_set_char		atomic_set_8
@@ -349,7 +550,13 @@
 #define	atomic_readandset_int	atomic_readandset_32
 #define	atomic_fetchadd_int	atomic_fetchadd_32
 
-#ifdef __mips64
+/*
+ * I think the following is right, even for n32.  For n32 the pointers
+ * are still 32-bits, so we need to operate on them as 32-bit quantities,
+ * even though they are sign extended in operation.  For longs, there's
+ * no question because they are always 32-bits.
+ */
+#ifdef __mips_n64
 /* Operations on longs. */
 #define	atomic_set_long		atomic_set_64
 #define	atomic_set_acq_long	atomic_set_acq_64
@@ -371,27 +578,7 @@
 #define	atomic_fetchadd_long	atomic_fetchadd_64
 #define	atomic_readandclear_long	atomic_readandclear_64
 
-/* Operations on pointers. */
-#define	atomic_set_ptr		atomic_set_64
-#define	atomic_set_acq_ptr	atomic_set_acq_64
-#define	atomic_set_rel_ptr	atomic_set_rel_64
-#define	atomic_clear_ptr	atomic_clear_64
-#define	atomic_clear_acq_ptr	atomic_clear_acq_64
-#define	atomic_clear_rel_ptr	atomic_clear_rel_64
-#define	atomic_add_ptr		atomic_add_64
-#define	atomic_add_acq_ptr	atomic_add_acq_64
-#define	atomic_add_rel_ptr	atomic_add_rel_64
-#define	atomic_subtract_ptr	atomic_subtract_64
-#define	atomic_subtract_acq_ptr	atomic_subtract_acq_64
-#define	atomic_subtract_rel_ptr	atomic_subtract_rel_64
-#define	atomic_cmpset_ptr	atomic_cmpset_64
-#define	atomic_cmpset_acq_ptr	atomic_cmpset_acq_64
-#define	atomic_cmpset_rel_ptr	atomic_cmpset_rel_64
-#define	atomic_load_acq_ptr	atomic_load_acq_64
-#define	atomic_store_rel_ptr	atomic_store_rel_64
-#define	atomic_readandclear_ptr	atomic_readandclear_64
-
-#else /* __mips64 */
+#else /* !__mips_n64 */
 
 /* Operations on longs. */
 #define	atomic_set_long		atomic_set_32
@@ -421,25 +608,26 @@
 	atomic_fetchadd_32((volatile u_int *)(p), (u_int)(v))
 #define	atomic_readandclear_long	atomic_readandclear_32
 
+#endif /* __mips_n64 */
+
 /* Operations on pointers. */
-#define	atomic_set_ptr		atomic_set_32
-#define	atomic_set_acq_ptr	atomic_set_acq_32
-#define	atomic_set_rel_ptr	atomic_set_rel_32
-#define	atomic_clear_ptr	atomic_clear_32
-#define	atomic_clear_acq_ptr	atomic_clear_acq_32
-#define	atomic_clear_rel_ptr	atomic_clear_rel_32
-#define	atomic_add_ptr		atomic_add_32
-#define	atomic_add_acq_ptr	atomic_add_acq_32
-#define	atomic_add_rel_ptr	atomic_add_rel_32
-#define	atomic_subtract_ptr	atomic_subtract_32
-#define	atomic_subtract_acq_ptr	atomic_subtract_acq_32
-#define	atomic_subtract_rel_ptr	atomic_subtract_rel_32
-#define	atomic_cmpset_ptr	atomic_cmpset_32
-#define	atomic_cmpset_acq_ptr	atomic_cmpset_acq_32
-#define	atomic_cmpset_rel_ptr	atomic_cmpset_rel_32
-#define	atomic_load_acq_ptr	atomic_load_acq_32
-#define	atomic_store_rel_ptr	atomic_store_rel_32
-#define	atomic_readandclear_ptr	atomic_readandclear_32
-#endif /* __mips64 */
+#define	atomic_set_ptr		atomic_set_long
+#define	atomic_set_acq_ptr	atomic_set_acq_long
+#define	atomic_set_rel_ptr	atomic_set_rel_long
+#define	atomic_clear_ptr	atomic_clear_long
+#define	atomic_clear_acq_ptr	atomic_clear_acq_long
+#define	atomic_clear_rel_ptr	atomic_clear_rel_long
+#define	atomic_add_ptr		atomic_add_long
+#define	atomic_add_acq_ptr	atomic_add_acq_long
+#define	atomic_add_rel_ptr	atomic_add_rel_long
+#define	atomic_subtract_ptr	atomic_subtract_long
+#define	atomic_subtract_acq_ptr	atomic_subtract_acq_long
+#define	atomic_subtract_rel_ptr	atomic_subtract_rel_long
+#define	atomic_cmpset_ptr	atomic_cmpset_long
+#define	atomic_cmpset_acq_ptr	atomic_cmpset_acq_long
+#define	atomic_cmpset_rel_ptr	atomic_cmpset_rel_long
+#define	atomic_load_acq_ptr	atomic_load_acq_long
+#define	atomic_store_rel_ptr	atomic_store_rel_long
+#define	atomic_readandclear_ptr	atomic_readandclear_long
 
 #endif /* ! _MACHINE_ATOMIC_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/bus.h svn/mips/sys/mips/include/bus.h
--- releng8/src/sys/mips/include/bus.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/bus.h	2009-05-06 14:57:15.000000000 -0700
@@ -1,8 +1,7 @@
-/*      $NetBSD: bus.h,v 1.12 1997/10/01 08:25:15 fvdl Exp $    */
+/*	$NetBSD: bus.h,v 1.11 2003/07/28 17:35:54 thorpej Exp $	*/
+
 /*-
- * $Id: bus.h,v 1.6 2007/08/09 11:23:32 katta Exp $
- *
- * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
+ * Copyright (c) 1996, 1997, 1998, 2001 The NetBSD Foundation, Inc.
  * All rights reserved.
  *
  * This code is derived from software contributed to The NetBSD Foundation
@@ -38,7 +37,7 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
+/*-
  * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
  * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
  *
@@ -68,843 +67,657 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- *	from: src/sys/alpha/include/bus.h,v 1.5 1999/08/28 00:38:40 peter
- * $FreeBSD: src/sys/mips/include/bus.h,v 1.2.2.1 2009/08/03 08:13:06 kensmith Exp $
-*/
+ * $FreeBSD: projects/mips/sys/mips/include/bus.h 191282 2009-04-19 22:02:14Z gonzo $
+ */
 
 #ifndef _MACHINE_BUS_H_
-#define	_MACHINE_BUS_H_
+#define _MACHINE_BUS_H_
 
-#ifdef TARGET_OCTEON
-#include <machine/bus_octeon.h>
-#else
 #include <machine/_bus.h>
-#include <machine/cpufunc.h>
-
-/*
- * Values for the mips bus space tag, not to be used directly by MI code.
- */
-#define	MIPS_BUS_SPACE_IO	0	/* space is i/o space */
-#define	MIPS_BUS_SPACE_MEM	1	/* space is mem space */
 
+struct bus_space {
+	/* cookie */
+	void		*bs_cookie;
+
+	/* mapping/unmapping */
+	int		(*bs_map) (void *, bus_addr_t, bus_size_t,
+			    int, bus_space_handle_t *);
+	void		(*bs_unmap) (void *, bus_space_handle_t, bus_size_t);
+	int		(*bs_subregion) (void *, bus_space_handle_t,
+			    bus_size_t, bus_size_t, bus_space_handle_t *);
+
+	/* allocation/deallocation */
+	int		(*bs_alloc) (void *, bus_addr_t, bus_addr_t,
+			    bus_size_t, bus_size_t, bus_size_t, int,
+			    bus_addr_t *, bus_space_handle_t *);
+	void		(*bs_free) (void *, bus_space_handle_t,
+			    bus_size_t);
+
+	/* get kernel virtual address */
+	/* barrier */
+	void		(*bs_barrier) (void *, bus_space_handle_t,
+			    bus_size_t, bus_size_t, int);
+
+	/* read (single) */
+	u_int8_t	(*bs_r_1) (void *, bus_space_handle_t, bus_size_t);
+	u_int16_t	(*bs_r_2) (void *, bus_space_handle_t, bus_size_t);
+	u_int32_t	(*bs_r_4) (void *, bus_space_handle_t, bus_size_t);
+	u_int64_t	(*bs_r_8) (void *, bus_space_handle_t, bus_size_t);
+
+	/* read multiple */
+	void		(*bs_rm_1) (void *, bus_space_handle_t, bus_size_t,
+	    u_int8_t *, bus_size_t);
+	void		(*bs_rm_2) (void *, bus_space_handle_t, bus_size_t,
+	    u_int16_t *, bus_size_t);
+	void		(*bs_rm_4) (void *, bus_space_handle_t,
+			    bus_size_t, u_int32_t *, bus_size_t);
+	void		(*bs_rm_8) (void *, bus_space_handle_t,
+			    bus_size_t, u_int64_t *, bus_size_t);
+					
+	/* read region */
+	void		(*bs_rr_1) (void *, bus_space_handle_t,
+			    bus_size_t, u_int8_t *, bus_size_t);
+	void		(*bs_rr_2) (void *, bus_space_handle_t,
+			    bus_size_t, u_int16_t *, bus_size_t);
+	void		(*bs_rr_4) (void *, bus_space_handle_t,
+			    bus_size_t, u_int32_t *, bus_size_t);
+	void		(*bs_rr_8) (void *, bus_space_handle_t,
+			    bus_size_t, u_int64_t *, bus_size_t);
+					
+	/* write (single) */
+	void		(*bs_w_1) (void *, bus_space_handle_t,
+			    bus_size_t, u_int8_t);
+	void		(*bs_w_2) (void *, bus_space_handle_t,
+			    bus_size_t, u_int16_t);
+	void		(*bs_w_4) (void *, bus_space_handle_t,
+			    bus_size_t, u_int32_t);
+	void		(*bs_w_8) (void *, bus_space_handle_t,
+			    bus_size_t, u_int64_t);
+
+	/* write multiple */
+	void		(*bs_wm_1) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int8_t *, bus_size_t);
+	void		(*bs_wm_2) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int16_t *, bus_size_t);
+	void		(*bs_wm_4) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int32_t *, bus_size_t);
+	void		(*bs_wm_8) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int64_t *, bus_size_t);
+					
+	/* write region */
+	void		(*bs_wr_1) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int8_t *, bus_size_t);
+	void		(*bs_wr_2) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int16_t *, bus_size_t);
+	void		(*bs_wr_4) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int32_t *, bus_size_t);
+	void		(*bs_wr_8) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int64_t *, bus_size_t);
+
+	/* set multiple */
+	void		(*bs_sm_1) (void *, bus_space_handle_t,
+			    bus_size_t, u_int8_t, bus_size_t);
+	void		(*bs_sm_2) (void *, bus_space_handle_t,
+			    bus_size_t, u_int16_t, bus_size_t);
+	void		(*bs_sm_4) (void *, bus_space_handle_t,
+			    bus_size_t, u_int32_t, bus_size_t);
+	void		(*bs_sm_8) (void *, bus_space_handle_t,
+			    bus_size_t, u_int64_t, bus_size_t);
+
+	/* set region */
+	void		(*bs_sr_1) (void *, bus_space_handle_t,
+			    bus_size_t, u_int8_t, bus_size_t);
+	void		(*bs_sr_2) (void *, bus_space_handle_t,
+			    bus_size_t, u_int16_t, bus_size_t);
+	void		(*bs_sr_4) (void *, bus_space_handle_t,
+			    bus_size_t, u_int32_t, bus_size_t);
+	void		(*bs_sr_8) (void *, bus_space_handle_t,
+			    bus_size_t, u_int64_t, bus_size_t);
+
+	/* copy */
+	void		(*bs_c_1) (void *, bus_space_handle_t, bus_size_t,
+			    bus_space_handle_t, bus_size_t, bus_size_t);
+	void		(*bs_c_2) (void *, bus_space_handle_t, bus_size_t,
+			    bus_space_handle_t, bus_size_t, bus_size_t);
+	void		(*bs_c_4) (void *, bus_space_handle_t, bus_size_t,
+			    bus_space_handle_t, bus_size_t, bus_size_t);
+	void		(*bs_c_8) (void *, bus_space_handle_t, bus_size_t,
+			    bus_space_handle_t, bus_size_t, bus_size_t);
+
+	/* read stream (single) */
+	u_int8_t	(*bs_r_1_s) (void *, bus_space_handle_t, bus_size_t);
+	u_int16_t	(*bs_r_2_s) (void *, bus_space_handle_t, bus_size_t);
+	u_int32_t	(*bs_r_4_s) (void *, bus_space_handle_t, bus_size_t);
+	u_int64_t	(*bs_r_8_s) (void *, bus_space_handle_t, bus_size_t);
+
+	/* read multiple stream */
+	void		(*bs_rm_1_s) (void *, bus_space_handle_t, bus_size_t,
+	    u_int8_t *, bus_size_t);
+	void		(*bs_rm_2_s) (void *, bus_space_handle_t, bus_size_t,
+	    u_int16_t *, bus_size_t);
+	void		(*bs_rm_4_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int32_t *, bus_size_t);
+	void		(*bs_rm_8_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int64_t *, bus_size_t);
+					
+	/* read region stream */
+	void		(*bs_rr_1_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int8_t *, bus_size_t);
+	void		(*bs_rr_2_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int16_t *, bus_size_t);
+	void		(*bs_rr_4_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int32_t *, bus_size_t);
+	void		(*bs_rr_8_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int64_t *, bus_size_t);
+					
+	/* write stream (single) */
+	void		(*bs_w_1_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int8_t);
+	void		(*bs_w_2_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int16_t);
+	void		(*bs_w_4_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int32_t);
+	void		(*bs_w_8_s) (void *, bus_space_handle_t,
+			    bus_size_t, u_int64_t);
+
+	/* write multiple stream */
+	void		(*bs_wm_1_s) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int8_t *, bus_size_t);
+	void		(*bs_wm_2_s) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int16_t *, bus_size_t);
+	void		(*bs_wm_4_s) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int32_t *, bus_size_t);
+	void		(*bs_wm_8_s) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int64_t *, bus_size_t);
+					
+	/* write region stream */
+	void		(*bs_wr_1_s) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int8_t *, bus_size_t);
+	void		(*bs_wr_2_s) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int16_t *, bus_size_t);
+	void		(*bs_wr_4_s) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int32_t *, bus_size_t);
+	void		(*bs_wr_8_s) (void *, bus_space_handle_t,
+			    bus_size_t, const u_int64_t *, bus_size_t);
+};
+
+
+/*
+ * Utility macros; INTERNAL USE ONLY.
+ */
+#define	__bs_c(a,b)		__CONCAT(a,b)
+#define	__bs_opname(op,size)	__bs_c(__bs_c(__bs_c(bs_,op),_),size)
+
+#define	__bs_rs(sz, t, h, o)						\
+	(*(t)->__bs_opname(r,sz))((t)->bs_cookie, h, o)
+#define	__bs_ws(sz, t, h, o, v)						\
+	(*(t)->__bs_opname(w,sz))((t)->bs_cookie, h, o, v)
+#define	__bs_nonsingle(type, sz, t, h, o, a, c)				\
+	(*(t)->__bs_opname(type,sz))((t)->bs_cookie, h, o, a, c)
+#define	__bs_set(type, sz, t, h, o, v, c)				\
+	(*(t)->__bs_opname(type,sz))((t)->bs_cookie, h, o, v, c)
+#define	__bs_copy(sz, t, h1, o1, h2, o2, cnt)				\
+	(*(t)->__bs_opname(c,sz))((t)->bs_cookie, h1, o1, h2, o2, cnt)
+
+#define	__bs_opname_s(op,size)	__bs_c(__bs_c(__bs_c(__bs_c(bs_,op),_),size),_s)
+#define	__bs_rs_s(sz, t, h, o)						\
+	(*(t)->__bs_opname_s(r,sz))((t)->bs_cookie, h, o)
+#define	__bs_ws_s(sz, t, h, o, v)					\
+	(*(t)->__bs_opname_s(w,sz))((t)->bs_cookie, h, o, v)
+#define	__bs_nonsingle_s(type, sz, t, h, o, a, c)			\
+	(*(t)->__bs_opname_s(type,sz))((t)->bs_cookie, h, o, a, c)
+
+
+/*
+ * Mapping and unmapping operations.
+ */
+#define	bus_space_map(t, a, s, c, hp)					\
+	(*(t)->bs_map)((t)->bs_cookie, (a), (s), (c), (hp))
+#define	bus_space_unmap(t, h, s)					\
+	(*(t)->bs_unmap)((t)->bs_cookie, (h), (s))
+#define	bus_space_subregion(t, h, o, s, hp)				\
+	(*(t)->bs_subregion)((t)->bs_cookie, (h), (o), (s), (hp))
+
+
+/*
+ * Allocation and deallocation operations.
+ */
+#define	bus_space_alloc(t, rs, re, s, a, b, c, ap, hp)			\
+	(*(t)->bs_alloc)((t)->bs_cookie, (rs), (re), (s), (a), (b),	\
+	    (c), (ap), (hp))
+#define	bus_space_free(t, h, s)						\
+	(*(t)->bs_free)((t)->bs_cookie, (h), (s))
+
+/*
+ * Bus barrier operations.
+ */
+#define	bus_space_barrier(t, h, o, l, f)				\
+	(*(t)->bs_barrier)((t)->bs_cookie, (h), (o), (l), (f))
+
+#define	BUS_SPACE_BARRIER_READ	0x01
+#define	BUS_SPACE_BARRIER_WRITE	0x02
+
+/*
+ * Bus read (single) operations.
+ */
+#define	bus_space_read_1(t, h, o)	__bs_rs(1,(t),(h),(o))
+#define	bus_space_read_2(t, h, o)	__bs_rs(2,(t),(h),(o))
+#define	bus_space_read_4(t, h, o)	__bs_rs(4,(t),(h),(o))
+#define	bus_space_read_8(t, h, o)	__bs_rs(8,(t),(h),(o))
+
+#define bus_space_read_stream_1(t, h, o)        __bs_rs_s(1,(t), (h), (o))
+#define bus_space_read_stream_2(t, h, o)        __bs_rs_s(2,(t), (h), (o))
+#define bus_space_read_stream_4(t, h, o)        __bs_rs_s(4,(t), (h), (o))
+#define	bus_space_read_stream_8(t, h, o)	__bs_rs_s(8,8,(t),(h),(o))
+
+/*
+ * Bus read multiple operations.
+ */
+#define	bus_space_read_multi_1(t, h, o, a, c)				\
+	__bs_nonsingle(rm,1,(t),(h),(o),(a),(c))
+#define	bus_space_read_multi_2(t, h, o, a, c)				\
+	__bs_nonsingle(rm,2,(t),(h),(o),(a),(c))
+#define	bus_space_read_multi_4(t, h, o, a, c)				\
+	__bs_nonsingle(rm,4,(t),(h),(o),(a),(c))
+#define	bus_space_read_multi_8(t, h, o, a, c)				\
+	__bs_nonsingle(rm,8,(t),(h),(o),(a),(c))
+
+#define	bus_space_read_multi_stream_1(t, h, o, a, c)			\
+	__bs_nonsingle_s(rm,1,(t),(h),(o),(a),(c))
+#define	bus_space_read_multi_stream_2(t, h, o, a, c)			\
+	__bs_nonsingle_s(rm,2,(t),(h),(o),(a),(c))
+#define	bus_space_read_multi_stream_4(t, h, o, a, c)			\
+	__bs_nonsingle_s(rm,4,(t),(h),(o),(a),(c))
+#define	bus_space_read_multi_stream_8(t, h, o, a, c)			\
+	__bs_nonsingle_s(rm,8,(t),(h),(o),(a),(c))
+
+
+/*
+ * Bus read region operations.
+ */
+#define	bus_space_read_region_1(t, h, o, a, c)				\
+	__bs_nonsingle(rr,1,(t),(h),(o),(a),(c))
+#define	bus_space_read_region_2(t, h, o, a, c)				\
+	__bs_nonsingle(rr,2,(t),(h),(o),(a),(c))
+#define	bus_space_read_region_4(t, h, o, a, c)				\
+	__bs_nonsingle(rr,4,(t),(h),(o),(a),(c))
+#define	bus_space_read_region_8(t, h, o, a, c)				\
+	__bs_nonsingle(rr,8,(t),(h),(o),(a),(c))
+
+#define	bus_space_read_region_stream_1(t, h, o, a, c)			\
+	__bs_nonsingle_s(rr,1,(t),(h),(o),(a),(c))
+#define	bus_space_read_region_stream_2(t, h, o, a, c)			\
+	__bs_nonsingle_s(rr,2,(t),(h),(o),(a),(c))
+#define	bus_space_read_region_stream_4(t, h, o, a, c)			\
+	__bs_nonsingle_s(rr,4,(t),(h),(o),(a),(c))
+#define	bus_space_read_region_stream_8(t, h, o, a, c)			\
+	__bs_nonsingle_s(rr,8,(t),(h),(o),(a),(c))
+
+
+/*
+ * Bus write (single) operations.
+ */
+#define	bus_space_write_1(t, h, o, v)	__bs_ws(1,(t),(h),(o),(v))
+#define	bus_space_write_2(t, h, o, v)	__bs_ws(2,(t),(h),(o),(v))
+#define	bus_space_write_4(t, h, o, v)	__bs_ws(4,(t),(h),(o),(v))
+#define	bus_space_write_8(t, h, o, v)	__bs_ws(8,(t),(h),(o),(v))
+
+#define	bus_space_write_stream_1(t, h, o, v)	__bs_ws_s(1,(t),(h),(o),(v))
+#define	bus_space_write_stream_2(t, h, o, v)	__bs_ws_s(2,(t),(h),(o),(v))
+#define	bus_space_write_stream_4(t, h, o, v)	__bs_ws_s(4,(t),(h),(o),(v))
+#define	bus_space_write_stream_8(t, h, o, v)	__bs_ws_s(8,(t),(h),(o),(v))
+
+
+/*
+ * Bus write multiple operations.
+ */
+#define	bus_space_write_multi_1(t, h, o, a, c)				\
+	__bs_nonsingle(wm,1,(t),(h),(o),(a),(c))
+#define	bus_space_write_multi_2(t, h, o, a, c)				\
+	__bs_nonsingle(wm,2,(t),(h),(o),(a),(c))
+#define	bus_space_write_multi_4(t, h, o, a, c)				\
+	__bs_nonsingle(wm,4,(t),(h),(o),(a),(c))
+#define	bus_space_write_multi_8(t, h, o, a, c)				\
+	__bs_nonsingle(wm,8,(t),(h),(o),(a),(c))
 
-#define	BUS_SPACE_MAXSIZE_24BIT	0xFFFFFF
-#define	BUS_SPACE_MAXSIZE_32BIT 0xFFFFFFFF
-#define	BUS_SPACE_MAXSIZE	0xFFFFFFFF /* Maximum supported size */
-#define	BUS_SPACE_MAXADDR_24BIT	0xFFFFFF
-#define	BUS_SPACE_MAXADDR_32BIT 0xFFFFFFFF
-#define	BUS_SPACE_MAXADDR	0xFFFFFFFF
+#define	bus_space_write_multi_stream_1(t, h, o, a, c)			\
+	__bs_nonsingle_s(wm,1,(t),(h),(o),(a),(c))
+#define	bus_space_write_multi_stream_2(t, h, o, a, c)			\
+	__bs_nonsingle_s(wm,2,(t),(h),(o),(a),(c))
+#define	bus_space_write_multi_stream_4(t, h, o, a, c)			\
+	__bs_nonsingle_s(wm,4,(t),(h),(o),(a),(c))
+#define	bus_space_write_multi_stream_8(t, h, o, a, c)			\
+	__bs_nonsingle_s(wm,8,(t),(h),(o),(a),(c))
 
-#define	BUS_SPACE_UNRESTRICTED	(~0)
 
 /*
- * Map a region of device bus space into CPU virtual address space.
+ * Bus write region operations.
  */
+#define	bus_space_write_region_1(t, h, o, a, c)				\
+	__bs_nonsingle(wr,1,(t),(h),(o),(a),(c))
+#define	bus_space_write_region_2(t, h, o, a, c)				\
+	__bs_nonsingle(wr,2,(t),(h),(o),(a),(c))
+#define	bus_space_write_region_4(t, h, o, a, c)				\
+	__bs_nonsingle(wr,4,(t),(h),(o),(a),(c))
+#define	bus_space_write_region_8(t, h, o, a, c)				\
+	__bs_nonsingle(wr,8,(t),(h),(o),(a),(c))
 
-static __inline int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
-				  bus_size_t size, int flags,
-				  bus_space_handle_t *bshp);
-
-static __inline int
-bus_space_map(bus_space_tag_t t __unused, bus_addr_t addr,
-	      bus_size_t size __unused, int flags __unused,
-	      bus_space_handle_t *bshp)
-{
+#define	bus_space_write_region_stream_1(t, h, o, a, c)			\
+	__bs_nonsingle_s(wr,1,(t),(h),(o),(a),(c))
+#define	bus_space_write_region_stream_2(t, h, o, a, c)			\
+	__bs_nonsingle_s(wr,2,(t),(h),(o),(a),(c))
+#define	bus_space_write_region_stream_4(t, h, o, a, c)			\
+	__bs_nonsingle_s(wr,4,(t),(h),(o),(a),(c))
+#define	bus_space_write_region_stream_8(t, h, o, a, c)			\
+	__bs_nonsingle_s(wr,8,(t),(h),(o),(a),(c))
 
-	*bshp = addr;
-	return (0);
-}
 
 /*
- * Unmap a region of device bus space.
+ * Set multiple operations.
  */
+#define	bus_space_set_multi_1(t, h, o, v, c)				\
+	__bs_set(sm,1,(t),(h),(o),(v),(c))
+#define	bus_space_set_multi_2(t, h, o, v, c)				\
+	__bs_set(sm,2,(t),(h),(o),(v),(c))
+#define	bus_space_set_multi_4(t, h, o, v, c)				\
+	__bs_set(sm,4,(t),(h),(o),(v),(c))
+#define	bus_space_set_multi_8(t, h, o, v, c)				\
+	__bs_set(sm,8,(t),(h),(o),(v),(c))
 
-void	bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
-	    bus_size_t size);
 
 /*
- * Get a new handle for a subregion of an already-mapped area of bus space.
+ * Set region operations.
  */
+#define	bus_space_set_region_1(t, h, o, v, c)				\
+	__bs_set(sr,1,(t),(h),(o),(v),(c))
+#define	bus_space_set_region_2(t, h, o, v, c)				\
+	__bs_set(sr,2,(t),(h),(o),(v),(c))
+#define	bus_space_set_region_4(t, h, o, v, c)				\
+	__bs_set(sr,4,(t),(h),(o),(v),(c))
+#define	bus_space_set_region_8(t, h, o, v, c)				\
+	__bs_set(sr,8,(t),(h),(o),(v),(c))
 
-int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
-	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
 
 /*
- * Allocate a region of memory that is accessible to devices in bus space.
+ * Copy operations.
  */
-
-int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
-	    bus_addr_t rend, bus_size_t size, bus_size_t align,
-	    bus_size_t boundary, int flags, bus_addr_t *addrp,
-	    bus_space_handle_t *bshp);
+#define	bus_space_copy_region_1(t, h1, o1, h2, o2, c)				\
+	__bs_copy(1, t, h1, o1, h2, o2, c)
+#define	bus_space_copy_region_2(t, h1, o1, h2, o2, c)				\
+	__bs_copy(2, t, h1, o1, h2, o2, c)
+#define	bus_space_copy_region_4(t, h1, o1, h2, o2, c)				\
+	__bs_copy(4, t, h1, o1, h2, o2, c)
+#define	bus_space_copy_region_8(t, h1, o1, h2, o2, c)				\
+	__bs_copy(8, t, h1, o1, h2, o2, c)
 
 /*
- * Free a region of bus space accessible memory.
+ * Macros to provide prototypes for all the functions used in the
+ * bus_space structure
  */
 
-void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
+#define bs_map_proto(f)							\
+int	__bs_c(f,_bs_map) (void *t, bus_addr_t addr,		\
+	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
+
+#define bs_unmap_proto(f)						\
+void	__bs_c(f,_bs_unmap) (void *t, bus_space_handle_t bsh,		\
 	    bus_size_t size);
 
+#define bs_subregion_proto(f)						\
+int	__bs_c(f,_bs_subregion) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, bus_size_t size, 			\
+	    bus_space_handle_t *nbshp);
+
+#define bs_alloc_proto(f)						\
+int	__bs_c(f,_bs_alloc) (void *t, bus_addr_t rstart,		\
+	    bus_addr_t rend, bus_size_t size, bus_size_t align,		\
+	    bus_size_t boundary, int cacheable, bus_addr_t *addrp,	\
+	    bus_space_handle_t *bshp);
 
-/*
- * Read a 1, 2, 4, or 8 byte quantity from bus space
- * described by tag/handle/offset.
- */
-static __inline u_int8_t bus_space_read_1(bus_space_tag_t tag,
-					  bus_space_handle_t handle,
-					  bus_size_t offset);
-
-static __inline u_int16_t bus_space_read_2(bus_space_tag_t tag,
-					   bus_space_handle_t handle,
-					   bus_size_t offset);
-
-static __inline u_int32_t bus_space_read_4(bus_space_tag_t tag,
-					   bus_space_handle_t handle,
-					   bus_size_t offset);
-
-static __inline u_int8_t
-bus_space_read_1(bus_space_tag_t tag, bus_space_handle_t handle,
-    bus_size_t offset)
-{
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		return (inb(handle + offset));
-	return (readb(handle + offset));
-}
-
-static __inline u_int16_t
-bus_space_read_2(bus_space_tag_t tag, bus_space_handle_t handle,
-    bus_size_t offset)
-{
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		return (inw(handle + offset));
-	return (readw(handle + offset));
-}
-
-static __inline u_int32_t
-bus_space_read_4(bus_space_tag_t tag, bus_space_handle_t handle,
-    bus_size_t offset)
-{
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		return (inl(handle + offset));
-	return (readl(handle + offset));
-}
-
-#if 0	/* Cause a link error for bus_space_read_8 */
-#define	bus_space_read_8(t, h, o)	!!! bus_space_read_8 unimplemented !!!
-#endif
-
-/*
- * Read `count' 1, 2, 4, or 8 byte quantities from bus space
- * described by tag/handle/offset and copy into buffer provided.
- */
-static __inline void bus_space_read_multi_1(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int8_t *addr,
-					    size_t count);
-
-static __inline void bus_space_read_multi_2(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int16_t *addr,
-					    size_t count);
-
-static __inline void bus_space_read_multi_4(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int32_t *addr,
-					    size_t count);
-
-static __inline void
-bus_space_read_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int8_t *addr, size_t count)
-{
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			*addr++ = inb(bsh + offset);
-	else
-	while (count--)
-		*addr++ = readb(bsh + offset);
-}
-
-static __inline void
-bus_space_read_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int16_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			*addr++ = inw(baddr);
-	else
-		while (count--)
-			*addr++ = readw(baddr);
-}
-
-static __inline void
-bus_space_read_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int32_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			*addr++ = inl(baddr);
-	else
-		while (count--)
-			*addr++ = readl(baddr);
-}
-
-#if 0	/* Cause a link error for bus_space_read_multi_8 */
-#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 unimplemented !!!
-#endif
-
-/*
- * Read `count' 1, 2, 4, or 8 byte quantities from bus space
- * described by tag/handle and starting at `offset' and copy into
- * buffer provided.
- */
-static __inline void bus_space_read_region_1(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset, u_int8_t *addr,
-					     size_t count);
-
-static __inline void bus_space_read_region_2(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset, u_int16_t *addr,
-					     size_t count);
-
-static __inline void bus_space_read_region_4(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset, u_int32_t *addr,
-					     size_t count);
-
-
-static __inline void
-bus_space_read_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int8_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--) {
-			*addr++ = inb(baddr);
-			baddr += 1;
-		}
-	else
-		while (count--) {
-			*addr++ = readb(baddr);
-			baddr += 1;
-		}
-}
-
-static __inline void
-bus_space_read_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int16_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--) {
-			*addr++ = inw(baddr);
-			baddr += 2;
-		}
-	else
-		while (count--) {
-			*addr++ = readw(baddr);
-			baddr += 2;
-		}
-}
-
-static __inline void
-bus_space_read_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int32_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--) {
-			*addr++ = inl(baddr);
-			baddr += 4;
-		}
-	else
-		while (count--) {
-			*addr++ = readb(baddr);
-			baddr += 4;
-		}
-}
-
-#if 0	/* Cause a link error for bus_space_read_region_8 */
-#define	bus_space_read_region_8	!!! bus_space_read_region_8 unimplemented !!!
-#endif
-
-/*
- * Write the 1, 2, 4, or 8 byte value `value' to bus space
- * described by tag/handle/offset.
- */
-
-static __inline void bus_space_write_1(bus_space_tag_t tag,
-				       bus_space_handle_t bsh,
-				       bus_size_t offset, u_int8_t value);
-
-static __inline void bus_space_write_2(bus_space_tag_t tag,
-				       bus_space_handle_t bsh,
-				       bus_size_t offset, u_int16_t value);
-
-static __inline void bus_space_write_4(bus_space_tag_t tag,
-				       bus_space_handle_t bsh,
-				       bus_size_t offset, u_int32_t value);
-
-static __inline void
-bus_space_write_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int8_t value)
-{
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		outb(bsh + offset, value);
-	else
-		writeb(bsh + offset, value);
-}
-
-static __inline void
-bus_space_write_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int16_t value)
-{
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		outw(bsh + offset, value);
-	else
-		writew(bsh + offset, value);
-}
-
-static __inline void
-bus_space_write_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int32_t value)
-{
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		outl(bsh + offset, value);
-	else
-		writel(bsh + offset, value);
-}
-
-#if 0	/* Cause a link error for bus_space_write_8 */
-#define	bus_space_write_8	!!! bus_space_write_8 not implemented !!!
-#endif
-
-/*
- * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
- * provided to bus space described by tag/handle/offset.
- */
-
-static __inline void bus_space_write_multi_1(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset,
-					     const u_int8_t *addr,
-					     size_t count);
-static __inline void bus_space_write_multi_2(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset,
-					     const u_int16_t *addr,
-					     size_t count);
-
-static __inline void bus_space_write_multi_4(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset,
-					     const u_int32_t *addr,
-					     size_t count);
-
-static __inline void
-bus_space_write_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, const u_int8_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			outb(baddr, *addr++);
-	else
-		while (count--)
-			writeb(baddr, *addr++);
-}
-
-static __inline void
-bus_space_write_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, const u_int16_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			outw(baddr, *addr++);
-	else
-		while (count--)
-			writew(baddr, *addr++);
-}
-
-static __inline void
-bus_space_write_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, const u_int32_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			outl(baddr, *addr++);
-	else
-		while (count--)
-			writel(baddr, *addr++);
-}
+#define bs_free_proto(f)						\
+void	__bs_c(f,_bs_free) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t size);
 
-#if 0	/* Cause a link error for bus_space_write_multi_8 */
-#define	bus_space_write_multi_8(t, h, o, a, c)				\
-			!!! bus_space_write_multi_8 unimplemented !!!
-#endif
+#define bs_barrier_proto(f)						\
+void	__bs_c(f,_bs_barrier) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, bus_size_t len, int flags);
+
+#define	bs_r_1_proto(f)							\
+u_int8_t	__bs_c(f,_bs_r_1) (void *t, bus_space_handle_t bsh,	\
+		    bus_size_t offset);
+
+#define	bs_r_2_proto(f)							\
+u_int16_t	__bs_c(f,_bs_r_2) (void *t, bus_space_handle_t bsh,	\
+		    bus_size_t offset);
+
+#define	bs_r_4_proto(f)							\
+u_int32_t	__bs_c(f,_bs_r_4) (void *t, bus_space_handle_t bsh,	\
+		    bus_size_t offset);
+
+#define	bs_r_8_proto(f)							\
+u_int64_t	__bs_c(f,_bs_r_8) (void *t, bus_space_handle_t bsh,	\
+		    bus_size_t offset);
+
+#define	bs_r_1_s_proto(f)						\
+u_int8_t	__bs_c(f,_bs_r_1_s) (void *t, bus_space_handle_t bsh,	\
+		    bus_size_t offset);
+
+#define	bs_r_2_s_proto(f)						\
+u_int16_t	__bs_c(f,_bs_r_2_s) (void *t, bus_space_handle_t bsh,	\
+		    bus_size_t offset);
+
+#define	bs_r_4_s_proto(f)						\
+u_int32_t	__bs_c(f,_bs_r_4_s) (void *t, bus_space_handle_t bsh,	\
+		    bus_size_t offset);
+
+#define	bs_w_1_proto(f)							\
+void	__bs_c(f,_bs_w_1) (void *t, bus_space_handle_t bsh,		\
+	    bus_size_t offset, u_int8_t value);
+
+#define	bs_w_2_proto(f)							\
+void	__bs_c(f,_bs_w_2) (void *t, bus_space_handle_t bsh,		\
+	    bus_size_t offset, u_int16_t value);
+
+#define	bs_w_4_proto(f)							\
+void	__bs_c(f,_bs_w_4) (void *t, bus_space_handle_t bsh,		\
+	    bus_size_t offset, u_int32_t value);
+
+#define	bs_w_8_proto(f)							\
+void	__bs_c(f,_bs_w_8) (void *t, bus_space_handle_t bsh,		\
+	    bus_size_t offset, u_int64_t value);
+
+#define	bs_w_1_s_proto(f)						\
+void	__bs_c(f,_bs_w_1_s) (void *t, bus_space_handle_t bsh,		\
+	    bus_size_t offset, u_int8_t value);
+
+#define	bs_w_2_s_proto(f)						\
+void	__bs_c(f,_bs_w_2_s) (void *t, bus_space_handle_t bsh,		\
+	    bus_size_t offset, u_int16_t value);
+
+#define	bs_w_4_s_proto(f)						\
+void	__bs_c(f,_bs_w_4_s) (void *t, bus_space_handle_t bsh,		\
+	    bus_size_t offset, u_int32_t value);
+
+#define	bs_rm_1_proto(f)						\
+void	__bs_c(f,_bs_rm_1) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int8_t *addr, bus_size_t count);
+
+#define	bs_rm_2_proto(f)						\
+void	__bs_c(f,_bs_rm_2) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int16_t *addr, bus_size_t count);
+
+#define	bs_rm_4_proto(f)						\
+void	__bs_c(f,_bs_rm_4) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int32_t *addr, bus_size_t count);		
+
+#define	bs_rm_8_proto(f)						\
+void	__bs_c(f,_bs_rm_8) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int64_t *addr, bus_size_t count);
+
+#define	bs_wm_1_proto(f)						\
+void	__bs_c(f,_bs_wm_1) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, const u_int8_t *addr, bus_size_t count);
+
+#define	bs_wm_2_proto(f)						\
+void	__bs_c(f,_bs_wm_2) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, const u_int16_t *addr, bus_size_t count);
+
+#define	bs_wm_4_proto(f)						\
+void	__bs_c(f,_bs_wm_4) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, const u_int32_t *addr, bus_size_t count);
+
+#define	bs_wm_8_proto(f)						\
+void	__bs_c(f,_bs_wm_8) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, const u_int64_t *addr, bus_size_t count);
+
+#define	bs_rr_1_proto(f)						\
+void	__bs_c(f, _bs_rr_1) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int8_t *addr, bus_size_t count);
+
+#define	bs_rr_2_proto(f)						\
+void	__bs_c(f, _bs_rr_2) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int16_t *addr, bus_size_t count);
+
+#define	bs_rr_4_proto(f)						\
+void	__bs_c(f, _bs_rr_4) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int32_t *addr, bus_size_t count);
+
+#define	bs_rr_8_proto(f)						\
+void	__bs_c(f, _bs_rr_8) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int64_t *addr, bus_size_t count);
+
+#define	bs_wr_1_proto(f)						\
+void	__bs_c(f, _bs_wr_1) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, const u_int8_t *addr, bus_size_t count);
+
+#define	bs_wr_2_proto(f)						\
+void	__bs_c(f, _bs_wr_2) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, const u_int16_t *addr, bus_size_t count);
+
+#define	bs_wr_4_proto(f)						\
+void	__bs_c(f, _bs_wr_4) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, const u_int32_t *addr, bus_size_t count);
+
+#define	bs_wr_8_proto(f)						\
+void	__bs_c(f, _bs_wr_8) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, const u_int64_t *addr, bus_size_t count);
+
+#define	bs_sm_1_proto(f)						\
+void	__bs_c(f,_bs_sm_1) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int8_t value, bus_size_t count);
+
+#define	bs_sm_2_proto(f)						\
+void	__bs_c(f,_bs_sm_2) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int16_t value, bus_size_t count);
+
+#define	bs_sm_4_proto(f)						\
+void	__bs_c(f,_bs_sm_4) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int32_t value, bus_size_t count);
+
+#define	bs_sm_8_proto(f)						\
+void	__bs_c(f,_bs_sm_8) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int64_t value, bus_size_t count);
+
+#define	bs_sr_1_proto(f)						\
+void	__bs_c(f,_bs_sr_1) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int8_t value, bus_size_t count);
+
+#define	bs_sr_2_proto(f)						\
+void	__bs_c(f,_bs_sr_2) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int16_t value, bus_size_t count);
+
+#define	bs_sr_4_proto(f)						\
+void	__bs_c(f,_bs_sr_4) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int32_t value, bus_size_t count);
+
+#define	bs_sr_8_proto(f)						\
+void	__bs_c(f,_bs_sr_8) (void *t, bus_space_handle_t bsh,	\
+	    bus_size_t offset, u_int64_t value, bus_size_t count);
+
+#define	bs_c_1_proto(f)							\
+void	__bs_c(f,_bs_c_1) (void *t, bus_space_handle_t bsh1,	\
+	    bus_size_t offset1, bus_space_handle_t bsh2,		\
+	    bus_size_t offset2, bus_size_t count);
+
+#define	bs_c_2_proto(f)							\
+void	__bs_c(f,_bs_c_2) (void *t, bus_space_handle_t bsh1,	\
+	    bus_size_t offset1, bus_space_handle_t bsh2,		\
+	    bus_size_t offset2, bus_size_t count);
+
+#define	bs_c_4_proto(f)							\
+void	__bs_c(f,_bs_c_4) (void *t, bus_space_handle_t bsh1,	\
+	    bus_size_t offset1, bus_space_handle_t bsh2,		\
+	    bus_size_t offset2, bus_size_t count);
+
+#define	bs_c_8_proto(f)							\
+void	__bs_c(f,_bs_c_8) (void *t, bus_space_handle_t bsh1,	\
+	    bus_size_t offset1, bus_space_handle_t bsh2,		\
+	    bus_size_t offset2, bus_size_t count);
+
+#define DECLARE_BUS_SPACE_PROTOTYPES(f)		\
+	bs_map_proto(f);			\
+	bs_unmap_proto(f);			\
+	bs_subregion_proto(f);			\
+	bs_alloc_proto(f);			\
+	bs_free_proto(f);			\
+	bs_barrier_proto(f);			\
+	bs_r_1_proto(f);			\
+	bs_r_2_proto(f);			\
+	bs_r_4_proto(f);			\
+	bs_r_8_proto(f);			\
+	bs_r_1_s_proto(f);			\
+	bs_r_2_s_proto(f);			\
+	bs_r_4_s_proto(f);			\
+	bs_w_1_proto(f);			\
+	bs_w_2_proto(f);			\
+	bs_w_4_proto(f);			\
+	bs_w_8_proto(f);			\
+	bs_w_1_s_proto(f);			\
+	bs_w_2_s_proto(f);			\
+	bs_w_4_s_proto(f);			\
+	bs_rm_1_proto(f);			\
+	bs_rm_2_proto(f);			\
+	bs_rm_4_proto(f);			\
+	bs_rm_8_proto(f);			\
+	bs_wm_1_proto(f);			\
+	bs_wm_2_proto(f);			\
+	bs_wm_4_proto(f);			\
+	bs_wm_8_proto(f);			\
+	bs_rr_1_proto(f);			\
+	bs_rr_2_proto(f);			\
+	bs_rr_4_proto(f);			\
+	bs_rr_8_proto(f);			\
+	bs_wr_1_proto(f);			\
+	bs_wr_2_proto(f);			\
+	bs_wr_4_proto(f);			\
+	bs_wr_8_proto(f);			\
+	bs_sm_1_proto(f);			\
+	bs_sm_2_proto(f);			\
+	bs_sm_4_proto(f);			\
+	bs_sm_8_proto(f);			\
+	bs_sr_1_proto(f);			\
+	bs_sr_2_proto(f);			\
+	bs_sr_4_proto(f);			\
+	bs_sr_8_proto(f);			\
+	bs_c_1_proto(f);			\
+	bs_c_2_proto(f);			\
+	bs_c_4_proto(f);			\
+	bs_c_8_proto(f);
+
+#define BUS_SPACE_ALIGNED_POINTER(p, t) ALIGNED_POINTER(p, t)
+
+#define BUS_SPACE_MAXADDR_24BIT	0xFFFFFF
+#define BUS_SPACE_MAXADDR_32BIT 0xFFFFFFFF
+#define BUS_SPACE_MAXADDR 	0xFFFFFFFF
+#define BUS_SPACE_MAXSIZE_24BIT	0xFFFFFF
+#define BUS_SPACE_MAXSIZE_32BIT	0xFFFFFFFF
+#define BUS_SPACE_MAXSIZE 	0xFFFFFFFF
 
-/*
- * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
- * to bus space described by tag/handle starting at `offset'.
+/* 
+ * declare generic bus space, it suits all needs in 
  */
-
-static __inline void bus_space_write_region_1(bus_space_tag_t tag,
-					      bus_space_handle_t bsh,
-					      bus_size_t offset,
-					      const u_int8_t *addr,
-					      size_t count);
-static __inline void bus_space_write_region_2(bus_space_tag_t tag,
-					      bus_space_handle_t bsh,
-					      bus_size_t offset,
-					      const u_int16_t *addr,
-					      size_t count);
-static __inline void bus_space_write_region_4(bus_space_tag_t tag,
-					      bus_space_handle_t bsh,
-					      bus_size_t offset,
-					      const u_int32_t *addr,
-					      size_t count);
-
-static __inline void
-bus_space_write_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, const u_int8_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--) {
-			outb(baddr, *addr++);
-			baddr += 1;
-		}
-	else
-		while (count--) {
-			writeb(baddr, *addr++);
-			baddr += 1;
-		}
-}
-
-static __inline void
-bus_space_write_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, const u_int16_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--) {
-			outw(baddr, *addr++);
-			baddr += 2;
-		}
-	else
-		while (count--) {
-			writew(baddr, *addr++);
-			baddr += 2;
-		}
-}
-
-static __inline void
-bus_space_write_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, const u_int32_t *addr, size_t count)
-{
-	bus_addr_t baddr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--) {
-			outl(baddr, *addr++);
-			baddr += 4;
-		}
-	else
-		while (count--) {
-			writel(baddr, *addr++);
-			baddr += 4;
-		}
-}
-
-#if 0	/* Cause a link error for bus_space_write_region_8 */
-#define	bus_space_write_region_8					\
-			!!! bus_space_write_region_8 unimplemented !!!
-#endif
-
-/*
- * Write the 1, 2, 4, or 8 byte value `val' to bus space described
- * by tag/handle/offset `count' times.
- */
-
-static __inline void bus_space_set_multi_1(bus_space_tag_t tag,
-					   bus_space_handle_t bsh,
-					   bus_size_t offset,
-					   u_int8_t value, size_t count);
-static __inline void bus_space_set_multi_2(bus_space_tag_t tag,
-					   bus_space_handle_t bsh,
-					   bus_size_t offset,
-					   u_int16_t value, size_t count);
-static __inline void bus_space_set_multi_4(bus_space_tag_t tag,
-					   bus_space_handle_t bsh,
-					   bus_size_t offset,
-					   u_int32_t value, size_t count);
-
-static __inline void
-bus_space_set_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int8_t value, size_t count)
-{
-	bus_addr_t addr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			outb(addr, value);
-	else
-		while (count--)
-			writeb(addr, value);
-}
-
-static __inline void
-bus_space_set_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int16_t value, size_t count)
-{
-	bus_addr_t addr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			outw(addr, value);
-	else
-		while (count--)
-			writew(addr, value);
-}
-
-static __inline void
-bus_space_set_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int32_t value, size_t count)
-{
-	bus_addr_t addr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		while (count--)
-			outl(addr, value);
-	else
-		while (count--)
-			writel(addr, value);
-}
-
-#if 0	/* Cause a link error for bus_space_set_multi_8 */
-#define	bus_space_set_multi_8 !!! bus_space_set_multi_8 unimplemented !!!
-#endif
-
-/*
- * Write `count' 1, 2, 4, or 8 byte value `val' to bus space described
- * by tag/handle starting at `offset'.
- */
-
-static __inline void bus_space_set_region_1(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int8_t value,
-					    size_t count);
-static __inline void bus_space_set_region_2(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int16_t value,
-					    size_t count);
-static __inline void bus_space_set_region_4(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int32_t value,
-					    size_t count);
-
-static __inline void
-bus_space_set_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int8_t value, size_t count)
-{
-	bus_addr_t addr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		for (; count != 0; count--, addr++)
-			outb(addr, value);
-	else
-		for (; count != 0; count--, addr++)
-			writeb(addr, value);
-}
-
-static __inline void
-bus_space_set_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int16_t value, size_t count)
-{
-	bus_addr_t addr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		for (; count != 0; count--, addr += 2)
-			outw(addr, value);
-	else
-		for (; count != 0; count--, addr += 2)
-			writew(addr, value);
-}
-
-static __inline void
-bus_space_set_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-    bus_size_t offset, u_int32_t value, size_t count)
-{
-	bus_addr_t addr = bsh + offset;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-		for (; count != 0; count--, addr += 4)
-			outl(addr, value);
-	else
-		for (; count != 0; count--, addr += 4)
-			writel(addr, value);
-}
-
-#if 0	/* Cause a link error for bus_space_set_region_8 */
-#define	bus_space_set_region_8	!!! bus_space_set_region_8 unimplemented !!!
-#endif
-
-/*
- * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
- * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
- */
-
-static __inline void bus_space_copy_region_1(bus_space_tag_t tag,
-					     bus_space_handle_t bsh1,
-					     bus_size_t off1,
-					     bus_space_handle_t bsh2,
-					     bus_size_t off2, size_t count);
-
-static __inline void bus_space_copy_region_2(bus_space_tag_t tag,
-					     bus_space_handle_t bsh1,
-					     bus_size_t off1,
-					     bus_space_handle_t bsh2,
-					     bus_size_t off2, size_t count);
-
-static __inline void bus_space_copy_region_4(bus_space_tag_t tag,
-					     bus_space_handle_t bsh1,
-					     bus_size_t off1,
-					     bus_space_handle_t bsh2,
-					     bus_size_t off2, size_t count);
-
-static __inline void
-bus_space_copy_region_1(bus_space_tag_t tag, bus_space_handle_t bsh1,
-    bus_size_t off1, bus_space_handle_t bsh2,
-    bus_size_t off2, size_t count)
-{
-	bus_addr_t addr1 = bsh1 + off1;
-	bus_addr_t addr2 = bsh2 + off2;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-	{
-		if (addr1 >= addr2) {
-			/* src after dest: copy forward */
-			for (; count != 0; count--, addr1++, addr2++)
-				outb(addr2, inb(addr1));
-		} else {
-			/* dest after src: copy backwards */
-			for (addr1 += (count - 1), addr2 += (count - 1);
-			    count != 0; count--, addr1--, addr2--)
-				outb(addr2, inb(addr1));
-		}
-	} else {
-		if (addr1 >= addr2) {
-			/* src after dest: copy forward */
-			for (; count != 0; count--, addr1++, addr2++)
-				writeb(addr2, readb(addr1));
-		} else {
-			/* dest after src: copy backwards */
-			for (addr1 += (count - 1), addr2 += (count - 1);
-			    count != 0; count--, addr1--, addr2--)
-				writeb(addr2, readb(addr1));
-		}
-	}
-}
-
-static __inline void
-bus_space_copy_region_2(bus_space_tag_t tag, bus_space_handle_t bsh1,
-    bus_size_t off1, bus_space_handle_t bsh2,
-    bus_size_t off2, size_t count)
-{
-	bus_addr_t addr1 = bsh1 + off1;
-	bus_addr_t addr2 = bsh2 + off2;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-	{
-		if (addr1 >= addr2) {
-			/* src after dest: copy forward */
-			for (; count != 0; count--, addr1 += 2, addr2 += 2)
-				outw(addr2, inw(addr1));
-		} else {
-			/* dest after src: copy backwards */
-			for (addr1 += 2 * (count - 1), addr2 += 2 * (count - 1);
-			    count != 0; count--, addr1 -= 2, addr2 -= 2)
-				outw(addr2, inw(addr1));
-		}
-	} else {
-		if (addr1 >= addr2) {
-			/* src after dest: copy forward */
-			for (; count != 0; count--, addr1 += 2, addr2 += 2)
-				writew(addr2, readw(addr1));
-		} else {
-			/* dest after src: copy backwards */
-			for (addr1 += 2 * (count - 1), addr2 += 2 * (count - 1);
-			    count != 0; count--, addr1 -= 2, addr2 -= 2)
-				writew(addr2, readw(addr1));
-		}
-	}
-}
-
-static __inline void
-bus_space_copy_region_4(bus_space_tag_t tag, bus_space_handle_t bsh1,
-    bus_size_t off1, bus_space_handle_t bsh2,
-    bus_size_t off2, size_t count)
-{
-	bus_addr_t addr1 = bsh1 + off1;
-	bus_addr_t addr2 = bsh2 + off2;
-
-	if (tag == MIPS_BUS_SPACE_IO)
-	{
-		if (addr1 >= addr2) {
-			/* src after dest: copy forward */
-			for (; count != 0; count--, addr1 += 4, addr2 += 4)
-				outl(addr2, inl(addr1));
-		} else {
-			/* dest after src: copy backwards */
-			for (addr1 += 4 * (count - 1), addr2 += 4 * (count - 1);
-			    count != 0; count--, addr1 -= 4, addr2 -= 4)
-				outl(addr2, inl(addr1));
-		}
-	} else {
-		if (addr1 >= addr2) {
-			/* src after dest: copy forward */
-			for (; count != 0; count--, addr1 += 4, addr2 += 4)
-				writel(addr2, readl(addr1));
-		} else {
-			/* dest after src: copy backwards */
-			for (addr1 += 4 * (count - 1), addr2 += 4 * (count - 1);
-			    count != 0; count--, addr1 -= 4, addr2 -= 4)
-				writel(addr2, readl(addr1));
-		}
-	}
-}
-
-
-#if 0	/* Cause a link error for bus_space_copy_8 */
-#define	bus_space_copy_region_8	!!! bus_space_copy_region_8 unimplemented !!!
-#endif
-
-
-/*
- * Bus read/write barrier methods.
- *
- *	void bus_space_barrier(bus_space_tag_t tag, bus_space_handle_t bsh,
- *			       bus_size_t offset, bus_size_t len, int flags);
- *
- *
- * Note that BUS_SPACE_BARRIER_WRITE doesn't do anything other than
- * prevent reordering by the compiler; all Intel x86 processors currently
- * retire operations outside the CPU in program order.
- */
-#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
-#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */
-
-static __inline void
-bus_space_barrier(bus_space_tag_t tag __unused, bus_space_handle_t bsh __unused,
-		  bus_size_t offset __unused, bus_size_t len __unused, int flags)
-{
-#if 0
-#ifdef __GNUCLIKE_ASM
-	if (flags & BUS_SPACE_BARRIER_READ)
-		__asm __volatile("lock; addl $0,0(%%rsp)" : : : "memory");
-	else
-		__asm __volatile("" : : : "memory");
-#endif
-#endif
-}
-
-#ifdef BUS_SPACE_NO_LEGACY
-#undef inb
-#undef outb
-#define inb(a) compiler_error
-#define inw(a) compiler_error
-#define inl(a) compiler_error
-#define outb(a, b) compiler_error
-#define outw(a, b) compiler_error
-#define outl(a, b) compiler_error
-#endif
-
+DECLARE_BUS_SPACE_PROTOTYPES(generic);
+extern bus_space_tag_t mips_bus_space_generic;
 #include <machine/bus_dma.h>
 
-/*
- * Stream accesses are the same as normal accesses on amd64; there are no
- * supported bus systems with an endianess different from the host one.
- */
-#define	bus_space_read_stream_1(t, h, o)	bus_space_read_1((t), (h), (o))
-#define	bus_space_read_stream_2(t, h, o)	bus_space_read_2((t), (h), (o))
-#define	bus_space_read_stream_4(t, h, o)	bus_space_read_4((t), (h), (o))
-
-#define	bus_space_read_multi_stream_1(t, h, o, a, c) \
-	bus_space_read_multi_1((t), (h), (o), (a), (c))
-#define	bus_space_read_multi_stream_2(t, h, o, a, c) \
-	bus_space_read_multi_2((t), (h), (o), (a), (c))
-#define	bus_space_read_multi_stream_4(t, h, o, a, c) \
-	bus_space_read_multi_4((t), (h), (o), (a), (c))
-
-#define	bus_space_write_stream_1(t, h, o, v) \
-	bus_space_write_1((t), (h), (o), (v))
-#define	bus_space_write_stream_2(t, h, o, v) \
-	bus_space_write_2((t), (h), (o), (v))
-#define	bus_space_write_stream_4(t, h, o, v) \
-	bus_space_write_4((t), (h), (o), (v))
-
-#define	bus_space_write_multi_stream_1(t, h, o, a, c) \
-	bus_space_write_multi_1((t), (h), (o), (a), (c))
-#define	bus_space_write_multi_stream_2(t, h, o, a, c) \
-	bus_space_write_multi_2((t), (h), (o), (a), (c))
-#define	bus_space_write_multi_stream_4(t, h, o, a, c) \
-	bus_space_write_multi_4((t), (h), (o), (a), (c))
-
-#define	bus_space_set_multi_stream_1(t, h, o, v, c) \
-	bus_space_set_multi_1((t), (h), (o), (v), (c))
-#define	bus_space_set_multi_stream_2(t, h, o, v, c) \
-	bus_space_set_multi_2((t), (h), (o), (v), (c))
-#define	bus_space_set_multi_stream_4(t, h, o, v, c) \
-	bus_space_set_multi_4((t), (h), (o), (v), (c))
-
-#define	bus_space_read_region_stream_1(t, h, o, a, c) \
-	bus_space_read_region_1((t), (h), (o), (a), (c))
-#define	bus_space_read_region_stream_2(t, h, o, a, c) \
-	bus_space_read_region_2((t), (h), (o), (a), (c))
-#define	bus_space_read_region_stream_4(t, h, o, a, c) \
-	bus_space_read_region_4((t), (h), (o), (a), (c))
-
-#define	bus_space_write_region_stream_1(t, h, o, a, c) \
-	bus_space_write_region_1((t), (h), (o), (a), (c))
-#define	bus_space_write_region_stream_2(t, h, o, a, c) \
-	bus_space_write_region_2((t), (h), (o), (a), (c))
-#define	bus_space_write_region_stream_4(t, h, o, a, c) \
-	bus_space_write_region_4((t), (h), (o), (a), (c))
-
-#define	bus_space_set_region_stream_1(t, h, o, v, c) \
-	bus_space_set_region_1((t), (h), (o), (v), (c))
-#define	bus_space_set_region_stream_2(t, h, o, v, c) \
-	bus_space_set_region_2((t), (h), (o), (v), (c))
-#define	bus_space_set_region_stream_4(t, h, o, v, c) \
-	bus_space_set_region_4((t), (h), (o), (v), (c))
-
-#define	bus_space_copy_region_stream_1(t, h1, o1, h2, o2, c) \
-	bus_space_copy_region_1((t), (h1), (o1), (h2), (o2), (c))
-#define	bus_space_copy_region_stream_2(t, h1, o1, h2, o2, c) \
-	bus_space_copy_region_2((t), (h1), (o1), (h2), (o2), (c))
-#define	bus_space_copy_region_stream_4(t, h1, o1, h2, o2, c) \
-	bus_space_copy_region_4((t), (h1), (o1), (h2), (o2), (c))
-
-#endif /* !TARGET_OCTEON */
-#endif /* !_MACHINE_BUS_H_ */
+#endif /* _MACHINE_BUS_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/bus_octeon.h svn/mips/sys/mips/include/bus_octeon.h
--- releng8/src/sys/mips/include/bus_octeon.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/bus_octeon.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,883 +0,0 @@
-/*-
- * Copyright (c) 2006 Oleksandr Tymoshenko.
- * Copyright (c) KATO Takenori, 1999.
- *
- * All rights reserved.  Unpublished rights reserved under the copyright
- * laws of Japan.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer as
- *    the first lines of this file unmodified.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $FreeBSD: src/sys/mips/include/bus_octeon.h,v 1.1.2.1 2009/08/03 08:13:06 kensmith Exp $
- */
-
-/*	$NetBSD: bus.h,v 1.12 1997/10/01 08:25:15 fvdl Exp $	*/
-
-/*-
- * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
- * NASA Ames Research Center.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the NetBSD
- *	Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*-
- * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
- * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *      This product includes software developed by Christopher G. Demetriou
- *	for the NetBSD Project.
- * 4. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _MIPS_BUS_OCTEON_H_
-#define _MIPS_BUS_OCTEON_H_
-
-#include "../../mips32/octeon32/octeon_pcmap_regs.h"
-#include <machine/_bus_octeon.h>
-#include <machine/cpufunc.h>
-
-/*
- * Values for the mips64 bus space tag, not to be used directly by MI code.
- */
-#define	MIPS_BUS_SPACE_IO	0	/* space is i/o space */
-#define MIPS_BUS_SPACE_MEM	1	/* space is mem space */
-
-#define BUS_SPACE_MAXSIZE_24BIT	0xFFFFFF
-#define BUS_SPACE_MAXSIZE_32BIT 0xFFFFFFFF
-#define BUS_SPACE_MAXSIZE	0xFFFFFFFF
-#define BUS_SPACE_MAXADDR_24BIT	0xFFFFFF
-#define BUS_SPACE_MAXADDR_32BIT 0xFFFFFFFF
-#define BUS_SPACE_MAXADDR	0xFFFFFFFF
-
-#define BUS_SPACE_UNRESTRICTED	(~0)
-
-/*
- * Map a region of device bus space into CPU virtual address space.
- */
-
-static __inline int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
-				  bus_size_t size, int flags,
-				  bus_space_handle_t *bshp);
-
-static __inline int
-bus_space_map(bus_space_tag_t t __unused, bus_addr_t addr,
-	      bus_size_t size __unused, int flags __unused,
-	      bus_space_handle_t *bshp)
-{
-
-	*bshp = addr;
-	return (0);
-}
-
-/*
- * Unmap a region of device bus space.
- */
-
-static __inline void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
-				     bus_size_t size);
-
-static __inline void
-bus_space_unmap(bus_space_tag_t t __unused, bus_space_handle_t bsh __unused,
-		bus_size_t size __unused)
-{
-}
-
-/*
- * Get a new handle for a subregion of an already-mapped area of bus space.
- */
-
-static __inline int bus_space_subregion(bus_space_tag_t t,
-					bus_space_handle_t bsh,
-					bus_size_t offset, bus_size_t size,
-					bus_space_handle_t *nbshp);
-
-static __inline int
-bus_space_subregion(bus_space_tag_t t __unused, bus_space_handle_t bsh,
-		    bus_size_t offset, bus_size_t size __unused,
-		    bus_space_handle_t *nbshp)
-{
-	*nbshp = bsh + offset;
-	return (0);
-}
-
-/*
- * Allocate a region of memory that is accessible to devices in bus space.
- */
-
-int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
-			bus_addr_t rend, bus_size_t size, bus_size_t align,
-			bus_size_t boundary, int flags, bus_addr_t *addrp,
-			bus_space_handle_t *bshp);
-
-/*
- * Free a region of bus space accessible memory.
- */
-
-static __inline void bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
-				    bus_size_t size);
-
-static __inline void
-bus_space_free(bus_space_tag_t t __unused, bus_space_handle_t bsh __unused,
-	       bus_size_t size __unused)
-{
-}
-
-
-/*
- * Read a 1, 2, 4, or 8 byte quantity from bus space
- * described by tag/handle/offset.
- */
-static __inline u_int8_t bus_space_read_1(bus_space_tag_t tag,
-					  bus_space_handle_t handle,
-					  bus_size_t offset);
-
-static __inline u_int16_t bus_space_read_2(bus_space_tag_t tag,
-					   bus_space_handle_t handle,
-					   bus_size_t offset);
-
-static __inline u_int32_t bus_space_read_4(bus_space_tag_t tag,
-					   bus_space_handle_t handle,
-					   bus_size_t offset);
-
-static __inline u_int8_t
-bus_space_read_1(bus_space_tag_t tag, bus_space_handle_t handle,
-		 bus_size_t offset)
-{
-    	uint64_t ret_val;
-        uint64_t oct64_addr;
-
-        oct64_addr = handle + offset;
-        ret_val = oct_read8(oct64_addr);
-    	return ((u_int8_t) ret_val);
-}
-
-static __inline u_int16_t
-bus_space_read_2(bus_space_tag_t tag, bus_space_handle_t handle,
-		 bus_size_t offset)
-{
-    	uint64_t ret_val;
-        uint64_t oct64_addr;
-
-        oct64_addr = handle + offset;
-        ret_val = oct_read16(oct64_addr);
-    	return ((u_int16_t) ret_val);
-}
-
-static __inline u_int32_t
-bus_space_read_4(bus_space_tag_t tag, bus_space_handle_t handle,
-		 bus_size_t offset)
-{
-    	uint64_t ret_val;
-        uint64_t oct64_addr;
-
-        oct64_addr = handle + offset;
-        ret_val = oct_read32(oct64_addr);
-    	return ((u_int32_t) ret_val);
-}
-
-
-static __inline u_int64_t
-bus_space_read_8(bus_space_tag_t tag, bus_space_handle_t handle,
-		 bus_size_t offset)
-{
-    	uint64_t ret_val;
-        uint64_t oct64_addr;
-
-        oct64_addr = handle + offset;
-        ret_val = oct_read64(oct64_addr);
-    	return (ret_val);
-}
-
-
-/*
- * Read `count' 1, 2, 4, or 8 byte quantities from bus space
- * described by tag/handle/offset and copy into buffer provided.
- */
-static __inline void bus_space_read_region_1(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int8_t *addr,
-					    size_t count);
-
-static __inline void bus_space_read_region_2(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int16_t *addr,
-					    size_t count);
-
-static __inline void bus_space_read_region_4(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int32_t *addr,
-					    size_t count);
-
-static __inline void
-bus_space_read_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int8_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++, ptr++) {
-		*addr = oct_read8(ptr);
-	}
-}
-
-static __inline void
-bus_space_read_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int16_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++, ptr+=2) {
-		*addr = oct_read16(ptr);
-	}
-}
-
-static __inline void
-bus_space_read_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int32_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++, ptr+=4) {
-		*addr = oct_read32(ptr);
-	}
-}
-
-static __inline void
-bus_space_read_region_8(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int64_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++, ptr+=4) {
-		*addr = oct_read64(ptr);
-	}
-}
-
-/*
- * Read `count' 1, 2, 4, or 8 byte quantities from bus space
- * described by tag/handle and starting at `offset' and copy into
- * buffer provided.
- */
-static __inline void bus_space_read_multi_1(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset, u_int8_t *addr,
-					     size_t count);
-
-static __inline void bus_space_read_multi_2(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset, u_int16_t *addr,
-					     size_t count);
-
-static __inline void bus_space_read_multi_4(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset, u_int32_t *addr,
-					     size_t count);
-
-
-static __inline void
-bus_space_read_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-			bus_size_t offset, u_int8_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++) {
-		*addr = oct_read8(ptr);
-	}
-}
-
-static __inline void
-bus_space_read_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-			bus_size_t offset, u_int16_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++) {
-		*addr = oct_read16(ptr);
-	}
-}
-
-static __inline void
-bus_space_read_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-			bus_size_t offset, u_int32_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++) {
-		*addr = oct_read32(ptr);
-	}
-}
-
-static __inline void
-bus_space_read_multi_8(bus_space_tag_t tag, bus_space_handle_t bsh,
-			bus_size_t offset, u_int64_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++) {
-		*addr = oct_read64(ptr);
-	}
-}
-
-
-/*
- * Write the 1, 2, 4, or 8 byte value `value' to bus space
- * described by tag/handle/offset.
- */
-
-static __inline void bus_space_write_1(bus_space_tag_t tag,
-				       bus_space_handle_t bsh,
-				       bus_size_t offset, u_int8_t value);
-
-static __inline void bus_space_write_2(bus_space_tag_t tag,
-				       bus_space_handle_t bsh,
-				       bus_size_t offset, u_int16_t value);
-
-static __inline void bus_space_write_4(bus_space_tag_t tag,
-				       bus_space_handle_t bsh,
-				       bus_size_t offset, u_int32_t value);
-
-static __inline void
-bus_space_write_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int8_t value)
-{
-      oct_write8(bsh+offset, value);
-}
-
-static __inline void
-bus_space_write_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int16_t value)
-{
-        oct_write16(bsh+offset, value);
-}
-
-static __inline void
-bus_space_write_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int32_t value)
-{
-        oct_write32(bsh+offset, value);
-}
-
-static __inline void
-bus_space_write_8(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int64_t value)
-{
-        oct_write64(bsh+offset, value);
-}
-
-/*
- * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
- * provided to bus space described by tag/handle/offset.
- */
-
-static __inline void bus_space_write_region_1(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset,
-					     const u_int8_t *addr,
-					     size_t count);
-static __inline void bus_space_write_region_2(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset,
-					     const u_int16_t *addr,
-					     size_t count);
-
-static __inline void bus_space_write_region_4(bus_space_tag_t tag,
-					     bus_space_handle_t bsh,
-					     bus_size_t offset,
-					     const u_int32_t *addr,
-					     size_t count);
-
-static __inline void
-bus_space_write_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-			bus_size_t offset, const u_int8_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++, ptr++) {
-            	oct_write8(ptr, *addr);
-	}
-}
-
-static __inline void
-bus_space_write_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-			bus_size_t offset, const u_int16_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++, ptr++) {
-            	oct_write16(ptr, *addr);
-	}
-}
-
-static __inline void
-bus_space_write_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-			bus_size_t offset, const u_int32_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++, ptr++) {
-            	oct_write32(ptr, *addr);
-	}
-}
-
-static __inline void
-bus_space_write_region_8(bus_space_tag_t tag, bus_space_handle_t bsh,
-			bus_size_t offset, const u_int64_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++, ptr++) {
-            	oct_write64(ptr, *addr);
-	}
-}
-
-/*
- * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
- * to bus space described by tag/handle starting at `offset'.
- */
-
-static __inline void bus_space_write_multi_1(bus_space_tag_t tag,
-					      bus_space_handle_t bsh,
-					      bus_size_t offset,
-					      const u_int8_t *addr,
-					      size_t count);
-static __inline void bus_space_write_multi_2(bus_space_tag_t tag,
-					      bus_space_handle_t bsh,
-					      bus_size_t offset,
-					      const u_int16_t *addr,
-					      size_t count);
-static __inline void bus_space_write_multi_4(bus_space_tag_t tag,
-					      bus_space_handle_t bsh,
-					      bus_size_t offset,
-					      const u_int32_t *addr,
-					      size_t count);
-
-static __inline void
-bus_space_write_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-			 bus_size_t offset, const u_int8_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++) {
-            	oct_write8(ptr, *addr);
-	}
-}
-
-static __inline void
-bus_space_write_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-			 bus_size_t offset, const u_int16_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++) {
-            	oct_write16(ptr, *addr);
-	}
-}
-
-static __inline void
-bus_space_write_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-			 bus_size_t offset, const u_int32_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++) {
-            	oct_write32(ptr, *addr);
-	}
-}
-
-static __inline void
-bus_space_write_multi_8(bus_space_tag_t tag, bus_space_handle_t bsh,
-			 bus_size_t offset, const u_int64_t *addr, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, addr++) {
-            	oct_write64(ptr, *addr);
-	}
-}
-
-/*
- * Write the 1, 2, 4, or 8 byte value `val' to bus space described
- * by tag/handle/offset `count' times.
- */
-
-static __inline void bus_space_set_multi_1(bus_space_tag_t tag,
-					   bus_space_handle_t bsh,
-					   bus_size_t offset,
-					   u_int8_t value, size_t count);
-static __inline void bus_space_set_multi_2(bus_space_tag_t tag,
-					   bus_space_handle_t bsh,
-					   bus_size_t offset,
-					   u_int16_t value, size_t count);
-static __inline void bus_space_set_multi_4(bus_space_tag_t tag,
-					   bus_space_handle_t bsh,
-					   bus_size_t offset,
-					   u_int32_t value, size_t count);
-
-static __inline void
-bus_space_set_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-		      bus_size_t offset, u_int8_t value, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--) {
-            	oct_write8(ptr, value);
-	}
-}
-
-static __inline void
-bus_space_set_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-		     bus_size_t offset, u_int16_t value, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--) {
-            	oct_write16(ptr, value);
-	}
-}
-
-static __inline void
-bus_space_set_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-		      bus_size_t offset, u_int32_t value, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--) {
-            	oct_write32(ptr, value);
-	}
-}
-
-static __inline void
-bus_space_set_multi_8(bus_space_tag_t tag, bus_space_handle_t bsh,
-		      bus_size_t offset, u_int64_t value, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--) {
-            	oct_write64(ptr, value);
-	}
-}
-
-/*
- * Write `count' 1, 2, 4, or 8 byte value `val' to bus space described
- * by tag/handle starting at `offset'.
- */
-
-static __inline void bus_space_set_region_1(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int8_t value,
-					    size_t count);
-static __inline void bus_space_set_region_2(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int16_t value,
-					    size_t count);
-static __inline void bus_space_set_region_4(bus_space_tag_t tag,
-					    bus_space_handle_t bsh,
-					    bus_size_t offset, u_int32_t value,
-					    size_t count);
-
-static __inline void
-bus_space_set_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int8_t value, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, ptr++) {
-		oct_write8(ptr, value);
-	}
-}
-
-static __inline void
-bus_space_set_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int16_t value, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, ptr++) {
-		oct_write16(ptr, value);
-	}
-}
-
-static __inline void
-bus_space_set_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int32_t value, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, ptr++) {
-		oct_write32(ptr, value);
-	}
-}
-
-static __inline void
-bus_space_set_region_8(bus_space_tag_t tag, bus_space_handle_t bsh,
-		       bus_size_t offset, u_int64_t value, size_t count)
-{
-	uint64_t ptr = ((uint64_t) bsh + (uint64_t) offset);
-
-	for(; count > 0; count--, ptr++) {
-		oct_write64(ptr, value);
-	}
-}
-
-/*
- * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
- * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
- */
-
-static __inline void bus_space_copy_region_1(bus_space_tag_t tag,
-					     bus_space_handle_t bsh1,
-					     bus_size_t off1,
-					     bus_space_handle_t bsh2,
-					     bus_size_t off2, size_t count);
-
-static __inline void bus_space_copy_region_2(bus_space_tag_t tag,
-					     bus_space_handle_t bsh1,
-					     bus_size_t off1,
-					     bus_space_handle_t bsh2,
-					     bus_size_t off2, size_t count);
-
-static __inline void bus_space_copy_region_4(bus_space_tag_t tag,
-					     bus_space_handle_t bsh1,
-					     bus_size_t off1,
-					     bus_space_handle_t bsh2,
-					     bus_size_t off2, size_t count);
-
-static __inline void
-bus_space_copy_region_1(bus_space_tag_t tag, bus_space_handle_t bsh1,
-			bus_size_t off1, bus_space_handle_t bsh2,
-			bus_size_t off2, size_t count)
-{
-	uint64_t ptr1 = ((uint64_t) bsh1 + (uint64_t) off1);
-	uint64_t ptr2 = ((uint64_t) bsh2 + (uint64_t) off2);
-        uint8_t val;
-
-	for(; count > 0; count--, ptr1++, ptr2++) {
-            	val = oct_read8(ptr1);
-            	oct_write8(ptr2, val);
-	}
-}
-
-static __inline void
-bus_space_copy_region_2(bus_space_tag_t tag, bus_space_handle_t bsh1,
-			bus_size_t off1, bus_space_handle_t bsh2,
-			bus_size_t off2, size_t count)
-{
-	uint64_t ptr1 = ((uint64_t) bsh1 + (uint64_t) off1);
-	uint64_t ptr2 = ((uint64_t) bsh2 + (uint64_t) off2);
-        uint16_t val;
-
-	for(; count > 0; count--, ptr1++, ptr2++) {
-            	val = oct_read16(ptr1);
-            	oct_write16(ptr2, val);
-	}
-}
-
-static __inline void
-bus_space_copy_region_4(bus_space_tag_t tag, bus_space_handle_t bsh1,
-			bus_size_t off1, bus_space_handle_t bsh2,
-			bus_size_t off2, size_t count)
-{
-	uint64_t ptr1 = ((uint64_t) bsh1 + (uint64_t) off1);
-	uint64_t ptr2 = ((uint64_t) bsh2 + (uint64_t) off2);
-        uint32_t val;
-
-	for(; count > 0; count--, ptr1++, ptr2++) {
-            	val = oct_read32(ptr1);
-            	oct_write32(ptr2, val);
-	}
-}
-
-static __inline void
-bus_space_copy_region_8(bus_space_tag_t tag, bus_space_handle_t bsh1,
-			bus_size_t off1, bus_space_handle_t bsh2,
-			bus_size_t off2, size_t count)
-{
-	uint64_t ptr1 = ((uint64_t) bsh1 + (uint64_t) off1);
-	uint64_t ptr2 = ((uint64_t) bsh2 + (uint64_t) off2);
-        uint64_t val;
-
-	for(; count > 0; count--, ptr1++, ptr2++) {
-            	val = oct_read64(ptr1);
-            	oct_write64(ptr2, val);
-	}
-}
-
-/*
- * Bus read/write barrier methods.
- *
- *	void bus_space_barrier(bus_space_tag_t tag, bus_space_handle_t bsh,
- *			       bus_size_t offset, bus_size_t len, int flags);
- *
- *
- * Note that BUS_SPACE_BARRIER_WRITE doesn't do anything other than
- * prevent reordering by the compiler; all Intel x86 processors currently
- * retire operations outside the CPU in program order.
- */
-#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
-#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */
-
-static __inline void
-bus_space_barrier(bus_space_tag_t tag __unused, bus_space_handle_t bsh __unused,
-		  bus_size_t offset __unused, bus_size_t len __unused, int flags)
-{
-#if 0
-#ifdef __GNUCLIKE_ASM
-	if (flags & BUS_SPACE_BARRIER_READ)
-		__asm __volatile("lock; addl $0,0(%%rsp)" : : : "memory");
-	else
-		__asm __volatile("" : : : "memory");
-#endif
-#endif
-    oct_read64(OCTEON_MIO_BOOT_BIST_STAT);
-}
-
-#ifdef BUS_SPACE_NO_LEGACY
-#undef inb
-#undef outb
-#define inb(a) compiler_error
-#define inw(a) compiler_error
-#define inl(a) compiler_error
-#define outb(a, b) compiler_error
-#define outw(a, b) compiler_error
-#define outl(a, b) compiler_error
-#endif
-
-#include <machine/bus_dma.h>
-
-/*
- * Stream accesses are the same as normal accesses on amd64; there are no
- * supported bus systems with an endianess different from the host one.
- */
-#define	bus_space_read_stream_1(t, h, o)	bus_space_read_1((t), (h), (o))
-#define	bus_space_read_stream_2(t, h, o)	bus_space_read_2((t), (h), (o))
-#define	bus_space_read_stream_4(t, h, o)	bus_space_read_4((t), (h), (o))
-
-#define	bus_space_read_multi_stream_1(t, h, o, a, c) \
-	bus_space_read_multi_1((t), (h), (o), (a), (c))
-#define	bus_space_read_multi_stream_2(t, h, o, a, c) \
-	bus_space_read_multi_2((t), (h), (o), (a), (c))
-#define	bus_space_read_multi_stream_4(t, h, o, a, c) \
-	bus_space_read_multi_4((t), (h), (o), (a), (c))
-
-#define	bus_space_write_stream_1(t, h, o, v) \
-	bus_space_write_1((t), (h), (o), (v))
-#define	bus_space_write_stream_2(t, h, o, v) \
-	bus_space_write_2((t), (h), (o), (v))
-#define	bus_space_write_stream_4(t, h, o, v) \
-	bus_space_write_4((t), (h), (o), (v))
-
-#define	bus_space_write_multi_stream_1(t, h, o, a, c) \
-	bus_space_write_multi_1((t), (h), (o), (a), (c))
-#define	bus_space_write_multi_stream_2(t, h, o, a, c) \
-	bus_space_write_multi_2((t), (h), (o), (a), (c))
-#define	bus_space_write_multi_stream_4(t, h, o, a, c) \
-	bus_space_write_multi_4((t), (h), (o), (a), (c))
-
-#define	bus_space_set_multi_stream_1(t, h, o, v, c) \
-	bus_space_set_multi_1((t), (h), (o), (v), (c))
-#define	bus_space_set_multi_stream_2(t, h, o, v, c) \
-	bus_space_set_multi_2((t), (h), (o), (v), (c))
-#define	bus_space_set_multi_stream_4(t, h, o, v, c) \
-	bus_space_set_multi_4((t), (h), (o), (v), (c))
-
-#define	bus_space_read_region_stream_1(t, h, o, a, c) \
-	bus_space_read_region_1((t), (h), (o), (a), (c))
-#define	bus_space_read_region_stream_2(t, h, o, a, c) \
-	bus_space_read_region_2((t), (h), (o), (a), (c))
-#define	bus_space_read_region_stream_4(t, h, o, a, c) \
-	bus_space_read_region_4((t), (h), (o), (a), (c))
-
-#define	bus_space_write_region_stream_1(t, h, o, a, c) \
-	bus_space_write_region_1((t), (h), (o), (a), (c))
-#define	bus_space_write_region_stream_2(t, h, o, a, c) \
-	bus_space_write_region_2((t), (h), (o), (a), (c))
-#define	bus_space_write_region_stream_4(t, h, o, a, c) \
-	bus_space_write_region_4((t), (h), (o), (a), (c))
-
-#define	bus_space_set_region_stream_1(t, h, o, v, c) \
-	bus_space_set_region_1((t), (h), (o), (v), (c))
-#define	bus_space_set_region_stream_2(t, h, o, v, c) \
-	bus_space_set_region_2((t), (h), (o), (v), (c))
-#define	bus_space_set_region_stream_4(t, h, o, v, c) \
-	bus_space_set_region_4((t), (h), (o), (v), (c))
-
-#define	bus_space_copy_region_stream_1(t, h1, o1, h2, o2, c) \
-	bus_space_copy_region_1((t), (h1), (o1), (h2), (o2), (c))
-#define	bus_space_copy_region_stream_2(t, h1, o1, h2, o2, c) \
-	bus_space_copy_region_2((t), (h1), (o1), (h2), (o2), (c))
-#define	bus_space_copy_region_stream_4(t, h1, o1, h2, o2, c) \
-	bus_space_copy_region_4((t), (h1), (o1), (h2), (o2), (c))
-
-#endif /* _MIPS_BUS_OCTEON_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/cache.h svn/mips/sys/mips/include/cache.h
--- releng8/src/sys/mips/include/cache.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/cache.h	2009-07-02 18:44:22.000000000 -0700
@@ -34,9 +34,12 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/mips/include/cache.h,v 1.1.2.1 2009/08/03 08:13:06 kensmith Exp $
+ * $FreeBSD: projects/mips/sys/mips/include/cache.h 195076 2009-06-26 19:54:06Z gonzo $
  */
 
+#ifndef	_MACHINE_CACHE_H_
+#define	_MACHINE_CACHE_H_
+
 /*
  * Cache operations.
  *
@@ -259,3 +262,4 @@
 void    mips_dcache_compute_align(void);
 
 #include <machine/cache_mipsNN.h>
+#endif	/* _MACHINE_CACHE_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/cache_mipsNN.h svn/mips/sys/mips/include/cache_mipsNN.h
--- releng8/src/sys/mips/include/cache_mipsNN.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/cache_mipsNN.h	2009-07-02 18:44:22.000000000 -0700
@@ -34,8 +34,10 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/mips/include/cache_mipsNN.h,v 1.1.2.1 2009/08/03 08:13:06 kensmith Exp $
+ * $FreeBSD: projects/mips/sys/mips/include/cache_mipsNN.h 195076 2009-06-26 19:54:06Z gonzo $
  */
+#ifndef	_MACHINE_CACHE_MIPSNN_H_
+#define	_MACHINE_CACHE_MIPSNN_H_
 
 void	mipsNN_cache_init(struct mips_cpuinfo *);
 
@@ -65,3 +67,5 @@
 void	mipsNN_pdcache_inv_range_128(vm_offset_t, vm_size_t);
 void	mipsNN_pdcache_wb_range_128(vm_offset_t, vm_size_t);
 #endif
+
+#endif	/* _MACHINE_CACHE_MIPSNN_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/cdefs.h svn/mips/sys/mips/include/cdefs.h
--- releng8/src/sys/mips/include/cdefs.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/include/cdefs.h	2009-08-04 10:46:58.000000000 -0700
@@ -0,0 +1,54 @@
+/*	$NetBSD: cdefs.h,v 1.12 2006/08/27 19:04:30 matt Exp $	*/
+
+/*
+ * Copyright (c) 1995 Carnegie-Mellon University.
+ * All rights reserved.
+ *
+ * Author: Chris G. Demetriou
+ *
+ * Permission to use, copy, modify and distribute this software and
+ * its documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ *
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
+ * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ *
+ * Carnegie Mellon requests users of this software to return to
+ *
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ *
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#ifndef _MIPS_CDEFS_H_
+#define	_MIPS_CDEFS_H_
+
+/*      MIPS Subprogram Interface Model */
+#define _MIPS_SIM_ABIX32	4	/* 64 bit safe, ILP32 o32 model */
+#define _MIPS_SIM_ABI64		3
+#define _MIPS_SIM_NABI32	2	/* 64bit safe, ILP32 n32 model */
+#define _MIPS_SIM_ABI32		1
+
+#define _MIPS_BSD_API_LP32	_MIPS_SIM_ABI32
+#define	_MIPS_BSD_API_LP32_64CLEAN	_MIPS_SIM_ABIX32
+#define	_MIPS_BSD_API_N32	_MIPS_SIM_NABI32
+#define	_MIPS_BSD_API_LP64	_MIPS_SIM_ABI64
+
+#if defined(__mips_n64)
+#define	_MIPS_BSD_API		_MIPS_BSD_API_LP64
+#elif defined(__mips_n32)
+#define	_MIPS_BSD_API		_MIPS_BSD_API_N32
+#elif defined(__mips_o64)
+#define	_MIPS_BSD_API		_MIPS_BSD_API_LP32_64CLEAN
+#else
+#define	_MIPS_BSD_API		_MIPS_BSD_API_LP32
+#endif
+
+#endif /* !_MIPS_CDEFS_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/cpu.h svn/mips/sys/mips/include/cpu.h
--- releng8/src/sys/mips/include/cpu.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/cpu.h	2009-08-04 10:46:58.000000000 -0700
@@ -56,21 +56,30 @@
 #define	MIPS_RESERVED_ADDR		0xbfc80000
 
 #define MIPS_KSEG0_LARGEST_PHYS         0x20000000
-#define	MIPS_CACHED_TO_PHYS(x)		((unsigned)(x) & 0x1fffffff)
-#define	MIPS_PHYS_TO_CACHED(x)		((unsigned)(x) | MIPS_CACHED_MEMORY_ADDR)
-#define	MIPS_UNCACHED_TO_PHYS(x)	((unsigned)(x) & 0x1fffffff)
-#define	MIPS_PHYS_TO_UNCACHED(x)	((unsigned)(x) | MIPS_UNCACHED_MEMORY_ADDR)
+#define	MIPS_CACHED_TO_PHYS(x)		((uintptr_t)(x) & 0x1fffffff)
+#define	MIPS_PHYS_TO_CACHED(x)		((uintptr_t)(x) | MIPS_CACHED_MEMORY_ADDR)
+#define	MIPS_UNCACHED_TO_PHYS(x)	((uintptr_t)(x) & 0x1fffffff)
+#define	MIPS_PHYS_TO_UNCACHED(x)	((uintptr_t)(x) | MIPS_UNCACHED_MEMORY_ADDR)
 
 #define	MIPS_PHYS_MASK			(0x1fffffff)
 #define	MIPS_PA_2_K1VA(x)		(MIPS_KSEG1_START | ((x) & MIPS_PHYS_MASK))
 
-#define	MIPS_VA_TO_CINDEX(x)		((unsigned)(x) & 0xffffff | MIPS_CACHED_MEMORY_ADDR)
+#define	MIPS_VA_TO_CINDEX(x)		((uintptr_t)(x) & 0xffffff | MIPS_CACHED_MEMORY_ADDR)
 #define	MIPS_CACHED_TO_UNCACHED(x)	(MIPS_PHYS_TO_UNCACHED(MIPS_CACHED_TO_PHYS(x)))
 
-#define	MIPS_PHYS_TO_KSEG0(x)		((unsigned)(x) | MIPS_KSEG0_START)
-#define	MIPS_PHYS_TO_KSEG1(x)		((unsigned)(x) | MIPS_KSEG1_START)
-#define	MIPS_KSEG0_TO_PHYS(x)		((unsigned)(x) & MIPS_PHYS_MASK)
-#define	MIPS_KSEG1_TO_PHYS(x)		((unsigned)(x) & MIPS_PHYS_MASK)
+#define	MIPS_PHYS_TO_KSEG0(x)		((uintptr_t)(x) | MIPS_KSEG0_START)
+#define	MIPS_PHYS_TO_KSEG1(x)		((uintptr_t)(x) | MIPS_KSEG1_START)
+#define	MIPS_KSEG0_TO_PHYS(x)		((uintptr_t)(x) & MIPS_PHYS_MASK)
+#define	MIPS_KSEG1_TO_PHYS(x)		((uintptr_t)(x) & MIPS_PHYS_MASK)
+
+#define	MIPS_IS_KSEG0_ADDR(x)					\
+	(((vm_offset_t)(x) >= MIPS_KSEG0_START) &&		\
+	    ((vm_offset_t)(x) <= MIPS_KSEG0_END))
+#define	MIPS_IS_KSEG1_ADDR(x)					\
+	(((vm_offset_t)(x) >= MIPS_KSEG1_START) &&		\
+	    ((vm_offset_t)(x) <= MIPS_KSEG1_END))
+#define	MIPS_IS_VALID_PTR(x)		(MIPS_IS_KSEG0_ADDR(x) || \
+						MIPS_IS_KSEG1_ADDR(x))
 
 /*
  *  Status register.
@@ -154,7 +163,11 @@
  * The bits in the CONFIG register
  */
 #define CFG_K0_UNCACHED	2
+#if defined(CPU_SB1)
+#define CFG_K0_COHERENT	5	/* cacheable coherent */
+#else
 #define	CFG_K0_CACHED	3
+#endif
 
 /*
  * The bits in the context register.
diff -I '.*' -Naur releng8/sys/mips/include/cpufunc.h svn/mips/sys/mips/include/cpufunc.h
--- releng8/src/sys/mips/include/cpufunc.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/cpufunc.h	2009-05-06 14:57:15.000000000 -0700
@@ -183,6 +183,28 @@
 	mips_barrier();						\
 } struct __hack
 
+#define	MIPS_RDRW32_COP0_SEL(n,r,s)					\
+static __inline uint32_t					\
+mips_rd_ ## n ## s(void)						\
+{								\
+	int v0;							\
+	__asm __volatile ("mfc0 %[v0], $"__XSTRING(r)", "__XSTRING(s)";"	\
+			  : [v0] "=&r"(v0));			\
+	mips_barrier();						\
+	return (v0);						\
+}								\
+static __inline void						\
+mips_wr_ ## n ## s(uint32_t a0)					\
+{								\
+	__asm __volatile ("mtc0 %[a0], $"__XSTRING(r)", "__XSTRING(s)";"	\
+			 __XSTRING(COP0_SYNC)";"		\
+			 "nop;"					\
+			 "nop;"					\
+			 :					\
+			 : [a0] "r"(a0));			\
+	mips_barrier();						\
+} struct __hack
+
 #ifdef TARGET_OCTEON
 static __inline void mips_sync_icache (void)
 {
@@ -197,6 +219,9 @@
 
 MIPS_RDRW32_COP0(compare, MIPS_COP_0_COMPARE);
 MIPS_RDRW32_COP0(config, MIPS_COP_0_CONFIG);
+MIPS_RDRW32_COP0_SEL(config, MIPS_COP_0_CONFIG, 1);
+MIPS_RDRW32_COP0_SEL(config, MIPS_COP_0_CONFIG, 2);
+MIPS_RDRW32_COP0_SEL(config, MIPS_COP_0_CONFIG, 3);
 MIPS_RDRW32_COP0(count, MIPS_COP_0_COUNT);
 MIPS_RDRW32_COP0(index, MIPS_COP_0_TLB_INDEX);
 MIPS_RDRW32_COP0(wired, MIPS_COP_0_TLB_WIRED);
@@ -211,18 +236,13 @@
 MIPS_RDRW32_COP0(pagemask, MIPS_COP_0_TLB_PG_MASK);
 MIPS_RDRW32_COP0(prid, MIPS_COP_0_PRID);
 MIPS_RDRW32_COP0(watchlo, MIPS_COP_0_WATCH_LO);
+MIPS_RDRW32_COP0_SEL(watchlo, MIPS_COP_0_WATCH_LO, 1);
+MIPS_RDRW32_COP0_SEL(watchlo, MIPS_COP_0_WATCH_LO, 2);
+MIPS_RDRW32_COP0_SEL(watchlo, MIPS_COP_0_WATCH_LO, 3);
 MIPS_RDRW32_COP0(watchhi, MIPS_COP_0_WATCH_HI);
-
-static __inline uint32_t
-mips_rd_config_sel1(void)
-{
-	int v0;
-	__asm __volatile("mfc0 %[v0], $16, 1 ;"
-			 : [v0] "=&r" (v0));
-	mips_barrier();
-	return (v0);
-}
-
+MIPS_RDRW32_COP0_SEL(watchhi, MIPS_COP_0_WATCH_HI, 1);
+MIPS_RDRW32_COP0_SEL(watchhi, MIPS_COP_0_WATCH_HI, 2);
+MIPS_RDRW32_COP0_SEL(watchhi, MIPS_COP_0_WATCH_HI, 3);
 #undef	MIPS_RDRW32_COP0
 
 static __inline register_t
diff -I '.*' -Naur releng8/sys/mips/include/cpuinfo.h svn/mips/sys/mips/include/cpuinfo.h
--- releng8/src/sys/mips/include/cpuinfo.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/cpuinfo.h	2009-09-08 11:01:49.000000000 -0700
@@ -57,11 +57,11 @@
 	u_int16_t	tlb_nentries;
 	u_int8_t	icache_virtual;
 	struct {
-		u_int8_t	ic_size;
+		u_int32_t	ic_size;
 		u_int8_t	ic_linesize;
 		u_int8_t	ic_nways;
 		u_int16_t	ic_nsets;
-		u_int8_t	dc_size;
+		u_int32_t	dc_size;
 		u_int8_t	dc_linesize;
 		u_int8_t	dc_nways;
 		u_int16_t	dc_nsets;
diff -I '.*' -Naur releng8/sys/mips/include/cpuregs.h svn/mips/sys/mips/include/cpuregs.h
--- releng8/src/sys/mips/include/cpuregs.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/cpuregs.h	2009-08-04 10:46:58.000000000 -0700
@@ -103,6 +103,8 @@
 /* CPU dependent mtc0 hazard hook */
 #ifdef TARGET_OCTEON
 #define	COP0_SYNC  nop; nop; nop; nop; nop;
+#elif defined(CPU_SB1)
+#define COP0_SYNC  ssnop; ssnop; ssnop; ssnop; ssnop; ssnop; ssnop; ssnop; ssnop
 #else
 #define	COP0_SYNC		/* nothing */
 #endif
diff -I '.*' -Naur releng8/sys/mips/include/db_machdep.h svn/mips/sys/mips/include/db_machdep.h
--- releng8/src/sys/mips/include/db_machdep.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/db_machdep.h	2009-08-04 10:46:58.000000000 -0700
@@ -46,7 +46,7 @@
 extern db_regs_t	ddb_regs;	/* register state */
 
 typedef	vm_offset_t	db_addr_t;	/* address - unsigned */
-typedef	int		db_expr_t;	/* expression - signed */
+typedef	intptr_t	db_expr_t;	/* expression - signed */
 
 #if BYTE_ORDER == _BIG_ENDIAN
 #define	BYTE_MSF	(1)
diff -I '.*' -Naur releng8/sys/mips/include/elf.h svn/mips/sys/mips/include/elf.h
--- releng8/src/sys/mips/include/elf.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/elf.h	2009-08-04 10:46:58.000000000 -0700
@@ -41,8 +41,12 @@
 /* Information taken from MIPS ABI supplemental */
 
 #ifndef __ELF_WORD_SIZE
+#if defined(__mips_n64)
+#define	__ELF_WORD_SIZE 64	/* Used by <sys/elf_generic.h> */
+#else
 #define	__ELF_WORD_SIZE 32	/* Used by <sys/elf_generic.h> */
 #endif
+#endif
 #include <sys/elf32.h>	/* Definitions common to all 32 bit architectures. */
 #include <sys/elf64.h>	/* Definitions common to all 64 bit architectures. */
 #include <sys/elf_generic.h>
diff -I '.*' -Naur releng8/sys/mips/include/endian.h svn/mips/sys/mips/include/endian.h
--- releng8/src/sys/mips/include/endian.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/endian.h	2009-05-06 14:57:15.000000000 -0700
@@ -108,12 +108,12 @@
 	    ((_x << 40) & ((__uint64_t)0xff << 48)) | ((_x << 56)));
 }
 
-#define	__bswap16(x)	(__uint16_t)(__is_constant(x) ? __bswap16_const(x) : \
-	__bswap16_var(x))
-#define	__bswap32(x)	(__uint32_t)(__is_constant(x) ? __bswap32_const(x) : \
-	__bswap32_var(x))
-#define	__bswap64(x)	(__uint64_t)(__is_constant(x) ? __bswap64_const(x) : \
-	__bswap64_var(x))
+#define	__bswap16(x)	(__uint16_t)(__is_constant(x) ?		\
+	__bswap16_const((__uint16_t)x) :  __bswap16_var((__uint16_t)x))
+#define	__bswap32(x)	(__uint32_t)(__is_constant(x) ?		\
+	__bswap32_const((__uint32_t)x) :  __bswap32_var((__uint32_t)x))
+#define	__bswap64(x)	(__uint64_t)(__is_constant(x) ?		\
+	__bswap64_const((__uint64_t)x) :  __bswap64_var((__uint64_t)x))
 
 #ifdef __MIPSEB__
 #define	__htonl(x)	((__uint32_t)(x))
diff -I '.*' -Naur releng8/sys/mips/include/float.h svn/mips/sys/mips/include/float.h
--- releng8/src/sys/mips/include/float.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/float.h	2009-06-12 04:42:48.000000000 -0700
@@ -42,10 +42,10 @@
 __END_DECLS
 
 #define	FLT_RADIX	2		/* b */
-#ifdef SOFTFLOAT
-#define	FLT_ROUNDS	-1
-#else
+#ifdef CPU_HAVEFPU
 #define	FLT_ROUNDS	__flt_rounds() /* FP addition rounds to nearest */
+#else
+#define	FLT_ROUNDS	-1
 #endif
 /*
  * XXXMIPS: MIPS32 has both float and double type, so set FLT_EVAL_METHOD
diff -I '.*' -Naur releng8/sys/mips/include/intr.h svn/mips/sys/mips/include/intr.h
--- releng8/src/sys/mips/include/intr.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/intr.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,94 +0,0 @@
-/*	$NetBSD: intr.h,v 1.5 1996/05/13 06:11:28 mycroft Exp $ */
-
-/*-
- * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by Charles M. Hannum.
- * 4. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *	JNPR: intr.h,v 1.4 2007/08/09 11:23:32 katta
- * $FreeBSD: src/sys/mips/include/intr.h,v 1.1.2.1 2009/08/03 08:13:06 kensmith Exp $
- */
-
-#ifndef _MACHINE_INTR_H_
-#define	_MACHINE_INTR_H_
-
-/* Interrupt sharing types. */
-#define	IST_NONE	0	/* none */
-#define	IST_PULSE	1	/* pulsed */
-#define	IST_EDGE	2	/* edge-triggered */
-#define	IST_LEVEL	3	/* level-triggered */
-
-#ifndef _LOCORE
-
-/*
- * Index into intrcnt[], which is defined in exceptions.S
- *	Index # = irq # - 1
- */
-#define	INTRCNT_HARDCLOCK	0
-#define	INTRCNT_RTC		1
-#define	INTRCNT_SIO		2	/* irq 3 */
-#define	INTRCNT_PE		3	/* irq 4 */
-#define	INTRCNT_PICNIC		4	/* irq 5 */
-
-extern uint32_t idle_mask;
-extern void (*mips_ack_interrupt)(int, uint32_t);
-
-typedef int	ih_func_t(void *);
-
-struct intr_event;
-
-struct mips_intr_handler {
-	int	(*ih_func) (void *);
-	void	*ih_arg;
-	struct	intr_event *ih_event;
-	u_int	ih_flags;
-	volatile long *ih_count;
-	int	ih_level;
-	int	ih_irq;
-	void	*frame;
-};
-
-extern struct mips_intr_handler intr_handlers[];
-
-typedef void (*mask_fn)(void *);
-
-void mips_mask_irq(void);
-void mips_unmask_irq(void);
-
-struct trapframe;
-void	mips_set_intr(int pri, uint32_t mask,
-	    uint32_t (*int_hand)(uint32_t, struct trapframe *));
-uint32_t mips_handle_interrupts(uint32_t pending, struct trapframe *cf);
-void	intr_enable_source(uintptr_t irq);
-struct trapframe * mips_get_trapframe(void *ih_arg);
-int	inthand_add(const char *name, u_int irq, void (*handler)(void *),
-	    void *arg, int flags, void **cookiep);
-int	inthand_remove(u_int irq, void *cookie);
-void	bvif_attach(void);
-
-#endif /* _LOCORE */
-
-#endif /* !_MACHINE_INTR_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/md_var.h svn/mips/sys/mips/include/md_var.h
--- releng8/src/sys/mips/include/md_var.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/md_var.h	2009-08-04 10:46:58.000000000 -0700
@@ -39,7 +39,7 @@
 /*
  * Miscellaneous machine-dependent declarations.
  */
-extern	int	Maxmem;
+extern	long	Maxmem;
 extern	char	sigcode[];
 extern	int	szsigcode, szosigcode;
 
@@ -48,10 +48,11 @@
 void	MipsSaveCurFPState(struct thread *);
 void	fork_trampoline(void);
 void	cpu_swapin(struct proc *);
-u_int	MipsEmulateBranch(struct trapframe *, int, int, u_int);
+uintptr_t MipsEmulateBranch(struct trapframe *, uintptr_t, int, uintptr_t);
 u_long	kvtop(void *addr);
 int	is_physical_memory(vm_offset_t addr);
 int	is_cacheable_mem(vm_offset_t pa);
+int	is_coherent_mem(vm_offset_t pa);
 
 #define	MIPS_DEBUG   0
 
@@ -69,4 +70,7 @@
 /* Platform call-downs. */
 void	platform_identify(void);
 
+extern int busdma_swi_pending;
+void busdma_swi(void);
+
 #endif /* !_MACHINE_MD_VAR_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/param.h svn/mips/sys/mips/include/param.h
--- releng8/src/sys/mips/include/param.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/param.h	2009-10-01 13:42:53.000000000 -0700
@@ -36,11 +36,13 @@
  *	from: Utah Hdr: machparam.h 1.11 89/08/14
  *	from: @(#)param.h	8.1 (Berkeley) 6/10/93
  *	JNPR: param.h,v 1.6.2.1 2007/09/10 07:49:36 girish
- * $FreeBSD: src/sys/mips/include/param.h,v 1.6.2.1 2009/08/03 08:13:06 kensmith Exp $
+ * $FreeBSD: projects/mips/sys/mips/include/param.h 196215 2009-08-14 16:15:18Z imp $
  */
 
-#ifndef _MACHINE_PARAM_H_
-#define	_MACHINE_PARAM_H_
+#ifndef _MIPS_INCLUDE_PARAM_H_
+#define	_MIPS_INCLUDE_PARAM_H_
+
+#include <machine/_align.h>
 
 #include <sys/cdefs.h>
 #ifdef _KERNEL
@@ -82,8 +84,6 @@
  * data types (int, long, ...).	  The result is u_int and must be cast to
  * any desired pointer type.
  */
-#define	_ALIGNBYTES	7
-#define	_ALIGN(p)	(((u_int)(p) + _ALIGNBYTES) &~ _ALIGNBYTES)
 
 #define	ALIGNBYTES	_ALIGNBYTES
 #define	ALIGN(p)	_ALIGN(p)
@@ -115,6 +115,8 @@
 #define	SEGOFSET	(NBSEG-1)	/* byte offset into segment */
 #define	SEGSHIFT	22		/* LOG2(NBSEG) */
 
+#define	MAXPAGESIZES	1		/* maximum number of supported page sizes */
+
 /* XXXimp: This has moved to vmparam.h */
 /* Also, this differs from the mips2 definition, but likely is better */
 /* since this means the kernel won't chew up TLBs when it is executing */
@@ -167,4 +169,4 @@
 #define	DELAY(n)	{ register int N = (n); while (--N > 0); }
 #endif /* !_KERNEL */
 
-#endif /* !_MACHINE_PARAM_H_ */
+#endif /* !_MIPS_INCLUDE_PARAM_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/pltfm.h svn/mips/sys/mips/include/pltfm.h
--- releng8/src/sys/mips/include/pltfm.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/pltfm.h	2009-08-04 10:46:58.000000000 -0700
@@ -13,17 +13,4 @@
 #define	SDRAM_ADDR_END		(SDRAM_ADDR_START + (1024*0x100000))
 #define	SDRAM_MEM_SIZE		(SDRAM_ADDR_END - SDRAM_ADDR_START)
 
-#define	UART_ADDR_START		0x1ef14000	/* UART */
-#define	UART_ADDR_END		0x1ef14fff
-#define	UART_MEM_SIZE		(UART_ADDR_END-UART_ADDR_START)
-
-/*
- * NS16550 UART address
- */
-#ifdef ADDR_NS16550_UART1
-#undef ADDR_NS16550_UART1
-#endif
-#define	ADDR_NS16550_UART1	0x1ef14000	/* UART */
-#define	VADDR_NS16550_UART1	0xbef14000	/* UART */
-
 #endif /* !_MACHINE_PLTFM_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/pmap.h svn/mips/sys/mips/include/pmap.h
--- releng8/src/sys/mips/include/pmap.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/pmap.h	2009-10-01 13:13:43.000000000 -0700
@@ -172,6 +172,7 @@
 void pmap_kenter_temporary_free(vm_paddr_t pa);
 int pmap_compute_pages_to_dump(void);
 void pmap_update_page(pmap_t pmap, vm_offset_t va, pt_entry_t pte);
+void pmap_flush_pvcache(vm_page_t m);
 
 /*
  * floating virtual pages (FPAGES)
diff -I '.*' -Naur releng8/sys/mips/include/proc.h svn/mips/sys/mips/include/proc.h
--- releng8/src/sys/mips/include/proc.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/proc.h	2009-07-02 18:44:22.000000000 -0700
@@ -54,6 +54,7 @@
 	int	md_pc_count;		/* performance counter */
 	int	md_pc_spill;		/* performance counter spill */
 	vm_offset_t	md_realstack;
+	void	*md_tls;
 };
 
 /* md_flags */
diff -I '.*' -Naur releng8/sys/mips/include/profile.h svn/mips/sys/mips/include/profile.h
--- releng8/src/sys/mips/include/profile.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/profile.h	2009-08-04 10:46:58.000000000 -0700
@@ -41,6 +41,8 @@
 
 /*XXX The cprestore instruction is a "dummy" to shut up as(1). */
 
+/*XXX This is not MIPS64 safe. */
+
 #define	MCOUNT \
 	__asm(".globl _mcount;"		\
 	".type _mcount,@function;"	\
diff -I '.*' -Naur releng8/sys/mips/include/psl.h svn/mips/sys/mips/include/psl.h
--- releng8/src/sys/mips/include/psl.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/psl.h	2009-05-26 09:40:41.000000000 -0700
@@ -47,8 +47,4 @@
 #define	USERMODE(ps)	(((ps) & SR_KSU_MASK) == SR_KSU_USER)
 #define	BASEPRI(ps)	(((ps) & (INT_MASK | SR_INT_ENA_PREV)) \
 			    == (INT_MASK | SR_INT_ENA_PREV))
-
-#ifdef _KERNEL
-#include <machine/intr.h>
-#endif
 #endif	/* _MACHINE_PSL_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/pte.h svn/mips/sys/mips/include/pte.h
--- releng8/src/sys/mips/include/pte.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/pte.h	2009-08-04 10:46:58.000000000 -0700
@@ -105,7 +105,11 @@
 #define PTE_ODDPG       0x00001000 
 /*#define	PG_ATTR		0x0000003f  Not Used */
 #define	PTE_UNCACHED	0x00000010
+#ifdef CPU_SB1
+#define	PTE_CACHE	0x00000028	/* cacheable coherent */
+#else
 #define	PTE_CACHE	0x00000018
+#endif
 /*#define	PG_CACHEMODE	0x00000038 Not Used*/
 #define	PTE_ROPAGE	(PTE_V | PTE_RO | PTE_CACHE) /* Write protected */
 #define	PTE_RWPAGE	(PTE_V | PTE_M | PTE_CACHE)  /* Not wr-prot not clean */
diff -I '.*' -Naur releng8/sys/mips/include/regdef.h svn/mips/sys/mips/include/regdef.h
--- releng8/src/sys/mips/include/regdef.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/regdef.h	2009-08-04 10:46:58.000000000 -0700
@@ -12,6 +12,8 @@
 #ifndef _MACHINE_REGDEF_H_
 #define	_MACHINE_REGDEF_H_
 
+#include <machine/cdefs.h>		/* For API selection */
+
 #if defined(__ASSEMBLER__)
 /* General purpose CPU register names */
 #define	zero	$0	/* wired zero */
@@ -22,6 +24,16 @@
 #define	a1	$5
 #define	a2	$6
 #define	a3	$7
+#if defined(__mips_n32) || defined(__mips_n64)
+#define	a4	$8
+#define	a5	$9
+#define	a6	$10
+#define	a7	$11
+#define	t0	$12	/* Temp regs, not saved accross subroutine calls */
+#define	t1	$13
+#define	t2	$14
+#define	t3	$15
+#else
 #define	t0	$8	/* caller saved */
 #define	t1	$9
 #define	t2	$10
@@ -30,6 +42,7 @@
 #define	t5	$13
 #define	t6	$14
 #define	t7	$15
+#endif
 #define	s0	$16	/* callee saved */
 #define	s1	$17
 #define	s2	$18
@@ -48,6 +61,26 @@
 #define	s8	$30	/* callee saved */
 #define	ra	$31	/* return address */
 
+/*
+ * These are temp registers whose names can be used in either the old
+ * or new ABI, although they map to different physical registers.  In
+ * the old ABI, they map to t4-t7, and in the new ABI, they map to a4-a7.
+ *
+ * Because they overlap with the last 4 arg regs in the new ABI, ta0-ta3
+ * should be used only when we need more than t0-t3.
+ */
+#if defined(__mips_n32) || defined(__mips_n64)
+#define	ta0	$8
+#define	ta1	$9
+#define	ta2	$10
+#define	ta3	$11
+#else
+#define	ta0	$12
+#define	ta1	$13
+#define	ta2	$14
+#define	ta3	$15
+#endif /* __mips_n32 || __mips_n64 */
+
 #endif /* __ASSEMBLER__ */
 
 #endif /* !_MACHINE_REGDEF_H_ */
diff -I '.*' -Naur releng8/sys/mips/include/regnum.h svn/mips/sys/mips/include/regnum.h
--- releng8/src/sys/mips/include/regnum.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/regnum.h	2009-08-04 10:46:58.000000000 -0700
@@ -82,10 +82,10 @@
 #define	T1	9
 #define	T2	10
 #define	T3	11
-#define	T4	12
-#define	T5	13
-#define	T6	14
-#define	T7	15
+#define	TA0	12
+#define	TA1	13
+#define	TA2	14
+#define	TA3	15
 #define	S0	16
 #define	S1	17
 #define	S2	18
diff -I '.*' -Naur releng8/sys/mips/include/sysarch.h svn/mips/sys/mips/include/sysarch.h
--- releng8/src/sys/mips/include/sysarch.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/sysarch.h	2009-07-02 18:44:22.000000000 -0700
@@ -35,16 +35,12 @@
 #ifndef _MACHINE_SYSARCH_H_
 #define _MACHINE_SYSARCH_H_
 
+#define	MIPS_SET_TLS	1
+#define	MIPS_GET_TLS	2
+
 #ifndef _KERNEL
 #include <sys/cdefs.h>
 
-#if 0
-/* Something useful for each MIPS platform. */
-#else
-#define	mips_tcb_set(tcb)	do {} while (0)
-#define	mips_tcb_get()		NULL
-#endif /* _MIPS_ARCH_XLR */
-
 __BEGIN_DECLS
 int sysarch(int, void *);
 __END_DECLS
diff -I '.*' -Naur releng8/sys/mips/include/ucontext.h svn/mips/sys/mips/include/ucontext.h
--- releng8/src/sys/mips/include/ucontext.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/include/ucontext.h	2009-08-04 10:46:58.000000000 -0700
@@ -53,14 +53,19 @@
 	int		mc_fpused;	/* fp has been used */
 	f_register_t	mc_fpregs[33];	/* fp regs 0 to 31 and csr */
 	register_t	mc_fpc_eir;	/* fp exception instruction reg */
+	void		*mc_tls;	/* pointer to TLS area */
 	int	__spare__[8];	/* XXX reserved */ 
 } mcontext_t;
 #endif
 
+#if defined(__mips_n64) || defined(__mips_n32)
+#define	SZREG		8
+#else
 #define	SZREG		4
+#endif
 
 /* offsets into mcontext_t */
-#define	UCTX_REG(x)	(8 + (x)*SZREG)
+#define	UCTX_REG(x)	(4 + SZREG + (x)*SZREG)
 
 #define	UCR_ZERO	UCTX_REG(0)
 #define	UCR_AT		UCTX_REG(1)
diff -I '.*' -Naur releng8/sys/mips/malta/gt_pci.c svn/mips/sys/mips/malta/gt_pci.c
--- releng8/src/sys/mips/malta/gt_pci.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/malta/gt_pci.c	2009-07-02 19:55:30.000000000 -0700
@@ -91,11 +91,16 @@
 #define OCW3_POLL_IRQ(x) ((x) & 0x7f)
 #define OCW3_POLL_PENDING (1U << 7)
 
+struct gt_pci_softc;
+
+struct gt_pci_intr_cookie {
+	int irq;
+	struct gt_pci_softc *sc;
+};
+
 struct gt_pci_softc {
 	device_t 		sc_dev;
 	bus_space_tag_t 	sc_st;
-	bus_space_tag_t		sc_pciio;
-	bus_space_tag_t		sc_pcimem;
 	bus_space_handle_t	sc_ioh_icu1;
 	bus_space_handle_t	sc_ioh_icu2;
 	bus_space_handle_t	sc_ioh_elcr;
@@ -109,6 +114,7 @@
 
 	struct resource		*sc_irq;
 	struct intr_event	*sc_eventstab[ICU_LEN];
+	struct gt_pci_intr_cookie	sc_intr_cookies[ICU_LEN];
 	uint16_t		sc_imask;
 	uint16_t		sc_elcr;
 
@@ -117,6 +123,52 @@
 	void			*sc_ih;
 };
 
+static void gt_pci_set_icus(struct gt_pci_softc *);
+static int gt_pci_intr(void *v);
+static int gt_pci_probe(device_t);
+static int gt_pci_attach(device_t);
+static int gt_pci_activate_resource(device_t, device_t, int, int, 
+    struct resource *);
+static int gt_pci_setup_intr(device_t, device_t, struct resource *, 
+    int, driver_filter_t *, driver_intr_t *, void *, void **);
+static int gt_pci_teardown_intr(device_t, device_t, struct resource *, void*);
+static int gt_pci_maxslots(device_t );
+static int gt_pci_conf_setup(struct gt_pci_softc *, int, int, int, int, 
+    uint32_t *);
+static uint32_t gt_pci_read_config(device_t, u_int, u_int, u_int, u_int, int);
+static void gt_pci_write_config(device_t, u_int, u_int, u_int, u_int, 
+    uint32_t, int);
+static int gt_pci_route_interrupt(device_t pcib, device_t dev, int pin);
+static struct resource * gt_pci_alloc_resource(device_t, device_t, int, 
+    int *, u_long, u_long, u_long, u_int);
+
+static void
+gt_pci_mask_irq(void *source)
+{
+	struct gt_pci_intr_cookie *cookie = source;
+	struct gt_pci_softc *sc = cookie->sc;
+	int irq = cookie->irq;
+
+	sc->sc_imask |= (1 << irq);
+	sc->sc_elcr |= (1 << irq);
+
+	gt_pci_set_icus(sc);
+}
+
+static void
+gt_pci_unmask_irq(void *source)
+{
+	struct gt_pci_intr_cookie *cookie = source;
+	struct gt_pci_softc *sc = cookie->sc;
+	int irq = cookie->irq;
+
+	/* Enable it, set trigger mode. */
+	sc->sc_imask &= ~(1 << irq);
+	sc->sc_elcr &= ~(1 << irq);
+
+	gt_pci_set_icus(sc);
+}
+
 static void
 gt_pci_set_icus(struct gt_pci_softc *sc)
 {
@@ -126,14 +178,14 @@
 	else
 		sc->sc_imask |= (1U << 2);
 
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, PIC_OCW1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, PIC_OCW1,
 	    sc->sc_imask & 0xff);
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2, PIC_OCW1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2, PIC_OCW1,
 	    (sc->sc_imask >> 8) & 0xff);
 
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_elcr, 0,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_elcr, 0,
 	    sc->sc_elcr & 0xff);
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_elcr, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_elcr, 1,
 	    (sc->sc_elcr >> 8) & 0xff);
 }
 
@@ -145,9 +197,9 @@
 	int irq;
 
 	for (;;) {
-		bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, PIC_OCW3,
+		bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, PIC_OCW3,
 		    OCW3_SEL | OCW3_P);
-		irq = bus_space_read_1(sc->sc_pciio, sc->sc_ioh_icu1, PIC_OCW3);
+		irq = bus_space_read_1(sc->sc_st, sc->sc_ioh_icu1, PIC_OCW3);
 		if ((irq & OCW3_POLL_PENDING) == 0)
 		{
 			return FILTER_HANDLED;
@@ -156,9 +208,9 @@
 		irq = OCW3_POLL_IRQ(irq);
 
 		if (irq == 2) {
-			bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2,
+			bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2,
 			    PIC_OCW3, OCW3_SEL | OCW3_P);
-			irq = bus_space_read_1(sc->sc_pciio, sc->sc_ioh_icu2,
+			irq = bus_space_read_1(sc->sc_st, sc->sc_ioh_icu2,
 			    PIC_OCW3);
 			if (irq & OCW3_POLL_PENDING)
 				irq = OCW3_POLL_IRQ(irq) + 8;
@@ -177,13 +229,13 @@
 
 		/* Send a specific EOI to the 8259. */
 		if (irq > 7) {
-			bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2,
+			bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2,
 			    PIC_OCW2, OCW2_SELECT | OCW2_EOI | OCW2_SL |
 			    OCW2_ILS(irq & 7));
 			irq = 2;
 		}
 
-		bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, PIC_OCW2,
+		bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, PIC_OCW2,
 		    OCW2_SELECT | OCW2_EOI | OCW2_SL | OCW2_ILS(irq));
 	}
 
@@ -208,8 +260,7 @@
 	busno = 0;
 	sc->sc_dev = dev;
 	sc->sc_busno = busno;
-	sc->sc_pciio = MIPS_BUS_SPACE_IO;
-	sc->sc_pcimem = MIPS_BUS_SPACE_MEM;
+	sc->sc_st = mips_bus_space_generic;
 
 	/* Use KSEG1 to access IO ports for it is uncached */
 	sc->sc_io = MIPS_PHYS_TO_KSEG1(MALTA_PCI0_IO_BASE);
@@ -239,11 +290,11 @@
 	 * Map the PIC/ELCR registers.
 	 */
 #if 0
-	if (bus_space_map(sc->sc_pciio, 0x4d0, 2, 0, &sc->sc_ioh_elcr) != 0)
+	if (bus_space_map(sc->sc_st, 0x4d0, 2, 0, &sc->sc_ioh_elcr) != 0)
 		device_printf(dev, "unable to map ELCR registers\n");
-	if (bus_space_map(sc->sc_pciio, IO_ICU1, 2, 0, &sc->sc_ioh_icu1) != 0)
+	if (bus_space_map(sc->sc_st, IO_ICU1, 2, 0, &sc->sc_ioh_icu1) != 0)
 		device_printf(dev, "unable to map ICU1 registers\n");
-	if (bus_space_map(sc->sc_pciio, IO_ICU2, 2, 0, &sc->sc_ioh_icu2) != 0)
+	if (bus_space_map(sc->sc_st, IO_ICU2, 2, 0, &sc->sc_ioh_icu2) != 0)
 		device_printf(dev, "unable to map ICU2 registers\n");
 #else
 	sc->sc_ioh_elcr = sc->sc_io + 0x4d0;
@@ -262,58 +313,58 @@
 	 * Initialize the 8259s.
 	 */
 	/* reset, program device, 4 bytes */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, 0,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, 0,
 	    ICW1_RESET | ICW1_IC4);
 	/*
 	 * XXX: values from NetBSD's <dev/ic/i8259reg.h>
 	 */	 
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, 1,
 	    0/*XXX*/);
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, 1,
 	    1 << 2);
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, 1,
 	    ICW4_8086);
 
 	/* mask all interrupts */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, 0,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, 0,
 	    sc->sc_imask & 0xff);
 
 	/* enable special mask mode */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, 1,
 	    OCW3_SEL | OCW3_ESMM | OCW3_SMM);
 
 	/* read IRR by default */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu1, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu1, 1,
 	    OCW3_SEL | OCW3_RR);
 
 	/* reset, program device, 4 bytes */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2, 0,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2, 0,
 	    ICW1_RESET | ICW1_IC4);
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2, 1,
 	    0/*XXX*/);
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2, 1,
 	    1 << 2);
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2, 1,
 	    ICW4_8086);
 
 	/* mask all interrupts */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2, 0,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2, 0,
 	    sc->sc_imask & 0xff);
 
 	/* enable special mask mode */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2, 1,
 	    OCW3_SEL | OCW3_ESMM | OCW3_SMM);
 
 	/* read IRR by default */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_icu2, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_icu2, 1,
 	    OCW3_SEL | OCW3_RR);
 
 	/*
 	 * Default all interrupts to edge-triggered.
 	 */
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_elcr, 0,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_elcr, 0,
 	    sc->sc_elcr & 0xff);
-	bus_space_write_1(sc->sc_pciio, sc->sc_ioh_elcr, 1,
+	bus_space_write_1(sc->sc_st, sc->sc_ioh_elcr, 1,
 	    (sc->sc_elcr >> 8) & 0xff);
 
 	/*
@@ -570,12 +621,12 @@
 		break;
 	case SYS_RES_MEMORY:
 		rm = &sc->sc_mem_rman;
-		bt = sc->sc_pcimem;
+		bt = sc->sc_st;
 		bh = sc->sc_mem;
 		break;
 	case SYS_RES_IOPORT:
 		rm = &sc->sc_io_rman;
-		bt = sc->sc_pciio;
+		bt = sc->sc_st;
 		bh = sc->sc_io;
 		break;
 	default:
@@ -632,10 +683,13 @@
 		panic("%s: bad irq or type", __func__);
 
 	event = sc->sc_eventstab[irq];
+	sc->sc_intr_cookies[irq].irq = irq;
+	sc->sc_intr_cookies[irq].sc = sc;
 	if (event == NULL) {
-                error = intr_event_create(&event, (void *)irq, 0, irq,
-		    (mask_fn)mips_mask_irq, (mask_fn)mips_unmask_irq,
-		    (mask_fn)mips_unmask_irq, NULL, "gt_pci intr%d:", irq);
+                error = intr_event_create(&event, 
+		    (void *)&sc->sc_intr_cookies[irq], 0, irq,
+		    gt_pci_mask_irq, gt_pci_unmask_irq,
+		    NULL, NULL, "gt_pci intr%d:", irq);
 		if (error)
 			return 0;
 		sc->sc_eventstab[irq] = event;
@@ -644,12 +698,7 @@
 	intr_event_add_handler(event, device_get_nameunit(child), filt, 
 	    handler, arg, intr_priority(flags), flags, cookiep);
 
-	/* Enable it, set trigger mode. */
-	sc->sc_imask &= ~(1 << irq);
-	sc->sc_elcr &= ~(1 << irq);
-
-	gt_pci_set_icus(sc);
-
+	gt_pci_unmask_irq((void *)&sc->sc_intr_cookies[irq]);
 	return 0;
 }
 
@@ -657,6 +706,12 @@
 gt_pci_teardown_intr(device_t dev, device_t child, struct resource *res,
     void *cookie)
 {
+	struct gt_pci_softc *sc = device_get_softc(dev);
+	int irq;
+
+	irq = rman_get_start(res);
+	gt_pci_mask_irq((void *)&sc->sc_intr_cookies[irq]);
+
 	return (intr_event_remove_handler(cookie));
 }
 
diff -I '.*' -Naur releng8/sys/mips/malta/malta_machdep.c svn/mips/sys/mips/malta/malta_machdep.c
--- releng8/src/sys/mips/malta/malta_machdep.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/malta/malta_machdep.c	2009-07-02 18:44:24.000000000 -0700
@@ -226,6 +226,52 @@
 
 }
 
+static uint64_t
+malta_cpu_freq(void)
+{
+	uint64_t platform_counter_freq = 0;
+
+#if defined(TICK_USE_YAMON_FREQ)
+	/*
+	 * If we are running on a board which uses YAMON firmware,
+	 * then query CPU pipeline clock from the syscon object.
+	 * If unsuccessful, use hard-coded default.
+	 */
+	platform_counter_freq = yamon_getcpufreq();
+
+#elif defined(TICK_USE_MALTA_RTC)
+	/*
+	 * If we are running on a board with the MC146818 RTC,
+	 * use it to determine CPU pipeline clock frequency.
+	 */
+	u_int64_t counterval[2];
+
+	/* Set RTC to binary mode. */
+	writertc(RTC_STATUSB, (rtcin(RTC_STATUSB) | RTCSB_BCD));
+
+	/* Busy-wait for falling edge of RTC update. */
+	while (((rtcin(RTC_STATUSA) & RTCSA_TUP) == 0))
+		;
+	while (((rtcin(RTC_STATUSA)& RTCSA_TUP) != 0))
+		;
+	counterval[0] = mips_rd_count();
+
+	/* Busy-wait for falling edge of RTC update. */
+	while (((rtcin(RTC_STATUSA) & RTCSA_TUP) == 0))
+		;
+	while (((rtcin(RTC_STATUSA)& RTCSA_TUP) != 0))
+		;
+	counterval[1] = mips_rd_count();
+
+	platform_counter_freq = counterval[1] - counterval[0];
+#endif
+
+	if (platform_counter_freq == 0)
+		platform_counter_freq = MIPS_DEFAULT_HZ;
+
+	return (platform_counter_freq);
+}
+
 void
 platform_start(__register_t a0, __register_t a1,  __register_t a2, 
     __register_t a3)
@@ -242,6 +288,9 @@
 	kernend = round_page((vm_offset_t)&end);
 	memset(&edata, 0, kernend - (vm_offset_t)(&edata));
 
+	platform_counter_freq = malta_cpu_freq();
+	mips_timer_early_init(platform_counter_freq);
+
 	cninit();
 	printf("entry: platform_start()\n");
 
@@ -262,44 +311,5 @@
 	realmem = btoc(memsize);
 	mips_init();
 
-	do {
-#if defined(TICK_USE_YAMON_FREQ)
-		/*
-		 * If we are running on a board which uses YAMON firmware,
-		 * then query CPU pipeline clock from the syscon object.
-		 * If unsuccessful, use hard-coded default.
-		 */
-		platform_counter_freq = yamon_getcpufreq();
-		if (platform_counter_freq == 0)
-			platform_counter_freq = MIPS_DEFAULT_HZ;
-
-#elif defined(TICK_USE_MALTA_RTC)
-		/*
-		 * If we are running on a board with the MC146818 RTC,
-		 * use it to determine CPU pipeline clock frequency.
-		 */
-		u_int64_t counterval[2];
-
-		/* Set RTC to binary mode. */
-		writertc(RTC_STATUSB, (rtcin(RTC_STATUSB) | RTCSB_BCD));
-
-		/* Busy-wait for falling edge of RTC update. */
-		while (((rtcin(RTC_STATUSA) & RTCSA_TUP) == 0))
-			;
-		while (((rtcin(RTC_STATUSA)& RTCSA_TUP) != 0))
-			;
-		counterval[0] = mips_rd_count();
-
-		/* Busy-wait for falling edge of RTC update. */
-		while (((rtcin(RTC_STATUSA) & RTCSA_TUP) == 0))
-			;
-		while (((rtcin(RTC_STATUSA)& RTCSA_TUP) != 0))
-			;
-		counterval[1] = mips_rd_count();
-
-		platform_counter_freq = counterval[1] - counterval[0];
-#endif
-	} while(0);
-
 	mips_timer_init_params(platform_counter_freq, 0);
 }
diff -I '.*' -Naur releng8/sys/mips/malta/maltareg.h svn/mips/sys/mips/malta/maltareg.h
--- releng8/src/sys/mips/malta/maltareg.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/malta/maltareg.h	2009-08-04 10:47:01.000000000 -0700
@@ -94,37 +94,37 @@
 		15	Secondary IDE	Secondary IDE slot/Compact flash connector
  */
 
-#define	MALTA_SYSTEMRAM_BASE	0x00000000  /* System RAM:	*/
+#define	MALTA_SYSTEMRAM_BASE	0x00000000ul  /* System RAM:	*/
 #define	MALTA_SYSTEMRAM_SIZE	0x08000000  /*   128 MByte	*/
 
-#define	MALTA_PCIMEM1_BASE	0x08000000  /* PCI 1 memory:	*/
+#define	MALTA_PCIMEM1_BASE	0x08000000ul  /* PCI 1 memory:	*/
 #define	MALTA_PCIMEM1_SIZE	0x08000000  /*   128 MByte	*/
 
-#define	MALTA_PCIMEM2_BASE	0x10000000  /* PCI 2 memory:	*/
+#define	MALTA_PCIMEM2_BASE	0x10000000ul  /* PCI 2 memory:	*/
 #define	MALTA_PCIMEM2_SIZE	0x08000000  /*   128 MByte	*/
 
-#define	MALTA_PCIMEM3_BASE	0x18000000  /* PCI 3 memory	*/
+#define	MALTA_PCIMEM3_BASE	0x18000000ul  /* PCI 3 memory	*/
 #define	MALTA_PCIMEM3_SIZE	0x03e00000  /*    62 MByte	*/
 
-#define	MALTA_CORECTRL_BASE	0x1be00000  /* Core control:	*/
+#define	MALTA_CORECTRL_BASE	0x1be00000ul  /* Core control:	*/
 #define	MALTA_CORECTRL_SIZE	0x00200000  /*     2 MByte	*/
 
-#define	MALTA_RESERVED_BASE1	0x1c000000  /* Reserved:	*/
+#define	MALTA_RESERVED_BASE1	0x1c000000ul  /* Reserved:	*/
 #define	MALTA_RESERVED_SIZE1	0x02000000  /*    32 MByte	*/
 
-#define	MALTA_MONITORFLASH_BASE	0x1e000000  /* Monitor Flash:	*/
+#define	MALTA_MONITORFLASH_BASE	0x1e000000ul  /* Monitor Flash:	*/
 #define	MALTA_MONITORFLASH_SIZE	0x003e0000  /*     4 MByte	*/
 #define	MALTA_MONITORFLASH_SECTORSIZE 0x00010000 /* Sect. = 64 KB */
 
-#define	MALTA_FILEFLASH_BASE	0x1e3e0000 /* File Flash (for monitor): */
+#define	MALTA_FILEFLASH_BASE	0x1e3e0000ul /* File Flash (for monitor): */
 #define	MALTA_FILEFLASH_SIZE	0x00020000 /*   128 KByte	*/
 
 #define	MALTA_FILEFLASH_SECTORSIZE 0x00010000 /* Sect. = 64 KB	*/
 
-#define	MALTA_RESERVED_BASE2	0x1e400000  /* Reserved:	*/
+#define	MALTA_RESERVED_BASE2	0x1e400000ul  /* Reserved:	*/
 #define	MALTA_RESERVED_SIZE2	0x00c00000  /*    12 MByte	*/
 
-#define	MALTA_FPGA_BASE		0x1f000000  /* FPGA:		*/
+#define	MALTA_FPGA_BASE		0x1f000000ul  /* FPGA:		*/
 #define	MALTA_FPGA_SIZE		0x00c00000  /*    12 MByte	*/
 
 #define	MALTA_NMISTATUS		(MALTA_FPGA_BASE + 0x24)
@@ -191,10 +191,10 @@
 #define	MALTA_I2COUT		0x10
 #define	MALTA_I2CSEL		0x18
 
-#define	MALTA_BOOTROM_BASE	0x1fc00000  /* Boot ROM:	*/
+#define	MALTA_BOOTROM_BASE	0x1fc00000ul  /* Boot ROM:	*/
 #define	MALTA_BOOTROM_SIZE	0x00400000  /*     4 MByte	*/
 
-#define	MALTA_REVISION		0x1fc00010
+#define	MALTA_REVISION		0x1fc00010ul
 #define	 MALTA_REV_FPGRV	 0xff0000	/* CBUS FPGA revision */
 #define	 MALTA_REV_CORID	 0x00fc00	/* Core Board ID */
 #define	 MALTA_REV_CORRV	 0x000300	/* Core Board Revision */
diff -I '.*' -Naur releng8/sys/mips/malta/obio.c svn/mips/sys/mips/malta/obio.c
--- releng8/src/sys/mips/malta/obio.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/malta/obio.c	2009-09-08 11:01:51.000000000 -0700
@@ -63,20 +63,18 @@
  * A bit tricky and hackish. Since we need OBIO to rely
  * on PCI we make it pseudo-pci device. But there should 
  * be only one such device, so we use this static flag 
- * to prevent false positives on every realPCI device probe. 
+ * to prevent false positives on every real PCI device probe.
  */
 static int have_one = 0;
 
 int
 obio_probe(device_t dev)
 {
-	if(!have_one)
-	{
+	if (!have_one) {
 		have_one = 1;
 		return 0;
 	}
-	else
-		return (ENXIO);
+	return (ENXIO);
 }
 
 int
@@ -84,7 +82,7 @@
 {
 	struct obio_softc *sc = device_get_softc(dev);
 
-	sc->oba_st = MIPS_BUS_SPACE_IO;
+	sc->oba_st = mips_bus_space_generic;
 	sc->oba_addr = MIPS_PHYS_TO_KSEG1(MALTA_UART0ADR);
 	sc->oba_size = MALTA_PCIMEM3_SIZE;
 	sc->oba_rman.rm_type = RMAN_ARRAY;
diff -I '.*' -Naur releng8/sys/mips/malta/std.malta svn/mips/sys/mips/malta/std.malta
--- releng8/src/sys/mips/malta/std.malta	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/malta/std.malta	2009-08-04 10:47:01.000000000 -0700
@@ -2,8 +2,7 @@
 files	"../malta/files.malta"
 
 cpu		CPU_MIPS4KC
-options 	ISA_MIPS32
-options		SOFTFLOAT
+#options 	ISA_MIPS32
 device		pci
 device		ata
 device		atadisk
diff -I '.*' -Naur releng8/sys/mips/malta/uart_bus_maltausart.c svn/mips/sys/mips/malta/uart_bus_maltausart.c
--- releng8/src/sys/mips/malta/uart_bus_maltausart.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/malta/uart_bus_maltausart.c	2009-09-08 11:01:51.000000000 -0700
@@ -28,10 +28,6 @@
  * code written by Olivier Houchard.
  */
 
-/*
- * XXXMIPS: This file is hacked from arm/... . XXXMIPS here means this file is
- * experimental and was written for MIPS32 port.
- */
 #include "opt_uart.h"
 
 #include <sys/cdefs.h>
@@ -53,9 +49,6 @@
 #include <dev/uart/uart_bus.h>
 #include <dev/uart/uart_cpu.h>
 
-/*
- * XXXMIPS:
- */
 #include <mips/malta/maltareg.h>
 
 #include "uart_if.h"
@@ -88,9 +81,9 @@
 	sc->sc_sysdev = SLIST_FIRST(&uart_sysdevs);
 	sc->sc_class = &uart_ns8250_class;
 	bcopy(&sc->sc_sysdev->bas, &sc->sc_bas, sizeof(sc->sc_bas));
-	sc->sc_sysdev->bas.bst = 0;
+	sc->sc_sysdev->bas.bst = mips_bus_space_generic;
 	sc->sc_sysdev->bas.bsh = MIPS_PHYS_TO_KSEG1(MALTA_UART0ADR);
-	sc->sc_bas.bst = 0;
+	sc->sc_bas.bst = mips_bus_space_generic;
 	sc->sc_bas.bsh = MIPS_PHYS_TO_KSEG1(MALTA_UART0ADR);
 	return(uart_bus_probe(dev, 0, 0, 0, 0));
 }
diff -I '.*' -Naur releng8/sys/mips/malta/uart_cpu_maltausart.c svn/mips/sys/mips/malta/uart_cpu_maltausart.c
--- releng8/src/sys/mips/malta/uart_cpu_maltausart.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/malta/uart_cpu_maltausart.c	2009-09-08 11:01:51.000000000 -0700
@@ -29,10 +29,6 @@
  * Skeleton of this file was based on respective code for ARM
  * code written by Olivier Houchard.
  */
-/*
- * XXXMIPS: This file is hacked from arm/... . XXXMIPS here means this file is
- * experimental and was written for MIPS32 port.
- */
 #include "opt_uart.h"
 
 #include <sys/cdefs.h>
@@ -67,16 +63,16 @@
 {
 	di->ops = uart_getops(&uart_ns8250_class);
 	di->bas.chan = 0;
-	di->bas.bst = 0;
+	di->bas.bst = mips_bus_space_generic;
+	di->bas.bsh = MIPS_PHYS_TO_KSEG1(MALTA_UART0ADR);
 	di->bas.regshft = 0;
 	di->bas.rclk = 0;
-	di->baudrate = 115200;
+	di->baudrate = 0;	/* retain the baudrate configured by YAMON */
 	di->databits = 8;
 	di->stopbits = 1;
 	di->parity = UART_PARITY_NONE;
 
-	uart_bus_space_io = MIPS_PHYS_TO_KSEG1(MALTA_UART0ADR);
-	uart_bus_space_mem = MIPS_PHYS_TO_KSEG1(MALTA_UART0ADR);
-	di->bas.bsh = MIPS_PHYS_TO_KSEG1(MALTA_UART0ADR);
+	uart_bus_space_io = NULL;
+	uart_bus_space_mem = mips_bus_space_generic;
 	return (0);
 }
diff -I '.*' -Naur releng8/sys/mips/malta/yamon.h svn/mips/sys/mips/malta/yamon.h
--- releng8/src/sys/mips/malta/yamon.h	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/malta/yamon.h	2009-08-04 10:47:01.000000000 -0700
@@ -38,7 +38,7 @@
 #ifndef _MALTA_YAMON_H_
 #define _MALTA_YAMON_H_
 
-#define YAMON_FUNCTION_BASE	0x1fc00500
+#define YAMON_FUNCTION_BASE	0x1fc00500ul
 
 #define YAMON_PRINT_COUNT_OFS	(YAMON_FUNCTION_BASE + 0x04)
 #define YAMON_EXIT_OFS		(YAMON_FUNCTION_BASE + 0x20)
@@ -53,7 +53,7 @@
 #define YAMON_GETCHAR_OFS	(YAMON_FUNCTION_BASE + 0x50)
 #define YAMON_SYSCON_READ_OFS	(YAMON_FUNCTION_BASE + 0x54)
 
-#define YAMON_FUNC(ofs)		(*(uint32_t *)(MIPS_PHYS_TO_KSEG0(ofs)))
+#define YAMON_FUNC(ofs)		((long)(*(int32_t *)(MIPS_PHYS_TO_KSEG0(ofs))))
 
 typedef void (*t_yamon_print_count)(uint32_t port, char *s, uint32_t count);
 #define YAMON_PRINT_COUNT(s, count) \
diff -I '.*' -Naur releng8/sys/mips/mips/bus_space_generic.c svn/mips/sys/mips/mips/bus_space_generic.c
--- releng8/src/sys/mips/mips/bus_space_generic.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/mips/bus_space_generic.c	2009-05-06 14:57:15.000000000 -0700
@@ -0,0 +1,571 @@
+/*      $NetBSD: bus.h,v 1.12 1997/10/01 08:25:15 fvdl Exp $    */
+/*-
+ * $Id: bus.h,v 1.6 2007/08/09 11:23:32 katta Exp $
+ *
+ * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the NetBSD
+ *	Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
+ * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Christopher G. Demetriou
+ *	for the NetBSD Project.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *	from: src/sys/alpha/include/bus.h,v 1.5 1999/08/28 00:38:40 peter
+ * $FreeBSD$
+ */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/ktr.h>
+
+#include <vm/vm.h>
+#include <vm/pmap.h>
+#include <vm/vm_kern.h>
+#include <vm/vm_extern.h>
+
+#include <machine/bus.h>
+#include <machine/cache.h>
+
+static struct bus_space generic_space = {
+	/* cookie */
+	(void *) 0,
+
+	/* mapping/unmapping */
+	generic_bs_map,
+	generic_bs_unmap,
+	generic_bs_subregion,
+
+	/* allocation/deallocation */
+	NULL,
+	NULL,
+
+	/* barrier */
+	generic_bs_barrier,
+
+	/* read (single) */
+	generic_bs_r_1,
+	generic_bs_r_2,
+	generic_bs_r_4,
+	NULL,
+
+	/* read multiple */
+	generic_bs_rm_1,
+	generic_bs_rm_2,
+	generic_bs_rm_4,
+	NULL,
+
+	/* read region */
+	generic_bs_rr_1,
+	generic_bs_rr_2,
+	generic_bs_rr_4,
+	NULL,
+
+	/* write (single) */
+	generic_bs_w_1,
+	generic_bs_w_2,
+	generic_bs_w_4,
+	NULL,
+
+	/* write multiple */
+	generic_bs_wm_1,
+	generic_bs_wm_2,
+	generic_bs_wm_4,
+	NULL,
+
+	/* write region */
+	NULL,
+	generic_bs_wr_2,
+	generic_bs_wr_4,
+	NULL,
+
+	/* set multiple */
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+
+	/* set region */
+	NULL,
+	generic_bs_sr_2,
+	generic_bs_sr_4,
+	NULL,
+
+	/* copy */
+	NULL,
+	generic_bs_c_2,
+	NULL,
+	NULL,
+
+	/* read (single) stream */
+	generic_bs_r_1,
+	generic_bs_r_2,
+	generic_bs_r_4,
+	NULL,
+
+	/* read multiple stream */
+	generic_bs_rm_1,
+	generic_bs_rm_2,
+	generic_bs_rm_4,
+	NULL,
+
+	/* read region stream */
+	generic_bs_rr_1,
+	generic_bs_rr_2,
+	generic_bs_rr_4,
+	NULL,
+
+	/* write (single) stream */
+	generic_bs_w_1,
+	generic_bs_w_2,
+	generic_bs_w_4,
+	NULL,
+
+	/* write multiple stream */
+	generic_bs_wm_1,
+	generic_bs_wm_2,
+	generic_bs_wm_4,
+	NULL,
+
+	/* write region stream */
+	NULL,
+	generic_bs_wr_2,
+	generic_bs_wr_4,
+	NULL,
+};
+
+/* generic bus_space tag */
+bus_space_tag_t mips_bus_space_generic = &generic_space;
+
+int
+generic_bs_map(void *t __unused, bus_addr_t addr,
+	      bus_size_t size __unused, int flags __unused,
+	      bus_space_handle_t *bshp)
+{
+
+	*bshp = addr;
+	return (0);
+}
+
+void
+generic_bs_unmap(void *t __unused, bus_space_handle_t bh __unused,
+	      bus_size_t size __unused)
+{
+
+	/* Do nothing */
+}
+
+int
+generic_bs_subregion(void *t __unused, bus_space_handle_t handle __unused,
+	      bus_size_t offset __unused, bus_size_t size __unused,
+	      bus_space_handle_t *nhandle __unused)
+{
+
+	printf("SUBREGION?!?!?!\n");
+	/* Do nothing */
+	return (0);
+}
+
+u_int8_t
+generic_bs_r_1(void *t, bus_space_handle_t handle,
+    bus_size_t offset)
+{
+
+	return (readb(handle + offset));
+}
+
+u_int16_t
+generic_bs_r_2(void *t, bus_space_handle_t handle,
+    bus_size_t offset)
+{
+
+	return (readw(handle + offset));
+}
+
+u_int32_t
+generic_bs_r_4(void *t, bus_space_handle_t handle,
+    bus_size_t offset)
+{
+
+	return (readl(handle + offset));
+}
+
+
+void
+generic_bs_rm_1(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int8_t *addr, size_t count)
+{
+
+	while (count--)
+		*addr++ = readb(bsh + offset);
+}
+
+void
+generic_bs_rm_2(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int16_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--)
+		*addr++ = readw(baddr);
+}
+
+void
+generic_bs_rm_4(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int32_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--)
+		*addr++ = readl(baddr);
+}
+
+
+/*
+ * Read `count' 1, 2, 4, or 8 byte quantities from bus space
+ * described by tag/handle and starting at `offset' and copy into
+ * buffer provided.
+ */
+void
+generic_bs_rr_1(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int8_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--) {
+		*addr++ = readb(baddr);
+		baddr += 1;
+	}
+}
+
+void
+generic_bs_rr_2(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int16_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--) {
+		*addr++ = readw(baddr);
+		baddr += 2;
+	}
+}
+
+void
+generic_bs_rr_4(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int32_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--) {
+		*addr++ = readl(baddr);
+		baddr += 4;
+	}
+}
+
+/*
+ * Write the 1, 2, 4, or 8 byte value `value' to bus space
+ * described by tag/handle/offset.
+ */
+void
+generic_bs_w_1(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int8_t value)
+{
+
+	writeb(bsh + offset, value);
+}
+
+void
+generic_bs_w_2(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int16_t value)
+{
+
+	writew(bsh + offset, value);
+}
+
+void
+generic_bs_w_4(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int32_t value)
+{
+
+	writel(bsh + offset, value);
+}
+
+/*
+ * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
+ * provided to bus space described by tag/handle/offset.
+ */
+void
+generic_bs_wm_1(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, const u_int8_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--)
+		writeb(baddr, *addr++);
+}
+
+void
+generic_bs_wm_2(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, const u_int16_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--)
+		writew(baddr, *addr++);
+}
+
+void
+generic_bs_wm_4(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, const u_int32_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--)
+		writel(baddr, *addr++);
+}
+
+/*
+ * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
+ * to bus space described by tag/handle starting at `offset'.
+ */
+void
+generic_bs_wr_1(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, const u_int8_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--) {
+		writeb(baddr, *addr++);
+		baddr += 1;
+	}
+}
+
+void
+generic_bs_wr_2(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, const u_int16_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--) {
+		writew(baddr, *addr++);
+		baddr += 2;
+	}
+}
+
+void
+generic_bs_wr_4(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, const u_int32_t *addr, size_t count)
+{
+	bus_addr_t baddr = bsh + offset;
+
+	while (count--) {
+		writel(baddr, *addr++);
+		baddr += 4;
+	}
+}
+
+/*
+ * Write the 1, 2, 4, or 8 byte value `val' to bus space described
+ * by tag/handle/offset `count' times.
+ */
+void
+generic_bs_sm_1(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int8_t value, size_t count)
+{
+	bus_addr_t addr = bsh + offset;
+
+	while (count--)
+		writeb(addr, value);
+}
+
+void
+generic_bs_sm_2(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int16_t value, size_t count)
+{
+	bus_addr_t addr = bsh + offset;
+
+	while (count--)
+		writew(addr, value);
+}
+
+void
+generic_bs_sm_4(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int32_t value, size_t count)
+{
+	bus_addr_t addr = bsh + offset;
+
+	while (count--)
+		writel(addr, value);
+}
+
+/*
+ * Write `count' 1, 2, 4, or 8 byte value `val' to bus space described
+ * by tag/handle starting at `offset'.
+ */
+void
+generic_bs_sr_1(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int8_t value, size_t count)
+{
+	bus_addr_t addr = bsh + offset;
+
+	for (; count != 0; count--, addr++)
+		writeb(addr, value);
+}
+
+void
+generic_bs_sr_2(void *t, bus_space_handle_t bsh,
+		       bus_size_t offset, u_int16_t value, size_t count)
+{
+	bus_addr_t addr = bsh + offset;
+
+	for (; count != 0; count--, addr += 2)
+		writew(addr, value);
+}
+
+void
+generic_bs_sr_4(void *t, bus_space_handle_t bsh,
+    bus_size_t offset, u_int32_t value, size_t count)
+{
+	bus_addr_t addr = bsh + offset;
+
+	for (; count != 0; count--, addr += 4)
+		writel(addr, value);
+}
+
+/*
+ * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
+ * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
+ */
+void
+generic_bs_c_1(void *t, bus_space_handle_t bsh1,
+    bus_size_t off1, bus_space_handle_t bsh2,
+    bus_size_t off2, size_t count)
+{
+	bus_addr_t addr1 = bsh1 + off1;
+	bus_addr_t addr2 = bsh2 + off2;
+
+	if (addr1 >= addr2) {
+		/* src after dest: copy forward */
+		for (; count != 0; count--, addr1++, addr2++)
+			writeb(addr2, readb(addr1));
+	} else {
+		/* dest after src: copy backwards */
+		for (addr1 += (count - 1), addr2 += (count - 1);
+		    count != 0; count--, addr1--, addr2--)
+			writeb(addr2, readb(addr1));
+	}
+}
+
+void
+generic_bs_c_2(void *t, bus_space_handle_t bsh1,
+    bus_size_t off1, bus_space_handle_t bsh2,
+    bus_size_t off2, size_t count)
+{
+	bus_addr_t addr1 = bsh1 + off1;
+	bus_addr_t addr2 = bsh2 + off2;
+
+	if (addr1 >= addr2) {
+		/* src after dest: copy forward */
+		for (; count != 0; count--, addr1 += 2, addr2 += 2)
+			writew(addr2, readw(addr1));
+	} else {
+		/* dest after src: copy backwards */
+		for (addr1 += 2 * (count - 1), addr2 += 2 * (count - 1);
+		    count != 0; count--, addr1 -= 2, addr2 -= 2)
+			writew(addr2, readw(addr1));
+	}
+}
+
+void
+generic_bs_c_4(void *t, bus_space_handle_t bsh1,
+    bus_size_t off1, bus_space_handle_t bsh2,
+    bus_size_t off2, size_t count)
+{
+	bus_addr_t addr1 = bsh1 + off1;
+	bus_addr_t addr2 = bsh2 + off2;
+
+	if (addr1 >= addr2) {
+		/* src after dest: copy forward */
+		for (; count != 0; count--, addr1 += 4, addr2 += 4)
+			writel(addr2, readl(addr1));
+	} else {
+		/* dest after src: copy backwards */
+		for (addr1 += 4 * (count - 1), addr2 += 4 * (count - 1);
+		    count != 0; count--, addr1 -= 4, addr2 -= 4)
+			writel(addr2, readl(addr1));
+	}
+}
+
+void
+generic_bs_barrier(void *t __unused, 
+		bus_space_handle_t bsh __unused,
+		bus_size_t offset __unused, bus_size_t len __unused, 
+		int flags)
+{
+#if 0
+	if (flags & BUS_SPACE_BARRIER_WRITE)
+		mips_dcache_wbinv_all();
+#endif
+}
diff -I '.*' -Naur releng8/sys/mips/mips/busdma_machdep.c svn/mips/sys/mips/mips/busdma_machdep.c
--- releng8/src/sys/mips/mips/busdma_machdep.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/busdma_machdep.c	2009-08-04 10:47:01.000000000 -0700
@@ -23,49 +23,15 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
+ *   From i386/busdma_machdep.c,v 1.26 2002/04/19 22:58:09 alfred
  */
 
-/*-
- * Copyright (c) 1997, 1998, 2001 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
- * NASA Ames Research Center.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the NetBSD
- *	Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*	$NetBSD: bus_dma.c,v 1.17 2006/03/01 12:38:11 yamt Exp $	*/
-
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/mips/mips/busdma_machdep.c,v 1.5.2.1 2009/08/03 08:13:06 kensmith Exp $");
+__FBSDID("$FreeBSD: projects/mips/sys/mips/mips/busdma_machdep.c 195983 2009-07-30 23:29:59Z gonzo $");
+
+/*
+ * MIPS bus dma support routines
+ */
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -79,6 +45,7 @@
 #include <sys/uio.h>
 #include <sys/ktr.h>
 #include <sys/kernel.h>
+#include <sys/sysctl.h>
 
 #include <vm/vm.h>
 #include <vm/vm_page.h>
@@ -88,6 +55,13 @@
 #include <machine/bus.h>
 #include <machine/cache.h>
 #include <machine/cpufunc.h>
+#include <machine/md_var.h>
+
+#define MAX_BPAGES 64
+#define BUS_DMA_COULD_BOUNCE	BUS_DMA_BUS3
+#define BUS_DMA_MIN_ALLOC_COMP	BUS_DMA_BUS4
+
+struct bounce_zone;
 
 struct bus_dma_tag {
 	bus_dma_tag_t		parent;
@@ -105,19 +79,59 @@
 	int			map_count;
 	bus_dma_lock_t		*lockfunc;
 	void			*lockfuncarg;
-	/* XXX: machine-dependent fields */
-	vm_offset_t		_physbase;
-	vm_offset_t		_wbase;
-	vm_offset_t		_wsize;
+	struct bounce_zone *bounce_zone;
+};
+
+struct bounce_page {
+	vm_offset_t	vaddr;		/* kva of bounce buffer */
+	vm_offset_t	vaddr_nocache;	/* kva of bounce buffer uncached */
+	bus_addr_t	busaddr;	/* Physical address */
+	vm_offset_t	datavaddr;	/* kva of client data */
+	bus_size_t	datacount;	/* client data count */
+	STAILQ_ENTRY(bounce_page) links;
+};
+
+int busdma_swi_pending;
+
+struct bounce_zone {
+	STAILQ_ENTRY(bounce_zone) links;
+	STAILQ_HEAD(bp_list, bounce_page) bounce_page_list;
+	int		total_bpages;
+	int		free_bpages;
+	int		reserved_bpages;
+	int		active_bpages;
+	int		total_bounced;
+	int		total_deferred;
+	int		map_count;
+	bus_size_t	alignment;
+	bus_addr_t	lowaddr;
+	char		zoneid[8];
+	char		lowaddrid[20];
+	struct sysctl_ctx_list sysctl_tree;
+	struct sysctl_oid *sysctl_tree_top;
 };
 
+static struct mtx bounce_lock;
+static int total_bpages;
+static int busdma_zonecount;
+static STAILQ_HEAD(, bounce_zone) bounce_zone_list;
+
+SYSCTL_NODE(_hw, OID_AUTO, busdma, CTLFLAG_RD, 0, "Busdma parameters");
+SYSCTL_INT(_hw_busdma, OID_AUTO, total_bpages, CTLFLAG_RD, &total_bpages, 0,
+	   "Total bounce pages");
+
 #define DMAMAP_LINEAR		0x1
 #define DMAMAP_MBUF		0x2
 #define DMAMAP_UIO		0x4
-#define DMAMAP_ALLOCATED	0x10
 #define DMAMAP_TYPE_MASK	(DMAMAP_LINEAR|DMAMAP_MBUF|DMAMAP_UIO)
 #define DMAMAP_COHERENT		0x8
+#define DMAMAP_ALLOCATED	0x10
+#define DMAMAP_MALLOCUSED	0x20
+
 struct bus_dmamap {
+	struct bp_list	bpages;
+	int		pagesneeded;
+	int		pagesreserved;
         bus_dma_tag_t	dmat;
 	int		flags;
 	void 		*buffer;
@@ -125,8 +139,15 @@
 	void		*allocbuffer;
 	TAILQ_ENTRY(bus_dmamap)	freelist;
 	int		len;
+	STAILQ_ENTRY(bus_dmamap) links;
+	bus_dmamap_callback_t *callback;
+	void		      *callback_arg;
+
 };
 
+static STAILQ_HEAD(, bus_dmamap) bounce_map_waitinglist;
+static STAILQ_HEAD(, bus_dmamap) bounce_map_callbacklist;
+
 static TAILQ_HEAD(,bus_dmamap) dmamap_freelist = 
 	TAILQ_HEAD_INITIALIZER(dmamap_freelist);
 
@@ -137,6 +158,45 @@
 
 MTX_SYSINIT(busdma_mtx, &busdma_mtx, "busdma lock", MTX_DEF);
 
+static void init_bounce_pages(void *dummy);
+static int alloc_bounce_zone(bus_dma_tag_t dmat);
+static int alloc_bounce_pages(bus_dma_tag_t dmat, u_int numpages);
+static int reserve_bounce_pages(bus_dma_tag_t dmat, bus_dmamap_t map,
+				int commit);
+static bus_addr_t add_bounce_page(bus_dma_tag_t dmat, bus_dmamap_t map,
+				   vm_offset_t vaddr, bus_size_t size);
+static void free_bounce_page(bus_dma_tag_t dmat, struct bounce_page *bpage);
+
+/* Default tag, as most drivers provide no parent tag. */
+bus_dma_tag_t mips_root_dma_tag;
+
+/*
+ * Return true if a match is made.
+ *
+ * To find a match walk the chain of bus_dma_tag_t's looking for 'paddr'.
+ *
+ * If paddr is within the bounds of the dma tag then call the filter callback
+ * to check for a match, if there is no filter callback then assume a match.
+ */
+static int
+run_filter(bus_dma_tag_t dmat, bus_addr_t paddr)
+{
+	int retval;
+
+	retval = 0;
+
+	do {
+		if (((paddr > dmat->lowaddr && paddr <= dmat->highaddr)
+		 || ((paddr & (dmat->alignment - 1)) != 0))
+		 && (dmat->filter == NULL
+		  || (*dmat->filter)(dmat->filterarg, paddr) != 0))
+			retval = 1;
+
+		dmat = dmat->parent;		
+	} while (retval == 0 && dmat != NULL);
+	return (retval);
+}
+
 static void
 mips_dmamap_freelist_init(void *dummy)
 {
@@ -157,6 +217,19 @@
     bus_dmamap_t map, void *buf, bus_size_t buflen, struct pmap *pmap,
     int flags, vm_offset_t *lastaddrp, int *segp);
 
+static __inline int
+_bus_dma_can_bounce(vm_offset_t lowaddr, vm_offset_t highaddr)
+{
+	int i;
+	for (i = 0; phys_avail[i] && phys_avail[i + 1]; i += 2) {
+		if ((lowaddr >= phys_avail[i] && lowaddr <= phys_avail[i + 1])
+		    || (lowaddr < phys_avail[i] && 
+		    highaddr > phys_avail[i]))
+			return (1);
+	}
+	return (0);
+}
+
 /*
  * Convenience function for manipulating driver locks from busdma (during
  * busdma_swi, for example).  Drivers that don't provide their own locks
@@ -213,6 +286,7 @@
 			map->flags = DMAMAP_ALLOCATED;
 	} else
 		map->flags = 0;
+	STAILQ_INIT(&map->bpages);
 	return (map);
 }
 
@@ -228,6 +302,11 @@
 	}
 }
 
+/*
+ * Allocate a device specific dma_tag.
+ */
+#define SEG_NB 1024
+
 int
 bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment,
 		   bus_size_t boundary, bus_addr_t lowaddr,
@@ -238,16 +317,12 @@
 {
 	bus_dma_tag_t newtag;
 	int error = 0;
-
-	/* Basic sanity checking */
-	if (boundary != 0 && boundary < maxsegsz)
-		maxsegsz = boundary;
-
 	/* Return a NULL tag on failure */
 	*dmat = NULL;
+	if (!parent)
+		parent = mips_root_dma_tag;
 
-	newtag = (bus_dma_tag_t)malloc(sizeof(*newtag), M_DEVBUF,
-	    M_ZERO | M_NOWAIT);
+	newtag = (bus_dma_tag_t)malloc(sizeof(*newtag), M_DEVBUF, M_NOWAIT);
 	if (newtag == NULL) {
 		CTR4(KTR_BUSDMA, "%s returned tag %p tag flags 0x%x error %d",
 		    __func__, newtag, 0, error);
@@ -257,21 +332,16 @@
 	newtag->parent = parent;
 	newtag->alignment = alignment;
 	newtag->boundary = boundary;
-	newtag->lowaddr = trunc_page((vm_paddr_t)lowaddr) + (PAGE_SIZE - 1);
-	newtag->highaddr = trunc_page((vm_paddr_t)highaddr) +
-	    (PAGE_SIZE - 1);
+	newtag->lowaddr = trunc_page((vm_offset_t)lowaddr) + (PAGE_SIZE - 1);
+	newtag->highaddr = trunc_page((vm_offset_t)highaddr) + (PAGE_SIZE - 1);
 	newtag->filter = filter;
 	newtag->filterarg = filterarg;
-	newtag->maxsize = maxsize;
-	newtag->nsegments = nsegments;
+        newtag->maxsize = maxsize;
+        newtag->nsegments = nsegments;
 	newtag->maxsegsz = maxsegsz;
 	newtag->flags = flags;
 	newtag->ref_count = 1; /* Count ourself */
 	newtag->map_count = 0;
-	newtag->_wbase = 0;
-	newtag->_physbase = 0;
-	/* XXXMIPS: Should we limit window size to amount of physical memory */
-	newtag->_wsize = MIPS_KSEG1_START - MIPS_KSEG0_START;
 	if (lockfunc != NULL) {
 		newtag->lockfunc = lockfunc;
 		newtag->lockfuncarg = lockfuncarg;
@@ -279,36 +349,68 @@
 		newtag->lockfunc = dflt_lock;
 		newtag->lockfuncarg = NULL;
 	}
-
-	/* Take into account any restrictions imposed by our parent tag */
-	if (parent != NULL) {
-		newtag->lowaddr = MIN(parent->lowaddr, newtag->lowaddr);
-		newtag->highaddr = MAX(parent->highaddr, newtag->highaddr);
+        /*
+	 * Take into account any restrictions imposed by our parent tag
+	 */
+        if (parent != NULL) {
+                newtag->lowaddr = min(parent->lowaddr, newtag->lowaddr);
+                newtag->highaddr = max(parent->highaddr, newtag->highaddr);
 		if (newtag->boundary == 0)
 			newtag->boundary = parent->boundary;
 		else if (parent->boundary != 0)
-			newtag->boundary = MIN(parent->boundary,
+                	newtag->boundary = min(parent->boundary,
 					       newtag->boundary);
-		if (newtag->filter == NULL) {
-			/*
-			 * Short circuit looking at our parent directly
-			 * since we have encapsulated all of its information
-			 */
-			newtag->filter = parent->filter;
-			newtag->filterarg = parent->filterarg;
-			newtag->parent = parent->parent;
+		if ((newtag->filter != NULL) ||
+		    ((parent->flags & BUS_DMA_COULD_BOUNCE) != 0))
+			newtag->flags |= BUS_DMA_COULD_BOUNCE;
+                if (newtag->filter == NULL) {
+                        /*
+                         * Short circuit looking at our parent directly
+                         * since we have encapsulated all of its information
+                         */
+                        newtag->filter = parent->filter;
+                        newtag->filterarg = parent->filterarg;
+                        newtag->parent = parent->parent;
 		}
 		if (newtag->parent != NULL)
 			atomic_add_int(&parent->ref_count, 1);
 	}
+	if (_bus_dma_can_bounce(newtag->lowaddr, newtag->highaddr)
+	 || newtag->alignment > 1)
+		newtag->flags |= BUS_DMA_COULD_BOUNCE;
+
+	if (((newtag->flags & BUS_DMA_COULD_BOUNCE) != 0) &&
+	    (flags & BUS_DMA_ALLOCNOW) != 0) {
+		struct bounce_zone *bz;
+
+		/* Must bounce */
+
+		if ((error = alloc_bounce_zone(newtag)) != 0) {
+			free(newtag, M_DEVBUF);
+			return (error);
+		}
+		bz = newtag->bounce_zone;
 
-	if (error != 0) {
+		if (ptoa(bz->total_bpages) < maxsize) {
+			int pages;
+
+			pages = atop(maxsize) - bz->total_bpages;
+
+			/* Add pages to our bounce pool */
+			if (alloc_bounce_pages(newtag, pages) < pages)
+				error = ENOMEM;
+		}
+		/* Performed initial allocation */
+		newtag->flags |= BUS_DMA_MIN_ALLOC_COMP;
+	} else
+		newtag->bounce_zone = NULL;
+	if (error != 0)
 		free(newtag, M_DEVBUF);
-	} else {
+	else
 		*dmat = newtag;
-	}
 	CTR4(KTR_BUSDMA, "%s returned tag %p tag flags 0x%x error %d",
 	    __func__, newtag, (newtag != NULL ? newtag->flags : 0), error);
+
 	return (error);
 }
 
@@ -346,6 +448,7 @@
         return (0);
 }
 
+#include <sys/kdb.h>
 /*
  * Allocate a handle for mapping from kva/uva/physical
  * address space into bus device space.
@@ -354,9 +457,7 @@
 bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp)
 {
 	bus_dmamap_t newmap;
-#ifdef KTR
 	int error = 0;
-#endif
 
 	newmap = _busdma_alloc_dmamap();
 	if (newmap == NULL) {
@@ -365,13 +466,64 @@
 	}
 	*mapp = newmap;
 	newmap->dmat = dmat;
+	newmap->allocbuffer = NULL;
 	dmat->map_count++;
 
+	/*
+	 * Bouncing might be required if the driver asks for an active
+	 * exclusion region, a data alignment that is stricter than 1, and/or
+	 * an active address boundary.
+	 */
+	if (dmat->flags & BUS_DMA_COULD_BOUNCE) {
+
+		/* Must bounce */
+		struct bounce_zone *bz;
+		int maxpages;
+
+		if (dmat->bounce_zone == NULL) {
+			if ((error = alloc_bounce_zone(dmat)) != 0) {
+				_busdma_free_dmamap(newmap);
+				*mapp = NULL;
+				return (error);
+			}
+		}
+		bz = dmat->bounce_zone;
+
+		/* Initialize the new map */
+		STAILQ_INIT(&((*mapp)->bpages));
+
+		/*
+		 * Attempt to add pages to our pool on a per-instance
+		 * basis up to a sane limit.
+		 */
+		maxpages = MAX_BPAGES;
+		if ((dmat->flags & BUS_DMA_MIN_ALLOC_COMP) == 0
+		 || (bz->map_count > 0 && bz->total_bpages < maxpages)) {
+			int pages;
+
+			pages = MAX(atop(dmat->maxsize), 1);
+			pages = MIN(maxpages - bz->total_bpages, pages);
+			pages = MAX(pages, 1);
+			if (alloc_bounce_pages(dmat, pages) < pages)
+				error = ENOMEM;
+
+			if ((dmat->flags & BUS_DMA_MIN_ALLOC_COMP) == 0) {
+				if (error == 0)
+					dmat->flags |= BUS_DMA_MIN_ALLOC_COMP;
+			} else {
+				error = 0;
+			}
+		}
+		bz->map_count++;
+	}
+
+	if (flags & BUS_DMA_COHERENT)
+	    newmap->flags |= DMAMAP_COHERENT;
+
 	CTR4(KTR_BUSDMA, "%s: tag %p tag flags 0x%x error %d",
 	    __func__, dmat, dmat->flags, error);
 
 	return (0);
-
 }
 
 /*
@@ -381,7 +533,15 @@
 int
 bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)
 {
+
 	_busdma_free_dmamap(map);
+	if (STAILQ_FIRST(&map->bpages) != NULL) {
+		CTR3(KTR_BUSDMA, "%s: tag %p error %d",
+		    __func__, dmat, EBUSY);
+		return (EBUSY);
+	}
+	if (dmat->bounce_zone)
+		dmat->bounce_zone->map_count--;
         dmat->map_count--;
 	CTR2(KTR_BUSDMA, "%s: tag %p error 0", __func__, dmat);
         return (0);
@@ -416,9 +576,16 @@
 	dmat->map_count++;
 	*mapp = newmap;
 	newmap->dmat = dmat;
+
+	if (flags & BUS_DMA_COHERENT)
+	    newmap->flags |= DMAMAP_COHERENT;
 	
-        if (dmat->maxsize <= PAGE_SIZE) {
+        if (dmat->maxsize <= PAGE_SIZE &&
+	   (dmat->alignment < dmat->maxsize) &&
+	   !_bus_dma_can_bounce(dmat->lowaddr, dmat->highaddr) && 
+	   !(flags & BUS_DMA_COHERENT)) {
                 *vaddr = malloc(dmat->maxsize, M_DEVBUF, mflags);
+		newmap->flags |= DMAMAP_MALLOCUSED;
         } else {
                 /*
                  * XXX Use Contigmalloc until it is merged into this facility
@@ -440,7 +607,7 @@
 		   maxphys = dmat->lowaddr;
 		 }
                 *vaddr = contigmalloc(dmat->maxsize, M_DEVBUF, mflags,
-                    0ul, maxphys, dmat->alignment? dmat->alignment : 1ul,
+                    0ul, dmat->lowaddr, dmat->alignment? dmat->alignment : 1ul,
                     dmat->boundary);
         }
         if (*vaddr == NULL) {
@@ -451,6 +618,7 @@
 		*mapp = NULL;
                 return (ENOMEM);
 	}
+
 	if (flags & BUS_DMA_COHERENT) {
 		void *tmpaddr = (void *)*vaddr;
 
@@ -463,10 +631,10 @@
 			*vaddr = tmpaddr;
 		} else
 			newmap->origbuffer = newmap->allocbuffer = NULL;
-	} else 
+	} else
 		newmap->origbuffer = newmap->allocbuffer = NULL;
-        return (0);
 
+        return (0);
 }
 
 /*
@@ -481,15 +649,69 @@
 		    ("Trying to freeing the wrong DMA buffer"));
 		vaddr = map->origbuffer;
 	}
-        if (dmat->maxsize <= PAGE_SIZE)
+
+        if (map->flags & DMAMAP_MALLOCUSED)
 		free(vaddr, M_DEVBUF);
-        else {
+        else
 		contigfree(vaddr, dmat->maxsize, M_DEVBUF);
-	}
+
 	dmat->map_count--;
 	_busdma_free_dmamap(map);
 	CTR3(KTR_BUSDMA, "%s: tag %p flags 0x%x", __func__, dmat, dmat->flags);
+}
+
+static int
+_bus_dmamap_count_pages(bus_dma_tag_t dmat, bus_dmamap_t map, pmap_t pmap,
+    void *buf, bus_size_t buflen, int flags)
+{
+	vm_offset_t vaddr;
+	vm_offset_t vendaddr;
+	bus_addr_t paddr;
+
+	if ((map->pagesneeded == 0)) {
+		CTR3(KTR_BUSDMA, "lowaddr= %d, boundary= %d, alignment= %d",
+		    dmat->lowaddr, dmat->boundary, dmat->alignment);
+		CTR2(KTR_BUSDMA, "map= %p, pagesneeded= %d",
+		    map, map->pagesneeded);
+		/*
+		 * Count the number of bounce pages
+		 * needed in order to complete this transfer
+		 */
+		vaddr = trunc_page((vm_offset_t)buf);
+		vendaddr = (vm_offset_t)buf + buflen;
 
+		while (vaddr < vendaddr) {
+			KASSERT(kernel_pmap == pmap, ("pmap is not kernel pmap"));
+			paddr = pmap_kextract(vaddr);
+			if (((dmat->flags & BUS_DMA_COULD_BOUNCE) != 0) &&
+			    run_filter(dmat, paddr) != 0)
+				map->pagesneeded++;
+			vaddr += PAGE_SIZE;
+		}
+		CTR1(KTR_BUSDMA, "pagesneeded= %d\n", map->pagesneeded);
+	}
+
+	/* Reserve Necessary Bounce Pages */
+	if (map->pagesneeded != 0) {
+		mtx_lock(&bounce_lock);
+		if (flags & BUS_DMA_NOWAIT) {
+			if (reserve_bounce_pages(dmat, map, 0) != 0) {
+				mtx_unlock(&bounce_lock);
+				return (ENOMEM);
+			}
+		} else {
+			if (reserve_bounce_pages(dmat, map, 1) != 0) {
+				/* Queue us for resources */
+				STAILQ_INSERT_TAIL(&bounce_map_waitinglist,
+				    map, links);
+				mtx_unlock(&bounce_lock);
+				return (EINPROGRESS);
+			}
+		}
+		mtx_unlock(&bounce_lock);
+	}
+
+	return (0);
 }
 
 /*
@@ -504,8 +726,7 @@
     int flags, vm_offset_t *lastaddrp, int *segp)
 {
 	bus_size_t sgsize;
-	bus_size_t bmask;
-	vm_offset_t curaddr, lastaddr;
+	bus_addr_t curaddr, lastaddr, baddr, bmask;
 	vm_offset_t vaddr = (vm_offset_t)buf;
 	int seg;
 	int error = 0;
@@ -513,36 +734,48 @@
 	lastaddr = *lastaddrp;
 	bmask = ~(dmat->boundary - 1);
 
+	if ((dmat->flags & BUS_DMA_COULD_BOUNCE) != 0) {
+		error = _bus_dmamap_count_pages(dmat, map, pmap, buf, buflen,
+		    flags);
+		if (error)
+			return (error);
+	}
+	CTR3(KTR_BUSDMA, "lowaddr= %d boundary= %d, "
+	    "alignment= %d", dmat->lowaddr, dmat->boundary, dmat->alignment);
+
 	for (seg = *segp; buflen > 0 ; ) {
 		/*
 		 * Get the physical address for this segment.
+		 *
+		 * XXX Don't support checking for coherent mappings
+		 * XXX in user address space.
 		 */
 		KASSERT(kernel_pmap == pmap, ("pmap is not kernel pmap"));
 		curaddr = pmap_kextract(vaddr);
 
 		/*
-		 * If we're beyond the current DMA window, indicate
-		 * that and try to fall back onto something else.
-		 */
-		if (curaddr < dmat->_physbase ||
-		    curaddr >= (dmat->_physbase + dmat->_wsize))
-			return (EINVAL);
-
-		/*
-		 * In a valid DMA range.  Translate the physical
-		 * memory address to an address in the DMA window.
-		 */
-		curaddr = (curaddr - dmat->_physbase) + dmat->_wbase;
-
-
-		/*
 		 * Compute the segment size, and adjust counts.
 		 */
 		sgsize = PAGE_SIZE - ((u_long)curaddr & PAGE_MASK);
+		if (sgsize > dmat->maxsegsz)
+			sgsize = dmat->maxsegsz;
 		if (buflen < sgsize)
 			sgsize = buflen;
 
 		/*
+		 * Make sure we don't cross any boundaries.
+		 */
+		if (dmat->boundary > 0) {
+			baddr = (curaddr + dmat->boundary) & bmask;
+			if (sgsize > (baddr - curaddr))
+				sgsize = (baddr - curaddr);
+		}
+		if (((dmat->flags & BUS_DMA_COULD_BOUNCE) != 0) &&
+		    map->pagesneeded != 0 && run_filter(dmat, curaddr)) {
+			curaddr = add_bounce_page(dmat, map, vaddr, sgsize);
+		}
+
+		/*
 		 * Insert chunk into a segment, coalescing with
 		 * the previous segment if possible.
 		 */
@@ -574,9 +807,8 @@
 	 * Did we fit?
 	 */
 	if (buflen != 0)
-		error = EFBIG;
-
-	return error;
+		error = EFBIG; /* XXX better return value here? */
+	return (error);
 }
 
 /*
@@ -597,14 +829,17 @@
 
 	KASSERT(dmat != NULL, ("dmatag is NULL"));
 	KASSERT(map != NULL, ("dmamap is NULL"));
+	map->callback = callback;
+	map->callback_arg = callback_arg;
 	map->flags &= ~DMAMAP_TYPE_MASK;
-	map->flags |= DMAMAP_LINEAR|DMAMAP_COHERENT;
+	map->flags |= DMAMAP_LINEAR;
 	map->buffer = buf;
 	map->len = buflen;
 	error = bus_dmamap_load_buffer(dmat,
 	    dm_segments, map, buf, buflen, kernel_pmap,
 	    flags, &lastaddr, &nsegs);
-
+	if (error == EINPROGRESS)
+		return (error);
 	if (error)
 		(*callback)(callback_arg, NULL, 0, error);
 	else
@@ -613,8 +848,7 @@
 	CTR5(KTR_BUSDMA, "%s: tag %p tag flags 0x%x error %d nsegs %d",
 	    __func__, dmat, dmat->flags, nsegs + 1, error);
 
-	return (0);
-
+	return (error);
 }
 
 /*
@@ -635,10 +869,9 @@
 	M_ASSERTPKTHDR(m0);
 
 	map->flags &= ~DMAMAP_TYPE_MASK;
-	map->flags |= DMAMAP_MBUF | DMAMAP_COHERENT;
+	map->flags |= DMAMAP_MBUF;
 	map->buffer = m0;
 	map->len = 0;
-
 	if (m0->m_pkthdr.len <= dmat->maxsize) {
 		vm_offset_t lastaddr = 0;
 		struct mbuf *m;
@@ -676,16 +909,14 @@
 			int flags)
 {
 	int error = 0;
-
 	M_ASSERTPKTHDR(m0);
 
 	flags |= BUS_DMA_NOWAIT;
 	*nsegs = -1;
 	map->flags &= ~DMAMAP_TYPE_MASK;
-	map->flags |= DMAMAP_MBUF | DMAMAP_COHERENT;
-	map->buffer = m0;
+	map->flags |= DMAMAP_MBUF;
+	map->buffer = m0;			
 	map->len = 0;
-
 	if (m0->m_pkthdr.len <= dmat->maxsize) {
 		vm_offset_t lastaddr = 0;
 		struct mbuf *m;
@@ -693,8 +924,9 @@
 		for (m = m0; m != NULL && error == 0; m = m->m_next) {
 			if (m->m_len > 0) {
 				error = bus_dmamap_load_buffer(dmat, segs, map,
-				    m->m_data, m->m_len, 
-				    kernel_pmap, flags, &lastaddr, nsegs);
+						m->m_data, m->m_len,
+						kernel_pmap, flags, &lastaddr,
+						nsegs);
 				map->len += m->m_len;
 			}
 		}
@@ -702,12 +934,11 @@
 		error = EINVAL;
 	}
 
+	/* XXX FIXME: Having to increment nsegs is really annoying */
 	++*nsegs;
 	CTR5(KTR_BUSDMA, "%s: tag %p tag flags 0x%x error %d nsegs %d",
 	    __func__, dmat, dmat->flags, error, *nsegs);
-
 	return (error);
-
 }
 
 /*
@@ -718,9 +949,65 @@
     bus_dmamap_callback2_t *callback, void *callback_arg,
     int flags)
 {
+	vm_offset_t lastaddr = 0;
+#ifdef __CC_SUPPORTS_DYNAMIC_ARRAY_INIT
+	bus_dma_segment_t dm_segments[dmat->nsegments];
+#else
+	bus_dma_segment_t dm_segments[BUS_DMAMAP_NSEGS];
+#endif
+	int nsegs, i, error;
+	bus_size_t resid;
+	struct iovec *iov;
+	struct pmap *pmap;
 
-	panic("Unimplemented %s at %s:%d\n", __func__, __FILE__, __LINE__);
-	return (0);
+	resid = uio->uio_resid;
+	iov = uio->uio_iov;
+	map->flags &= ~DMAMAP_TYPE_MASK;
+	map->flags |= DMAMAP_UIO;
+	map->buffer = uio;
+	map->len = 0;
+
+	if (uio->uio_segflg == UIO_USERSPACE) {
+		KASSERT(uio->uio_td != NULL,
+		    ("bus_dmamap_load_uio: USERSPACE but no proc"));
+		/* XXX: pmap = vmspace_pmap(uio->uio_td->td_proc->p_vmspace); */
+		panic("can't do it yet");
+	} else
+		pmap = kernel_pmap;
+
+	error = 0;
+	nsegs = -1;
+	for (i = 0; i < uio->uio_iovcnt && resid != 0 && !error; i++) {
+		/*
+		 * Now at the first iovec to load.  Load each iovec
+		 * until we have exhausted the residual count.
+		 */
+		bus_size_t minlen =
+		    resid < iov[i].iov_len ? resid : iov[i].iov_len;
+		caddr_t addr = (caddr_t) iov[i].iov_base;
+
+		if (minlen > 0) {
+			error = bus_dmamap_load_buffer(dmat, dm_segments, map,
+			    addr, minlen, pmap, flags, &lastaddr, &nsegs);
+
+			map->len += minlen;
+			resid -= minlen;
+		}
+	}
+
+	if (error) {
+		/* 
+		 * force "no valid mappings" on error in callback.
+		 */
+		(*callback)(callback_arg, dm_segments, 0, 0, error);
+	} else {
+		(*callback)(callback_arg, dm_segments, nsegs+1,
+		    uio->uio_resid, error);
+	}
+
+	CTR5(KTR_BUSDMA, "%s: tag %p tag flags 0x%x error %d nsegs %d",
+	    __func__, dmat, dmat->flags, error, nsegs + 1);
+	return (error);
 }
 
 /*
@@ -729,21 +1016,31 @@
 void
 _bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)
 {
+	struct bounce_page *bpage;
 
+	map->flags &= ~DMAMAP_TYPE_MASK;
+	while ((bpage = STAILQ_FIRST(&map->bpages)) != NULL) {
+		STAILQ_REMOVE_HEAD(&map->bpages, links);
+		free_bounce_page(dmat, bpage);
+	}
 	return;
 }
 
-static __inline void
+static void
 bus_dmamap_sync_buf(void *buf, int len, bus_dmasync_op_t op)
 {
-
 	switch (op) {
+	case BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE:
+	case BUS_DMASYNC_POSTREAD:
+		mips_dcache_inv_range((vm_offset_t)buf, len);
+		break;
+
 	case BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE:
 		mips_dcache_wbinv_range((vm_offset_t)buf, len);
 		break;
 
 	case BUS_DMASYNC_PREREAD:
-#if 1
+#if 0
 		mips_dcache_wbinv_range((vm_offset_t)buf, len);
 #else
 		mips_dcache_inv_range((vm_offset_t)buf, len);
@@ -756,6 +1053,51 @@
 	}
 }
 
+static void
+_bus_dmamap_sync_bp(bus_dma_tag_t dmat, bus_dmamap_t map, bus_dmasync_op_t op)
+{
+	struct bounce_page *bpage;
+
+	STAILQ_FOREACH(bpage, &map->bpages, links) {
+		if (op & BUS_DMASYNC_PREWRITE) {
+			bcopy((void *)bpage->datavaddr,
+			    (void *)(bpage->vaddr_nocache != 0 ? 
+				     bpage->vaddr_nocache : bpage->vaddr),
+			    bpage->datacount);
+			if (bpage->vaddr_nocache == 0) {
+				mips_dcache_wb_range(bpage->vaddr,
+				    bpage->datacount);
+			}
+			dmat->bounce_zone->total_bounced++;
+		}
+		if (op & BUS_DMASYNC_POSTREAD) {
+			if (bpage->vaddr_nocache == 0) {
+				mips_dcache_inv_range(bpage->vaddr,
+				    bpage->datacount);
+			}
+			bcopy((void *)(bpage->vaddr_nocache != 0 ? 
+	       		    bpage->vaddr_nocache : bpage->vaddr),
+			    (void *)bpage->datavaddr, bpage->datacount);
+			dmat->bounce_zone->total_bounced++;
+		}
+	}
+}
+
+static __inline int
+_bus_dma_buf_is_in_bp(bus_dmamap_t map, void *buf, int len)
+{
+	struct bounce_page *bpage;
+
+	STAILQ_FOREACH(bpage, &map->bpages, links) {
+		if ((vm_offset_t)buf >= bpage->datavaddr &&
+		    (vm_offset_t)buf + len <= bpage->datavaddr + 
+		    bpage->datacount)
+			return (1);
+	}
+	return (0);
+
+}
+
 void
 _bus_dmamap_sync(bus_dma_tag_t dmat, bus_dmamap_t map, bus_dmasync_op_t op)
 {
@@ -764,51 +1106,23 @@
 	int resid;
 	struct iovec *iov;
 	
-
-	/*
-	 * Mixing PRE and POST operations is not allowed.
-	 */
-	if ((op & (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)) != 0 &&
-	    (op & (BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)) != 0)
-		panic("_bus_dmamap_sync: mix PRE and POST");
-
-	/*
-	 * Since we're dealing with a virtually-indexed, write-back
-	 * cache, we need to do the following things:
-	 *
-	 *	PREREAD -- Invalidate D-cache.  Note we might have
-	 *	to also write-back here if we have to use an Index
-	 *	op, or if the buffer start/end is not cache-line aligned.
-	 *
-	 *	PREWRITE -- Write-back the D-cache.  If we have to use
-	 *	an Index op, we also have to invalidate.  Note that if
-	 *	we are doing PREREAD|PREWRITE, we can collapse everything
-	 *	into a single op.
-	 *
-	 *	POSTREAD -- Nothing.
-	 *
-	 *	POSTWRITE -- Nothing.
-	 */
-
-	/*
-	 * Flush the write buffer.
-	 * XXX Is this always necessary?
-	 */
-	mips_wbflush();
-
-	op &= (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
-	if (op == 0)
+	if (op == BUS_DMASYNC_POSTWRITE)
+		return;
+	if (STAILQ_FIRST(&map->bpages))
+		_bus_dmamap_sync_bp(dmat, map, op);
+	if (map->flags & DMAMAP_COHERENT)
 		return;
-
 	CTR3(KTR_BUSDMA, "%s: op %x flags %x", __func__, op, map->flags);
 	switch(map->flags & DMAMAP_TYPE_MASK) {
 	case DMAMAP_LINEAR:
-		bus_dmamap_sync_buf(map->buffer, map->len, op);
+		if (!(_bus_dma_buf_is_in_bp(map, map->buffer, map->len)))
+			bus_dmamap_sync_buf(map->buffer, map->len, op);
 		break;
 	case DMAMAP_MBUF:
 		m = map->buffer;
 		while (m) {
-			if (m->m_len > 0)
+			if (m->m_len > 0 &&
+			    !(_bus_dma_buf_is_in_bp(map, m->m_data, m->m_len)))
 				bus_dmamap_sync_buf(m->m_data, m->m_len, op);
 			m = m->m_next;
 		}
@@ -821,7 +1135,10 @@
 			bus_size_t minlen = resid < iov[i].iov_len ? resid :
 			    iov[i].iov_len;
 			if (minlen > 0) {
-				bus_dmamap_sync_buf(iov[i].iov_base, minlen, op);
+				if (!_bus_dma_buf_is_in_bp(map, iov[i].iov_base,
+				    minlen))
+					bus_dmamap_sync_buf(iov[i].iov_base,
+					    minlen, op);
 				resid -= minlen;
 			}
 		}
@@ -830,3 +1147,256 @@
 		break;
 	}
 }
+
+static void
+init_bounce_pages(void *dummy __unused)
+{
+
+	total_bpages = 0;
+	STAILQ_INIT(&bounce_zone_list);
+	STAILQ_INIT(&bounce_map_waitinglist);
+	STAILQ_INIT(&bounce_map_callbacklist);
+	mtx_init(&bounce_lock, "bounce pages lock", NULL, MTX_DEF);
+}
+SYSINIT(bpages, SI_SUB_LOCK, SI_ORDER_ANY, init_bounce_pages, NULL);
+
+static struct sysctl_ctx_list *
+busdma_sysctl_tree(struct bounce_zone *bz)
+{
+	return (&bz->sysctl_tree);
+}
+
+static struct sysctl_oid *
+busdma_sysctl_tree_top(struct bounce_zone *bz)
+{
+	return (bz->sysctl_tree_top);
+}
+
+static int
+alloc_bounce_zone(bus_dma_tag_t dmat)
+{
+	struct bounce_zone *bz;
+
+	/* Check to see if we already have a suitable zone */
+	STAILQ_FOREACH(bz, &bounce_zone_list, links) {
+		if ((dmat->alignment <= bz->alignment)
+		 && (dmat->lowaddr >= bz->lowaddr)) {
+			dmat->bounce_zone = bz;
+			return (0);
+		}
+	}
+
+	if ((bz = (struct bounce_zone *)malloc(sizeof(*bz), M_DEVBUF,
+	    M_NOWAIT | M_ZERO)) == NULL)
+		return (ENOMEM);
+
+	STAILQ_INIT(&bz->bounce_page_list);
+	bz->free_bpages = 0;
+	bz->reserved_bpages = 0;
+	bz->active_bpages = 0;
+	bz->lowaddr = dmat->lowaddr;
+	bz->alignment = MAX(dmat->alignment, PAGE_SIZE);
+	bz->map_count = 0;
+	snprintf(bz->zoneid, 8, "zone%d", busdma_zonecount);
+	busdma_zonecount++;
+	snprintf(bz->lowaddrid, 18, "%#jx", (uintmax_t)bz->lowaddr);
+	STAILQ_INSERT_TAIL(&bounce_zone_list, bz, links);
+	dmat->bounce_zone = bz;
+
+	sysctl_ctx_init(&bz->sysctl_tree);
+	bz->sysctl_tree_top = SYSCTL_ADD_NODE(&bz->sysctl_tree,
+	    SYSCTL_STATIC_CHILDREN(_hw_busdma), OID_AUTO, bz->zoneid,
+	    CTLFLAG_RD, 0, "");
+	if (bz->sysctl_tree_top == NULL) {
+		sysctl_ctx_free(&bz->sysctl_tree);
+		return (0);	/* XXX error code? */
+	}
+
+	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),
+	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,
+	    "total_bpages", CTLFLAG_RD, &bz->total_bpages, 0,
+	    "Total bounce pages");
+	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),
+	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,
+	    "free_bpages", CTLFLAG_RD, &bz->free_bpages, 0,
+	    "Free bounce pages");
+	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),
+	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,
+	    "reserved_bpages", CTLFLAG_RD, &bz->reserved_bpages, 0,
+	    "Reserved bounce pages");
+	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),
+	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,
+	    "active_bpages", CTLFLAG_RD, &bz->active_bpages, 0,
+	    "Active bounce pages");
+	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),
+	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,
+	    "total_bounced", CTLFLAG_RD, &bz->total_bounced, 0,
+	    "Total bounce requests");
+	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),
+	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,
+	    "total_deferred", CTLFLAG_RD, &bz->total_deferred, 0,
+	    "Total bounce requests that were deferred");
+	SYSCTL_ADD_STRING(busdma_sysctl_tree(bz),
+	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,
+	    "lowaddr", CTLFLAG_RD, bz->lowaddrid, 0, "");
+	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),
+	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,
+	    "alignment", CTLFLAG_RD, &bz->alignment, 0, "");
+
+	return (0);
+}
+
+static int
+alloc_bounce_pages(bus_dma_tag_t dmat, u_int numpages)
+{
+	struct bounce_zone *bz;
+	int count;
+
+	bz = dmat->bounce_zone;
+	count = 0;
+	while (numpages > 0) {
+		struct bounce_page *bpage;
+
+		bpage = (struct bounce_page *)malloc(sizeof(*bpage), M_DEVBUF,
+						     M_NOWAIT | M_ZERO);
+
+		if (bpage == NULL)
+			break;
+		bpage->vaddr = (vm_offset_t)contigmalloc(PAGE_SIZE, M_DEVBUF,
+							 M_NOWAIT, 0ul,
+							 bz->lowaddr,
+							 PAGE_SIZE,
+							 0);
+		if (bpage->vaddr == 0) {
+			free(bpage, M_DEVBUF);
+			break;
+		}
+		bpage->busaddr = pmap_kextract(bpage->vaddr);
+		bpage->vaddr_nocache = 
+		    (vm_offset_t)MIPS_PHYS_TO_KSEG1(bpage->busaddr);
+		mtx_lock(&bounce_lock);
+		STAILQ_INSERT_TAIL(&bz->bounce_page_list, bpage, links);
+		total_bpages++;
+		bz->total_bpages++;
+		bz->free_bpages++;
+		mtx_unlock(&bounce_lock);
+		count++;
+		numpages--;
+	}
+	return (count);
+}
+
+static int
+reserve_bounce_pages(bus_dma_tag_t dmat, bus_dmamap_t map, int commit)
+{
+	struct bounce_zone *bz;
+	int pages;
+
+	mtx_assert(&bounce_lock, MA_OWNED);
+	bz = dmat->bounce_zone;
+	pages = MIN(bz->free_bpages, map->pagesneeded - map->pagesreserved);
+	if (commit == 0 && map->pagesneeded > (map->pagesreserved + pages))
+		return (map->pagesneeded - (map->pagesreserved + pages));
+	bz->free_bpages -= pages;
+	bz->reserved_bpages += pages;
+	map->pagesreserved += pages;
+	pages = map->pagesneeded - map->pagesreserved;
+
+	return (pages);
+}
+
+static bus_addr_t
+add_bounce_page(bus_dma_tag_t dmat, bus_dmamap_t map, vm_offset_t vaddr,
+		bus_size_t size)
+{
+	struct bounce_zone *bz;
+	struct bounce_page *bpage;
+
+	KASSERT(dmat->bounce_zone != NULL, ("no bounce zone in dma tag"));
+	KASSERT(map != NULL, ("add_bounce_page: bad map %p", map));
+
+	bz = dmat->bounce_zone;
+	if (map->pagesneeded == 0)
+		panic("add_bounce_page: map doesn't need any pages");
+	map->pagesneeded--;
+
+	if (map->pagesreserved == 0)
+		panic("add_bounce_page: map doesn't need any pages");
+	map->pagesreserved--;
+
+	mtx_lock(&bounce_lock);
+	bpage = STAILQ_FIRST(&bz->bounce_page_list);
+	if (bpage == NULL)
+		panic("add_bounce_page: free page list is empty");
+
+	STAILQ_REMOVE_HEAD(&bz->bounce_page_list, links);
+	bz->reserved_bpages--;
+	bz->active_bpages++;
+	mtx_unlock(&bounce_lock);
+
+	if (dmat->flags & BUS_DMA_KEEP_PG_OFFSET) {
+		/* Page offset needs to be preserved. */
+		bpage->vaddr |= vaddr & PAGE_MASK;
+		bpage->busaddr |= vaddr & PAGE_MASK;
+	}
+	bpage->datavaddr = vaddr;
+	bpage->datacount = size;
+	STAILQ_INSERT_TAIL(&(map->bpages), bpage, links);
+	return (bpage->busaddr);
+}
+
+static void
+free_bounce_page(bus_dma_tag_t dmat, struct bounce_page *bpage)
+{
+	struct bus_dmamap *map;
+	struct bounce_zone *bz;
+
+	bz = dmat->bounce_zone;
+	bpage->datavaddr = 0;
+	bpage->datacount = 0;
+	if (dmat->flags & BUS_DMA_KEEP_PG_OFFSET) {
+		/*
+		 * Reset the bounce page to start at offset 0.  Other uses
+		 * of this bounce page may need to store a full page of
+		 * data and/or assume it starts on a page boundary.
+		 */
+		bpage->vaddr &= ~PAGE_MASK;
+		bpage->busaddr &= ~PAGE_MASK;
+	}
+
+	mtx_lock(&bounce_lock);
+	STAILQ_INSERT_HEAD(&bz->bounce_page_list, bpage, links);
+	bz->free_bpages++;
+	bz->active_bpages--;
+	if ((map = STAILQ_FIRST(&bounce_map_waitinglist)) != NULL) {
+		if (reserve_bounce_pages(map->dmat, map, 1) == 0) {
+			STAILQ_REMOVE_HEAD(&bounce_map_waitinglist, links);
+			STAILQ_INSERT_TAIL(&bounce_map_callbacklist,
+					   map, links);
+			busdma_swi_pending = 1;
+			bz->total_deferred++;
+			swi_sched(vm_ih, 0);
+		}
+	}
+	mtx_unlock(&bounce_lock);
+}
+
+void
+busdma_swi(void)
+{
+	bus_dma_tag_t dmat;
+	struct bus_dmamap *map;
+
+	mtx_lock(&bounce_lock);
+	while ((map = STAILQ_FIRST(&bounce_map_callbacklist)) != NULL) {
+		STAILQ_REMOVE_HEAD(&bounce_map_callbacklist, links);
+		mtx_unlock(&bounce_lock);
+		dmat = map->dmat;
+		(dmat->lockfunc)(dmat->lockfuncarg, BUS_DMA_LOCK);
+		bus_dmamap_load(map->dmat, map, map->buffer, map->len,
+		    map->callback, map->callback_arg, /*flags*/0);
+		(dmat->lockfunc)(dmat->lockfuncarg, BUS_DMA_UNLOCK);
+		mtx_lock(&bounce_lock);
+	}
+	mtx_unlock(&bounce_lock);
+}
diff -I '.*' -Naur releng8/sys/mips/mips/cache_mipsNN.c svn/mips/sys/mips/mips/cache_mipsNN.c
--- releng8/src/sys/mips/mips/cache_mipsNN.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/cache_mipsNN.c	2009-08-04 10:47:01.000000000 -0700
@@ -66,8 +66,6 @@
 #endif
 
 
-__asm(".set mips32");
-
 static int picache_size;
 static int picache_stride;
 static int picache_loopcount;
@@ -115,6 +113,7 @@
 	pdcache_way_mask = cpuinfo->l1.dc_nways - 1;
 #define CACHE_DEBUG
 #ifdef CACHE_DEBUG
+	printf("Cache info:\n");
 	if (cpuinfo->icache_virtual)
 		printf("  icache is virtual\n");
 	printf("  picache_stride    = %d\n", picache_stride);
diff -I '.*' -Naur releng8/sys/mips/mips/copystr.S svn/mips/sys/mips/mips/copystr.S
--- releng8/src/sys/mips/mips/copystr.S	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/copystr.S	2009-08-04 10:47:01.000000000 -0700
@@ -67,13 +67,13 @@
 	move	v0, zero
 	beqz	a2, 2f
 	move	t1, zero
-1:	subu	a2, 1
+1:	subu	a2, 1			/*XXX mips64 unsafe -- long */
 	lbu	t0, 0(a0)
-	addu	a0, 1
+	PTR_ADDU a0, 1
 	sb	t0, 0(a1)
-	addu	a1, 1
+	PTR_ADDU a1, 1
 	beqz	t0, 3f /* NULL  - end of string*/
-	addu	t1, 1
+	addu	t1, 1			/*XXX mips64 unsafe -- long */
 	bnez	a2, 1b
 	nop
 2:	/* ENAMETOOLONG */
@@ -81,7 +81,7 @@
 3:	/* done != NULL -> how many bytes were copied */
 	beqz	a3, 4f
 	nop
-	sw	t1, 0(a3)
+	sw	t1, 0(a3)		/*XXX mips64 unsafe -- long */
 4:	jr	ra
 	nop
 	.set reorder
@@ -100,25 +100,25 @@
 	.set noat
 	lw	t2, pcpup
 	lw	v1, PC_CURPCB(t2)
-	la	v0, _C_LABEL(copystrerr)
+	PTR_LA	v0, _C_LABEL(copystrerr)
 	blt	a0, zero, _C_LABEL(copystrerr)
 	sw	v0, PCB_ONFAULT(v1)
 	move	t0, a2
 	beq	a2, zero, 4f
 1:
 	lbu	v0, 0(a0)
-	subu	a2, a2, 1
+	subu	a2, a2, 1		/*xxx mips64 unsafe -- long */
 	beq	v0, zero, 2f
 	sb	v0, 0(a1)
-	addu	a0, a0, 1
+	PTR_ADDU a0, a0, 1
 	bne	a2, zero, 1b
-	addu	a1, a1, 1
+	PTR_ADDU a1, a1, 1
 4:
 	li	v0, ENAMETOOLONG
 2:
 	beq	a3, zero, 3f
-	subu	a2, t0, a2
-	sw	a2, 0(a3)
+	subu	a2, t0, a2		/*xxx mips64 unsafe -- long */
+	sw	a2, 0(a3)		/*xxx mips64 unsafe -- long */
 3:
 	j	ra				# v0 is 0 or ENAMETOOLONG
 	sw	zero, PCB_ONFAULT(v1)
@@ -138,25 +138,25 @@
 	.set noat
 	lw	t2, pcpup
 	lw	v1, PC_CURPCB(t2)
-	la	v0, _C_LABEL(copystrerr)
+	PTR_LA	v0, _C_LABEL(copystrerr)
 	blt	a1, zero, _C_LABEL(copystrerr)
 	sw	v0, PCB_ONFAULT(v1)
 	move	t0, a2
 	beq	a2, zero, 4f
 1:
 	lbu	v0, 0(a0)
-	subu	a2, a2, 1
+	subu	a2, a2, 1		/*xxx mips64 unsafe -- long */
 	beq	v0, zero, 2f
 	sb	v0, 0(a1)
-	addu	a0, a0, 1
+	PTR_ADDU a0, a0, 1
 	bne	a2, zero, 1b
-	addu	a1, a1, 1
+	PTR_ADDU a1, a1, 1
 4:
 	li	v0, ENAMETOOLONG
 2:
 	beq	a3, zero, 3f
-	subu	a2, t0, a2
-	sw	a2, 0(a3)
+	subu	a2, t0, a2		/*xxx mips64 unsafe -- long */
+	sw	a2, 0(a3)		/*xxx mips64 unsafe -- long */
 3:
 	j	ra				# v0 is 0 or ENAMETOOLONG
 	sw	zero, PCB_ONFAULT(v1)
diff -I '.*' -Naur releng8/sys/mips/mips/cpu.c svn/mips/sys/mips/mips/cpu.c
--- releng8/src/sys/mips/mips/cpu.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/cpu.c	2009-05-06 14:57:15.000000000 -0700
@@ -64,61 +64,66 @@
 static void
 mips_get_identity(struct mips_cpuinfo *cpuinfo)
 {
-    u_int32_t prid;
-    u_int32_t cfg0;
-    u_int32_t cfg1;
-    u_int32_t tmp;
-
-    memset(cpuinfo, 0, sizeof(struct mips_cpuinfo));
-
-    /* Read and store the PrID ID for CPU identification. */
-    prid = mips_rd_prid();
-    cpuinfo->cpu_vendor = MIPS_PRID_CID(prid);
-    cpuinfo->cpu_rev = MIPS_PRID_REV(prid);
-    cpuinfo->cpu_impl = MIPS_PRID_IMPL(prid);
-
-    /* Read config register selection 0 to learn TLB type. */
-    cfg0 = mips_rd_config();
-
-    cpuinfo->tlb_type = ((cfg0 & MIPS_CONFIG0_MT_MASK) >> MIPS_CONFIG0_MT_SHIFT);
-    cpuinfo->icache_virtual = cfg0 & MIPS_CONFIG0_VI;
-
-    /* If config register selection 1 does not exist, exit. */
-    if (!(cfg0 & MIPS3_CONFIG_CM))
-	return;
-
-    /* Learn TLB size and L1 cache geometry. */
-    cfg1 = mips_rd_config_sel1();
-    cpuinfo->tlb_nentries = ((cfg1 & MIPS_CONFIG1_TLBSZ_MASK) >> MIPS_CONFIG1_TLBSZ_SHIFT) + 1;
-
-    /* L1 instruction cache. */
-    tmp = 1 << (((cfg1 & MIPS_CONFIG1_IL_MASK) >> MIPS_CONFIG1_IL_SHIFT) + 1);
-    if (tmp != 0) {
-	cpuinfo->l1.ic_linesize = tmp;
-	cpuinfo->l1.ic_nways = (((cfg1 & MIPS_CONFIG1_IA_MASK) >> MIPS_CONFIG1_IA_SHIFT)) + 1;
-	cpuinfo->l1.ic_nsets = 1 << (((cfg1 & MIPS_CONFIG1_IS_MASK) >> MIPS_CONFIG1_IS_SHIFT) + 6);
-	cpuinfo->l1.ic_size = cpuinfo->l1.ic_linesize * cpuinfo->l1.ic_nsets 
-	    * cpuinfo->l1.ic_nways;
-    }
-
-    /* L1 data cache. */
-    tmp = 1 << (((cfg1 & MIPS_CONFIG1_DL_MASK) >> MIPS_CONFIG1_DL_SHIFT) + 1);
-    if (tmp != 0) {
-	cpuinfo->l1.dc_linesize = tmp;
-	cpuinfo->l1.dc_nways = (((cfg1 & MIPS_CONFIG1_DA_MASK) >> MIPS_CONFIG1_DA_SHIFT)) + 1;
-	cpuinfo->l1.dc_nsets = 1 << (((cfg1 & MIPS_CONFIG1_DS_MASK) >> MIPS_CONFIG1_DS_SHIFT) + 6);
+	u_int32_t prid;
+	u_int32_t cfg0;
+	u_int32_t cfg1;
+	u_int32_t tmp;
+
+	memset(cpuinfo, 0, sizeof(struct mips_cpuinfo));
+
+	/* Read and store the PrID ID for CPU identification. */
+	prid = mips_rd_prid();
+	cpuinfo->cpu_vendor = MIPS_PRID_CID(prid);
+	cpuinfo->cpu_rev = MIPS_PRID_REV(prid);
+	cpuinfo->cpu_impl = MIPS_PRID_IMPL(prid);
+
+	/* Read config register selection 0 to learn TLB type. */
+	cfg0 = mips_rd_config();
+
+	cpuinfo->tlb_type = 
+	    ((cfg0 & MIPS_CONFIG0_MT_MASK) >> MIPS_CONFIG0_MT_SHIFT);
+	cpuinfo->icache_virtual = cfg0 & MIPS_CONFIG0_VI;
+
+	/* If config register selection 1 does not exist, exit. */
+	if (!(cfg0 & MIPS3_CONFIG_CM))
+		return;
+
+	/* Learn TLB size and L1 cache geometry. */
+	cfg1 = mips_rd_config1();
+	cpuinfo->tlb_nentries = 
+	    ((cfg1 & MIPS_CONFIG1_TLBSZ_MASK) >> MIPS_CONFIG1_TLBSZ_SHIFT) + 1;
+
+	/* L1 instruction cache. */
+	tmp = 1 << (((cfg1 & MIPS_CONFIG1_IL_MASK) >> MIPS_CONFIG1_IL_SHIFT) + 1);
+	if (tmp != 0) {
+		cpuinfo->l1.ic_linesize = tmp;
+		cpuinfo->l1.ic_nways = (((cfg1 & MIPS_CONFIG1_IA_MASK) >> MIPS_CONFIG1_IA_SHIFT)) + 1;
+		cpuinfo->l1.ic_nsets = 
+	    		1 << (((cfg1 & MIPS_CONFIG1_IS_MASK) >> MIPS_CONFIG1_IS_SHIFT) + 6);
+		cpuinfo->l1.ic_size = 
+		    cpuinfo->l1.ic_linesize * cpuinfo->l1.ic_nsets * cpuinfo->l1.ic_nways;
+	}
+
+	/* L1 data cache. */
+	tmp = 1 << (((cfg1 & MIPS_CONFIG1_DL_MASK) >> MIPS_CONFIG1_DL_SHIFT) + 1);
+	if (tmp != 0) {
+		cpuinfo->l1.dc_linesize = tmp;
+		cpuinfo->l1.dc_nways = 
+		    (((cfg1 & MIPS_CONFIG1_DA_MASK) >> MIPS_CONFIG1_DA_SHIFT)) + 1;
+		cpuinfo->l1.dc_nsets = 
+		    1 << (((cfg1 & MIPS_CONFIG1_DS_MASK) >> MIPS_CONFIG1_DS_SHIFT) + 6);
 #ifdef TARGET_OCTEON
-        /*
-         * Octeon does 128 byte line-size. But Config-Sel1 doesn't show
-         * 128 line-size, 1 Set, 64 ways.
-         */
-	cpuinfo->l1.dc_linesize = 128;
-	cpuinfo->l1.dc_nsets = 1;
-	cpuinfo->l1.dc_nways = 64;
+		/*
+		 * Octeon does 128 byte line-size. But Config-Sel1 doesn't show
+		 * 128 line-size, 1 Set, 64 ways.
+		 */
+		cpuinfo->l1.dc_linesize = 128;
+		cpuinfo->l1.dc_nsets = 1;
+		cpuinfo->l1.dc_nways = 64;
 #endif
-	cpuinfo->l1.dc_size = cpuinfo->l1.dc_linesize * cpuinfo->l1.dc_nsets 
-	    * cpuinfo->l1.dc_nways;
-    }
+		cpuinfo->l1.dc_size = cpuinfo->l1.dc_linesize 
+		    * cpuinfo->l1.dc_nsets * cpuinfo->l1.dc_nways;
+	}
 }
 
 void
@@ -141,77 +146,107 @@
 void
 cpu_identify(void)
 {
-    printf("cpu%d: ", 0);   /* XXX per-cpu */
-    switch (cpuinfo.cpu_vendor) {
-    case MIPS_PRID_CID_MTI:
-	printf("MIPS Technologies");
-	break;
-    case MIPS_PRID_CID_BROADCOM:
-    case MIPS_PRID_CID_SIBYTE:
-	printf("Broadcom");
-	break;
-    case MIPS_PRID_CID_ALCHEMY:
-	printf("AMD");
-	break;
-    case MIPS_PRID_CID_SANDCRAFT:
-	printf("Sandcraft");
-	break;
-    case MIPS_PRID_CID_PHILIPS:
-	printf("Philips");
-	break;
-    case MIPS_PRID_CID_TOSHIBA:
-	printf("Toshiba");
-	break;
-    case MIPS_PRID_CID_LSI:
-	printf("LSI");
-	break;
-    case MIPS_PRID_CID_LEXRA:
-	printf("Lexra");
-	break;
-    case MIPS_PRID_CID_PREHISTORIC:
-    default:
-	printf("Unknown");
-	break;
-    }
-    printf(" processor v%d.%d\n", cpuinfo.cpu_rev, cpuinfo.cpu_impl);
-
-    printf("  MMU: ");
-    if (cpuinfo.tlb_type == MIPS_MMU_NONE) {
-	printf("none present\n");
-    } else {
-	if (cpuinfo.tlb_type == MIPS_MMU_TLB) {
-	    printf("Standard TLB");
-	} else if (cpuinfo.tlb_type == MIPS_MMU_BAT) {
-	    printf("Standard BAT");
-	} else if (cpuinfo.tlb_type == MIPS_MMU_FIXED) {
-	    printf("Fixed mapping");
+	uint32_t cfg0, cfg1, cfg2, cfg3;
+	printf("cpu%d: ", 0);   /* XXX per-cpu */
+	switch (cpuinfo.cpu_vendor) {
+	case MIPS_PRID_CID_MTI:
+		printf("MIPS Technologies");
+		break;
+	case MIPS_PRID_CID_BROADCOM:
+	case MIPS_PRID_CID_SIBYTE:
+		printf("Broadcom");
+		break;
+	case MIPS_PRID_CID_ALCHEMY:
+		printf("AMD");
+		break;
+	case MIPS_PRID_CID_SANDCRAFT:
+		printf("Sandcraft");
+		break;
+	case MIPS_PRID_CID_PHILIPS:
+		printf("Philips");
+		break;
+	case MIPS_PRID_CID_TOSHIBA:
+		printf("Toshiba");
+		break;
+	case MIPS_PRID_CID_LSI:
+		printf("LSI");
+		break;
+	case MIPS_PRID_CID_LEXRA:
+		printf("Lexra");
+		break;
+	case MIPS_PRID_CID_PREHISTORIC:
+	default:
+		printf("Unknown");
+		break;
 	}
-	printf(", %d entries\n", cpuinfo.tlb_nentries);
-    }
+	printf(" processor v%d.%d\n", cpuinfo.cpu_rev, cpuinfo.cpu_impl);
 
-    printf("  L1 i-cache: ");
-    if (cpuinfo.l1.ic_linesize == 0) {
-	printf("disabled");
-    } else {
-	if (cpuinfo.l1.ic_nways == 1) {
-	    printf("direct-mapped with");
+	printf("  MMU: ");
+	if (cpuinfo.tlb_type == MIPS_MMU_NONE) {
+		printf("none present\n");
 	} else {
-	    printf ("%d ways of", cpuinfo.l1.ic_nways);
+		if (cpuinfo.tlb_type == MIPS_MMU_TLB) {
+			printf("Standard TLB");
+		} else if (cpuinfo.tlb_type == MIPS_MMU_BAT) {
+			printf("Standard BAT");
+		} else if (cpuinfo.tlb_type == MIPS_MMU_FIXED) {
+			printf("Fixed mapping");
+		}
+		printf(", %d entries\n", cpuinfo.tlb_nentries);
 	}
-	printf(" %d sets, %d bytes per line\n", cpuinfo.l1.ic_nsets, cpuinfo.l1.ic_linesize);
-    }
 
-    printf("  L1 d-cache: ");
-    if (cpuinfo.l1.dc_linesize == 0) {
-	printf("disabled");
-    } else {
-	if (cpuinfo.l1.dc_nways == 1) {
-	    printf("direct-mapped with");
+	printf("  L1 i-cache: ");
+	if (cpuinfo.l1.ic_linesize == 0) {
+		printf("disabled");
 	} else {
-	    printf ("%d ways of", cpuinfo.l1.dc_nways);
+		if (cpuinfo.l1.ic_nways == 1) {
+			printf("direct-mapped with");
+		} else {
+			printf ("%d ways of", cpuinfo.l1.ic_nways);
+		}
+		printf(" %d sets, %d bytes per line\n", 
+		    cpuinfo.l1.ic_nsets, cpuinfo.l1.ic_linesize);
 	}
-	printf(" %d sets, %d bytes per line\n", cpuinfo.l1.dc_nsets, cpuinfo.l1.dc_linesize);
-    }
+
+	printf("  L1 d-cache: ");
+	if (cpuinfo.l1.dc_linesize == 0) {
+		printf("disabled");
+	} else {
+		if (cpuinfo.l1.dc_nways == 1) {
+			printf("direct-mapped with");
+		} else {
+			printf ("%d ways of", cpuinfo.l1.dc_nways);
+		}
+		printf(" %d sets, %d bytes per line\n", 
+		    cpuinfo.l1.dc_nsets, cpuinfo.l1.dc_linesize);
+	}
+
+	cfg0 = mips_rd_config();
+	/* If config register selection 1 does not exist, exit. */
+	if (!(cfg0 & MIPS3_CONFIG_CM))
+		return;
+
+	cfg1 = mips_rd_config1();
+	printf("  Config1=0x%b\n", cfg1, 
+	    "\20\7COP2\6MDMX\5PerfCount\4WatchRegs\3MIPS16\2EJTAG\1FPU");
+
+	/* If config register selection 2 does not exist, exit. */
+	if (!(cfg1 & MIPS3_CONFIG_CM))
+		return;
+	cfg2 = mips_rd_config2();
+	/* 
+	 * Config2 contains no useful information other then Config3 
+	 * existence flag
+	 */
+
+	/* If config register selection 3 does not exist, exit. */
+	if (!(cfg2 & MIPS3_CONFIG_CM))
+		return;
+	cfg3 = mips_rd_config3();
+
+	/* Print Config3 if it contains any useful info */
+	if (cfg3 & ~(0x80000000))
+		printf("  Config3=0x%b\n", cfg3, "\20\2SmartMIPS\1TraceLogic");
 }
 
 static struct rman cpu_hardirq_rman;
diff -I '.*' -Naur releng8/sys/mips/mips/elf_machdep.c svn/mips/sys/mips/mips/elf_machdep.c
--- releng8/src/sys/mips/mips/elf_machdep.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/elf_machdep.c	2009-09-08 11:01:51.000000000 -0700
@@ -47,6 +47,59 @@
 #include <machine/elf.h>
 #include <machine/md_var.h>
 
+#ifdef __mips_n64
+struct sysentvec elf64_freebsd_sysvec = {
+	.sv_size	= SYS_MAXSYSCALL,
+	.sv_table	= sysent,
+	.sv_mask	= 0,
+	.sv_sigsize	= 0,
+	.sv_sigtbl	= NULL,
+	.sv_errsize	= 0,
+	.sv_errtbl	= NULL,
+	.sv_transtrap	= NULL,
+	.sv_fixup	= __elfN(freebsd_fixup),
+	.sv_sendsig	= sendsig,
+	.sv_sigcode	= sigcode,
+	.sv_szsigcode	= &szsigcode,
+	.sv_prepsyscall	= NULL,
+	.sv_name	= "FreeBSD ELF64",
+	.sv_coredump	= __elfN(coredump),
+	.sv_imgact_try	= NULL,
+	.sv_minsigstksz	= MINSIGSTKSZ,
+	.sv_pagesize	= PAGE_SIZE,
+	.sv_minuser	= VM_MIN_ADDRESS,
+	.sv_maxuser	= VM_MAXUSER_ADDRESS,
+	.sv_usrstack	= USRSTACK,
+	.sv_psstrings	= PS_STRINGS,
+	.sv_stackprot	= VM_PROT_ALL,
+	.sv_copyout_strings = exec_copyout_strings,
+	.sv_setregs	= exec_setregs,
+	.sv_fixlimit	= NULL,
+	.sv_maxssiz	= NULL,
+	.sv_flags	= SV_ABI_FREEBSD | SV_LP64
+};
+
+static Elf64_Brandinfo freebsd_brand_info = {
+	.brand		= ELFOSABI_FREEBSD,
+	.machine	= EM_MIPS,
+	.compat_3_brand	= "FreeBSD",
+	.emul_path	= NULL,
+	.interp_path	= "/libexec/ld-elf.so.1",
+	.sysvec		= &elf64_freebsd_sysvec,
+	.interp_newpath	= NULL,
+	.flags		= 0
+};
+
+SYSINIT(elf64, SI_SUB_EXEC, SI_ORDER_ANY,
+    (sysinit_cfunc_t) elf64_insert_brand_entry,
+    &freebsd_brand_info);
+
+void
+elf64_dump_thread(struct thread *td __unused, void *dst __unused,
+    size_t *off __unused)
+{
+}
+#else
 struct sysentvec elf32_freebsd_sysvec = {
 	.sv_size	= SYS_MAXSYSCALL,
 	.sv_table	= sysent,
@@ -86,8 +139,7 @@
 	.interp_path	= "/libexec/ld-elf.so.1",
 	.sysvec		= &elf32_freebsd_sysvec,
 	.interp_newpath	= NULL,
-	.brand_note	= &elf32_freebsd_brandnote,
-	.flags		= BI_BRAND_NOTE
+	.flags		= 0
 };
 
 SYSINIT(elf32, SI_SUB_EXEC, SI_ORDER_ANY,
@@ -99,6 +151,7 @@
     size_t *off __unused)
 {
 }
+#endif
 
 /* Process one elf relocation with addend. */
 static int
diff -I '.*' -Naur releng8/sys/mips/mips/elf_trampoline.c svn/mips/sys/mips/mips/elf_trampoline.c
--- releng8/src/sys/mips/mips/elf_trampoline.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/mips/elf_trampoline.c	2009-09-30 19:27:13.000000000 -0700
@@ -0,0 +1,147 @@
+/*-
+ * Copyright (c) 2005 Olivier Houchard.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+#include <machine/asm.h>
+#include <sys/param.h>
+
+#ifdef __mips_n64
+#include <sys/elf64.h>
+#else
+#include <sys/elf32.h>
+#endif
+#include <sys/inflate.h>
+#include <machine/elf.h>
+#include <machine/cpufunc.h>
+#include <machine/stdarg.h>
+
+/*
+ * Since we are compiled outside of the normal kernel build process, we
+ * need to include opt_global.h manually.
+ */
+#include "opt_global.h"
+#include "opt_kernname.h"
+
+extern char kernel_start[];
+extern char kernel_end[];
+
+static __inline void *
+memcpy(void *dst, const void *src, size_t len)
+{
+	const char *s = src;
+    	char *d = dst;
+
+	while (len) {
+		if (0 && len >= 4 && !((vm_offset_t)d & 3) &&
+		    !((vm_offset_t)s & 3)) {
+			*(uint32_t *)d = *(uint32_t *)s;
+			s += 4;
+			d += 4;
+			len -= 4;
+		} else {
+			*d++ = *s++;
+			len--;
+		}
+	}
+	return (dst);
+}
+
+static __inline void
+bzero(void *addr, size_t count)
+{
+	char *tmp = (char *)addr;
+
+	while (count > 0) {
+		if (count >= 4 && !((vm_offset_t)tmp & 3)) {
+			*(uint32_t *)tmp = 0;
+			tmp += 4;
+			count -= 4;
+		} else {
+			*tmp = 0;
+			tmp++;
+			count--;
+		}
+	}
+}
+
+/*
+ * Relocate PT_LOAD segements of kernel ELF image to their respective
+ * virtual addresses and return entry point
+ */
+void *
+load_kernel(void * kstart)
+{
+#ifdef __mips_n64
+	Elf64_Ehdr *eh;
+	Elf64_Phdr phdr[64] /* XXX */;
+#else
+	Elf32_Ehdr *eh;
+	Elf32_Phdr phdr[64] /* XXX */;
+#endif
+	int i;
+	void *entry_point;
+	
+#ifdef __mips_n64
+	eh = (Elf64_Ehdr *)kstart;
+#else
+	eh = (Elf32_Ehdr *)kstart;
+#endif
+	entry_point = (void*)eh->e_entry;
+	memcpy(phdr, (void *)(kstart + eh->e_phoff ),
+	    eh->e_phnum * sizeof(phdr[0]));
+
+	for (i = 0; i < eh->e_phnum; i++) {
+		volatile char c;
+
+		if (phdr[i].p_type != PT_LOAD)
+			continue;
+		
+		memcpy((void *)(phdr[i].p_vaddr),
+		    (void*)(kstart + phdr[i].p_offset), phdr[i].p_filesz);
+		/* Clean space from oversized segments, eg: bss. */
+		if (phdr[i].p_filesz < phdr[i].p_memsz)
+			bzero((void *)(phdr[i].p_vaddr + phdr[i].p_filesz), 
+			    phdr[i].p_memsz - phdr[i].p_filesz);
+	}
+
+	return entry_point;
+}
+
+void
+_startC(register_t a0, register_t a1, register_t a2, register_t a3)
+{
+	unsigned int * code;
+	int i;
+	void (*entry_point)(register_t, register_t, register_t, register_t);
+
+	/* 
+	 * Relocate segment to the predefined memory location
+	 * Most likely it will be KSEG0/KSEG1 address
+	 */
+	entry_point = load_kernel(kernel_start);
+
+	/* Pass saved registers to original _start */
+	entry_point(a0, a1, a2, a3);
+}
diff -I '.*' -Naur releng8/sys/mips/mips/exception.S svn/mips/sys/mips/mips/exception.S
--- releng8/src/sys/mips/mips/exception.S	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/exception.S	2009-08-04 10:47:01.000000000 -0700
@@ -139,12 +139,14 @@
  *----------------------------------------------------------------------------
  */
 MipsDoTLBMiss:
+#xxx mips64 unsafe?
 #ifndef SMP
 	lui	k1, %hi(_C_LABEL(pcpup))
 #endif
 						#k0 already has BadVA
 	bltz	k0, 1f				#02: k0<0 -> 1f (kernel fault)
 	srl	k0, k0, SEGSHIFT - 2		#03: k0=seg offset (almost)
+#xxx mips64 unsafe?
 #ifdef SMP
 	GET_CPU_PCPU(k1)
 #else
@@ -153,6 +155,7 @@
 	lw	k1, PC_SEGBASE(k1)
 	beqz	k1, 2f			      #05: make sure segbase is not null
 	andi	k0, k0, 0x7fc			#06: k0=seg offset (mask 0x3)
+#xxx mips64 unsafe?
 	addu	k1, k0, k1			#07: k1=seg entry address
 	lw	k1, 0(k1)			#08: k1=seg entry
 	mfc0	k0, COP_0_BAD_VADDR		#09: k0=bad address (again)
@@ -160,6 +163,7 @@
 	srl	k0, PGSHIFT - 2			#0b: k0=VPN (aka va>>10)
 
 	andi	k0, k0, ((NPTEPG/2) - 1) << 3	#0c: k0=page tab offset
+#xxx mips64 unsafe?
 	addu	k1, k1, k0			#0d: k1=pte address
 	lw	k0, 0(k1)			#0e: k0=lo0 pte
 	lw	k1, 4(k1)			#0f: k1=lo1 pte
@@ -199,8 +203,8 @@
 	and	k1, k1, CR_EXC_CODE		# Mask out the cause bits.
 	or	k1, k1, k0			# change index to user table
 1:
-	la	k0, _C_LABEL(machExceptionTable)  # get base of the jump table
-	addu	k0, k0, k1			# Get the address of the
+	PTR_LA	k0, _C_LABEL(machExceptionTable)  # get base of the jump table
+	PTR_ADDU k0, k0, k1			# Get the address of the
 						#  function entry.  Note that
 						#  the cause is already
 						#  shifted left by 2 bits so
@@ -272,7 +276,7 @@
 	and     a0, a0, a2              ; \
 	mtc0	a0, COP_0_STATUS_REG
 #endif
-
+	
 #define	SAVE_CPU \
 	SAVE_REG(AT, AST, sp)		;\
 	.set	at		        ; \
@@ -286,10 +290,10 @@
 	SAVE_REG(t1, T1, sp)		;\
 	SAVE_REG(t2, T2, sp)		;\
 	SAVE_REG(t3, T3, sp)		;\
-	SAVE_REG(t4, T4, sp)		;\
-	SAVE_REG(t5, T5, sp)		;\
-	SAVE_REG(t6, T6, sp)		;\
-	SAVE_REG(t7, T7, sp)		;\
+	SAVE_REG(ta0, TA0, sp)		;\
+	SAVE_REG(ta1, TA1, sp)		;\
+	SAVE_REG(ta2, TA2, sp)		;\
+	SAVE_REG(ta3, TA3, sp)		;\
 	SAVE_REG(t8, T8, sp)		;\
 	SAVE_REG(t9, T9, sp)		;\
 	SAVE_REG(gp, GP, sp)		;\
@@ -315,10 +319,10 @@
 	SAVE_REG(ra, RA, sp)		;\
 	SAVE_REG(a2, BADVADDR, sp)	;\
 	SAVE_REG(a3, PC, sp)		;\
-	addu	v0, sp, KERN_EXC_FRAME_SIZE ;\
+	PTR_ADDU v0, sp, KERN_EXC_FRAME_SIZE ;\
 	SAVE_REG(v0, SP, sp)		;\
 	CLEAR_STATUS			;\
-	addu	a0, sp, STAND_ARG_SIZE	;\
+	PTR_ADDU a0, sp, STAND_ARG_SIZE	;\
 	ITLBNOPFIX
 
 #define	RESTORE_REG(reg, offs, base) \
@@ -326,14 +330,13 @@
 
 #define	RESTORE_CPU \
 	mtc0	zero,COP_0_STATUS_REG	;\
-	RESTORE_REG(a0, SR, sp)		;\
+	RESTORE_REG(k0, SR, sp)		;\
 	RESTORE_REG(t0, MULLO, sp)	;\
 	RESTORE_REG(t1, MULHI, sp)	;\
-	mtc0	a0, COP_0_STATUS_REG	;\
 	mtlo	t0			;\
 	mthi	t1			;\
 	_MTC0	v0, COP_0_EXC_PC	;\
-	.set noat		        ; \
+	.set noat		        ;\
 	RESTORE_REG(AT, AST, sp)	;\
 	RESTORE_REG(v0, V0, sp)		;\
 	RESTORE_REG(v1, V1, sp)		;\
@@ -345,10 +348,10 @@
 	RESTORE_REG(t1, T1, sp)		;\
 	RESTORE_REG(t2, T2, sp)		;\
 	RESTORE_REG(t3, T3, sp)		;\
-	RESTORE_REG(t4, T4, sp)		;\
-	RESTORE_REG(t5, T5, sp)		;\
-	RESTORE_REG(t6, T6, sp)		;\
-	RESTORE_REG(t7, T7, sp)		;\
+	RESTORE_REG(ta0, TA0, sp)	;\
+	RESTORE_REG(ta1, TA1, sp)	;\
+	RESTORE_REG(ta2, TA2, sp)	;\
+	RESTORE_REG(ta3, TA3, sp)	;\
 	RESTORE_REG(t8, T8, sp)		;\
 	RESTORE_REG(t9, T9, sp)		;\
 	RESTORE_REG(s0, S0, sp)		;\
@@ -362,7 +365,8 @@
 	RESTORE_REG(s8, S8, sp)	        ;\
 	RESTORE_REG(gp, GP, sp)		;\
 	RESTORE_REG(ra, RA, sp)		;\
-	addu	sp, sp, KERN_EXC_FRAME_SIZE
+	PTR_ADDU sp, sp, KERN_EXC_FRAME_SIZE;\
+	mtc0	k0, COP_0_STATUS_REG
 
 
 /*
@@ -384,11 +388,24 @@
 /*
  *  Call the exception handler. a0 points at the saved frame.
  */
-	la	gp, _C_LABEL(_gp)
-	la	k0, _C_LABEL(trap)
+	PTR_LA	gp, _C_LABEL(_gp)
+	PTR_LA	k0, _C_LABEL(trap)
 	jalr	k0
 	sw	a3, STAND_RA_OFFSET + KERN_REG_SIZE(sp)		# for debugging
 
+	/*
+	 * Update interrupt mask in saved status register
+	 * Some of interrupts could be disabled by
+	 * intr filters if interrupts are enabled later
+	 * in trap handler
+	 */
+	mfc0	a0, COP_0_STATUS_REG
+	mtc0	zero, COP_0_STATUS_REG
+	and	a0, a0, SR_INT_MASK
+	RESTORE_REG(a1, SR, sp)
+	and	a1, a1, ~SR_INT_MASK
+	or	a1, a1, a0
+	SAVE_REG(a1, SR, sp)
 	RESTORE_CPU			# v0 contains the return address.
 	sync
 	eret
@@ -438,11 +455,11 @@
 	SAVE_U_PCB_REG(t1, T1, k1)
 	SAVE_U_PCB_REG(t2, T2, k1)
 	SAVE_U_PCB_REG(t3, T3, k1)
-	SAVE_U_PCB_REG(t4, T4, k1)
+	SAVE_U_PCB_REG(ta0, TA0, k1)
 	mfc0	a0, COP_0_STATUS_REG		# First arg is the status reg.
-	SAVE_U_PCB_REG(t5, T5, k1)
-	SAVE_U_PCB_REG(t6, T6, k1)
-	SAVE_U_PCB_REG(t7, T7, k1)
+	SAVE_U_PCB_REG(ta1, TA1, k1)
+	SAVE_U_PCB_REG(ta2, TA2, k1)
+	SAVE_U_PCB_REG(ta3, TA3, k1)
 	SAVE_U_PCB_REG(s0, S0, k1)
 	mfc0	a1, COP_0_CAUSE_REG		# Second arg is the cause reg.
 	SAVE_U_PCB_REG(s1, S1, k1)
@@ -468,32 +485,35 @@
 	SAVE_U_PCB_REG(a2, BADVADDR, k1)
 	SAVE_U_PCB_REG(a3, PC, k1)
 	sw	a3, STAND_RA_OFFSET(sp)	# for debugging
-	la	gp, _C_LABEL(_gp)	# switch to kernel GP
+	PTR_LA	gp, _C_LABEL(_gp)	# switch to kernel GP
 # Turn off fpu and enter kernel mode
 	and	t0, a0, ~(SR_COP_1_BIT | SR_EXL | SR_KSU_MASK | SR_INT_ENAB)
 #ifdef TARGET_OCTEON
 	or      t0, t0, (MIPS_SR_KX | MIPS_SR_SX | MIPS_SR_UX)
 #endif	
 	mtc0	t0, COP_0_STATUS_REG
-	addu	a0, k1, U_PCB_REGS
+	PTR_ADDU a0, k1, U_PCB_REGS
 	ITLBNOPFIX
 
 /*
  * Call the exception handler.
  */
-	la	k0, _C_LABEL(trap)
+	PTR_LA	k0, _C_LABEL(trap)
 	jalr	k0
 	nop
+
 /*
  * Restore user registers and return.
  * First disable interrupts and set exeption level.
  */
 	DO_AST
 
-	mtc0	zero, COP_0_STATUS_REG	# disable int
+	mfc0	t0, COP_0_STATUS_REG	# disable int
+	and	t0, t0, ~(MIPS_SR_INT_IE)
+	mtc0	t0, COP_0_STATUS_REG
 	ITLBNOPFIX
-	li	v0, SR_EXL
-	mtc0	v0, COP_0_STATUS_REG	# set exeption level
+	or	t0, t0, SR_EXL
+	mtc0	t0, COP_0_STATUS_REG	# set exeption level
 	ITLBNOPFIX
 
 /*
@@ -504,6 +524,18 @@
 	GET_CPU_PCPU(k1)
 	lw	k1, PC_CURPCB(k1)
 
+	/*
+	 * Update interrupt mask in saved status register
+	 * Some of interrupts could be enabled by ithread
+	 * scheduled by ast()
+	 */
+	mfc0	a0, COP_0_STATUS_REG
+	and	a0, a0, SR_INT_MASK
+	RESTORE_U_PCB_REG(a1, SR, k1)
+	and	a1, a1, ~SR_INT_MASK
+	or	a1, a1, a0
+	SAVE_U_PCB_REG(a1, SR, k1)
+
 	RESTORE_U_PCB_REG(t0, MULLO, k1)
 	RESTORE_U_PCB_REG(t1, MULHI, k1)
 	mtlo	t0
@@ -520,10 +552,10 @@
 	RESTORE_U_PCB_REG(t1, T1, k1)
 	RESTORE_U_PCB_REG(t2, T2, k1)
 	RESTORE_U_PCB_REG(t3, T3, k1)
-	RESTORE_U_PCB_REG(t4, T4, k1)
-	RESTORE_U_PCB_REG(t5, T5, k1)
-	RESTORE_U_PCB_REG(t6, T6, k1)
-	RESTORE_U_PCB_REG(t7, T7, k1)
+	RESTORE_U_PCB_REG(ta0, TA0, k1)
+	RESTORE_U_PCB_REG(ta1, TA1, k1)
+	RESTORE_U_PCB_REG(ta2, TA2, k1)
+	RESTORE_U_PCB_REG(ta3, TA3, k1)
 	RESTORE_U_PCB_REG(s0, S0, k1)
 	RESTORE_U_PCB_REG(s1, S1, k1)
 	RESTORE_U_PCB_REG(s2, S2, k1)
@@ -587,12 +619,25 @@
 /*
  * Call the interrupt handler.
  */
-	la	gp, _C_LABEL(_gp)
-	addu	a0, sp, STAND_ARG_SIZE
-	la	k0, _C_LABEL(cpu_intr)
+	PTR_LA	gp, _C_LABEL(_gp)
+	PTR_ADDU a0, sp, STAND_ARG_SIZE
+	PTR_LA	k0, _C_LABEL(cpu_intr)
 	jalr	k0
 	sw	a3, STAND_RA_OFFSET + KERN_REG_SIZE(sp)
 	/* Why no AST processing here? */
+
+	/*
+	 * Update interrupt mask in saved status register
+	 * Some of interrupts could be disabled by
+	 * intr filters
+	 */
+	mfc0	a0, COP_0_STATUS_REG
+	and	a0, a0, SR_INT_MASK
+	RESTORE_REG(a1, SR, sp)
+	and	a1, a1, ~SR_INT_MASK
+	or	a1, a1, a0
+	SAVE_REG(a1, SR, sp)
+
 /*
  * Restore registers and return from the interrupt.
  */
@@ -643,10 +688,10 @@
 	SAVE_U_PCB_REG(t1, T1, k1)
 	SAVE_U_PCB_REG(t2, T2, k1)
 	SAVE_U_PCB_REG(t3, T3, k1)
-	SAVE_U_PCB_REG(t4, T4, k1)
-	SAVE_U_PCB_REG(t5, T5, k1)
-	SAVE_U_PCB_REG(t6, T6, k1)
-	SAVE_U_PCB_REG(t7, T7, k1)
+	SAVE_U_PCB_REG(ta0, TA0, k1)
+	SAVE_U_PCB_REG(ta1, TA1, k1)
+	SAVE_U_PCB_REG(ta2, TA2, k1)
+	SAVE_U_PCB_REG(ta3, TA3, k1)
 	SAVE_U_PCB_REG(t8, T8, k1)
 	SAVE_U_PCB_REG(t9, T9, k1)
 	SAVE_U_PCB_REG(gp, GP, k1)
@@ -676,7 +721,7 @@
 	SAVE_U_PCB_REG(a1, CAUSE, k1)
 	SAVE_U_PCB_REG(a3, PC, k1)	# PC in a3, note used later!
 	subu	sp, k1, STAND_FRAME_SIZE  # switch to kernel SP
-	la	gp, _C_LABEL(_gp)	# switch to kernel GP
+	PTR_LA	gp, _C_LABEL(_gp)	# switch to kernel GP
 
 # Turn off fpu, disable interrupts, set kernel mode kernel mode, clear exception level.
 	and	t0, a0, ~(SR_COP_1_BIT | SR_EXL | SR_INT_ENAB | SR_KSU_MASK)
@@ -685,40 +730,45 @@
 #endif	
 	mtc0	t0, COP_0_STATUS_REG
 	ITLBNOPFIX
-	addu	a0, k1, U_PCB_REGS
+	PTR_ADDU a0, k1, U_PCB_REGS
 /*
  * Call the interrupt handler.
  */
-	la	k0, _C_LABEL(cpu_intr)
+	PTR_LA	k0, _C_LABEL(cpu_intr)
 	jalr	k0
 	sw	a3, STAND_RA_OFFSET(sp)	# for debugging
+
 /*
- * Since interrupts are enabled at this point, we use a1 instead of
- * k0 or k1 to store the PCB pointer.  This is because k0 and k1
- * are not preserved across interrupts. ** RRS - And how did the
- * get enabled? cpu_intr clears the cause register but it does
- * not touch the sr as far as I can see thus intr are still
- * disabled.
+ * DO_AST enabled interrupts
  */
 	DO_AST
 	
 /*
- * Restore user registers and return. NOTE: interrupts are enabled.
- */
-
-/*
- * Since interrupts are enabled at this point, we use a1 instead of
- * k0 or k1 to store the PCB pointer.  This is because k0 and k1
- * are not preserved across interrupts.
+ * Restore user registers and return. 
  */
-	mtc0	zero, COP_0_STATUS_REG
+	mfc0	t0, COP_0_STATUS_REG	# disable int
+	and	t0, t0, ~(MIPS_SR_INT_IE)
+	mtc0	t0, COP_0_STATUS_REG
 	ITLBNOPFIX
-	li	v0, SR_EXL
-	mtc0	v0, COP_0_STATUS_REG	# set exeption level bit.
+	or	t0, t0, SR_EXL
+	mtc0	t0, COP_0_STATUS_REG	# set exeption level
 	ITLBNOPFIX
 
 	GET_CPU_PCPU(k1)
-	lw	a1, PC_CURPCB(k1)
+	lw	k1, PC_CURPCB(k1)
+
+	/*
+	 * Update interrupt mask in saved status register
+	 * Some of interrupts could be disabled by
+	 * intr filters
+	 */
+	mfc0	a0, COP_0_STATUS_REG
+	and	a0, a0, SR_INT_MASK
+	RESTORE_U_PCB_REG(a1, SR, k1)
+	and	a1, a1, ~SR_INT_MASK
+	or	a1, a1, a0
+	SAVE_U_PCB_REG(a1, SR, k1)
+
 	RESTORE_U_PCB_REG(s0, S0, k1)
 	RESTORE_U_PCB_REG(s1, S1, k1)
 	RESTORE_U_PCB_REG(s2, S2, k1)
@@ -744,10 +794,10 @@
 	RESTORE_U_PCB_REG(t1, T1, k1)
 	RESTORE_U_PCB_REG(t2, T2, k1)
 	RESTORE_U_PCB_REG(t3, T3, k1)
-	RESTORE_U_PCB_REG(t4, T4, k1)
-	RESTORE_U_PCB_REG(t5, T5, k1)
-	RESTORE_U_PCB_REG(t6, T6, k1)
-	RESTORE_U_PCB_REG(t7, T7, k1)
+	RESTORE_U_PCB_REG(ta0, TA0, k1)
+	RESTORE_U_PCB_REG(ta1, TA1, k1)
+	RESTORE_U_PCB_REG(ta2, TA2, k1)
+	RESTORE_U_PCB_REG(ta3, TA3, k1)
 	RESTORE_U_PCB_REG(t8, T8, k1)
 	RESTORE_U_PCB_REG(t9, T9, k1)
 	RESTORE_U_PCB_REG(gp, GP, k1)
@@ -833,6 +883,7 @@
 2:
 	srl	k0, 20				# k0=seg offset (almost)
 	andi	k0, k0, 0xffc			# k0=seg offset (mask 0x3)
+#xxx mips64 unsafe?
 	addu	k1, k0, k1			# k1=seg entry address
 	lw	k1, 0(k1)			# k1=seg entry
 	mfc0	k0, COP_0_BAD_VADDR		# k0=bad address (again)
@@ -840,6 +891,7 @@
 	srl	k0, k0, PGSHIFT-2
 	andi	k0, k0, 0xffc			# compute offset from index
 	tlbp					# Probe the invalid entry
+#xxx mips64 unsafe?
 	addu	k1, k1, k0
 	and	k0, k0, 4			# check even/odd page
 	nop					# required for QED 5230
@@ -905,6 +957,7 @@
 	sltu	k1, k0, k1
 	beqz	k1, _C_LABEL(MipsUserGenException)
 	nop
+#xxx mips64 unsafe?
 #ifdef SMP
 	GET_CPU_PCPU(k1)
 #else
@@ -917,6 +970,7 @@
 2:
 	srl	k0, 20				# k0=seg offset (almost)
 	andi	k0, k0, 0xffc			# k0=seg offset (mask 0x3)
+#xxx mips64 unsafe?
 	addu	k1, k0, k1			# k1=seg entry address
 	lw	k1, 0(k1)			# k1=seg entry
 	mfc0	k0, COP_0_BAD_VADDR		# k0=bad address (again)
@@ -924,6 +978,7 @@
 	srl	k0, k0, PGSHIFT-2
 	andi	k0, k0, 0xffc			# compute offset from index
 	tlbp					# Probe the invalid entry
+#xxx mips64 unsafe?
 	addu	k1, k1, k0
 	and	k0, k0, 4			# check even/odd page
 	nop					# required for QED 5230
@@ -1007,12 +1062,14 @@
 	lw	k1, %lo(_C_LABEL(kernel_segmap))(k1)  # k1=segment tab base
 	beq	k1, zero, _C_LABEL(MipsKernGenException)  # ==0 -- no seg tab
 	andi	k0, k0, 0xffc			# k0=seg offset (mask 0x3)
+#xxx mips64 unsafe
 	addu	k1, k0, k1			# k1=seg entry address
 	lw	k1, 0(k1)			# k1=seg entry
 	mfc0	k0, COP_0_BAD_VADDR		# k0=bad address (again)
 	beq	k1, zero, _C_LABEL(MipsKernGenException)  # ==0 -- no page table
 	srl	k0, 10				# k0=VPN (aka va>>10)
 	andi	k0, k0, 0xff8			# k0=page tab offset
+#xxx mips64 unsafe
 	addu	k1, k1, k0			# k1=pte address
 	lw	k0, 0(k1)			# k0=lo0 pte
 	lw	k1, 4(k1)			# k1=lo1 pte
@@ -1037,31 +1094,31 @@
 	nop
 
 # stack overflow
-	la	a0, _C_LABEL(_start) - START_FRAME - 8  # set sp to a valid place
+	PTR_LA	a0, _C_LABEL(_start) - START_FRAME - 8  # set sp to a valid place
 	sw	sp, 24(a0)
 	move	sp, a0
-	la	a0, 1f
+	PTR_LA	a0, 1f
 	mfc0	a2, COP_0_STATUS_REG
 	mfc0	a3, COP_0_CAUSE_REG
 	_MFC0	a1, COP_0_EXC_PC
 	sw	a2, 16(sp)
 	sw	a3, 20(sp)
 	move	a2, ra
-	la	k0, _C_LABEL(printf)
+	PTR_LA	k0, _C_LABEL(printf)
 	jalr	k0
 	mfc0	a3, COP_0_BAD_VADDR
 
-	la	sp, _C_LABEL(_start) - START_FRAME  # set sp to a valid place
+	PTR_LA	sp, _C_LABEL(_start) - START_FRAME  # set sp to a valid place
 
 #if !defined(SMP) && defined(DDB)
-	la	a0, 2f
-	la	k0, _C_LABEL(trapDump)
+	PTR_LA	a0, 2f
+	PTR_LA	k0, _C_LABEL(trapDump)
 	jalr	k0
 	nop
 
 	li	a0, 0
 	lw	a1, _C_LABEL(num_tlbentries)
-	la	k0, _C_LABEL(db_dump_tlb)
+	PTR_LA	k0, _C_LABEL(db_dump_tlb)
 	jalr	k0
 	addu	a1, -1
 
@@ -1138,11 +1195,12 @@
  */
 	sw	a2, STAND_FRAME_SIZE + 8(sp)
 	GET_CPU_PCPU(a0)
+#mips64 unsafe?
 	lw	a0, PC_CURPCB(a0)
-	addu	a0, a0, U_PCB_REGS		# first arg is ptr to CPU registers
+	PTR_ADDU a0, a0, U_PCB_REGS		# first arg is ptr to CPU registers
 	move	a1, a2				# second arg is instruction PC
 	move	a2, t1				# third arg is floating point CSR
-	la	t3, _C_LABEL(MipsEmulateBranch)	# compute PC after branch
+	PTR_LA	t3, _C_LABEL(MipsEmulateBranch)	# compute PC after branch
 	jalr	t3				# compute PC after branch
 	move	a3, zero			# fourth arg is FALSE
 /*
@@ -1158,6 +1216,7 @@
  */
 1:
 	lw	a0, 0(a2)			# a0 = coproc instruction
+#xxx mips64 unsafe?
 	addu	v0, a2, 4			# v0 = next pc
 2:
 	GET_CPU_PCPU(t2)
@@ -1178,7 +1237,7 @@
 	lw	a0, PC_CURTHREAD(a0)		# get current thread
 	cfc1	a2, FPC_CSR			# code = FP execptions
 	ctc1	zero, FPC_CSR			# Clear exceptions
-	la	t3, _C_LABEL(trapsignal)
+	PTR_LA	t3, _C_LABEL(trapsignal)
 	jalr	t3
 	li	a1, SIGFPE
 	b	FPReturn
@@ -1188,7 +1247,7 @@
  * Finally, we can call MipsEmulateFP() where a0 is the instruction to emulate.
  */
 4:
-	la	t3, _C_LABEL(MipsEmulateFP)
+	PTR_LA	t3, _C_LABEL(MipsEmulateFP)
 	jalr	t3
 	nop
 
@@ -1202,26 +1261,9 @@
 	mtc0	t0, COP_0_STATUS_REG
 	ITLBNOPFIX
 	j	ra
-	addu	sp, sp, STAND_FRAME_SIZE
+	PTR_ADDU sp, sp, STAND_FRAME_SIZE
 END(MipsFPTrap)
 
-
-#if 0
-/*
- *  Atomic ipending update
- */
-LEAF(set_sint)
-	la	v1, ipending
-1:
-	ll	v0, 0(v1)
-	or	v0, a0
-	sc	v0, 0(v1)
-	beqz	v0, 1b
-	j	ra
-	nop
-END(set_sint)
-#endif
-
 /*
  * Interrupt counters for vmstat.
  */
@@ -1248,7 +1290,7 @@
  */
 	.text
 VECTOR(MipsCache, unknown)
-	la	k0, _C_LABEL(MipsCacheException)
+	PTR_LA	k0, _C_LABEL(MipsCacheException)
 	li	k1, MIPS_PHYS_MASK
 	and	k0, k1
 	li	k1, MIPS_UNCACHED_MEMORY_ADDR
@@ -1267,8 +1309,8 @@
 NESTED_NOPROFILE(MipsCacheException, KERN_EXC_FRAME_SIZE, ra)
 	.set	noat
 	.mask	0x80000000, -4
-	la	k0, _C_LABEL(panic)		# return to panic
-	la	a0, 9f				# panicstr
+	PTR_LA	k0, _C_LABEL(panic)		# return to panic
+	PTR_LA	a0, 9f				# panicstr
 	_MFC0	a1, COP_0_ERROR_PC
 	mfc0	a2, COP_0_CACHE_ERR		# 3rd arg cache error
 
diff -I '.*' -Naur releng8/sys/mips/mips/fp.S svn/mips/sys/mips/mips/fp.S
--- releng8/src/sys/mips/mips/fp.S	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/fp.S	2009-08-04 10:47:01.000000000 -0700
@@ -634,7 +634,7 @@
  */
 sub_s:
 	jal	get_ft_fs_s
-	xor	t4, t4, 1			# negate FT sign bit
+	xor	ta0, ta0, 1			# negate FT sign bit
 	b	add_sub_s
 /*
  * Single precision add.
@@ -643,38 +643,38 @@
 	jal	get_ft_fs_s
 add_sub_s:
 	bne	t1, SEXP_INF, 1f		# is FS an infinity?
-	bne	t5, SEXP_INF, result_fs_s	# if FT is not inf, result=FS
+	bne	ta1, SEXP_INF, result_fs_s	# if FT is not inf, result=FS
 	bne	t2, zero, result_fs_s		# if FS is NAN, result is FS
-	bne	t6, zero, result_ft_s		# if FT is NAN, result is FT
-	bne	t0, t4, invalid_s		# both infinities same sign?
+	bne	ta2, zero, result_ft_s		# if FT is NAN, result is FT
+	bne	t0, ta0, invalid_s		# both infinities same sign?
 	b	result_fs_s			# result is in FS
 1:
-	beq	t5, SEXP_INF, result_ft_s	# if FT is inf, result=FT
+	beq	ta1, SEXP_INF, result_ft_s	# if FT is inf, result=FT
 	bne	t1, zero, 4f			# is FS a denormalized num?
 	beq	t2, zero, 3f			# is FS zero?
-	bne	t5, zero, 2f			# is FT a denormalized num?
-	beq	t6, zero, result_fs_s		# FT is zero, result=FS
+	bne	ta1, zero, 2f			# is FT a denormalized num?
+	beq	ta2, zero, result_fs_s		# FT is zero, result=FS
 	jal	renorm_fs_s
 	jal	renorm_ft_s
 	b	5f
 2:
 	jal	renorm_fs_s
-	subu	t5, t5, SEXP_BIAS		# unbias FT exponent
-	or	t6, t6, SIMPL_ONE		# set implied one bit
+	subu	ta1, ta1, SEXP_BIAS		# unbias FT exponent
+	or	ta2, ta2, SIMPL_ONE		# set implied one bit
 	b	5f
 3:
-	bne	t5, zero, result_ft_s		# if FT != 0, result=FT
-	bne	t6, zero, result_ft_s
+	bne	ta1, zero, result_ft_s		# if FT != 0, result=FT
+	bne	ta2, zero, result_ft_s
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
 	bne	v0, FPC_ROUND_RM, 1f		# round to -infinity?
-	or	t0, t0, t4			# compute result sign
+	or	t0, t0, ta0			# compute result sign
 	b	result_fs_s
 1:
-	and	t0, t0, t4			# compute result sign
+	and	t0, t0, ta0			# compute result sign
 	b	result_fs_s
 4:
-	bne	t5, zero, 2f			# is FT a denormalized num?
-	beq	t6, zero, result_fs_s		# FT is zero, result=FS
+	bne	ta1, zero, 2f			# is FT a denormalized num?
+	beq	ta2, zero, result_fs_s		# FT is zero, result=FS
 	subu	t1, t1, SEXP_BIAS		# unbias FS exponent
 	or	t2, t2, SIMPL_ONE		# set implied one bit
 	jal	renorm_ft_s
@@ -682,15 +682,15 @@
 2:
 	subu	t1, t1, SEXP_BIAS		# unbias FS exponent
 	or	t2, t2, SIMPL_ONE		# set implied one bit
-	subu	t5, t5, SEXP_BIAS		# unbias FT exponent
-	or	t6, t6, SIMPL_ONE		# set implied one bit
+	subu	ta1, ta1, SEXP_BIAS		# unbias FT exponent
+	or	ta2, ta2, SIMPL_ONE		# set implied one bit
 /*
  * Perform the addition.
  */
 5:
 	move	t8, zero			# no shifted bits (sticky reg)
-	beq	t1, t5, 4f			# no shift needed
-	subu	v0, t1, t5			# v0 = difference of exponents
+	beq	t1, ta1, 4f			# no shift needed
+	subu	v0, t1, ta1			# v0 = difference of exponents
 	move	v1, v0				# v1 = abs(difference)
 	bge	v0, zero, 1f
 	negu	v1
@@ -698,50 +698,50 @@
 	ble	v1, SFRAC_BITS+2, 2f		# is difference too great?
 	li	t8, STICKYBIT			# set the sticky bit
 	bge	v0, zero, 1f			# check which exp is larger
-	move	t1, t5				# result exp is FTs
+	move	t1, ta1				# result exp is FTs
 	move	t2, zero			# FSs fraction shifted is zero
 	b	4f
 1:
-	move	t6, zero			# FTs fraction shifted is zero
+	move	ta2, zero			# FTs fraction shifted is zero
 	b	4f
 2:
 	li	t9, 32				# compute 32 - abs(exp diff)
 	subu	t9, t9, v1
 	bgt	v0, zero, 3f			# if FS > FT, shift FTs frac
-	move	t1, t5				# FT > FS, result exp is FTs
+	move	t1, ta1				# FT > FS, result exp is FTs
 	sll	t8, t2, t9			# save bits shifted out
 	srl	t2, t2, v1			# shift FSs fraction
 	b	4f
 3:
-	sll	t8, t6, t9			# save bits shifted out
-	srl	t6, t6, v1			# shift FTs fraction
+	sll	t8, ta2, t9			# save bits shifted out
+	srl	ta2, ta2, v1			# shift FTs fraction
 4:
-	bne	t0, t4, 1f			# if signs differ, subtract
-	addu	t2, t2, t6			# add fractions
+	bne	t0, ta0, 1f			# if signs differ, subtract
+	addu	t2, t2, ta2			# add fractions
 	b	norm_s
 1:
-	blt	t2, t6, 3f			# subtract larger from smaller
-	bne	t2, t6, 2f			# if same, result=0
+	blt	t2, ta2, 3f			# subtract larger from smaller
+	bne	t2, ta2, 2f			# if same, result=0
 	move	t1, zero			# result=0
 	move	t2, zero
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
-	bne	v0, FPC_ROUND_RM, 1f	# round to -infinity?
-	or	t0, t0, t4			# compute result sign
+	bne	v0, FPC_ROUND_RM, 1f		# round to -infinity?
+	or	t0, t0, ta0			# compute result sign
 	b	result_fs_s
 1:
-	and	t0, t0, t4			# compute result sign
+	and	t0, t0, ta0			# compute result sign
 	b	result_fs_s
 2:
-	sltu	t9, zero, t8			# compute t2:zero - t6:t8
+	sltu	t9, zero, t8			# compute t2:zero - ta2:t8
 	subu	t8, zero, t8
-	subu	t2, t2, t6			# subtract fractions
+	subu	t2, t2, ta2			# subtract fractions
 	subu	t2, t2, t9			# subtract barrow
 	b	norm_s
 3:
-	move	t0, t4				# sign of result = FTs
-	sltu	t9, zero, t8			# compute t6:zero - t2:t8
+	move	t0, ta0				# sign of result = FTs
+	sltu	t9, zero, t8			# compute ta2:zero - t2:t8
 	subu	t8, zero, t8
-	subu	t2, t6, t2			# subtract fractions
+	subu	t2, ta2, t2			# subtract fractions
 	subu	t2, t2, t9			# subtract barrow
 	b	norm_s
 
@@ -750,7 +750,7 @@
  */
 sub_d:
 	jal	get_ft_fs_d
-	xor	t4, t4, 1			# negate sign bit
+	xor	ta0, ta0, 1			# negate sign bit
 	b	add_sub_d
 /*
  * Double precision add.
@@ -759,46 +759,46 @@
 	jal	get_ft_fs_d
 add_sub_d:
 	bne	t1, DEXP_INF, 1f		# is FS an infinity?
-	bne	t5, DEXP_INF, result_fs_d	# if FT is not inf, result=FS
+	bne	ta1, DEXP_INF, result_fs_d	# if FT is not inf, result=FS
 	bne	t2, zero, result_fs_d		# if FS is NAN, result is FS
 	bne	t3, zero, result_fs_d
-	bne	t6, zero, result_ft_d		# if FT is NAN, result is FT
-	bne	t7, zero, result_ft_d
-	bne	t0, t4, invalid_d		# both infinities same sign?
+	bne	ta2, zero, result_ft_d		# if FT is NAN, result is FT
+	bne	ta3, zero, result_ft_d
+	bne	t0, ta0, invalid_d		# both infinities same sign?
 	b	result_fs_d			# result is in FS
 1:
-	beq	t5, DEXP_INF, result_ft_d	# if FT is inf, result=FT
+	beq	ta1, DEXP_INF, result_ft_d	# if FT is inf, result=FT
 	bne	t1, zero, 4f			# is FS a denormalized num?
 	bne	t2, zero, 1f			# is FS zero?
 	beq	t3, zero, 3f
 1:
-	bne	t5, zero, 2f			# is FT a denormalized num?
-	bne	t6, zero, 1f
-	beq	t7, zero, result_fs_d		# FT is zero, result=FS
+	bne	ta1, zero, 2f			# is FT a denormalized num?
+	bne	ta2, zero, 1f
+	beq	ta3, zero, result_fs_d		# FT is zero, result=FS
 1:
 	jal	renorm_fs_d
 	jal	renorm_ft_d
 	b	5f
 2:
 	jal	renorm_fs_d
-	subu	t5, t5, DEXP_BIAS		# unbias FT exponent
-	or	t6, t6, DIMPL_ONE		# set implied one bit
+	subu	ta1, ta1, DEXP_BIAS		# unbias FT exponent
+	or	ta2, ta2, DIMPL_ONE		# set implied one bit
 	b	5f
 3:
-	bne	t5, zero, result_ft_d		# if FT != 0, result=FT
-	bne	t6, zero, result_ft_d
-	bne	t7, zero, result_ft_d
+	bne	ta1, zero, result_ft_d		# if FT != 0, result=FT
+	bne	ta2, zero, result_ft_d
+	bne	ta3, zero, result_ft_d
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
-	bne	v0, FPC_ROUND_RM, 1f	# round to -infinity?
-	or	t0, t0, t4			# compute result sign
+	bne	v0, FPC_ROUND_RM, 1f		# round to -infinity?
+	or	t0, t0, ta0			# compute result sign
 	b	result_fs_d
 1:
-	and	t0, t0, t4			# compute result sign
+	and	t0, t0, ta0			# compute result sign
 	b	result_fs_d
 4:
-	bne	t5, zero, 2f			# is FT a denormalized num?
-	bne	t6, zero, 1f
-	beq	t7, zero, result_fs_d		# FT is zero, result=FS
+	bne	ta1, zero, 2f			# is FT a denormalized num?
+	bne	ta2, zero, 1f
+	beq	ta3, zero, result_fs_d		# FT is zero, result=FS
 1:
 	subu	t1, t1, DEXP_BIAS		# unbias FS exponent
 	or	t2, t2, DIMPL_ONE		# set implied one bit
@@ -807,15 +807,15 @@
 2:
 	subu	t1, t1, DEXP_BIAS		# unbias FS exponent
 	or	t2, t2, DIMPL_ONE		# set implied one bit
-	subu	t5, t5, DEXP_BIAS		# unbias FT exponent
-	or	t6, t6, DIMPL_ONE		# set implied one bit
+	subu	ta1, ta1, DEXP_BIAS		# unbias FT exponent
+	or	ta2, ta2, DIMPL_ONE		# set implied one bit
 /*
  * Perform the addition.
  */
 5:
 	move	t8, zero			# no shifted bits (sticky reg)
-	beq	t1, t5, 4f			# no shift needed
-	subu	v0, t1, t5			# v0 = difference of exponents
+	beq	t1, ta1, 4f			# no shift needed
+	subu	v0, t1, ta1			# v0 = difference of exponents
 	move	v1, v0				# v1 = abs(difference)
 	bge	v0, zero, 1f
 	negu	v1
@@ -823,18 +823,18 @@
 	ble	v1, DFRAC_BITS+2, 2f		# is difference too great?
 	li	t8, STICKYBIT			# set the sticky bit
 	bge	v0, zero, 1f			# check which exp is larger
-	move	t1, t5				# result exp is FTs
+	move	t1, ta1				# result exp is FTs
 	move	t2, zero			# FSs fraction shifted is zero
 	move	t3, zero
 	b	4f
 1:
-	move	t6, zero			# FTs fraction shifted is zero
-	move	t7, zero
+	move	ta2, zero			# FTs fraction shifted is zero
+	move	ta3, zero
 	b	4f
 2:
 	li	t9, 32
 	bge	v0, zero, 3f			# if FS > FT, shift FTs frac
-	move	t1, t5				# FT > FS, result exp is FTs
+	move	t1, ta1				# FT > FS, result exp is FTs
 	blt	v1, t9, 1f			# shift right by < 32?
 	subu	v1, v1, t9
 	subu	t9, t9, v1
@@ -856,62 +856,62 @@
 	blt	v1, t9, 1f			# shift right by < 32?
 	subu	v1, v1, t9
 	subu	t9, t9, v1
-	sll	t8, t6, t9			# save bits shifted out
-	srl	t7, t6, v1			# shift FTs fraction
-	move	t6, zero
+	sll	t8, ta2, t9			# save bits shifted out
+	srl	ta3, ta2, v1			# shift FTs fraction
+	move	ta2, zero
 	b	4f
 1:
 	subu	t9, t9, v1
-	sll	t8, t7, t9			# save bits shifted out
-	srl	t7, t7, v1			# shift FTs fraction
-	sll	t9, t6, t9			# save bits shifted out of t2
-	or	t7, t7, t9			# and put into t3
-	srl	t6, t6, v1
+	sll	t8, ta3, t9			# save bits shifted out
+	srl	ta3, ta3, v1			# shift FTs fraction
+	sll	t9, ta2, t9			# save bits shifted out of t2
+	or	ta3, ta3, t9			# and put into t3
+	srl	ta2, ta2, v1
 4:
-	bne	t0, t4, 1f			# if signs differ, subtract
-	addu	t3, t3, t7			# add fractions
-	sltu	t9, t3, t7			# compute carry
-	addu	t2, t2, t6			# add fractions
+	bne	t0, ta0, 1f			# if signs differ, subtract
+	addu	t3, t3, ta3			# add fractions
+	sltu	t9, t3, ta3			# compute carry
+	addu	t2, t2, ta2			# add fractions
 	addu	t2, t2, t9			# add carry
 	b	norm_d
 1:
-	blt	t2, t6, 3f			# subtract larger from smaller
-	bne	t2, t6, 2f
-	bltu	t3, t7, 3f
-	bne	t3, t7, 2f			# if same, result=0
+	blt	t2, ta2, 3f			# subtract larger from smaller
+	bne	t2, ta2, 2f
+	bltu	t3, ta3, 3f
+	bne	t3, ta3, 2f			# if same, result=0
 	move	t1, zero			# result=0
 	move	t2, zero
 	move	t3, zero
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
 	bne	v0, FPC_ROUND_RM, 1f		# round to -infinity?
-	or	t0, t0, t4			# compute result sign
+	or	t0, t0, ta0			# compute result sign
 	b	result_fs_d
 1:
-	and	t0, t0, t4			# compute result sign
+	and	t0, t0, ta0			# compute result sign
 	b	result_fs_d
 2:
-	beq	t8, zero, 1f			# compute t2:t3:zero - t6:t7:t8
+	beq	t8, zero, 1f			# compute t2:t3:zero - ta2:ta3:t8
 	subu	t8, zero, t8
 	sltu	v0, t3, 1			# compute barrow out
 	subu	t3, t3, 1			# subtract barrow
 	subu	t2, t2, v0
 1:
-	sltu	v0, t3, t7
-	subu	t3, t3, t7			# subtract fractions
-	subu	t2, t2, t6			# subtract fractions
+	sltu	v0, t3, ta3
+	subu	t3, t3, ta3			# subtract fractions
+	subu	t2, t2, ta2			# subtract fractions
 	subu	t2, t2, v0			# subtract barrow
 	b	norm_d
 3:
-	move	t0, t4				# sign of result = FTs
-	beq	t8, zero, 1f			# compute t6:t7:zero - t2:t3:t8
+	move	t0, ta0				# sign of result = FTs
+	beq	t8, zero, 1f			# compute ta2:ta3:zero - t2:t3:t8
 	subu	t8, zero, t8
-	sltu	v0, t7, 1			# compute barrow out
-	subu	t7, t7, 1			# subtract barrow
-	subu	t6, t6, v0
-1:
-	sltu	v0, t7, t3
-	subu	t3, t7, t3			# subtract fractions
-	subu	t2, t6, t2			# subtract fractions
+	sltu	v0, ta3, 1			# compute barrow out
+	subu	ta3, ta3, 1			# subtract barrow
+	subu	ta2, ta2, v0
+1:
+	sltu	v0, ta3, t3
+	subu	t3, ta3, t3			# subtract fractions
+	subu	t2, ta2, t2			# subtract fractions
 	subu	t2, t2, v0			# subtract barrow
 	b	norm_d
 
@@ -920,22 +920,22 @@
  */
 mul_s:
 	jal	get_ft_fs_s
-	xor	t0, t0, t4			# compute sign of result
-	move	t4, t0
+	xor	t0, t0, ta0			# compute sign of result
+	move	ta0, t0
 	bne	t1, SEXP_INF, 2f		# is FS an infinity?
 	bne	t2, zero, result_fs_s		# if FS is a NAN, result=FS
-	bne	t5, SEXP_INF, 1f		# FS is inf, is FT an infinity?
-	bne	t6, zero, result_ft_s		# if FT is a NAN, result=FT
+	bne	ta1, SEXP_INF, 1f		# FS is inf, is FT an infinity?
+	bne	ta2, zero, result_ft_s		# if FT is a NAN, result=FT
 	b	result_fs_s			# result is infinity
 1:
-	bne	t5, zero, result_fs_s		# inf * zero? if no, result=FS
-	bne	t6, zero, result_fs_s
+	bne	ta1, zero, result_fs_s		# inf * zero? if no, result=FS
+	bne	ta2, zero, result_fs_s
 	b	invalid_s			# infinity * zero is invalid
 2:
-	bne	t5, SEXP_INF, 1f		# FS != inf, is FT an infinity?
+	bne	ta1, SEXP_INF, 1f		# FS != inf, is FT an infinity?
 	bne	t1, zero, result_ft_s		# zero * inf? if no, result=FT
 	bne	t2, zero, result_ft_s
-	bne	t6, zero, result_ft_s		# if FT is a NAN, result=FT
+	bne	ta2, zero, result_ft_s		# if FT is a NAN, result=FT
 	b	invalid_s			# zero * infinity is invalid
 1:
 	bne	t1, zero, 1f			# is FS zero?
@@ -946,17 +946,17 @@
 	subu	t1, t1, SEXP_BIAS		# unbias FS exponent
 	or	t2, t2, SIMPL_ONE		# set implied one bit
 2:
-	bne	t5, zero, 1f			# is FT zero?
-	beq	t6, zero, result_ft_s		# result is zero
+	bne	ta1, zero, 1f			# is FT zero?
+	beq	ta2, zero, result_ft_s		# result is zero
 	jal	renorm_ft_s
 	b	2f
 1:
-	subu	t5, t5, SEXP_BIAS		# unbias FT exponent
-	or	t6, t6, SIMPL_ONE		# set implied one bit
+	subu	ta1, ta1, SEXP_BIAS		# unbias FT exponent
+	or	ta2, ta2, SIMPL_ONE		# set implied one bit
 2:
-	addu	t1, t1, t5			# compute result exponent
+	addu	t1, t1, ta1			# compute result exponent
 	addu	t1, t1, 9			# account for binary point
-	multu	t2, t6				# multiply fractions
+	multu	t2, ta2				# multiply fractions
 	mflo	t8
 	mfhi	t2
 	b	norm_s
@@ -966,27 +966,27 @@
  */
 mul_d:
 	jal	get_ft_fs_d
-	xor	t0, t0, t4			# compute sign of result
-	move	t4, t0
+	xor	t0, t0, ta0			# compute sign of result
+	move	ta0, t0
 	bne	t1, DEXP_INF, 2f		# is FS an infinity?
 	bne	t2, zero, result_fs_d		# if FS is a NAN, result=FS
 	bne	t3, zero, result_fs_d
-	bne	t5, DEXP_INF, 1f		# FS is inf, is FT an infinity?
-	bne	t6, zero, result_ft_d		# if FT is a NAN, result=FT
-	bne	t7, zero, result_ft_d
+	bne	ta1, DEXP_INF, 1f		# FS is inf, is FT an infinity?
+	bne	ta2, zero, result_ft_d		# if FT is a NAN, result=FT
+	bne	ta3, zero, result_ft_d
 	b	result_fs_d			# result is infinity
 1:
-	bne	t5, zero, result_fs_d		# inf * zero? if no, result=FS
-	bne	t6, zero, result_fs_d
-	bne	t7, zero, result_fs_d
+	bne	ta1, zero, result_fs_d		# inf * zero? if no, result=FS
+	bne	ta2, zero, result_fs_d
+	bne	ta3, zero, result_fs_d
 	b	invalid_d			# infinity * zero is invalid
 2:
-	bne	t5, DEXP_INF, 1f		# FS != inf, is FT an infinity?
+	bne	ta1, DEXP_INF, 1f		# FS != inf, is FT an infinity?
 	bne	t1, zero, result_ft_d		# zero * inf? if no, result=FT
 	bne	t2, zero, result_ft_d		# if FS is a NAN, result=FS
 	bne	t3, zero, result_ft_d
-	bne	t6, zero, result_ft_d		# if FT is a NAN, result=FT
-	bne	t7, zero, result_ft_d
+	bne	ta2, zero, result_ft_d		# if FT is a NAN, result=FT
+	bne	ta3, zero, result_ft_d
 	b	invalid_d			# zero * infinity is invalid
 1:
 	bne	t1, zero, 2f			# is FS zero?
@@ -999,37 +999,37 @@
 	subu	t1, t1, DEXP_BIAS		# unbias FS exponent
 	or	t2, t2, DIMPL_ONE		# set implied one bit
 3:
-	bne	t5, zero, 2f			# is FT zero?
-	bne	t6, zero, 1f
-	beq	t7, zero, result_ft_d		# result is zero
+	bne	ta1, zero, 2f			# is FT zero?
+	bne	ta2, zero, 1f
+	beq	ta3, zero, result_ft_d		# result is zero
 1:
 	jal	renorm_ft_d
 	b	3f
 2:
-	subu	t5, t5, DEXP_BIAS		# unbias FT exponent
-	or	t6, t6, DIMPL_ONE		# set implied one bit
+	subu	ta1, ta1, DEXP_BIAS		# unbias FT exponent
+	or	ta2, ta2, DIMPL_ONE		# set implied one bit
 3:
-	addu	t1, t1, t5			# compute result exponent
+	addu	t1, t1, ta1			# compute result exponent
 	addu	t1, t1, 12			# ???
-	multu	t3, t7				# multiply fractions (low * low)
-	move	t4, t2				# free up t2,t3 for result
-	move	t5, t3
+	multu	t3, ta3				# multiply fractions (low * low)
+	move	ta0, t2				# free up t2,t3 for result
+	move	ta1, t3
 	mflo	a3				# save low order bits
 	mfhi	t8
 	not	v0, t8
-	multu	t4, t7				# multiply FS(high) * FT(low)
+	multu	ta0, ta3			# multiply FS(high) * FT(low)
 	mflo	v1
 	mfhi	t3				# init low result
 	sltu	v0, v0, v1			# compute carry
 	addu	t8, v1
-	multu	t5, t6				# multiply FS(low) * FT(high)
+	multu	ta1, ta2			# multiply FS(low) * FT(high)
 	addu	t3, t3, v0			# add carry
 	not	v0, t8
 	mflo	v1
 	mfhi	t2
 	sltu	v0, v0, v1
 	addu	t8, v1
-	multu	t4, t6				# multiply FS(high) * FT(high)
+	multu	ta0, ta2			# multiply FS(high) * FT(high)
 	addu	t3, v0
 	not	v1, t3
 	sltu	v1, v1, t2
@@ -1050,24 +1050,24 @@
  */
 div_s:
 	jal	get_ft_fs_s
-	xor	t0, t0, t4			# compute sign of result
-	move	t4, t0
+	xor	t0, t0, ta0			# compute sign of result
+	move	ta0, t0
 	bne	t1, SEXP_INF, 1f		# is FS an infinity?
 	bne	t2, zero, result_fs_s		# if FS is NAN, result is FS
-	bne	t5, SEXP_INF, result_fs_s	# is FT an infinity?
-	bne	t6, zero, result_ft_s		# if FT is NAN, result is FT
+	bne	ta1, SEXP_INF, result_fs_s	# is FT an infinity?
+	bne	ta2, zero, result_ft_s		# if FT is NAN, result is FT
 	b	invalid_s			# infinity/infinity is invalid
 1:
-	bne	t5, SEXP_INF, 1f		# is FT an infinity?
-	bne	t6, zero, result_ft_s		# if FT is NAN, result is FT
+	bne	ta1, SEXP_INF, 1f		# is FT an infinity?
+	bne	ta2, zero, result_ft_s		# if FT is NAN, result is FT
 	move	t1, zero			# x / infinity is zero
 	move	t2, zero
 	b	result_fs_s
 1:
 	bne	t1, zero, 2f			# is FS zero?
 	bne	t2, zero, 1f
-	bne	t5, zero, result_fs_s		# FS=zero, is FT zero?
-	beq	t6, zero, invalid_s		# 0 / 0
+	bne	ta1, zero, result_fs_s		# FS=zero, is FT zero?
+	beq	ta2, zero, invalid_s		# 0 / 0
 	b	result_fs_s			# result = zero
 1:
 	jal	renorm_fs_s
@@ -1076,8 +1076,8 @@
 	subu	t1, t1, SEXP_BIAS		# unbias FS exponent
 	or	t2, t2, SIMPL_ONE		# set implied one bit
 3:
-	bne	t5, zero, 2f			# is FT zero?
-	bne	t6, zero, 1f
+	bne	ta1, zero, 2f			# is FT zero?
+	bne	ta2, zero, 1f
 	or	a1, a1, FPC_EXCEPTION_DIV0 | FPC_STICKY_DIV0
 	and	v0, a1, FPC_ENABLE_DIV0 	# trap enabled?
 	bne	v0, zero, fpe_trap
@@ -1089,18 +1089,18 @@
 	jal	renorm_ft_s
 	b	3f
 2:
-	subu	t5, t5, SEXP_BIAS		# unbias FT exponent
-	or	t6, t6, SIMPL_ONE		# set implied one bit
+	subu	ta1, ta1, SEXP_BIAS		# unbias FT exponent
+	or	ta2, ta2, SIMPL_ONE		# set implied one bit
 3:
-	subu	t1, t1, t5			# compute exponent
+	subu	t1, t1, ta1			# compute exponent
 	subu	t1, t1, 3			# compensate for result position
 	li	v0, SFRAC_BITS+3		# number of bits to divide
 	move	t8, t2				# init dividend
 	move	t2, zero			# init result
 1:
-	bltu	t8, t6, 3f			# is dividend >= divisor?
+	bltu	t8, ta2, 3f			# is dividend >= divisor?
 2:
-	subu	t8, t8, t6			# subtract divisor from dividend
+	subu	t8, t8, ta2			# subtract divisor from dividend
 	or	t2, t2, 1			# remember that we did
 	bne	t8, zero, 3f			# if not done, continue
 	sll	t2, t2, v0			# shift result to final position
@@ -1117,19 +1117,19 @@
  */
 div_d:
 	jal	get_ft_fs_d
-	xor	t0, t0, t4			# compute sign of result
-	move	t4, t0
+	xor	t0, t0, ta0			# compute sign of result
+	move	ta0, t0
 	bne	t1, DEXP_INF, 1f		# is FS an infinity?
 	bne	t2, zero, result_fs_d		# if FS is NAN, result is FS
 	bne	t3, zero, result_fs_d
-	bne	t5, DEXP_INF, result_fs_d	# is FT an infinity?
-	bne	t6, zero, result_ft_d		# if FT is NAN, result is FT
-	bne	t7, zero, result_ft_d
+	bne	ta1, DEXP_INF, result_fs_d	# is FT an infinity?
+	bne	ta2, zero, result_ft_d		# if FT is NAN, result is FT
+	bne	ta3, zero, result_ft_d
 	b	invalid_d			# infinity/infinity is invalid
 1:
-	bne	t5, DEXP_INF, 1f		# is FT an infinity?
-	bne	t6, zero, result_ft_d		# if FT is NAN, result is FT
-	bne	t7, zero, result_ft_d
+	bne	ta1, DEXP_INF, 1f		# is FT an infinity?
+	bne	ta2, zero, result_ft_d		# if FT is NAN, result is FT
+	bne	ta3, zero, result_ft_d
 	move	t1, zero			# x / infinity is zero
 	move	t2, zero
 	move	t3, zero
@@ -1138,9 +1138,9 @@
 	bne	t1, zero, 2f			# is FS zero?
 	bne	t2, zero, 1f
 	bne	t3, zero, 1f
-	bne	t5, zero, result_fs_d		# FS=zero, is FT zero?
-	bne	t6, zero, result_fs_d
-	beq	t7, zero, invalid_d		# 0 / 0
+	bne	ta1, zero, result_fs_d		# FS=zero, is FT zero?
+	bne	ta2, zero, result_fs_d
+	beq	ta3, zero, invalid_d		# 0 / 0
 	b	result_fs_d			# result = zero
 1:
 	jal	renorm_fs_d
@@ -1149,9 +1149,9 @@
 	subu	t1, t1, DEXP_BIAS		# unbias FS exponent
 	or	t2, t2, DIMPL_ONE		# set implied one bit
 3:
-	bne	t5, zero, 2f			# is FT zero?
-	bne	t6, zero, 1f
-	bne	t7, zero, 1f
+	bne	ta1, zero, 2f			# is FT zero?
+	bne	ta2, zero, 1f
+	bne	ta3, zero, 1f
 	or	a1, a1, FPC_EXCEPTION_DIV0 | FPC_STICKY_DIV0
 	and	v0, a1, FPC_ENABLE_DIV0		# trap enabled?
 	bne	v0, zero, fpe_trap
@@ -1164,10 +1164,10 @@
 	jal	renorm_ft_d
 	b	3f
 2:
-	subu	t5, t5, DEXP_BIAS		# unbias FT exponent
-	or	t6, t6, DIMPL_ONE		# set implied one bit
+	subu	ta1, ta1, DEXP_BIAS		# unbias FT exponent
+	or	ta2, ta2, DIMPL_ONE		# set implied one bit
 3:
-	subu	t1, t1, t5			# compute exponent
+	subu	t1, t1, ta1			# compute exponent
 	subu	t1, t1, 3			# compensate for result position
 	li	v0, DFRAC_BITS+3		# number of bits to divide
 	move	t8, t2				# init dividend
@@ -1175,13 +1175,13 @@
 	move	t2, zero			# init result
 	move	t3, zero
 1:
-	bltu	t8, t6, 3f			# is dividend >= divisor?
-	bne	t8, t6, 2f
-	bltu	t9, t7, 3f
-2:
-	sltu	v1, t9, t7			# subtract divisor from dividend
-	subu	t9, t9, t7
-	subu	t8, t8, t6
+	bltu	t8, ta2, 3f			# is dividend >= divisor?
+	bne	t8, ta2, 2f
+	bltu	t9, ta3, 3f
+2:
+	sltu	v1, t9, ta3			# subtract divisor from dividend
+	subu	t9, t9, ta3
+	subu	t8, t8, ta2
 	subu	t8, t8, v1
 	or	t3, t3, 1			# remember that we did
 	bne	t8, zero, 3f			# if not done, continue
@@ -1576,23 +1576,23 @@
 	bne	t1, SEXP_INF, 1f		# is FS an infinity?
 	bne	t2, zero, unordered		# FS is a NAN
 1:
-	bne	t5, SEXP_INF, 2f		# is FT an infinity?
-	bne	t6, zero, unordered		# FT is a NAN
+	bne	ta1, SEXP_INF, 2f		# is FT an infinity?
+	bne	ta2, zero, unordered		# FT is a NAN
 2:
 	sll	t1, t1, 23			# reassemble exp & frac
 	or	t1, t1, t2
-	sll	t5, t5, 23			# reassemble exp & frac
-	or	t5, t5, t6
+	sll	ta1, ta1, 23			# reassemble exp & frac
+	or	ta1, ta1, ta2
 	beq	t0, zero, 1f			# is FS positive?
 	negu	t1
 1:
-	beq	t4, zero, 1f			# is FT positive?
-	negu	t5
+	beq	ta0, zero, 1f			# is FT positive?
+	negu	ta1
 1:
 	li	v0, COND_LESS
-	blt	t1, t5, test_cond		# is FS < FT?
+	blt	t1, ta1, test_cond		# is FS < FT?
 	li	v0, COND_EQUAL
-	beq	t1, t5, test_cond		# is FS == FT?
+	beq	t1, ta1, test_cond		# is FS == FT?
 	move	v0, zero			# FS > FT
 	b	test_cond
 
@@ -1605,14 +1605,14 @@
 	bne	t2, zero, unordered
 	bne	t3, zero, unordered		# FS is a NAN
 1:
-	bne	t5, DEXP_INF, 2f		# is FT an infinity?
-	bne	t6, zero, unordered
-	bne	t7, zero, unordered		# FT is a NAN
+	bne	ta1, DEXP_INF, 2f		# is FT an infinity?
+	bne	ta2, zero, unordered
+	bne	ta3, zero, unordered		# FT is a NAN
 2:
 	sll	t1, t1, 20			# reassemble exp & frac
 	or	t1, t1, t2
-	sll	t5, t5, 20			# reassemble exp & frac
-	or	t5, t5, t6
+	sll	ta1, ta1, 20			# reassemble exp & frac
+	or	ta1, ta1, ta2
 	beq	t0, zero, 1f			# is FS positive?
 	not	t3				# negate t1,t3
 	not	t1
@@ -1620,21 +1620,21 @@
 	seq	v0, t3, zero			# compute carry
 	addu	t1, t1, v0
 1:
-	beq	t4, zero, 1f			# is FT positive?
-	not	t7				# negate t5,t7
-	not	t5
-	addu	t7, t7, 1
-	seq	v0, t7, zero			# compute carry
-	addu	t5, t5, v0
+	beq	ta0, zero, 1f			# is FT positive?
+	not	ta3				# negate ta1,ta3
+	not	ta1
+	addu	ta3, ta3, 1
+	seq	v0, ta3, zero			# compute carry
+	addu	ta1, ta1, v0
 1:
 	li	v0, COND_LESS
-	blt	t1, t5, test_cond		# is FS(MSW) < FT(MSW)?
+	blt	t1, ta1, test_cond		# is FS(MSW) < FT(MSW)?
 	move	v0, zero
-	bne	t1, t5, test_cond		# is FS(MSW) > FT(MSW)?
+	bne	t1, ta1, test_cond		# is FS(MSW) > FT(MSW)?
 	li	v0, COND_LESS
-	bltu	t3, t7, test_cond		# is FS(LSW) < FT(LSW)?
+	bltu	t3, ta3, test_cond		# is FS(LSW) < FT(LSW)?
 	li	v0, COND_EQUAL
-	beq	t3, t7, test_cond		# is FS(LSW) == FT(LSW)?
+	beq	t3, ta3, test_cond		# is FS(LSW) == FT(LSW)?
 	move	v0, zero			# FS > FT
 test_cond:
 	and	v0, v0, a0			# condition match instruction?
@@ -1725,8 +1725,8 @@
 	or	t8, t8, v0
 	srl	t2, t2, t9
 norm_noshift_s:
-	move	t5, t1				# save unrounded exponent
-	move	t6, t2				# save unrounded fraction
+	move	ta1, t1				# save unrounded exponent
+	move	ta2, t2				# save unrounded fraction
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
 	beq	v0, FPC_ROUND_RN, 3f		# round to nearest
 	beq	v0, FPC_ROUND_RZ, 5f		# round to zero (truncate)
@@ -1826,8 +1826,8 @@
  * signal inexact result (if it is) and trap (if enabled).
  */
 1:
-	move	t1, t5				# get unrounded exponent
-	move	t2, t6				# get unrounded fraction
+	move	t1, ta1				# get unrounded exponent
+	move	t2, ta2				# get unrounded fraction
 	li	t9, SEXP_MIN			# compute shift amount
 	subu	t9, t9, t1			# shift t2,t8 right by t9
 	blt	t9, SFRAC_BITS+2, 3f		# shift all the bits out?
@@ -1841,7 +1841,7 @@
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
 	beq	v0, FPC_ROUND_RN, inexact_nobias_s # round to nearest
 	beq	v0, FPC_ROUND_RZ, inexact_nobias_s # round to zero
-	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
+	beq	v0, FPC_ROUND_RP, 1f		# round to +infinity
 	beq	t0, zero, inexact_nobias_s	# if sign is positive, truncate
 	b	2f
 1:
@@ -1970,9 +1970,9 @@
 	or	t3, t3, v0
 	srl	t2, t2, t9
 norm_noshift_d:
-	move	t5, t1				# save unrounded exponent
-	move	t6, t2				# save unrounded fraction (MS)
-	move	t7, t3				# save unrounded fraction (LS)
+	move	ta1, t1				# save unrounded exponent
+	move	ta2, t2				# save unrounded fraction (MS)
+	move	ta3, t3				# save unrounded fraction (LS)
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
 	beq	v0, FPC_ROUND_RN, 3f		# round to nearest
 	beq	v0, FPC_ROUND_RZ, 5f		# round to zero (truncate)
@@ -2078,9 +2078,9 @@
  * signal inexact result (if it is) and trap (if enabled).
  */
 1:
-	move	t1, t5				# get unrounded exponent
-	move	t2, t6				# get unrounded fraction (MS)
-	move	t3, t7				# get unrounded fraction (LS)
+	move	t1, ta1				# get unrounded exponent
+	move	t2, ta2				# get unrounded fraction (MS)
+	move	t3, ta3				# get unrounded fraction (LS)
 	li	t9, DEXP_MIN			# compute shift amount
 	subu	t9, t9, t1			# shift t2,t8 right by t9
 	blt	t9, DFRAC_BITS+2, 3f		# shift all the bits out?
@@ -2095,7 +2095,7 @@
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
 	beq	v0, FPC_ROUND_RN, inexact_nobias_d  # round to nearest
 	beq	v0, FPC_ROUND_RZ, inexact_nobias_d  # round to zero
-	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
+	beq	v0, FPC_ROUND_RP, 1f		# round to +infinity
 	beq	t0, zero, inexact_nobias_d	# if sign is positive, truncate
 	b	2f
 1:
@@ -2128,9 +2128,9 @@
  */
 2:
 	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
-	beq	v0, FPC_ROUND_RN, 3f	# round to nearest
-	beq	v0, FPC_ROUND_RZ, 5f	# round to zero (truncate)
-	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
+	beq	v0, FPC_ROUND_RN, 3f		# round to nearest
+	beq	v0, FPC_ROUND_RZ, 5f		# round to zero (truncate)
+	beq	v0, FPC_ROUND_RP, 1f		# round to +infinity
 	beq	t0, zero, 5f			# if sign is positive, truncate
 	b	2f
 1:
@@ -2227,9 +2227,9 @@
 	break	0
 
 result_ft_s:
-	move	t0, t4				# result is FT
-	move	t1, t5
-	move	t2, t6
+	move	t0, ta0				# result is FT
+	move	t1, ta1
+	move	t2, ta2
 result_fs_s:					# result is FS
 	jal	set_fd_s			# save result (in t0,t1,t2)
 	b	done
@@ -2239,10 +2239,10 @@
 	b	done
 
 result_ft_d:
-	move	t0, t4				# result is FT
-	move	t1, t5
-	move	t2, t6
-	move	t3, t7
+	move	t0, ta0				# result is FT
+	move	t1, ta1
+	move	t2, ta2
+	move	t3, ta3
 result_fs_d:					# result is FS
 	jal	set_fd_d			# save result (in t0,t1,t2,t3)
 
@@ -2356,9 +2356,9 @@
  *	t0	contains the FS sign
  *	t1	contains the FS (biased) exponent
  *	t2	contains the FS fraction
- *	t4	contains the FT sign
- *	t5	contains the FT (biased) exponent
- *	t6	contains the FT fraction
+ *	ta0	contains the FT sign
+ *	ta1	contains the FT (biased) exponent
+ *	ta2	contains the FT fraction
  *
  *----------------------------------------------------------------------------
  */
@@ -2389,59 +2389,59 @@
 	.text
 
 get_ft_s_f0:
-	mfc1	t4, $f0
+	mfc1	ta0, $f0
 	b	get_ft_s_done
 get_ft_s_f2:
-	mfc1	t4, $f2
+	mfc1	ta0, $f2
 	b	get_ft_s_done
 get_ft_s_f4:
-	mfc1	t4, $f4
+	mfc1	ta0, $f4
 	b	get_ft_s_done
 get_ft_s_f6:
-	mfc1	t4, $f6
+	mfc1	ta0, $f6
 	b	get_ft_s_done
 get_ft_s_f8:
-	mfc1	t4, $f8
+	mfc1	ta0, $f8
 	b	get_ft_s_done
 get_ft_s_f10:
-	mfc1	t4, $f10
+	mfc1	ta0, $f10
 	b	get_ft_s_done
 get_ft_s_f12:
-	mfc1	t4, $f12
+	mfc1	ta0, $f12
 	b	get_ft_s_done
 get_ft_s_f14:
-	mfc1	t4, $f14
+	mfc1	ta0, $f14
 	b	get_ft_s_done
 get_ft_s_f16:
-	mfc1	t4, $f16
+	mfc1	ta0, $f16
 	b	get_ft_s_done
 get_ft_s_f18:
-	mfc1	t4, $f18
+	mfc1	ta0, $f18
 	b	get_ft_s_done
 get_ft_s_f20:
-	mfc1	t4, $f20
+	mfc1	ta0, $f20
 	b	get_ft_s_done
 get_ft_s_f22:
-	mfc1	t4, $f22
+	mfc1	ta0, $f22
 	b	get_ft_s_done
 get_ft_s_f24:
-	mfc1	t4, $f24
+	mfc1	ta0, $f24
 	b	get_ft_s_done
 get_ft_s_f26:
-	mfc1	t4, $f26
+	mfc1	ta0, $f26
 	b	get_ft_s_done
 get_ft_s_f28:
-	mfc1	t4, $f28
+	mfc1	ta0, $f28
 	b	get_ft_s_done
 get_ft_s_f30:
-	mfc1	t4, $f30
+	mfc1	ta0, $f30
 get_ft_s_done:
-	srl	t5, t4, 23			# get exponent
-	and	t5, t5, 0xFF
-	and	t6, t4, 0x7FFFFF		# get fraction
-	srl	t4, t4, 31			# get sign
-	bne	t5, SEXP_INF, 1f		# is it a signaling NAN?
-	and	v0, t6, SSIGNAL_NAN
+	srl	ta1, ta0, 23			# get exponent
+	and	ta1, ta1, 0xFF
+	and	ta2, ta0, 0x7FFFFF		# get fraction
+	srl	ta0, ta0, 31			# get sign
+	bne	ta1, SEXP_INF, 1f		# is it a signaling NAN?
+	and	v0, ta2, SSIGNAL_NAN
 	bne	v0, zero, invalid_s
 1:
 	/* fall through to get FS */
@@ -2557,10 +2557,10 @@
  *	t1	contains the FS (biased) exponent
  *	t2	contains the FS fraction
  *	t3	contains the FS remaining fraction
- *	t4	contains the FT sign
- *	t5	contains the FT (biased) exponent
- *	t6	contains the FT fraction
- *	t7	contains the FT remaining fraction
+ *	ta0	contains the FT sign
+ *	ta1	contains the FT (biased) exponent
+ *	ta2	contains the FT fraction
+ *	ta3	contains the FT remaining fraction
  *
  *----------------------------------------------------------------------------
  */
@@ -2591,75 +2591,75 @@
 	.text
 
 get_ft_d_f0:
-	mfc1	t7, $f0
-	mfc1	t4, $f1
+	mfc1	ta3, $f0
+	mfc1	ta0, $f1
 	b	get_ft_d_done
 get_ft_d_f2:
-	mfc1	t7, $f2
-	mfc1	t4, $f3
+	mfc1	ta3, $f2
+	mfc1	ta0, $f3
 	b	get_ft_d_done
 get_ft_d_f4:
-	mfc1	t7, $f4
-	mfc1	t4, $f5
+	mfc1	ta3, $f4
+	mfc1	ta0, $f5
 	b	get_ft_d_done
 get_ft_d_f6:
-	mfc1	t7, $f6
-	mfc1	t4, $f7
+	mfc1	ta3, $f6
+	mfc1	ta0, $f7
 	b	get_ft_d_done
 get_ft_d_f8:
-	mfc1	t7, $f8
-	mfc1	t4, $f9
+	mfc1	ta3, $f8
+	mfc1	ta0, $f9
 	b	get_ft_d_done
 get_ft_d_f10:
-	mfc1	t7, $f10
-	mfc1	t4, $f11
+	mfc1	ta3, $f10
+	mfc1	ta0, $f11
 	b	get_ft_d_done
 get_ft_d_f12:
-	mfc1	t7, $f12
-	mfc1	t4, $f13
+	mfc1	ta3, $f12
+	mfc1	ta0, $f13
 	b	get_ft_d_done
 get_ft_d_f14:
-	mfc1	t7, $f14
-	mfc1	t4, $f15
+	mfc1	ta3, $f14
+	mfc1	ta0, $f15
 	b	get_ft_d_done
 get_ft_d_f16:
-	mfc1	t7, $f16
-	mfc1	t4, $f17
+	mfc1	ta3, $f16
+	mfc1	ta0, $f17
 	b	get_ft_d_done
 get_ft_d_f18:
-	mfc1	t7, $f18
-	mfc1	t4, $f19
+	mfc1	ta3, $f18
+	mfc1	ta0, $f19
 	b	get_ft_d_done
 get_ft_d_f20:
-	mfc1	t7, $f20
-	mfc1	t4, $f21
+	mfc1	ta3, $f20
+	mfc1	ta0, $f21
 	b	get_ft_d_done
 get_ft_d_f22:
-	mfc1	t7, $f22
-	mfc1	t4, $f23
+	mfc1	ta3, $f22
+	mfc1	ta0, $f23
 	b	get_ft_d_done
 get_ft_d_f24:
-	mfc1	t7, $f24
-	mfc1	t4, $f25
+	mfc1	ta3, $f24
+	mfc1	ta0, $f25
 	b	get_ft_d_done
 get_ft_d_f26:
-	mfc1	t7, $f26
-	mfc1	t4, $f27
+	mfc1	ta3, $f26
+	mfc1	ta0, $f27
 	b	get_ft_d_done
 get_ft_d_f28:
-	mfc1	t7, $f28
-	mfc1	t4, $f29
+	mfc1	ta3, $f28
+	mfc1	ta0, $f29
 	b	get_ft_d_done
 get_ft_d_f30:
-	mfc1	t7, $f30
-	mfc1	t4, $f31
+	mfc1	ta3, $f30
+	mfc1	ta0, $f31
 get_ft_d_done:
-	srl	t5, t4, 20			# get exponent
-	and	t5, t5, 0x7FF
-	and	t6, t4, 0xFFFFF			# get fraction
-	srl	t4, t4, 31			# get sign
-	bne	t5, DEXP_INF, 1f		# is it a signaling NAN?
-	and	v0, t6, DSIGNAL_NAN
+	srl	ta1, ta0, 20			# get exponent
+	and	ta1, ta1, 0x7FF
+	and	ta2, ta0, 0xFFFFF		# get fraction
+	srl	ta0, ta0, 31			# get sign
+	bne	ta1, DEXP_INF, 1f		# is it a signaling NAN?
+	and	v0, ta2, DSIGNAL_NAN
 	bne	v0, zero, invalid_d
 1:
 	/* fall through to get FS */
@@ -2791,9 +2791,9 @@
  *	t0	contains the sign
  *	t1	contains the (biased) exponent
  *	t2	contains the fraction
- *	t4	contains the sign
- *	t5	contains the (biased) exponent
- *	t6	contains the fraction
+ *	ta0	contains the sign
+ *	ta1	contains the (biased) exponent
+ *	ta2	contains the fraction
  *
  *----------------------------------------------------------------------------
  */
@@ -2902,57 +2902,57 @@
 	.text
 
 cmp_ft_s_f0:
-	mfc1	t4, $f0
+	mfc1	ta0, $f0
 	b	cmp_ft_s_done
 cmp_ft_s_f2:
-	mfc1	t4, $f2
+	mfc1	ta0, $f2
 	b	cmp_ft_s_done
 cmp_ft_s_f4:
-	mfc1	t4, $f4
+	mfc1	ta0, $f4
 	b	cmp_ft_s_done
 cmp_ft_s_f6:
-	mfc1	t4, $f6
+	mfc1	ta0, $f6
 	b	cmp_ft_s_done
 cmp_ft_s_f8:
-	mfc1	t4, $f8
+	mfc1	ta0, $f8
 	b	cmp_ft_s_done
 cmp_ft_s_f10:
-	mfc1	t4, $f10
+	mfc1	ta0, $f10
 	b	cmp_ft_s_done
 cmp_ft_s_f12:
-	mfc1	t4, $f12
+	mfc1	ta0, $f12
 	b	cmp_ft_s_done
 cmp_ft_s_f14:
-	mfc1	t4, $f14
+	mfc1	ta0, $f14
 	b	cmp_ft_s_done
 cmp_ft_s_f16:
-	mfc1	t4, $f16
+	mfc1	ta0, $f16
 	b	cmp_ft_s_done
 cmp_ft_s_f18:
-	mfc1	t4, $f18
+	mfc1	ta0, $f18
 	b	cmp_ft_s_done
 cmp_ft_s_f20:
-	mfc1	t4, $f20
+	mfc1	ta0, $f20
 	b	cmp_ft_s_done
 cmp_ft_s_f22:
-	mfc1	t4, $f22
+	mfc1	ta0, $f22
 	b	cmp_ft_s_done
 cmp_ft_s_f24:
-	mfc1	t4, $f24
+	mfc1	ta0, $f24
 	b	cmp_ft_s_done
 cmp_ft_s_f26:
-	mfc1	t4, $f26
+	mfc1	ta0, $f26
 	b	cmp_ft_s_done
 cmp_ft_s_f28:
-	mfc1	t4, $f28
+	mfc1	ta0, $f28
 	b	cmp_ft_s_done
 cmp_ft_s_f30:
-	mfc1	t4, $f30
+	mfc1	ta0, $f30
 cmp_ft_s_done:
-	srl	t5, t4, 23			# get exponent
-	and	t5, t5, 0xFF
-	and	t6, t4, 0x7FFFFF		# get fraction
-	srl	t4, t4, 31			# get sign
+	srl	ta1, ta0, 23			# get exponent
+	and	ta1, ta1, 0xFF
+	and	ta2, ta0, 0x7FFFFF		# get fraction
+	srl	ta0, ta0, 31			# get sign
 	j	ra
 END(get_cmp_s)
 
@@ -2968,10 +2968,10 @@
  *	t1	contains the (biased) exponent
  *	t2	contains the fraction
  *	t3	contains the remaining fraction
- *	t4	contains the sign
- *	t5	contains the (biased) exponent
- *	t6	contains the fraction
- *	t7	contains the remaining fraction
+ *	ta0	contains the sign
+ *	ta1	contains the (biased) exponent
+ *	ta2	contains the fraction
+ *	ta3	contains the remaining fraction
  *
  *----------------------------------------------------------------------------
  */
@@ -3096,73 +3096,73 @@
 	.text
 
 cmp_ft_d_f0:
-	mfc1	t7, $f0
-	mfc1	t4, $f1
+	mfc1	ta3, $f0
+	mfc1	ta0, $f1
 	b	cmp_ft_d_done
 cmp_ft_d_f2:
-	mfc1	t7, $f2
-	mfc1	t4, $f3
+	mfc1	ta3, $f2
+	mfc1	ta0, $f3
 	b	cmp_ft_d_done
 cmp_ft_d_f4:
-	mfc1	t7, $f4
-	mfc1	t4, $f5
+	mfc1	ta3, $f4
+	mfc1	ta0, $f5
 	b	cmp_ft_d_done
 cmp_ft_d_f6:
-	mfc1	t7, $f6
-	mfc1	t4, $f7
+	mfc1	ta3, $f6
+	mfc1	ta0, $f7
 	b	cmp_ft_d_done
 cmp_ft_d_f8:
-	mfc1	t7, $f8
-	mfc1	t4, $f9
+	mfc1	ta3, $f8
+	mfc1	ta0, $f9
 	b	cmp_ft_d_done
 cmp_ft_d_f10:
-	mfc1	t7, $f10
-	mfc1	t4, $f11
+	mfc1	ta3, $f10
+	mfc1	ta0, $f11
 	b	cmp_ft_d_done
 cmp_ft_d_f12:
-	mfc1	t7, $f12
-	mfc1	t4, $f13
+	mfc1	ta3, $f12
+	mfc1	ta0, $f13
 	b	cmp_ft_d_done
 cmp_ft_d_f14:
-	mfc1	t7, $f14
-	mfc1	t4, $f15
+	mfc1	ta3, $f14
+	mfc1	ta0, $f15
 	b	cmp_ft_d_done
 cmp_ft_d_f16:
-	mfc1	t7, $f16
-	mfc1	t4, $f17
+	mfc1	ta3, $f16
+	mfc1	ta0, $f17
 	b	cmp_ft_d_done
 cmp_ft_d_f18:
-	mfc1	t7, $f18
-	mfc1	t4, $f19
+	mfc1	ta3, $f18
+	mfc1	ta0, $f19
 	b	cmp_ft_d_done
 cmp_ft_d_f20:
-	mfc1	t7, $f20
-	mfc1	t4, $f21
+	mfc1	ta3, $f20
+	mfc1	ta0, $f21
 	b	cmp_ft_d_done
 cmp_ft_d_f22:
-	mfc1	t7, $f22
-	mfc1	t4, $f23
+	mfc1	ta3, $f22
+	mfc1	ta0, $f23
 	b	cmp_ft_d_done
 cmp_ft_d_f24:
-	mfc1	t7, $f24
-	mfc1	t4, $f25
+	mfc1	ta3, $f24
+	mfc1	ta0, $f25
 	b	cmp_ft_d_done
 cmp_ft_d_f26:
-	mfc1	t7, $f26
-	mfc1	t4, $f27
+	mfc1	ta3, $f26
+	mfc1	ta0, $f27
 	b	cmp_ft_d_done
 cmp_ft_d_f28:
-	mfc1	t7, $f28
-	mfc1	t4, $f29
+	mfc1	ta3, $f28
+	mfc1	ta0, $f29
 	b	cmp_ft_d_done
 cmp_ft_d_f30:
-	mfc1	t7, $f30
-	mfc1	t4, $f31
+	mfc1	ta3, $f30
+	mfc1	ta0, $f31
 cmp_ft_d_done:
-	srl	t5, t4, 20			# get exponent
-	and	t5, t5, 0x7FF
-	and	t6, t4, 0xFFFFF			# get fraction
-	srl	t4, t4, 31			# get sign
+	srl	ta1, ta0, 20			# get exponent
+	and	ta1, ta1, 0x7FF
+	and	ta2, ta0, 0xFFFFF		# get fraction
+	srl	ta0, ta0, 31			# get sign
 	j	ra
 END(get_cmp_d)
 
@@ -3498,16 +3498,16 @@
  * renorm_ft_s --
  *
  * Results:
- *	t5	unbiased exponent
- *	t6	normalized fraction
+ *	ta1	unbiased exponent
+ *	ta2	normalized fraction
  *
  *----------------------------------------------------------------------------
  */
 LEAF(renorm_ft_s)
 /*
- * Find out how many leading zero bits are in t6 and put in t9.
+ * Find out how many leading zero bits are in ta2 and put in t9.
  */
-	move	v0, t6
+	move	v0, ta2
 	move	t9, zero
 	srl	v1, v0, 16
 	bne	v1, zero, 1f
@@ -3533,13 +3533,13 @@
 	bne	v1, zero, 1f
 	addu	t9, 1
 /*
- * Now shift t6 the correct number of bits.
+ * Now shift ta2 the correct number of bits.
  */
 1:
 	subu	t9, t9, SLEAD_ZEROS	# dont count normal leading zeros
-	li	t5, SEXP_MIN
-	subu	t5, t5, t9		# adjust exponent
-	sll	t6, t6, t9
+	li	ta1, SEXP_MIN
+	subu	ta1, ta1, t9		# adjust exponent
+	sll	ta2, ta2, t9
 	j	ra
 END(renorm_ft_s)
 
@@ -3547,19 +3547,19 @@
  * renorm_ft_d --
  *
  * Results:
- *	t5	unbiased exponent
- *	t6,t7	normalized fraction
+ *	ta1	unbiased exponent
+ *	ta2,ta3	normalized fraction
  *
  *----------------------------------------------------------------------------
  */
 LEAF(renorm_ft_d)
 /*
- * Find out how many leading zero bits are in t6,t7 and put in t9.
+ * Find out how many leading zero bits are in ta2,ta3 and put in t9.
  */
-	move	v0, t6
+	move	v0, ta2
 	move	t9, zero
-	bne	t6, zero, 1f
-	move	v0, t7
+	bne	ta2, zero, 1f
+	move	v0, ta3
 	addu	t9, 32
 1:
 	srl	v1, v0, 16
@@ -3586,23 +3586,23 @@
 	bne	v1, zero, 1f
 	addu	t9, 1
 /*
- * Now shift t6,t7 the correct number of bits.
+ * Now shift ta2,ta3 the correct number of bits.
  */
 1:
 	subu	t9, t9, DLEAD_ZEROS	# dont count normal leading zeros
-	li	t5, DEXP_MIN
-	subu	t5, t5, t9		# adjust exponent
+	li	ta1, DEXP_MIN
+	subu	ta1, ta1, t9		# adjust exponent
 	li	v0, 32
 	blt	t9, v0, 1f
 	subu	t9, t9, v0		# shift fraction left >= 32 bits
-	sll	t6, t7, t9
-	move	t7, zero
+	sll	ta2, ta3, t9
+	move	ta3, zero
 	j	ra
 1:
 	subu	v0, v0, t9		# shift fraction left < 32 bits
-	sll	t6, t6, t9
-	srl	v1, t7, v0
-	or	t6, t6, v1
-	sll	t7, t7, t9
+	sll	ta2, ta2, t9
+	srl	v1, ta3, v0
+	or	ta2, ta2, v1
+	sll	ta3, ta3, t9
 	j	ra
 END(renorm_ft_d)
diff -I '.*' -Naur releng8/sys/mips/mips/genassym.c svn/mips/sys/mips/mips/genassym.c
--- releng8/src/sys/mips/mips/genassym.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/genassym.c	2009-08-04 10:47:01.000000000 -0700
@@ -69,6 +69,7 @@
 ASSYM(TD_FLAGS, offsetof(struct thread, td_flags));
 ASSYM(TD_LOCK, offsetof(struct thread, td_lock));
 ASSYM(TD_FRAME, offsetof(struct thread, td_frame));
+ASSYM(TD_TLS, offsetof(struct thread, td_md.md_tls));
 
 ASSYM(TF_REG_SR, offsetof(struct trapframe, sr));
 
@@ -90,6 +91,7 @@
 ASSYM(VM_KERNEL_ALLOC_OFFSET, VM_KERNEL_ALLOC_OFFSET);
 ASSYM(SIGF_UC, offsetof(struct sigframe, sf_uc));
 ASSYM(SIGFPE, SIGFPE);
+ASSYM(PAGE_SHIFT, PAGE_SHIFT);
 ASSYM(PGSHIFT, PGSHIFT);
 ASSYM(NBPG, NBPG);
 ASSYM(SEGSHIFT, SEGSHIFT);
diff -I '.*' -Naur releng8/sys/mips/mips/in_cksum.c svn/mips/sys/mips/mips/in_cksum.c
--- releng8/src/sys/mips/mips/in_cksum.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/in_cksum.c	2009-08-04 10:47:01.000000000 -0700
@@ -226,7 +226,7 @@
 		if (len < mlen)
 			mlen = len;
 
-		if ((clen ^ (int) addr) & 1)
+		if ((clen ^ (uintptr_t) addr) & 1)
 			sum += in_cksumdata(addr, mlen) << 8;
 		else
 			sum += in_cksumdata(addr, mlen);
diff -I '.*' -Naur releng8/sys/mips/mips/inckern.S svn/mips/sys/mips/mips/inckern.S
--- releng8/src/sys/mips/mips/inckern.S	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/mips/inckern.S	2009-04-14 15:39:44.000000000 -0700
@@ -0,0 +1,34 @@
+/*-
+ * Copyright (c) 2005 Olivier Houchard.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opt_kernname.h"
+
+#include <machine/asm.h>
+__FBSDID("$FreeBSD$")
+.section ".real_kernel","aw"
+.globl kernel_start;
+kernel_start:
+.incbin KERNNAME
+.globl kernel_end;
+kernel_end:
diff -I '.*' -Naur releng8/sys/mips/mips/intr_machdep.c svn/mips/sys/mips/mips/intr_machdep.c
--- releng8/src/sys/mips/mips/intr_machdep.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/intr_machdep.c	2009-08-04 10:47:01.000000000 -0700
@@ -53,18 +53,39 @@
 static int last_printed = 0;
 #endif
 
-void
-mips_mask_irq(void)
+static void
+mips_mask_hard_irq(void *source)
 {
+	uintptr_t irq = (uintptr_t)source;
 
+	mips_wr_status(mips_rd_status() & ~(((1 << irq) << 8) << 2));
 }
 
-void
-mips_unmask_irq(void)
+static void
+mips_unmask_hard_irq(void *source)
 {
+	uintptr_t irq = (uintptr_t)source;
 
+	mips_wr_status(mips_rd_status() | (((1 << irq) << 8) << 2));
 }
 
+static void
+mips_mask_soft_irq(void *source)
+{
+	uintptr_t irq = (uintptr_t)source;
+
+	mips_wr_status(mips_rd_status() & ~((1 << irq) << 8));
+}
+
+static void
+mips_unmask_soft_irq(void *source)
+{
+	uintptr_t irq = (uintptr_t)source;
+
+	mips_wr_status(mips_rd_status() | ((1 << irq) << 8));
+}
+
+
 void
 cpu_establish_hardintr(const char *name, driver_filter_t *filt,
     void (*handler)(void*), void *arg, int irq, int flags, void **cookiep)
@@ -72,8 +93,10 @@
 	struct intr_event *event;
 	int error;
 
+#if 0
 	printf("Establish HARD IRQ %d: filt %p handler %p arg %p\n",
 	    irq, filt, handler, arg);
+#endif
 	/*
 	 * We have 6 levels, but thats 0 - 5 (not including 6)
 	 */
@@ -82,8 +105,8 @@
 
 	event = hardintr_events[irq];
 	if (event == NULL) {
-		error = intr_event_create(&event, (void *)irq, 0, irq,
-		    (mask_fn)mips_mask_irq, (mask_fn)mips_unmask_irq,
+		error = intr_event_create(&event, (void *)(uintptr_t)irq, 0,
+		    irq, mips_mask_hard_irq, mips_unmask_hard_irq,
 		    NULL, NULL, "hard intr%d:", irq);
 		if (error)
 			return;
@@ -101,7 +124,7 @@
 	intr_event_add_handler(event, name, filt, handler, arg,
 	    intr_priority(flags), flags, cookiep);
 
-	mips_wr_status(mips_rd_status() | (((1 << irq) << 8) << 2));
+	mips_unmask_hard_irq((void*)(uintptr_t)irq);
 }
 
 void
@@ -112,15 +135,17 @@
 	struct intr_event *event;
 	int error;
 
+#if 0
 	printf("Establish SOFT IRQ %d: filt %p handler %p arg %p\n",
 	    irq, filt, handler, arg);
+#endif
 	if (irq < 0 || irq > NSOFT_IRQS)
 		panic("%s called for unknown hard intr %d", __func__, irq);
 
 	event = softintr_events[irq];
 	if (event == NULL) {
-		error = intr_event_create(&event, (void *)irq, 0, irq,
-		    (mask_fn)mips_mask_irq, (mask_fn)mips_unmask_irq,
+		error = intr_event_create(&event, (void *)(uintptr_t)irq, 0,
+		    irq, mips_mask_soft_irq, mips_unmask_soft_irq,
 		    NULL, NULL, "intr%d:", irq);
 		if (error)
 			return;
@@ -130,22 +155,27 @@
 	intr_event_add_handler(event, name, filt, handler, arg,
 	    intr_priority(flags), flags, cookiep);
 
-	mips_wr_status(mips_rd_status() | (((1<< irq) << 8)));
+	mips_unmask_soft_irq((void*)(uintptr_t)irq);
 }
 
 void
 cpu_intr(struct trapframe *tf)
 {
 	struct intr_event *event;
-	register_t cause;
+	register_t cause, status;
 	int hard, i, intr;
 
 	critical_enter();
 
 	cause = mips_rd_cause();
+	status = mips_rd_status();
 	intr = (cause & MIPS_INT_MASK) >> 8;
-	cause &= ~MIPS_INT_MASK;
-	mips_wr_cause(cause);
+	/*
+	 * Do not handle masked interrupts. They were masked by 
+	 * pre_ithread function (mips_mask_XXX_intr) and will be 
+	 * unmasked once ithread is through with handler
+	 */
+	intr &= (status & MIPS_INT_MASK) >> 8;
 	while ((i = fls(intr)) != 0) {
 		intr &= ~(1 << (i - 1));
 		switch (i) {
diff -I '.*' -Naur releng8/sys/mips/mips/locore.S svn/mips/sys/mips/mips/locore.S
--- releng8/src/sys/mips/mips/locore.S	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/locore.S	2009-08-04 10:47:01.000000000 -0700
@@ -138,14 +138,18 @@
 	mtc0	t2, COP_0_STATUS_REG
 	COP0_SYNC
 	/* Make sure KSEG0 is cached */
+#ifdef CPU_SB1
+	li	t0, CFG_K0_COHERENT
+#else
 	li	t0, CFG_K0_CACHED
+#endif
 	mtc0	t0, MIPS_COP_0_CONFIG
 	COP0_SYNC
 
 	/* Read and store the PrID FPU ID for CPU identification, if any. */
 	mfc0	t2, COP_0_STATUS_REG
 	mfc0	t0, MIPS_COP_0_PRID
-#ifndef CPU_NOFPU
+#ifdef CPU_HAVEFPU
 	and	t2, MIPS_SR_COP_1_BIT
 	beqz	t2, 1f
 	move	t1, zero
@@ -164,8 +168,8 @@
 /*
  * Initialize stack and call machine startup.
  */
-	la	sp, _C_LABEL(topstack) - START_FRAME
-	la	gp, _C_LABEL(_gp)
+	PTR_LA	sp, _C_LABEL(topstack) - START_FRAME
+	PTR_LA	gp, _C_LABEL(_gp)
 	sw	zero, START_FRAME - 4(sp)  # Zero out old ra for debugger
 
 	/*xxximp
@@ -187,7 +191,7 @@
 no_cfe:
 #endif
 #if defined(TARGET_OCTEON)
-	la	a0, app_descriptor_addr
+	PTR_LA	a0, app_descriptor_addr
 	sw	a3, 0(a0)		/* Store app descriptor ptr */
 #endif
 
@@ -232,7 +236,7 @@
 	nop
 
 #ifdef SMP
-	la	t0, _C_LABEL(__pcpu)
+	PTR_LA	t0, _C_LABEL(__pcpu)
 	SET_CPU_PCPU(t0)
 	/* If not master cpu, jump... */
 /*XXX this assumes the above #if 0'd code runs */
@@ -244,7 +248,7 @@
 	jal	_C_LABEL(platform_start)
 	sw	zero, START_FRAME - 8(sp)	# Zero out old fp for debugger
 
-	la      sp, _C_LABEL(thread0)
+	PTR_LA	sp, _C_LABEL(thread0)
 	lw      a0, TD_PCB(sp)
 	li	t0, ~7
 	and	a0, a0, t0
diff -I '.*' -Naur releng8/sys/mips/mips/machdep.c svn/mips/sys/mips/mips/machdep.c
--- releng8/src/sys/mips/mips/machdep.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/machdep.c	2009-09-08 11:01:51.000000000 -0700
@@ -104,6 +104,7 @@
 
 int cold = 1;
 long realmem = 0;
+long Maxmem = 0;
 int cpu_clock = MIPS_DEFAULT_HZ;
 SYSCTL_INT(_hw, OID_AUTO, clockrate, CTLFLAG_RD, 
     &cpu_clock, 0, "CPU instruction clock rate");
@@ -170,11 +171,13 @@
 
 		printf("Physical memory chunk(s):\n");
 		for (indx = 0; phys_avail[indx + 1] != 0; indx += 2) {
-			int size1 = phys_avail[indx + 1] - phys_avail[indx];
+			uintptr_t size1 = phys_avail[indx + 1] - phys_avail[indx];
 
-			printf("0x%08x - 0x%08x, %u bytes (%u pages)\n",
-			    phys_avail[indx], phys_avail[indx + 1] - 1, size1,
-			    size1 / PAGE_SIZE);
+			printf("0x%08llx - 0x%08llx, %llu bytes (%llu pages)\n",
+			    (unsigned long long)phys_avail[indx],
+			    (unsigned long long)phys_avail[indx + 1] - 1,
+			    (unsigned long long)size1,
+			    (unsigned long long)size1 / PAGE_SIZE);
 		}
 	}
 
@@ -255,10 +258,7 @@
 	proc_linkup(&proc0, &thread0);
 	thread0.td_kstack = kstack0;
 	thread0.td_kstack_pages = KSTACK_PAGES - 1;
-	if (thread0.td_kstack & (1 << PAGE_SHIFT))
-		thread0.td_md.md_realstack = thread0.td_kstack + PAGE_SIZE;
-	else
-		thread0.td_md.md_realstack = thread0.td_kstack;
+	thread0.td_md.md_realstack = roundup2(thread0.td_kstack, PAGE_SIZE * 2);
 	/* Initialize pcpu info of cpu-zero */
 #ifdef SMP
 	pcpu_init(&__pcpu[0], 0, sizeof(struct pcpu));
@@ -274,6 +274,9 @@
 	    (thread0.td_kstack_pages - 1) * PAGE_SIZE) - 1;
 	thread0.td_frame = &thread0.td_pcb->pcb_regs;
 
+	/* Steal memory for the dynamic per-cpu area. */
+	dpcpu_init((void *)pmap_steal_memory(DPCPU_SIZE), 0);
+
 	/*
 	 * There is no need to initialize md_upte array for thread0 as it's
 	 * located in .bss section and should be explicitly zeroed during 
@@ -350,12 +353,6 @@
 }
 
 int
-sysarch(struct thread *td, register struct sysarch_args *uap)
-{
-	return (ENOSYS);
-}
-
-int
 fill_dbregs(struct thread *td, struct dbreg *dbregs)
 {
 
diff -I '.*' -Naur releng8/sys/mips/mips/mem.c svn/mips/sys/mips/mips/mem.c
--- releng8/src/sys/mips/mips/mem.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/mem.c	2009-08-04 10:47:01.000000000 -0700
@@ -101,8 +101,15 @@
 			vm_paddr_t pa;
 			register int o;
 
+#ifdef CPU_SB1
+			if (!is_physical_memory(v) ||
+			    !is_physical_memory(roundup2(v, PAGE_SIZE) - 1)) {
+				return (EFAULT);
+			}
+#else
 			if (v + c > (SDRAM_ADDR_START + ctob(physmem)))
 				return (EFAULT);
+#endif
 
 			if (is_cacheable_mem(v) && is_cacheable_mem(v + c)) {
 				struct fpage *fp;
@@ -117,7 +124,7 @@
 				va = pmap_map_fpage(pa, fp, FALSE);
 				o = (int)uio->uio_offset & PAGE_MASK;
 				c = (u_int)(PAGE_SIZE -
-					    ((int)iov->iov_base & PAGE_MASK));
+					    ((uintptr_t)iov->iov_base & PAGE_MASK));
 				c = min(c, (u_int)(PAGE_SIZE - o));
 				c = min(c, (u_int)iov->iov_len);
 				error = uiomove((caddr_t)(va + o), (int)c, uio);
@@ -133,6 +140,7 @@
 		else if (dev2unit(dev) == CDEV_MINOR_KMEM) {
 			v = uio->uio_offset;
 			c = min(iov->iov_len, MAXPHYS);
+
 			vm_offset_t addr, eaddr;
 			vm_offset_t wired_tlb_virtmem_end;
 
@@ -143,25 +151,37 @@
 			addr = trunc_page(uio->uio_offset);
 			eaddr = round_page(uio->uio_offset + c);
 
-			if (addr < (vm_offset_t) VM_MIN_KERNEL_ADDRESS)
-				return EFAULT;
-
-			wired_tlb_virtmem_end = VM_MIN_KERNEL_ADDRESS +
-			    VM_KERNEL_ALLOC_OFFSET;
-			if ((addr < wired_tlb_virtmem_end) &&
-			    (eaddr >= wired_tlb_virtmem_end))
-				addr = wired_tlb_virtmem_end;
-
-			if (addr >= wired_tlb_virtmem_end) {
-				for (; addr < eaddr; addr += PAGE_SIZE) 
-					if (pmap_extract(kernel_pmap,addr) == 0)
-						return EFAULT;
-
-				if (!kernacc((caddr_t)(int)uio->uio_offset, c,
-				    uio->uio_rw == UIO_READ ?
-				    VM_PROT_READ : VM_PROT_WRITE))
+			if (addr > (vm_offset_t) VM_MIN_KERNEL_ADDRESS) {
+				wired_tlb_virtmem_end = VM_MIN_KERNEL_ADDRESS +
+				    VM_KERNEL_ALLOC_OFFSET;
+				if ((addr < wired_tlb_virtmem_end) &&
+				    (eaddr >= wired_tlb_virtmem_end))
+					addr = wired_tlb_virtmem_end;
+
+				if (addr >= wired_tlb_virtmem_end) {
+					for (; addr < eaddr; addr += PAGE_SIZE) 
+						if (pmap_extract(kernel_pmap,
+						    addr) == 0)
+							return EFAULT;
+
+					if (!kernacc(
+					    (caddr_t)(uintptr_t)uio->uio_offset, c,
+					    uio->uio_rw == UIO_READ ?
+					    VM_PROT_READ : VM_PROT_WRITE))
+						return (EFAULT);
+				}
+			}
+			else if (MIPS_IS_KSEG0_ADDR(v)) {
+				if (MIPS_KSEG0_TO_PHYS(v + c) >= ctob(physmem))
 					return (EFAULT);
 			}
+			else if (MIPS_IS_KSEG1_ADDR(v)) {
+				if (MIPS_KSEG1_TO_PHYS(v + c) >= ctob(physmem))
+					return (EFAULT);
+			}
+			else
+				return (EFAULT);
+
 
 			error = uiomove((caddr_t)v, c, uio);
 			continue;
diff -I '.*' -Naur releng8/sys/mips/mips/nexus.c svn/mips/sys/mips/mips/nexus.c
--- releng8/src/sys/mips/mips/nexus.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/nexus.c	2009-09-08 11:01:51.000000000 -0700
@@ -58,6 +58,7 @@
 #include <machine/resource.h>
 #include <machine/vmparam.h>
 
+#undef NEXUS_DEBUG
 #ifdef NEXUS_DEBUG
 #define dprintf printf
 #else 
@@ -76,20 +77,7 @@
 
 static struct rman irq_rman;
 static struct rman mem_rman;
-
-#ifdef notyet
-/*
- * XXX: TODO: Implement bus space barrier functions.
- * Currently tag and handle are set when memory resources
- * are activated.
- */
-struct bus_space_tag nexus_bustag = {
-	NULL,			/* cookie */
-	NULL,			/* parent bus tag */
-	NEXUS_BUS_SPACE,	/* type */
-	nexus_bus_barrier,	/* bus_space_barrier */
-};
-#endif
+static struct rman port_rman;
 
 static struct resource *
 		nexus_alloc_resource(device_t, device_t, int, int *, u_long,
@@ -173,6 +161,21 @@
 		panic("%s: mem_rman", __func__);
 	}
 
+	/*
+	 * MIPS has no concept of the x86 I/O address space but some cpus
+	 * provide a memory mapped window to access the PCI I/O BARs.
+	 */
+	port_rman.rm_start = 0;
+#ifdef PCI_IOSPACE_SIZE
+	port_rman.rm_end = PCI_IOSPACE_SIZE - 1;
+#endif
+	port_rman.rm_type = RMAN_ARRAY;
+	port_rman.rm_descr = "I/O ports";
+	if (rman_init(&port_rman) != 0 ||
+	    rman_manage_region(&port_rman, 0, port_rman.rm_end) != 0)
+		panic("%s: port_rman", __func__);
+
+
 	return (0);
 }
 
@@ -182,14 +185,14 @@
 {
 	int irq;
 
-	register_t sr = intr_disable();
+	intrmask_t s = disableintr();
 	irq = rman_get_start(res);
 	if (irq >= NUM_MIPS_IRQS)
 		return (0);
 
 	cpu_establish_hardintr(device_get_nameunit(child), filt, intr, arg,
 	    irq, flags, cookiep);
-	intr_restore(sr);
+	restoreintr(s);
 	return (0);
 }
 
@@ -238,6 +241,7 @@
 
 	retval += resource_list_print_type(rl, "mem", SYS_RES_MEMORY, "%#lx");
 	retval += resource_list_print_type(rl, "irq", SYS_RES_IRQ, "%ld");
+	retval += resource_list_print_type(rl, "port", SYS_RES_IOPORT, "%#lx");
 
 	return (retval);
 }
@@ -249,6 +253,8 @@
 	long	maddr;
 	int	msize;
 	int	result;
+	int	irq;
+	int	mem_hints_count;
 
 	child = BUS_ADD_CHILD(bus, 0, dname, dunit);
 
@@ -256,17 +262,35 @@
 	 * Set hard-wired resources for hinted child using
 	 * specific RIDs.
 	 */
-	resource_long_value(dname, dunit, "maddr", &maddr);
-	resource_int_value(dname, dunit, "msize", &msize);
+	mem_hints_count = 0;
+	if (resource_long_value(dname, dunit, "maddr", &maddr) == 0)
+		mem_hints_count++;
+	if (resource_int_value(dname, dunit, "msize", &msize) == 0)
+		mem_hints_count++;
+
+	/* check if all info for mem resource has been provided */
+	if ((mem_hints_count > 0) && (mem_hints_count < 2)) {
+		printf("Either maddr or msize hint is missing for %s%d\n",
+		    dname, dunit);
+	} 
+	else if (mem_hints_count) {
+		dprintf("%s: discovered hinted child %s at maddr %p(%d)\n",
+		    __func__, device_get_nameunit(child),
+		    (void *)(intptr_t)maddr, msize);
+
+		result = bus_set_resource(child, SYS_RES_MEMORY, 0, maddr, 
+		    msize);
+		if (result != 0) {
+			device_printf(bus, 
+			    "warning: bus_set_resource() failed\n");
+		}
+	}
 
-	dprintf("%s: discovered hinted child %s at maddr %p(%d)\n",
-	    __func__, device_get_nameunit(child),
-	    (void *)(intptr_t)maddr, msize);
-
-	result = bus_set_resource(child, SYS_RES_MEMORY, MIPS_MEM_RID,
-	    maddr, msize);
-	if (result != 0) {
-		device_printf(bus, "warning: bus_set_resource() failed\n");
+	if (resource_int_value(dname, dunit, "irq", &irq) == 0) {
+		result = bus_set_resource(child, SYS_RES_IRQ, 0, irq, 1);
+		if (result != 0)
+			device_printf(bus,
+			    "warning: bus_set_resource() failed\n");
 	}
 }
 
@@ -338,6 +362,9 @@
 	case SYS_RES_MEMORY:
 		rm = &mem_rman;
 		break;
+	case SYS_RES_IOPORT:
+		rm = &port_rman;
+		break;
 	default:
 		printf("%s: unknown resource type %d\n", __func__, type);
 		return (0);
@@ -345,7 +372,8 @@
 
 	rv = rman_reserve_resource(rm, start, end, count, flags, child);
 	if (rv == 0) {
-		printf("%s: could not reserve resource\n", __func__);
+		printf("%s: could not reserve resource for %s\n", __func__,
+		    device_get_nameunit(child));
 		return (0);
 	}
 
@@ -366,33 +394,24 @@
 nexus_activate_resource(device_t bus, device_t child, int type, int rid,
     struct resource *r)
 {
-#ifdef TARGET_OCTEON
-        uint64_t temp;
-#endif		
 	/*
 	 * If this is a memory resource, track the direct mapping
 	 * in the uncached MIPS KSEG1 segment.
 	 */
 	if ((type == SYS_RES_MEMORY) || (type == SYS_RES_IOPORT)) {
-                caddr_t vaddr = 0;
-                u_int32_t paddr;
-                u_int32_t psize;
-                u_int32_t poffs;
-                
-                paddr = rman_get_start(r);
-                psize = rman_get_size(r);
-                poffs = paddr - trunc_page(paddr);
-                vaddr = (caddr_t) pmap_mapdev(paddr-poffs, psize+poffs) + poffs;
+		caddr_t vaddr = 0;
+		u_int32_t paddr;
+		u_int32_t psize;
+		u_int32_t poffs;
+		
+		paddr = rman_get_start(r);
+		psize = rman_get_size(r);
+		poffs = paddr - trunc_page(paddr);
+		vaddr = (caddr_t) pmap_mapdev(paddr-poffs, psize+poffs) + poffs;
 
 		rman_set_virtual(r, vaddr);
-		rman_set_bustag(r, MIPS_BUS_SPACE_MEM);
-#ifdef TARGET_OCTEON
-		temp = 0x0000000000000000;
-		temp |= (uint32_t)vaddr;
-		rman_set_bushandle(r, (bus_space_handle_t)temp);
-#else		
+		rman_set_bustag(r, mips_bus_space_generic);
 		rman_set_bushandle(r, (bus_space_handle_t)vaddr);
-#endif		
 	}
 
 	return (rman_activate_resource(r));
@@ -473,6 +492,12 @@
 nexus_deactivate_resource(device_t bus, device_t child, int type, int rid,
 			  struct resource *r)
 {
+	vm_offset_t va;
+	
+	if (type == SYS_RES_MEMORY || type == SYS_RES_IOPORT) {
+		va = (vm_offset_t)rman_get_virtual(r);
+		pmap_unmapdev(va, rman_get_size(r));
+	}
 
 	return (rman_deactivate_resource(r));
 }
diff -I '.*' -Naur releng8/sys/mips/mips/pm_machdep.c svn/mips/sys/mips/mips/pm_machdep.c
--- releng8/src/sys/mips/mips/pm_machdep.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/pm_machdep.c	2009-08-04 10:47:01.000000000 -0700
@@ -230,13 +230,13 @@
 /* #ifdef DEBUG */
 	if (ucp->uc_mcontext.mc_regs[ZERO] != UCONTEXT_MAGIC) {
 		printf("sigreturn: pid %d, ucp %p\n", p->p_pid, ucp);
-		printf("  old sp %x ra %x pc %x\n",
-		    regs->sp, regs->ra, regs->pc);
-		printf("  new sp %x ra %x pc %x z %x\n",
-		    ucp->uc_mcontext.mc_regs[SP],
-		    ucp->uc_mcontext.mc_regs[RA],
-		    ucp->uc_mcontext.mc_regs[PC],
-		    ucp->uc_mcontext.mc_regs[ZERO]);
+		printf("  old sp %p ra %p pc %p\n",
+		    (void *)regs->sp, (void *)regs->ra, (void *)regs->pc);
+		printf("  new sp %p ra %p pc %p z %p\n",
+		    (void *)ucp->uc_mcontext.mc_regs[SP],
+		    (void *)ucp->uc_mcontext.mc_regs[RA],
+		    (void *)ucp->uc_mcontext.mc_regs[PC],
+		    (void *)ucp->uc_mcontext.mc_regs[ZERO]);
 		return EINVAL;
 	}
 /* #endif */
@@ -327,7 +327,7 @@
 	/* compute next address after current location */
 	if(curinstr != 0) {
 		va = MipsEmulateBranch(locr0, locr0->pc, locr0->fsr,
-		    (u_int)&curinstr);
+		    (uintptr_t)&curinstr);
 	} else {
 		va = locr0->pc + 4;
 	}
@@ -413,9 +413,16 @@
 		bcopy((void *)&td->td_frame->f0, (void *)&mcp->mc_fpregs,
 		    sizeof(mcp->mc_fpregs));
 	}
+	if (flags & GET_MC_CLEAR_RET) {
+		mcp->mc_regs[V0] = 0;
+		mcp->mc_regs[V1] = 0;
+		mcp->mc_regs[A3] = 0;
+	}
+
 	mcp->mc_pc = td->td_frame->pc;
 	mcp->mullo = td->td_frame->mullo;
 	mcp->mulhi = td->td_frame->mulhi;
+	mcp->mc_tls = td->td_md.md_tls;
 	return (0);
 }
 
@@ -436,6 +443,7 @@
 	td->td_frame->pc = mcp->mc_pc;
 	td->td_frame->mullo = mcp->mullo;
 	td->td_frame->mulhi = mcp->mulhi;
+	td->td_md.md_tls = mcp->mc_tls;
 	/* Dont let user to set any bits in Status and casue registers */
 
 	return (0);
@@ -482,7 +490,8 @@
 //	td->td_frame->sr = SR_KSU_USER | SR_EXL | SR_INT_ENAB;
 //?	td->td_frame->sr |=  idle_mask & ALL_INT_MASK;
 #else
-	td->td_frame->sr = SR_KSU_USER | SR_EXL;// mips2 also did COP_0_BIT
+	td->td_frame->sr = SR_KSU_USER | SR_EXL | SR_INT_ENAB |
+	    (mips_rd_status() & ALL_INT_MASK);
 #endif
 #ifdef TARGET_OCTEON
 	td->td_frame->sr |= MIPS_SR_COP_2_BIT | MIPS32_SR_PX | MIPS_SR_UX |
diff -I '.*' -Naur releng8/sys/mips/mips/pmap.c svn/mips/sys/mips/mips/pmap.c
--- releng8/src/sys/mips/mips/pmap.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/pmap.c	2009-10-01 13:13:43.000000000 -0700
@@ -313,6 +313,8 @@
 		}
 	}
 
+	Maxmem = atop(phys_avail[i - 1]);
+
 	if (bootverbose) {
 		printf("Physical memory chunk(s):\n");
 		for (i = 0; phys_avail[i + 1] != 0; i += 2) {
@@ -324,6 +326,7 @@
 			    (uintmax_t) phys_avail[i + 1] - 1,
 			    (uintmax_t) size, (uintmax_t) size / PAGE_SIZE);
 		}
+		printf("Maxmem is 0x%0lx\n", ptoa(Maxmem));
 	}
 	/*
 	 * Steal the message buffer from the beginning of memory.
@@ -331,9 +334,6 @@
 	msgbufp = (struct msgbuf *)pmap_steal_memory(MSGBUF_SIZE);
 	msgbufinit(msgbufp, MSGBUF_SIZE);
 
-	/* Steal memory for the dynamic per-cpu area. */
-	dpcpu_init((void *)pmap_steal_memory(DPCPU_SIZE), 0);
-
 	/*
 	 * Steal thread0 kstack.
 	 */
@@ -400,21 +400,15 @@
 	for (i = 0, pte = pgtab; i < (nkpt * NPTEPG); i++, pte++)
 		*pte = PTE_G;
 
-	printf("Va=0x%x Ve=%x\n", virtual_avail, virtual_end);
 	/*
 	 * The segment table contains the KVA of the pages in the second
 	 * level page table.
 	 */
-	printf("init kernel_segmap va >> = %d nkpt:%d\n",
-	    (virtual_avail >> SEGSHIFT),
-	    nkpt);
 	for (i = 0, j = (virtual_avail >> SEGSHIFT); i < nkpt; i++, j++)
 		kernel_segmap[j] = (pd_entry_t)(pgtab + (i * NPTEPG));
 
 	for (i = 0; phys_avail[i + 2]; i += 2)
 		continue;
-	printf("avail_start:0x%x avail_end:0x%x\n",
-	    phys_avail[0], phys_avail[i + 1]);
 
 	/*
 	 * The kernel's pmap is statically allocated so we don't have to use
@@ -697,6 +691,11 @@
 {
 	register pt_entry_t *pte;
 
+	/*
+	 * Write back all caches from the page being destroyed
+	 */
+	mips_dcache_wbinv_range_index(va, NBPG);
+
 	pte = pmap_pte(kernel_pmap, va);
 	*pte = PTE_G;
 	pmap_invalidate_page(kernel_pmap, va);
@@ -741,11 +740,15 @@
 pmap_qenter(vm_offset_t va, vm_page_t *m, int count)
 {
 	int i;
+	vm_offset_t origva = va;
 
 	for (i = 0; i < count; i++) {
+		pmap_flush_pvcache(m[i]);
 		pmap_kenter(va, VM_PAGE_TO_PHYS(m[i]));
 		va += PAGE_SIZE;
 	}
+
+	mips_dcache_inv_range(origva, PAGE_SIZE*count);
 }
 
 /*
@@ -755,6 +758,11 @@
 void
 pmap_qremove(vm_offset_t va, int count)
 {
+	/*
+	 * No need to wb/inv caches here, 
+	 *   pmap_kremove will do it for us
+	 */
+
 	while (count-- > 0) {
 		pmap_kremove(va);
 		va += PAGE_SIZE;
@@ -1533,6 +1541,12 @@
 	if (!ptq || !pmap_pte_v(ptq)) {
 		return;
 	}
+
+	/*
+	 * Write back all caches from the page being destroyed
+	 */
+	mips_dcache_wbinv_range_index(va, NBPG);
+
 	/*
 	 * get a local va for mappings for this pmap.
 	 */
@@ -1612,6 +1626,14 @@
 
 	while ((pv = TAILQ_FIRST(&m->md.pv_list)) != NULL) {
 		PMAP_LOCK(pv->pv_pmap);
+
+		/*
+		 * If it's last mapping writeback all caches from 
+		 * the page being destroyed
+	 	 */
+		if (m->md.pv_list_count == 1) 
+			mips_dcache_wbinv_range_index(pv->pv_va, NBPG);
+
 		pv->pv_pmap->pm_stats.resident_count--;
 
 		pte = pmap_pte(pv->pv_pmap, pv->pv_va);
@@ -1768,8 +1790,8 @@
 	 * Page Directory table entry not valid, we need a new PT page
 	 */
 	if (pte == NULL) {
-		panic("pmap_enter: invalid page directory, pdir=%p, va=0x%x\n",
-		    (void *)pmap->pm_segtab, va);
+		panic("pmap_enter: invalid page directory, pdir=%p, va=%p\n",
+		    (void *)pmap->pm_segtab, (void *)va);
 	}
 	pa = VM_PAGE_TO_PHYS(m);
 	om = NULL;
@@ -1830,7 +1852,7 @@
 			mpte->wire_count--;
 			KASSERT(mpte->wire_count > 0,
 			    ("pmap_enter: missing reference to page table page,"
-			    " va: 0x%x", va));
+			    " va: %p", (void *)va));
 		}
 	} else
 		pmap->pm_stats.resident_count++;
@@ -1892,7 +1914,7 @@
 			if (origpte & PTE_M) {
 				KASSERT((origpte & PTE_RW),
 				    ("pmap_enter: modified page not writable:"
-				    " va: 0x%x, pte: 0x%lx", va, origpte));
+				    " va: %p, pte: 0x%lx", (void *)va, origpte));
 				if (page_is_managed(opa))
 					vm_page_dirty(om);
 			}
@@ -2229,7 +2251,7 @@
 #endif
 	if (phys < MIPS_KSEG0_LARGEST_PHYS) {
 
-		va = MIPS_PHYS_TO_UNCACHED(phys);
+		va = MIPS_PHYS_TO_CACHED(phys);
 
 		bzero((caddr_t)va, PAGE_SIZE);
 		mips_dcache_wbinv_range(va, PAGE_SIZE);
@@ -2285,7 +2307,7 @@
 	} else
 #endif
 	if (phys < MIPS_KSEG0_LARGEST_PHYS) {
-		va = MIPS_PHYS_TO_UNCACHED(phys);
+		va = MIPS_PHYS_TO_CACHED(phys);
 		bzero((char *)(caddr_t)va + off, size);
 		mips_dcache_wbinv_range(va + off, size);
 	} else {
@@ -2324,7 +2346,7 @@
 	} else
 #endif
 	if (phys < MIPS_KSEG0_LARGEST_PHYS) {
-		va = MIPS_PHYS_TO_UNCACHED(phys);
+		va = MIPS_PHYS_TO_CACHED(phys);
 		bzero((caddr_t)va, PAGE_SIZE);
 		mips_dcache_wbinv_range(va, PAGE_SIZE);
 	} else {
@@ -2361,7 +2383,6 @@
 	vm_paddr_t phy_src = VM_PAGE_TO_PHYS(src);
 	vm_paddr_t phy_dst = VM_PAGE_TO_PHYS(dst);
 
-
 #ifdef VM_ALLOC_WIRED_TLB_PG_POOL
 	if (need_wired_tlb_page_pool) {
 		struct fpage *fp1, *fp2;
@@ -2391,9 +2412,16 @@
 #endif
 	{
 		if ((phy_src < MIPS_KSEG0_LARGEST_PHYS) && (phy_dst < MIPS_KSEG0_LARGEST_PHYS)) {
-			/* easy case, all can be accessed via KSEG0 */
-			va_src = MIPS_PHYS_TO_CACHED(phy_src);
-			va_dst = MIPS_PHYS_TO_CACHED(phy_dst);
+			/* easy case, all can be accessed via KSEG1 */
+			/*
+			 * Flush all caches for VA that are mapped to this page
+			 * to make sure that data in SDRAM is up to date
+			 */
+			pmap_flush_pvcache(src);
+			mips_dcache_wbinv_range_index(
+			    MIPS_PHYS_TO_CACHED(phy_dst), NBPG);
+			va_src = MIPS_PHYS_TO_UNCACHED(phy_src);
+			va_dst = MIPS_PHYS_TO_UNCACHED(phy_dst);
 			bcopy((caddr_t)va_src, (caddr_t)va_dst, PAGE_SIZE);
 		} else {
 			int cpu;
@@ -2495,9 +2523,7 @@
 	PMAP_LOCK(pmap);
 	sched_pin();
 	//XXX need to be TAILQ_FOREACH_SAFE ?
-	    for (pv = TAILQ_FIRST(&pmap->pm_pvlist);
-	    pv;
-	    pv = npv) {
+	for (pv = TAILQ_FIRST(&pmap->pm_pvlist); pv; pv = npv) {
 
 		pte = pmap_pte(pv->pv_pmap, pv->pv_va);
 		if (!pmap_pte_v(pte))
@@ -2802,15 +2828,16 @@
 	 * KSEG1 maps only first 512M of phys address space. For 
 	 * pa > 0x20000000 we should make proper mapping * using pmap_kenter.
 	 */
-	if (pa + size < MIPS_KSEG0_LARGEST_PHYS)
+	if ((pa + size - 1) < MIPS_KSEG0_LARGEST_PHYS)
 		return (void *)MIPS_PHYS_TO_KSEG1(pa);
 	else {
 		offset = pa & PAGE_MASK;
-		size = roundup(size, PAGE_SIZE);
+		size = roundup(size + offset, PAGE_SIZE);
         
 		va = kmem_alloc_nofault(kernel_map, size);
 		if (!va)
 			panic("pmap_mapdev: Couldn't alloc kernel virtual memory");
+		pa = trunc_page(pa);
 		for (tmpva = va; size > 0;) {
 			pmap_kenter(tmpva, pa);
 			size -= PAGE_SIZE;
@@ -2825,6 +2852,18 @@
 void
 pmap_unmapdev(vm_offset_t va, vm_size_t size)
 {
+	vm_offset_t base, offset, tmpva;
+
+	/* If the address is within KSEG1 then there is nothing to do */
+	if (va >= MIPS_KSEG1_START && va <= MIPS_KSEG1_END)
+		return;
+
+	base = trunc_page(va);
+	offset = va & PAGE_MASK;
+	size = roundup(size + offset, PAGE_SIZE);
+	for (tmpva = base; tmpva < base + size; tmpva += PAGE_SIZE)
+		pmap_kremove(tmpva);
+	kmem_free(kernel_map, base, size);
 }
 
 /*
@@ -2899,6 +2938,7 @@
 		PCPU_SET(segbase, pmap->pm_segtab);
 		MachSetPID(pmap->pm_asid[PCPU_GET(cpuid)].asid);
 	}
+
 	PCPU_SET(curpmap, pmap);
 	critical_exit();
 }
@@ -2960,7 +3000,7 @@
 				pde = &pmap->pm_segtab[i];
 				if (pde && pmap_pde_v(pde)) {
 					for (j = 0; j < 1024; j++) {
-						unsigned va = base +
+						vm_offset_t va = base +
 						(j << PAGE_SHIFT);
 
 						pte = pmap_pte(pmap, va);
@@ -2970,8 +3010,9 @@
 
 							pa = mips_tlbpfn_to_paddr(*pte);
 							m = PHYS_TO_VM_PAGE(pa);
-							printf("va: 0x%x, pt: 0x%x, h: %d, w: %d, f: 0x%x",
-							    va, pa,
+							printf("va: %p, pt: %p, h: %d, w: %d, f: 0x%x",
+							    (void *)va,
+							    (void *)pa,
 							    m->hold_count,
 							    m->wire_count,
 							    m->flags);
@@ -3271,3 +3312,16 @@
 	}
 	return pa;
 }
+
+void 
+pmap_flush_pvcache(vm_page_t m)
+{
+	pv_entry_t pv;
+
+	if (m != NULL) {
+		for (pv = TAILQ_FIRST(&m->md.pv_list); pv;
+	    	    pv = TAILQ_NEXT(pv, pv_list)) {
+			mips_dcache_wbinv_range_index(pv->pv_va, NBPG);
+		}
+	}
+}
diff -I '.*' -Naur releng8/sys/mips/mips/support.S svn/mips/sys/mips/mips/support.S
--- releng8/src/sys/mips/mips/support.S	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/support.S	2009-09-08 11:01:51.000000000 -0700
@@ -460,8 +460,10 @@
 	sw	zero, U_PCB_ONFAULT(v1)
 END(fubyte)
 
-LEAF(suword)
-XLEAF(suword32)
+LEAF(suword32)
+#ifndef __mips_n64
+XLEAF(suword)
+#endif
 	blt	a0, zero, fswberr	# make sure address is in user space
 	li	v0, FSWBERR
 	GET_CPU_PCPU(v1)
@@ -471,31 +473,86 @@
 	sw	zero, U_PCB_ONFAULT(v1)
 	j	ra
 	move	v0, zero
-END(suword)
+END(suword32)
+
+#ifdef __mips_n64
+LEAF(suword64)
+XLEAF(suword)
+	blt	a0, zero, fswberr	# make sure address is in user space
+	li	v0, FSWBERR
+	GET_CPU_PCPU(v1)
+	lw	v1, PC_CURPCB(v1)
+	sw	v0, U_PCB_ONFAULT(v1)
+	sd	a1, 0(a0)		# store word
+	sw	zero, U_PCB_ONFAULT(v1)
+	j	ra
+	move	v0, zero
+END(suword64)
+#endif
 
 /*
  * casuword(9)
  * <v0>u_long casuword(<a0>u_long *p, <a1>u_long oldval, <a2>u_long newval)
  */
-ENTRY(casuword)
-	break
-	li	v0, -1
-	jr	ra
-	nop
-END(casuword)
-
 /*
  * casuword32(9)
  * <v0>uint32_t casuword(<a0>uint32_t *p, <a1>uint32_t oldval, 
  *							<a2>uint32_t newval)
  */
-ENTRY(casuword32)
-	break
+LEAF(casuword32)
+#ifndef __mips_n64
+XLEAF(casuword)
+#endif
+	blt	a0, zero, fswberr	# make sure address is in user space
+	li	v0, FSWBERR
+	GET_CPU_PCPU(v1)
+	lw	v1, PC_CURPCB(v1)
+	sw	v0, U_PCB_ONFAULT(v1)
+1:
+	move	t0, a2
+	ll	v0, 0(a0)
+	bne	a1, v0, 2f
+	nop
+	sc	t0, 0(a0)		# store word
+	beqz	t0, 1b
+	nop
+	j	3f
+	nop
+2:
 	li	v0, -1
+3:
+	sw	zero, U_PCB_ONFAULT(v1)
 	jr	ra
 	nop
 END(casuword32)
 
+#ifdef __mips_n64
+LEAF(casuword64)
+XLEAF(casuword)
+	blt	a0, zero, fswberr	# make sure address is in user space
+	li	v0, FSWBERR
+	GET_CPU_PCPU(v1)
+	lw	v1, PC_CURPCB(v1)
+	sw	v0, U_PCB_ONFAULT(v1)
+1:
+	move	t0, a2
+	lld	v0, 0(a0)
+	bne	a1, v0, 2f
+	nop
+	scd	t0, 0(a0)		# store double word
+	beqz	t0, 1b
+	nop
+	j	3f
+	nop
+2:
+	li	v0, -1
+3:
+	sw	zero, U_PCB_ONFAULT(v1)
+	jr	ra
+	nop
+END(casuword64)
+#endif
+
 #if 0
 	/* unused in FreeBSD */
 /*
@@ -1280,17 +1337,11 @@
 	.set	mips3
 #endif
 
-LEAF(atomic_readandclear_64)
-1:
-	lld	v0, 0(a0)
-	li	t0, 0
-	scd	t0, 0(a0)
-	beqz	t0, 1b
-	nop
-	j	ra
-	nop
-END(atomic_readandclear_64)
-
+#if !defined(__mips_n64) && !defined(__mips_n32)	
+	/*
+	 * I don't know if these routines have the right number of
+	 * NOPs in it for all processors.  XXX
+	 */
 LEAF(atomic_store_64)
 	mfc0	t1, COP_0_STATUS_REG
 	and	t2, t1, ~SR_INT_ENAB
@@ -1336,6 +1387,7 @@
 	j	ra
 	nop
 END(atomic_load_64)
+#endif
 
 #if defined(DDB) || defined(DEBUG)
 
diff -I '.*' -Naur releng8/sys/mips/mips/swtch.S svn/mips/sys/mips/mips/swtch.S
--- releng8/src/sys/mips/mips/swtch.S	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/swtch.S	2009-08-04 10:47:01.000000000 -0700
@@ -81,14 +81,12 @@
 #define	_MFC0	dmfc0
 #define	_MTC0	dmtc0
 #define WIRED_SHIFT 34
-#define PAGE_SHIFT 34
 #else
 #define _SLL	sll
 #define	_SRL	srl
 #define	_MFC0	mfc0
 #define	_MTC0	mtc0
 #define WIRED_SHIFT 2
-#define PAGE_SHIFT 2
 #endif
 	.set	noreorder			# Noreorder is default style!
 #if defined(ISA_MIPS32)
@@ -205,10 +203,10 @@
 	RESTORE_U_PCB_REG(t1, T1, k1)
 	RESTORE_U_PCB_REG(t2, T2, k1)
 	RESTORE_U_PCB_REG(t3, T3, k1)
-	RESTORE_U_PCB_REG(t4, T4, k1)
-	RESTORE_U_PCB_REG(t5, T5, k1)
-	RESTORE_U_PCB_REG(t6, T6, k1)
-	RESTORE_U_PCB_REG(t7, T7, k1)
+	RESTORE_U_PCB_REG(ta0, TA0, k1)
+	RESTORE_U_PCB_REG(ta1, TA1, k1)
+	RESTORE_U_PCB_REG(ta2, TA2, k1)
+	RESTORE_U_PCB_REG(ta3, TA3, k1)
 	RESTORE_U_PCB_REG(s0, S0, k1)
 	RESTORE_U_PCB_REG(s1, S1, k1)
 	RESTORE_U_PCB_REG(s2, S2, k1)
@@ -224,6 +222,11 @@
 	RESTORE_U_PCB_REG(s8, S8, k1)
 	RESTORE_U_PCB_REG(ra, RA, k1)
 	RESTORE_U_PCB_REG(sp, SP, k1)
+	li	k1, ~SR_INT_MASK
+	and	k0, k0, k1
+	mfc0	k1, COP_0_STATUS_REG
+	and	k1, k1, SR_INT_MASK
+	or	k0, k0, k1
 	mtc0	k0, COP_0_STATUS_REG	# switch to user mode (when eret...)
 	HAZARD_DELAY
 	sync
@@ -320,7 +323,7 @@
 
 mips_sw1:
 #if defined(SMP) && defined(SCHED_ULE)
-	la	t0, _C_LABEL(blocked_lock)
+	PTR_LA	t0, _C_LABEL(blocked_lock)
 blocked_loop:
 	lw	t1, TD_LOCK(a1)
 	beq	t0, t1, blocked_loop
@@ -361,7 +364,7 @@
 	nop
 pgm:
 	bltz	s0, entry0set
-	li	t1, MIPS_KSEG0_START + 0x0fff0000	# invalidate tlb entry
+	li	t1, MIPS_KSEG0_START		# invalidate tlb entry
 	sll	s0, PAGE_SHIFT + 1
 	addu	t1, s0
 	mtc0	t1, COP_0_TLB_HI
@@ -385,7 +388,7 @@
  * Now running on new u struct.
  */
 sw2:
-	la	t1, _C_LABEL(pmap_activate)	# s7 = new proc pointer
+	PTR_LA	t1, _C_LABEL(pmap_activate)	# s7 = new proc pointer
 	jalr	t1				# s7 = new proc pointer
 	move	a0, s7				# BDSLOT
 /*
@@ -410,6 +413,10 @@
 	 * In case there are CPU-specific registers that need
 	 * to be restored with the other registers do so here.
 	 */
+	mfc0	t0, COP_0_STATUS_REG
+	and	t0, t0, SR_INT_MASK
+	and	v0, v0, ~SR_INT_MASK
+	or	v0, v0, t0
 	mtc0	v0, COP_0_STATUS_REG
 	ITLBNOPFIX
 
diff -I '.*' -Naur releng8/sys/mips/mips/sys_machdep.c svn/mips/sys/mips/mips/sys_machdep.c
--- releng8/src/sys/mips/mips/sys_machdep.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/mips/sys_machdep.c	2009-07-02 18:44:22.000000000 -0700
@@ -0,0 +1,77 @@
+/*-
+ * Copyright (c) 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	from: @(#)sys_machdep.c	5.5 (Berkeley) 1/19/91
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/proc.h>
+#include <sys/sysproto.h>
+#include <sys/syscall.h>
+#include <sys/sysent.h>
+
+#include <machine/sysarch.h>
+
+#ifndef _SYS_SYSPROTO_H_
+struct sysarch_args {
+	int op;
+	char *parms;
+};
+#endif
+
+int
+sysarch(td, uap)
+	struct thread *td;
+	register struct sysarch_args *uap;
+{
+	int error;
+	void *tlsbase;
+
+	switch (uap->op) {
+	case MIPS_SET_TLS : 
+		td->td_md.md_tls = (void*)uap->parms;
+		error = 0;
+		break;
+
+	case MIPS_GET_TLS : 
+		tlsbase = td->td_md.md_tls;
+		error = copyout(&tlsbase, uap->parms, sizeof(tlsbase));
+		break;
+	default:
+		error = EINVAL;
+	}
+	return (error);
+}
diff -I '.*' -Naur releng8/sys/mips/mips/tick.c svn/mips/sys/mips/mips/tick.c
--- releng8/src/sys/mips/mips/tick.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/tick.c	2009-05-26 09:40:41.000000000 -0700
@@ -138,25 +138,19 @@
 	 * function should  be called before cninit.
 	 */
 	counter_freq = platform_counter_freq;
+	/*
+	 * XXX: Some MIPS32 cores update the Count register only every two
+	 * pipeline cycles.
+	 */
+	if (double_count != 0)
+		counter_freq /= 2;
+
 	cycles_per_tick = counter_freq / 1000;
-	if (double_count)
-		cycles_per_tick *= 2;
 	cycles_per_hz = counter_freq / hz;
 	cycles_per_usec = counter_freq / (1 * 1000 * 1000);
 	cycles_per_sec =  counter_freq ;
 	
 	counter_timecounter.tc_frequency = counter_freq;
-	/*
-	 * XXX: Some MIPS32 cores update the Count register only every two
-	 * pipeline cycles.
-	 * XXX2: We can read this from the hardware register on some
-	 * systems.  Need to investigate.
-	 */
-	if (double_count != 0) {
-		cycles_per_hz /= 2;
-		cycles_per_usec /= 2;
-		cycles_per_sec /= 2;
-	}
 	printf("hz=%d cyl_per_hz:%jd cyl_per_usec:%jd freq:%jd cyl_per_hz:%jd cyl_per_sec:%jd\n",
 	       hz,
 	       cycles_per_tick,
@@ -346,6 +340,7 @@
 		device_printf(dev, "bus_setup_intr returned %d\n", error);
 		return (error);
 	}
+
 	mips_wr_compare(mips_rd_count() + counter_freq / hz);
 	return (0);
 }
diff -I '.*' -Naur releng8/sys/mips/mips/tlb.S svn/mips/sys/mips/mips/tlb.S
--- releng8/src/sys/mips/mips/tlb.S	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/tlb.S	2009-08-04 10:47:01.000000000 -0700
@@ -81,14 +81,12 @@
 #define	_MFC0	dmfc0
 #define	_MTC0	dmtc0
 #define WIRED_SHIFT 34
-#define PAGE_SHIFT 34
 #else
 #define _SLL	sll
 #define	_SRL	srl
 #define	_MFC0	mfc0
 #define	_MTC0	mtc0
 #define WIRED_SHIFT 2
-#define PAGE_SHIFT 2
 #endif
 	.set	noreorder			# Noreorder is default style!
 #if defined(ISA_MIPS32)
@@ -232,28 +230,38 @@
 	mtc0	zero, COP_0_STATUS_REG		# Disable interrupts
 	ITLBNOPFIX
 	mfc0	t1, COP_0_TLB_WIRED
-	li	v0, MIPS_KSEG3_START + 0x0fff0000 # invalid address
 	_MFC0	t0, COP_0_TLB_HI		# Save the PID
-
 	_MTC0	v0, COP_0_TLB_HI		# Mark entry high as invalid
 	_MTC0	zero, COP_0_TLB_LO0		# Zero out low entry0.
 	_MTC0	zero, COP_0_TLB_LO1		# Zero out low entry1.
 	mtc0	zero, COP_0_TLB_PG_MASK 	# Zero out mask entry.
+	#
+	# Load invalid entry, each TLB entry should have it's own bogus 
+	# address calculated by following expression:
+	# MIPS_KSEG0_START + 2 * i * PAGE_SIZE;
+	# One bogus value for every TLB entry might cause MCHECK exception
+	#
+	sll	t3, t1, PGSHIFT + 1
+	li	v0, MIPS_KSEG0_START		# invalid address
+	addu	v0, t3
 /*
  * Align the starting value (t1) and the upper bound (a0).
  */
 1:
 	mtc0	t1, COP_0_TLB_INDEX		# Set the index register.
 	ITLBNOPFIX
-	_MTC0	t0, COP_0_TLB_HI		# Restore the PID
+#xxx imp
+#	_MTC0	t0, COP_0_TLB_HI		# Restore the PID
+	_MTC0	v0, COP_0_TLB_HI		# Mark entry high as invalid
 	addu	t1, t1, 1			# Increment index.
-	addu	t0, t0, 8 * 1024
+#xxx imp
+#	addu	t0, t0, 8 * 1024
+	addu	v0, v0, 8 * 1024
 	MIPS_CPU_NOP_DELAY
 	tlbwi					# Write the TLB entry.
 	MIPS_CPU_NOP_DELAY
 	bne	t1, a0, 1b
 	nop
-
 	_MTC0	t0, COP_0_TLB_HI		# Restore the PID
 	mtc0	v1, COP_0_STATUS_REG		# Restore the status register
 	ITLBNOPFIX
@@ -289,14 +297,14 @@
 	tlbp					# Probe for the entry.
 	MIPS_CPU_NOP_DELAY
 	mfc0	v0, COP_0_TLB_INDEX		# See what we got
-	li	t1, MIPS_KSEG0_START + 0x0fff0000
+	li	t1, MIPS_KSEG0_START
 	bltz	v0, 1f				# index < 0 => !found
 	nop
 	# Load invalid entry, each TLB entry should have it's own bogus 
 	# address calculated by following expression:
-	# MIPS_KSEG0_START + 0x0fff0000 + 2 * i * PAGE_SIZE;
+	# MIPS_KSEG0_START + 2 * i * PAGE_SIZE;
 	# One bogus value for every TLB entry might cause MCHECK exception
-	sll	v0, PAGE_SHIFT + 1
+	sll	v0, PGSHIFT + 1
 	addu	t1, v0
 	_MTC0	t1, COP_0_TLB_HI		# Mark entry high as invalid
 
@@ -424,17 +432,17 @@
 	MIPS_CPU_NOP_DELAY
 	mfc0	t2, COP_0_TLB_PG_MASK		# fetch the hi entry
 	_MFC0	t3, COP_0_TLB_HI		# fetch the hi entry
-	_MFC0	t4, COP_0_TLB_LO0		# See what we got
-	_MFC0	t5, COP_0_TLB_LO1		# See what we got
+	_MFC0	ta0, COP_0_TLB_LO0		# See what we got
+	_MFC0	ta1, COP_0_TLB_LO1		# See what we got
 	_MTC0	t0, COP_0_TLB_HI		# restore PID
 	MIPS_CPU_NOP_DELAY
 	mtc0	v1, COP_0_STATUS_REG		# Restore the status register
 	ITLBNOPFIX
 	sw	t2, 0(a1)
 	sw	t3, 4(a1)
-	sw	t4, 8(a1)
+	sw	ta0, 8(a1)
 	j	ra
-	sw	t5, 12(a1)
+	sw	ta1, 12(a1)
 END(Mips_TLBRead)
 
 /*--------------------------------------------------------------------------
@@ -470,10 +478,20 @@
 	mfc0	v1, COP_0_STATUS_REG		# save status register
 	mtc0	zero, COP_0_STATUS_REG		# disable interrupts
 
-	_MFC0	t4, COP_0_TLB_HI		# Get current PID
+	_MFC0	ta0, COP_0_TLB_HI		# Get current PID
 	move	t2, a0
 	mfc0	t1, COP_0_TLB_WIRED
-	li	v0, MIPS_KSEG0_START + 0x0fff0000	# invalid address
+	li	v0, MIPS_KSEG0_START		# invalid address
+	#
+	# Load invalid entry, each TLB entry should have it's own bogus 
+	# address calculated by following expression:
+	# MIPS_KSEG0_START + 2 * i * PAGE_SIZE;
+	# One bogus value for every TLB entry might cause MCHECK exception
+	#
+	sll	t3, t1, PGSHIFT + 1
+	li	v0, MIPS_KSEG0_START		# invalid address
+	addu	v0, t3
+
 	mfc0	t3, COP_0_TLB_PG_MASK		# save current pgMask
 
 	# do {} while (t1 < t2)
@@ -495,11 +513,11 @@
 	tlbwi					# invalidate the TLB entry
 2:
 	addu	t1, t1, 1
-	addu	v0, 1 << (PAGE_SHIFT + 1)
+	addu	v0, 1 << (PGSHIFT + 1)
 	bne	t1, t2, 1b
 	nop
 
-	_MTC0	t4, COP_0_TLB_HI		# restore PID
+	_MTC0	ta0, COP_0_TLB_HI		# restore PID
 	mtc0	t3, COP_0_TLB_PG_MASK		# restore pgMask
 	MIPS_CPU_NOP_DELAY
 	mtc0	v1, COP_0_STATUS_REG		# restore status register
diff -I '.*' -Naur releng8/sys/mips/mips/trap.c svn/mips/sys/mips/mips/trap.c
--- releng8/src/sys/mips/mips/trap.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/trap.c	2009-09-08 11:01:51.000000000 -0700
@@ -76,7 +76,6 @@
 #include <machine/trap.h>
 #include <machine/psl.h>
 #include <machine/cpu.h>
-#include <machine/intr.h>
 #include <machine/pte.h>
 #include <machine/pmap.h>
 #include <machine/mips_opcode.h>
@@ -99,7 +98,6 @@
 
 #ifdef TRAP_DEBUG
 int trap_debug = 1;
-
 #endif
 
 extern unsigned onfault_table[];
@@ -252,7 +250,7 @@
 extern void MipsFPTrap(u_int, u_int, u_int);
 
 u_int trap(struct trapframe *);
-u_int MipsEmulateBranch(struct trapframe *, int, int, u_int);
+u_int MipsEmulateBranch(struct trapframe *, uintptr_t, int, uintptr_t);
 
 #define	KERNLAND(x) ((int)(x) < 0)
 #define	DELAYBRANCH(x) ((int)(x) < 0)
@@ -261,7 +259,6 @@
  * kdbpeekD(addr) - skip one word starting at 'addr', then read the second word
  */
 #define	kdbpeekD(addr)	kdbpeek(((int *)(addr)) + 1)
-int rrs_debug = 0;
 
 /*
  * MIPS load/store access type
@@ -306,8 +303,7 @@
  * p->p_addr->u_pcb.pcb_onfault is set, otherwise, return old pc.
  */
 u_int
-trap(trapframe)
-	struct trapframe *trapframe;
+trap(struct trapframe *trapframe)
 {
 	int type, usermode;
 	int i = 0;
@@ -365,7 +361,7 @@
 		printf("cpuid = %d\n", PCPU_GET(cpuid));
 #endif
 		MachTLBGetPID(pid);
-		printf("badaddr = %p, pc = %p, ra = %p, sp = %p, sr = 0x%x, pid = %d, ASID = 0x%x\n",
+		printf("badaddr = 0x%0x, pc = 0x%0x, ra = 0x%0x, sp = 0x%0x, sr = 0x%x, pid = %d, ASID = 0x%x\n",
 		    trapframe->badvaddr, trapframe->pc, trapframe->ra,
 		    trapframe->sp, trapframe->sr,
 		    (curproc ? curproc->p_pid : -1), pid);
@@ -389,7 +385,7 @@
 		    ((type & ~T_USER) != T_SYSCALL)) {
 			if (++count == 3) {
 				trap_frame_dump(trapframe);
-				panic("too many faults at %p\n", last_badvaddr);
+				panic("too many faults at %x\n", last_badvaddr);
 			}
 		} else {
 			last_badvaddr = this_badvaddr;
@@ -570,7 +566,7 @@
 			--p->p_lock;
 			PROC_UNLOCK(p);
 #ifdef VMFAULT_TRACE
-			printf("vm_fault(%x (pmap %x), %x (%x), %x, %d) -> %x at pc %x\n",
+			printf("vm_fault(%p (pmap %p), %x (%x), %x, %d) -> %x at pc %x\n",
 			    map, &vm->vm_pmap, va, trapframe->badvaddr, ftype, flag,
 			    rv, trapframe->pc);
 #endif
@@ -849,7 +845,7 @@
 
 	case T_BREAK + T_USER:
 		{
-			unsigned int va, instr;
+			uintptr_t va, instr;
 
 			/* compute address of break instruction */
 			va = trapframe->pc;
@@ -882,13 +878,13 @@
 	case T_IWATCH + T_USER:
 	case T_DWATCH + T_USER:
 		{
-			unsigned int va;
+			uintptr_t va;
 
 			/* compute address of trapped instruction */
 			va = trapframe->pc;
 			if (DELAYBRANCH(trapframe->cause))
 				va += sizeof(int);
-			printf("watch exception @ 0x%x\n", va);
+			printf("watch exception @ %p\n", (void *)va);
 			i = SIGTRAP;
 			addr = va;
 			break;
@@ -896,7 +892,7 @@
 
 	case T_TRAP + T_USER:
 		{
-			unsigned int va, instr;
+			uintptr_t va, instr;
 			struct trapframe *locr0 = td->td_frame;
 
 			/* compute address of trap instruction */
@@ -929,7 +925,7 @@
 		goto err;
 		break;
 	case T_COP_UNUSABLE + T_USER:
-#if defined(SOFTFLOAT)
+#if !defined(CPU_HAVEFPU)
 		/* FP (COP1) instruction */
 		if ((trapframe->cause & CR_COP_ERR) == 0x10000000) {
 			i = SIGILL;
@@ -1091,26 +1087,26 @@
  * Return the resulting PC as if the branch was executed.
  */
 u_int
-MipsEmulateBranch(struct trapframe *framePtr, int instPC, int fpcCSR,
-    u_int instptr)
+MipsEmulateBranch(struct trapframe *framePtr, uintptr_t instPC, int fpcCSR,
+    uintptr_t instptr)
 {
 	InstFmt inst;
 	register_t *regsPtr = (register_t *) framePtr;
-	unsigned retAddr = 0;
+	uintptr_t retAddr = 0;
 	int condition;
 
 #define	GetBranchDest(InstPtr, inst) \
-	((unsigned)InstPtr + 4 + ((short)inst.IType.imm << 2))
+	(InstPtr + 4 + ((short)inst.IType.imm << 2))
 
 
 	if (instptr) {
 		if (instptr < MIPS_KSEG0_START)
-			inst.word = fuword((void *)instptr);
+			inst.word = fuword32((void *)instptr);
 		else
 			inst = *(InstFmt *) instptr;
 	} else {
 		if ((vm_offset_t)instPC < MIPS_KSEG0_START)
-			inst.word = fuword((void *)instPC);
+			inst.word = fuword32((void *)instPC);
 		else
 			inst = *(InstFmt *) instPC;
 	}
@@ -1230,10 +1226,27 @@
 
 
 #if defined(DDB) || defined(DEBUG)
-#define	MIPS_JR_RA	0x03e00008	/* instruction code for jr ra */
+/*
+ * A function using a stack frame has the following instruction as the first
+ * one: addiu sp,sp,-<frame_size>
+ *
+ * We make use of this to detect starting address of a function. This works
+ * better than using 'j ra' instruction to signify end of the previous
+ * function (for e.g. functions like boot() or panic() do not actually
+ * emit a 'j ra' instruction).
+ *
+ * XXX the abi does not require that the addiu instruction be the first one.
+ */
+#define	MIPS_START_OF_FUNCTION(ins)	(((ins) & 0xffff8000) == 0x27bd8000)
 
+/*
+ * MIPS ABI 3.0 requires that all functions return using the 'j ra' instruction
+ *
+ * XXX gcc doesn't do this true for functions with __noreturn__ attribute.
+ */
+#define	MIPS_END_OF_FUNCTION(ins)	((ins) == 0x03e00008)
 /* forward */
-char *fn_name(unsigned addr);
+static char *fn_name(uintptr_t addr);
 
 /*
  * Print a stack backtrace.
@@ -1248,7 +1261,7 @@
 stacktrace_subr(struct trapframe *regs, int (*printfn) (const char *,...))
 {
 	InstFmt i;
-	unsigned a0, a1, a2, a3, pc, sp, fp, ra, va, subr;
+	uintptr_t a0, a1, a2, a3, pc, sp, fp, ra, va, subr;
 	unsigned instr, mask;
 	unsigned int frames = 0;
 	int more, stksize;
@@ -1275,6 +1288,7 @@
 		goto finish;	/* XXX */
 	}
 	/* check for bad SP: could foul up next frame */
+	/*XXX MIPS64 bad: this hard-coded SP is lame */
 	if (sp & 3 || sp < 0x80000000) {
 		(*printfn) ("SP 0x%x: not in kernel\n", sp);
 		ra = 0;
@@ -1284,7 +1298,7 @@
 #define Between(x, y, z) \
 		( ((x) <= (y)) && ((y) < (z)) )
 #define pcBetween(a,b) \
-		Between((unsigned)a, pc, (unsigned)b)
+		Between((uintptr_t)a, pc, (uintptr_t)b)
 
 	/*
 	 * Check for current PC in  exception handler code that don't have a
@@ -1292,30 +1306,31 @@
 	 * on relative ordering of functions in exception.S, swtch.S.
 	 */
 	if (pcBetween(MipsKernGenException, MipsUserGenException))
-		subr = (unsigned)MipsKernGenException;
+		subr = (uintptr_t)MipsKernGenException;
 	else if (pcBetween(MipsUserGenException, MipsKernIntr))
-		subr = (unsigned)MipsUserGenException;
+		subr = (uintptr_t)MipsUserGenException;
 	else if (pcBetween(MipsKernIntr, MipsUserIntr))
-		subr = (unsigned)MipsKernIntr;
+		subr = (uintptr_t)MipsKernIntr;
 	else if (pcBetween(MipsUserIntr, MipsTLBInvalidException))
-		subr = (unsigned)MipsUserIntr;
+		subr = (uintptr_t)MipsUserIntr;
 	else if (pcBetween(MipsTLBInvalidException,
 	    MipsKernTLBInvalidException))
-		subr = (unsigned)MipsTLBInvalidException;
+		subr = (uintptr_t)MipsTLBInvalidException;
 	else if (pcBetween(MipsKernTLBInvalidException,
 	    MipsUserTLBInvalidException))
-		subr = (unsigned)MipsKernTLBInvalidException;
+		subr = (uintptr_t)MipsKernTLBInvalidException;
 	else if (pcBetween(MipsUserTLBInvalidException, MipsTLBMissException))
-		subr = (unsigned)MipsUserTLBInvalidException;
+		subr = (uintptr_t)MipsUserTLBInvalidException;
 	else if (pcBetween(cpu_switch, MipsSwitchFPState))
-		subr = (unsigned)cpu_switch;
+		subr = (uintptr_t)cpu_switch;
 	else if (pcBetween(_locore, _locoreEnd)) {
-		subr = (unsigned)_locore;
+		subr = (uintptr_t)_locore;
 		ra = 0;
 		goto done;
 	}
 	/* check for bad PC */
-	if (pc & 3 || pc < (unsigned)0x80000000 || pc >= (unsigned)edata) {
+	/*XXX MIPS64 bad: These hard coded constants are lame */
+	if (pc & 3 || pc < (uintptr_t)0x80000000 || pc >= (uintptr_t)edata) {
 		(*printfn) ("PC 0x%x: not in kernel\n", pc);
 		ra = 0;
 		goto done;
@@ -1327,9 +1342,21 @@
 	 */
 	if (!subr) {
 		va = pc - sizeof(int);
-		while ((instr = kdbpeek((int *)va)) != MIPS_JR_RA)
-			va -= sizeof(int);
-		va += 2 * sizeof(int);	/* skip back over branch & delay slot */
+		while (1) {
+			instr = kdbpeek((int *)va);
+
+			if (MIPS_START_OF_FUNCTION(instr))
+				break;
+
+			if (MIPS_END_OF_FUNCTION(instr)) {
+				/* skip over branch-delay slot instruction */
+				va += 2 * sizeof(int);
+				break;
+			}
+
+ 			va -= sizeof(int);
+		}
+
 		/* skip over nulls which might separate .o files */
 		while ((instr = kdbpeek((int *)va)) == 0)
 			va += sizeof(int);
@@ -1507,8 +1534,8 @@
 /*
  * Map a function address to a string name, if known; or a hex string.
  */
-char *
-fn_name(unsigned addr)
+static char *
+fn_name(uintptr_t addr)
 {
 	static char buf[17];
 	int i = 0;
@@ -1529,7 +1556,7 @@
 	for (i = 0; names[i].name; i++)
 		if (names[i].addr == (void *)addr)
 			return (names[i].name);
-	sprintf(buf, "%x", addr);
+	sprintf(buf, "%jx", (uintmax_t)addr);
 	return (buf);
 }
 
@@ -1539,39 +1566,39 @@
 log_frame_dump(struct trapframe *frame)
 {
 	log(LOG_ERR, "Trapframe Register Dump:\n");
-	log(LOG_ERR, "\tzero: %08x\tat: %08x\tv0: %08x\tv1: %08x\n",
-	    0, frame->ast, frame->v0, frame->v1);
+	log(LOG_ERR, "\tzero: %p\tat: %p\tv0: %p\tv1: %p\n",
+	    (void *)0, (void *)frame->ast, (void *)frame->v0, (void *)frame->v1);
 
-	log(LOG_ERR, "\ta0: %08x\ta1: %08x\ta2: %08x\ta3: %08x\n",
-	    frame->a0, frame->a1, frame->a2, frame->a3);
+	log(LOG_ERR, "\ta0: %p\ta1: %p\ta2: %p\ta3: %p\n",
+	    (void *)frame->a0, (void *)frame->a1, (void *)frame->a2, (void *)frame->a3);
 
-	log(LOG_ERR, "\tt0: %08x\tt1: %08x\tt2: %08x\tt3: %08x\n",
-	    frame->t0, frame->t1, frame->t2, frame->t3);
+	log(LOG_ERR, "\tt0: %p\tt1: %p\tt2: %p\tt3: %p\n",
+	    (void *)frame->t0, (void *)frame->t1, (void *)frame->t2, (void *)frame->t3);
 
-	log(LOG_ERR, "\tt4: %08x\tt5: %08x\tt6: %08x\tt7: %08x\n",
-	    frame->t4, frame->t5, frame->t6, frame->t7);
+	log(LOG_ERR, "\tt4: %p\tt5: %p\tt6: %p\tt7: %p\n",
+	    (void *)frame->t4, (void *)frame->t5, (void *)frame->t6, (void *)frame->t7);
 
-	log(LOG_ERR, "\tt8: %08x\tt9: %08x\ts0: %08x\ts1: %08x\n",
-	    frame->t8, frame->t9, frame->s0, frame->s1);
+	log(LOG_ERR, "\tt8: %p\tt9: %p\ts0: %p\ts1: %p\n",
+	    (void *)frame->t8, (void *)frame->t9, (void *)frame->s0, (void *)frame->s1);
 
-	log(LOG_ERR, "\ts2: %08x\ts3: %08x\ts4: %08x\ts5: %08x\n",
-	    frame->s2, frame->s3, frame->s4, frame->s5);
+	log(LOG_ERR, "\ts2: %p\ts3: %p\ts4: %p\ts5: %p\n",
+	    (void *)frame->s2, (void *)frame->s3, (void *)frame->s4, (void *)frame->s5);
 
-	log(LOG_ERR, "\ts6: %08x\ts7: %08x\tk0: %08x\tk1: %08x\n",
-	    frame->s6, frame->s7, frame->k0, frame->k1);
+	log(LOG_ERR, "\ts6: %p\ts7: %p\tk0: %p\tk1: %p\n",
+	    (void *)frame->s6, (void *)frame->s7, (void *)frame->k0, (void *)frame->k1);
 
-	log(LOG_ERR, "\tgp: %08x\tsp: %08x\ts8: %08x\tra: %08x\n",
-	    frame->gp, frame->sp, frame->s8, frame->ra);
+	log(LOG_ERR, "\tgp: %p\tsp: %p\ts8: %p\tra: %p\n",
+	    (void *)frame->gp, (void *)frame->sp, (void *)frame->s8, (void *)frame->ra);
 
-	log(LOG_ERR, "\tsr: %08x\tmullo: %08x\tmulhi: %08x\tbadvaddr: %08x\n",
-	    frame->sr, frame->mullo, frame->mulhi, frame->badvaddr);
+	log(LOG_ERR, "\tsr: %p\tmullo: %p\tmulhi: %p\tbadvaddr: %p\n",
+	    (void *)frame->sr, (void *)frame->mullo, (void *)frame->mulhi, (void *)frame->badvaddr);
 
 #ifdef IC_REG
-	log(LOG_ERR, "\tcause: %08x\tpc: %08x\tic: %08x\n",
-	    frame->cause, frame->pc, frame->ic);
+	log(LOG_ERR, "\tcause: %p\tpc: %p\tic: %p\n",
+	    (void *)frame->cause, (void *)frame->pc, (void *)frame->ic);
 #else
-	log(LOG_ERR, "\tcause: %08x\tpc: %08x\n",
-	    frame->cause, frame->pc);
+	log(LOG_ERR, "\tcause: %p\tpc: %p\n",
+	    (void *)frame->cause, (void *)frame->pc);
 #endif
 }
 
@@ -1580,39 +1607,39 @@
 trap_frame_dump(struct trapframe *frame)
 {
 	printf("Trapframe Register Dump:\n");
-	printf("\tzero: %08x\tat: %08x\tv0: %08x\tv1: %08x\n",
-	    0, frame->ast, frame->v0, frame->v1);
+	printf("\tzero: %p\tat: %p\tv0: %p\tv1: %p\n",
+	    (void *)0, (void *)frame->ast, (void *)frame->v0, (void *)frame->v1);
 
-	printf("\ta0: %08x\ta1: %08x\ta2: %08x\ta3: %08x\n",
-	    frame->a0, frame->a1, frame->a2, frame->a3);
+	printf("\ta0: %p\ta1: %p\ta2: %p\ta3: %p\n",
+	    (void *)frame->a0, (void *)frame->a1, (void *)frame->a2, (void *)frame->a3);
 
-	printf("\tt0: %08x\tt1: %08x\tt2: %08x\tt3: %08x\n",
-	    frame->t0, frame->t1, frame->t2, frame->t3);
+	printf("\tt0: %p\tt1: %p\tt2: %p\tt3: %p\n",
+	    (void *)frame->t0, (void *)frame->t1, (void *)frame->t2, (void *)frame->t3);
 
-	printf("\tt4: %08x\tt5: %08x\tt6: %08x\tt7: %08x\n",
-	    frame->t4, frame->t5, frame->t6, frame->t7);
+	printf("\tt4: %p\tt5: %p\tt6: %p\tt7: %p\n",
+	    (void *)frame->t4, (void *)frame->t5, (void *)frame->t6, (void *)frame->t7);
 
-	printf("\tt8: %08x\tt9: %08x\ts0: %08x\ts1: %08x\n",
-	    frame->t8, frame->t9, frame->s0, frame->s1);
+	printf("\tt8: %p\tt9: %p\ts0: %p\ts1: %p\n",
+	    (void *)frame->t8, (void *)frame->t9, (void *)frame->s0, (void *)frame->s1);
 
-	printf("\ts2: %08x\ts3: %08x\ts4: %08x\ts5: %08x\n",
-	    frame->s2, frame->s3, frame->s4, frame->s5);
+	printf("\ts2: %p\ts3: %p\ts4: %p\ts5: %p\n",
+	    (void *)frame->s2, (void *)frame->s3, (void *)frame->s4, (void *)frame->s5);
 
-	printf("\ts6: %08x\ts7: %08x\tk0: %08x\tk1: %08x\n",
-	    frame->s6, frame->s7, frame->k0, frame->k1);
+	printf("\ts6: %p\ts7: %p\tk0: %p\tk1: %p\n",
+	    (void *)frame->s6, (void *)frame->s7, (void *)frame->k0, (void *)frame->k1);
 
-	printf("\tgp: %08x\tsp: %08x\ts8: %08x\tra: %08x\n",
-	    frame->gp, frame->sp, frame->s8, frame->ra);
+	printf("\tgp: %p\tsp: %p\ts8: %p\tra: %p\n",
+	    (void *)frame->gp, (void *)frame->sp, (void *)frame->s8, (void *)frame->ra);
 
-	printf("\tsr: %08x\tmullo: %08x\tmulhi: %08x\tbadvaddr: %08x\n",
-	    frame->sr, frame->mullo, frame->mulhi, frame->badvaddr);
+	printf("\tsr: %p\tmullo: %p\tmulhi: %p\tbadvaddr: %p\n",
+	    (void *)frame->sr, (void *)frame->mullo, (void *)frame->mulhi, (void *)frame->badvaddr);
 
 #ifdef IC_REG
-	printf("\tcause: %08x\tpc: %08x\tic: %08x\n",
-	    frame->cause, frame->pc, frame->ic);
+	printf("\tcause: %p\tpc: %p\tic: %p\n",
+	    (void *)frame->cause, (void *)frame->pc, (void *)frame->ic);
 #else
-	printf("\tcause: %08x\tpc: %08x\n",
-	    frame->cause, frame->pc);
+	printf("\tcause: %p\tpc: %p\n",
+	    (void *)frame->cause, (void *)frame->pc);
 #endif
 }
 
@@ -1667,12 +1694,12 @@
 	}
 
 	pc = frame->pc + (DELAYBRANCH(frame->cause) ? 4 : 0);
-	log(LOG_ERR, "%s: pid %d (%s), uid %d: pc 0x%x got a %s fault at 0x%x\n",
+	log(LOG_ERR, "%s: pid %d (%s), uid %d: pc %p got a %s fault at %p\n",
 	    msg, p->p_pid, p->p_comm,
 	    p->p_ucred ? p->p_ucred->cr_uid : -1,
-	    pc,
+	    (void *)pc,
 	    read_or_write,
-	    frame->badvaddr);
+	    (void *)frame->badvaddr);
 
 	/* log registers in trap frame */
 	log_frame_dump(frame);
@@ -1687,8 +1714,8 @@
 	    (trap_type != T_BUS_ERR_IFETCH) &&
 	    useracc((caddr_t)pc, sizeof(int) * 4, VM_PROT_READ)) {
 		/* dump page table entry for faulting instruction */
-		log(LOG_ERR, "Page table info for pc address 0x%x: pde = %p, pte = 0x%lx\n",
-		    pc, *pdep, ptep ? *ptep : 0);
+		log(LOG_ERR, "Page table info for pc address %p: pde = %p, pte = 0x%lx\n",
+		    (void *)pc, *pdep, ptep ? *ptep : 0);
 
 		addr = (unsigned int *)pc;
 		log(LOG_ERR, "Dumping 4 words starting at pc address %p: \n",
@@ -1696,8 +1723,8 @@
 		log(LOG_ERR, "%08x %08x %08x %08x\n",
 		    addr[0], addr[1], addr[2], addr[3]);
 	} else {
-		log(LOG_ERR, "pc address 0x%x is inaccessible, pde = 0x%p, pte = 0x%lx\n",
-		    pc, *pdep, ptep ? *ptep : 0);
+		log(LOG_ERR, "pc address %p is inaccessible, pde = 0x%p, pte = 0x%lx\n",
+		    (void *)pc, *pdep, ptep ? *ptep : 0);
 	}
 	/*	panic("Bad trap");*/
 }
@@ -1806,8 +1833,9 @@
 			else
 				frame->pc += 4;
 
-			log(LOG_INFO, "Unaligned %s: pc=0x%x, badvaddr=0x%x\n",
-			    access_name[access_type - 1], pc, frame->badvaddr);
+			log(LOG_INFO, "Unaligned %s: pc=%p, badvaddr=%p\n",
+			    access_name[access_type - 1], (void *)pc,
+			    (void *)frame->badvaddr);
 		}
 	}
 	return access_type;
diff -I '.*' -Naur releng8/sys/mips/mips/vm_machdep.c svn/mips/sys/mips/mips/vm_machdep.c
--- releng8/src/sys/mips/mips/vm_machdep.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/mips/vm_machdep.c	2009-10-01 13:13:43.000000000 -0700
@@ -52,6 +52,7 @@
 #include <sys/sysctl.h>
 #include <sys/unistd.h>
 
+#include <machine/cache.h>
 #include <machine/clock.h>
 #include <machine/cpu.h>
 #include <machine/md_var.h>
@@ -148,7 +149,7 @@
 	pcb2->pcb_context.val[PCB_REG_S0] = (register_t)fork_return;
 	pcb2->pcb_context.val[PCB_REG_S1] = (register_t)td2;
 	pcb2->pcb_context.val[PCB_REG_S2] = (register_t)td2->td_frame;
-	pcb2->pcb_context.val[PCB_REG_SR] = SR_INT_MASK;
+	pcb2->pcb_context.val[PCB_REG_SR] = SR_INT_MASK & mips_rd_status();
 	/*
 	 * FREEBSD_DEVELOPERS_FIXME:
 	 * Setup any other CPU-Specific registers (Not MIPS Standard)
@@ -156,6 +157,7 @@
 	 *  that are needed.
 	 */
 
+	td2->td_md.md_tls = td1->td_md.md_tls;
 	td2->td_md.md_saved_intr = MIPS_SR_INT_IE;
 	td2->td_md.md_spinlock_count = 1;
 #ifdef TARGET_OCTEON
@@ -298,11 +300,9 @@
 	pcb2->pcb_context.val[PCB_REG_S0] = (register_t)fork_return;
 	pcb2->pcb_context.val[PCB_REG_S1] = (register_t)td;
 	pcb2->pcb_context.val[PCB_REG_S2] = (register_t)td->td_frame;
-
-
 	/* Dont set IE bit in SR. sched lock release will take care of it */
-/* idle_mask is jmips pcb2->pcb_context.val[11] = (ALL_INT_MASK & idle_mask); */
-	pcb2->pcb_context.val[PCB_REG_SR] = SR_INT_MASK;
+	pcb2->pcb_context.val[PCB_REG_SR] = SR_INT_MASK & mips_rd_status();
+
 #ifdef TARGET_OCTEON
 	pcb2->pcb_context.val[PCB_REG_SR] |= MIPS_SR_COP_2_BIT | MIPS_SR_COP_0_BIT |
 	  MIPS32_SR_PX | MIPS_SR_UX | MIPS_SR_KX | MIPS_SR_SX;
@@ -335,14 +335,14 @@
     stack_t *stack)
 {
 	struct trapframe *tf;
-	u_int32_t sp;
+	register_t sp;
 
 	/*
 	* At the point where a function is called, sp must be 8
 	* byte aligned[for compatibility with 64-bit CPUs]
 	* in ``See MIPS Run'' by D. Sweetman, p. 269
 	* align stack */
-	sp = ((uint32_t)(stack->ss_sp + stack->ss_size) & ~0x7) -
+	sp = ((register_t)(stack->ss_sp + stack->ss_size) & ~0x7) -
 	    STAND_FRAME_SIZE;
 
 	/*
@@ -353,9 +353,18 @@
 	bzero(tf, sizeof(struct trapframe));
 	tf->sp = (register_t)sp;
 	tf->pc = (register_t)entry;
+	/* 
+	 * MIPS ABI requires T9 to be the same as PC 
+	 * in subroutine entry point
+	 */
+	tf->t9 = (register_t)entry; 
 	tf->a0 = (register_t)arg;
 
-	tf->sr = SR_KSU_USER | SR_EXL;
+	/*
+	 * Keep interrupt mask
+	 */
+	tf->sr = SR_KSU_USER | SR_EXL | (SR_INT_MASK & mips_rd_status()) |
+	    MIPS_SR_INT_IE;
 #ifdef TARGET_OCTEON
 	tf->sr |=  MIPS_SR_INT_IE | MIPS_SR_COP_0_BIT | MIPS_SR_UX |
 	  MIPS_SR_KX;
@@ -466,6 +475,12 @@
 				nsfbufsused++;
 				nsfbufspeak = imax(nsfbufspeak, nsfbufsused);
 			}
+			/*
+			 * Flush all mappings in order to have up to date 
+			 * physycal memory
+			 */
+			pmap_flush_pvcache(sf->m);
+			mips_dcache_inv_range(sf->kva, PAGE_SIZE);
 			goto done;
 		}
 	}
@@ -507,6 +522,10 @@
 {
 	mtx_lock(&sf_buf_lock);
 	sf->ref_count--;
+	/*
+	 * Make sure all changes in KVA end up in physical memory
+	 */
+	mips_dcache_wbinv_range(sf->kva, PAGE_SIZE);
 	if (sf->ref_count == 0) {
 		TAILQ_INSERT_TAIL(&sf_buf_freelist, sf, free_entry);
 		nsfbufsused--;
@@ -528,7 +547,7 @@
 cpu_set_user_tls(struct thread *td, void *tls_base)
 {
 
-	/* TBD */
+	td->td_md.md_tls = tls_base;
 	return (0);
 }
 
diff -I '.*' -Naur releng8/sys/mips/octeon1/asm_octeon.S svn/mips/sys/mips/octeon1/asm_octeon.S
--- releng8/src/sys/mips/octeon1/asm_octeon.S	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/asm_octeon.S	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,143 @@
+
+#include <machine/asm.h>
+#include <machine/cache_r4k.h>
+#include <machine/cpuregs.h>
+#include <machine/param.h>
+#include <machine/pte.h>
+
+#include "assym.s"
+	
+
+
+#define CPU_DISABLE_INTERRUPTS(reg, reg2, reg3) \
+        mfc0    reg, MIPS_COP_0_STATUS; \
+        nop; \
+        move    reg3, reg; \
+        li      reg2, ~MIPS_SR_INT_IE; \
+        and     reg, reg2, reg; \
+        mtc0    reg, MIPS_COP_0_STATUS; \
+        COP0_SYNC
+
+
+
+#define CPU_ENABLE_INTERRUPTS(reg, reg3) \
+        mfc0    reg, MIPS_COP_0_STATUS; \
+        nop; \
+        or      reg, reg, reg3; \
+        mtc0    reg, MIPS_COP_0_STATUS; \
+        COP0_SYNC
+
+
+#define PUSHR(reg) \
+        addiu   sp,sp,-16        ; \
+        sd      reg, 8(sp)      ; \
+        nop                     ; 
+
+#define POPR(reg) \
+        ld      reg, 8(sp)      ; \
+        addiu   sp,sp,16        ; \
+        nop                     ; 
+
+
+
+                
+/*
+ * octeon_ciu_get_interrupt_reg_addr
+ *
+ * Given  Int-X, En-X combination, return the CIU Interrupt Enable Register addr
+ * a0 = ciu Int-X:  0/1
+ * a1 = ciu EN-0:   0/1
+ */
+LEAF(octeon_ciu_get_interrupt_reg_addr)
+        .set    noreorder
+        .set    mips3
+
+        beqz    a0, ciu_get_interrupt_reg_addr_Int_0
+        nop
+
+ciu_get_interrupt_reg_addr_Int_1:
+        beqz    a1, ciu_get_interrupt_reg_addr_Int_1_En_0
+        nop
+
+ciu_get_interrupt_reg_addr_Int_1_En1:
+        li      a0, OCTEON_CIU_ADDR_HI
+        dsll32  a0, a0, 0
+        nop
+        ori      a0, OCTEON_CIU_EN1_INT1_LO
+        j       ciu_get_interrupt_reg_addr_ret
+        nop
+
+ciu_get_interrupt_reg_addr_Int_1_En_0:
+        li      a0, OCTEON_CIU_ADDR_HI
+        dsll32  a0, a0, 0
+        nop
+        ori     a0, OCTEON_CIU_EN0_INT1_LO
+        j       ciu_get_interrupt_reg_addr_ret
+        nop
+
+ciu_get_interrupt_reg_addr_Int_0:
+        beqz    a1, ciu_get_interrupt_reg_addr_Int_0_En_0
+        nop
+
+ciu_get_interrupt_reg_addr_Int_0_En_1:
+        li      a0, OCTEON_CIU_ADDR_HI
+        dsll32  a0, a0, 0
+        nop
+        ori     a0, OCTEON_CIU_EN1_INT0_LO
+        j       ciu_get_interrupt_reg_addr_ret
+        nop
+
+ciu_get_interrupt_reg_addr_Int_0_En_0:
+        li      a0, OCTEON_CIU_ADDR_HI
+        dsll32  a0, a0, 0
+        nop
+        ori     a0, OCTEON_CIU_EN0_INT0_LO
+                
+        
+ciu_get_interrupt_reg_addr_ret: 
+        j       ra
+        nop
+        
+        .set	mips0
+        .set    reorder
+END(octeon_ciu_get_interrupt_reg_addr)
+
+
+                
+/*
+ * octeon_ciu_mask_all_interrupts
+ *
+ * a0 = ciu Interrupt-X:  0/1
+ * a1 = ciu Enable-X:   0/1
+ */
+LEAF(octeon_ciu_mask_all_interrupts)
+	.set    noreorder
+        .set    mips3
+
+        PUSHR(ra)
+        PUSHR(s0)
+        
+        move    t0, a0
+        move    t1, a1
+        li      a0, MIPS_SR_INT_IE
+        CPU_DISABLE_INTERRUPTS(a2, a1, s0)
+        move    a0, t0
+        move    t1, a1
+        jal     octeon_ciu_get_interrupt_reg_addr
+        nop
+        ld      a2, 0(a0)       # Dummy read
+        nop
+        move    a2, zero        # Clear all
+        sd      a2, 0(a0)       # Write new Enable bits
+        nop
+        CPU_ENABLE_INTERRUPTS(a2, s0)
+
+        POPR(s0)
+        POPR(ra)
+	j	ra			# Return
+	nop				# (bd slot)
+
+        .set	mips0
+	.set	reorder
+END(octeon_ciu_mask_all_interrupts)
+
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_fau.c svn/mips/sys/mips/octeon1/dev/rgmii/octeon_fau.c
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_fau.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_fau.c	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,42 @@
+/*------------------------------------------------------------------
+ * octeon_fau.c        Fetch & Add Block
+ *
+ *------------------------------------------------------------------
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+
+#include <mips/octeon1/octeon_pcmap_regs.h>
+#include "octeon_fau.h"
+
+/*
+ * oct_fau_init
+ *
+ * How do we initialize FAU unit. I don't even think we can reset it.
+ */
+void octeon_fau_init (void)
+{
+}
+
+
+/*
+ * oct_fau_enable
+ *
+ * Let the Fetch/Add unit roll
+ */
+void octeon_fau_enable (void)
+{
+}
+
+
+/*
+ * oct_fau_disable
+ *
+ * disable fau
+ *
+ * Don't know if we can even do that.
+ */
+void octeon_fau_disable (void)
+{
+}
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_fau.h svn/mips/sys/mips/octeon1/dev/rgmii/octeon_fau.h
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_fau.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_fau.h	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,185 @@
+/*------------------------------------------------------------------
+ * octeon_fau.h        Fetch & Add Unit
+ *
+ *------------------------------------------------------------------
+ */
+
+
+#ifndef ___OCTEON_FAU__H___
+#define ___OCTEON_FAU__H___
+
+
+
+
+typedef enum {
+   OCTEON_FAU_OP_SIZE_8  = 0,
+   OCTEON_FAU_OP_SIZE_16 = 1,
+   OCTEON_FAU_OP_SIZE_32 = 2,
+   OCTEON_FAU_OP_SIZE_64 = 3
+} octeon_fau_op_size_t;
+
+
+
+#define OCTEON_FAU_LOAD_IO_ADDRESS    octeon_build_io_address(0x1e, 0)
+#define OCTEON_FAU_BITS_SCRADDR       63,56
+#define OCTEON_FAU_BITS_LEN           55,48
+#define OCTEON_FAU_BITS_INEVAL        35,14
+#define OCTEON_FAU_BITS_TAGWAIT       13,13
+#define OCTEON_FAU_BITS_NOADD         13,13
+#define OCTEON_FAU_BITS_SIZE          12,11
+#define OCTEON_FAU_BITS_REGISTER      10,0
+
+#define OCTEON_FAU_REG_64_ADDR(x) ((x <<3) + OCTEON_FAU_REG_64_START)
+typedef enum
+{
+    OCTEON_FAU_REG_64_START		= 0, 
+    OCTEON_FAU_REG_OQ_ADDR_INDEX 	= OCTEON_FAU_REG_64_ADDR(0),
+    OCTEON_FAU_REG_OQ_ADDR_END 		= OCTEON_FAU_REG_64_ADDR(31),
+    OCTEON_FAU_REG_64_END		= OCTEON_FAU_REG_64_ADDR(39),
+} octeon_fau_reg_64_t;
+
+#define OCTEON_FAU_REG_32_ADDR(x) ((x <<2) + OCTEON_FAU_REG_32_START)
+typedef enum
+{
+    OCTEON_FAU_REG_32_START          = OCTEON_FAU_REG_64_END,
+    OCTEON_FAU_REG_32_END            = OCTEON_FAU_REG_32_ADDR(0),
+} octeon_fau_reg_32_t;
+
+
+
+/*
+ * octeon_fau_atomic_address
+ *
+ * Builds a I/O address for accessing the FAU
+ *
+ * @param tagwait Should the atomic add wait for the current tag switch
+ *                operation to complete.
+ *                - 0 = Don't wait
+ *                - 1 = Wait for tag switch to complete
+ * @param reg     FAU atomic register to access. 0 <= reg < 4096.
+ *                - Step by 2 for 16 bit access.
+ *                - Step by 4 for 32 bit access.
+ *                - Step by 8 for 64 bit access.
+ * @param value   Signed value to add.
+ *                Note: When performing 32 and 64 bit access, only the low
+ *                22 bits are available.
+ * @return Address to read from for atomic update
+ */
+static inline uint64_t octeon_fau_atomic_address (uint64_t tagwait, uint64_t reg,
+                                               int64_t value)
+{
+    return (OCTEON_ADD_IO_SEG(OCTEON_FAU_LOAD_IO_ADDRESS) |
+            octeon_build_bits(OCTEON_FAU_BITS_INEVAL, value) |
+            octeon_build_bits(OCTEON_FAU_BITS_TAGWAIT, tagwait) |
+            octeon_build_bits(OCTEON_FAU_BITS_REGISTER, reg));
+}
+
+
+/*
+ * octeon_fau_store_address
+ *
+ * Builds a store I/O address for writing to the FAU
+ *
+ * noadd  0 = Store value is atomically added to the current value
+ *               1 = Store value is atomically written over the current value
+ * reg    FAU atomic register to access. 0 <= reg < 4096.
+ *               - Step by 2 for 16 bit access.
+ *               - Step by 4 for 32 bit access.
+ *               - Step by 8 for 64 bit access.
+ * Returns Address to store for atomic update
+ */
+static inline uint64_t octeon_fau_store_address (uint64_t noadd, uint64_t reg)
+{
+    return (OCTEON_ADD_IO_SEG(OCTEON_FAU_LOAD_IO_ADDRESS) |
+            octeon_build_bits(OCTEON_FAU_BITS_NOADD, noadd) |
+            octeon_build_bits(OCTEON_FAU_BITS_REGISTER, reg));
+}
+
+
+/*
+ * octeon_fau_atomic_add32
+ *
+ * Perform an atomic 32 bit add
+ *
+ * @param reg     FAU atomic register to access. 0 <= reg < 4096.
+ *                - Step by 4 for 32 bit access.
+ * @param value   Signed value to add.
+ */
+static inline void octeon_fau_atomic_add32 (octeon_fau_reg_32_t reg, int32_t value)
+{
+    oct_write32(octeon_fau_store_address(0, reg), value);
+}
+
+/*
+ * octeon_fau_fetch_and_add
+ *
+ * reg     FAU atomic register to access. 0 <= reg < 4096.
+ *                - Step by 8 for 64 bit access.
+ * value   Signed value to add.
+ *                Note: Only the low 22 bits are available.
+ * returns Value of the register before the update
+ */
+static inline int64_t octeon_fau_fetch_and_add64 (octeon_fau_reg_64_t reg,
+                                               int64_t  val64)
+{
+
+    return (oct_read64(octeon_fau_atomic_address(0, reg, val64)));
+}
+
+/*
+ * octeon_fau_fetch_and_add32
+ *
+ * reg     FAU atomic register to access. 0 <= reg < 4096.
+ *                - Step by 8 for 64 bit access.
+ * value   Signed value to add.
+ *                Note: Only the low 22 bits are available.
+ * returns Value of the register before the update
+ */
+static inline int32_t octeon_fau_fetch_and_add32 (octeon_fau_reg_64_t reg,
+                                               int32_t val32)
+{
+    return (oct_read32(octeon_fau_atomic_address(0, reg, val32)));
+}
+
+/*
+ * octeon_fau_atomic_write32
+ *
+ * Perform an atomic 32 bit write
+ *
+ * @param reg     FAU atomic register to access. 0 <= reg < 4096.
+ *                - Step by 4 for 32 bit access.
+ * @param value   Signed value to write.
+ */
+static inline void octeon_fau_atomic_write32(octeon_fau_reg_32_t reg, int32_t value)
+{
+    oct_write32(octeon_fau_store_address(1, reg), value);
+}
+
+
+/*
+ * octeon_fau_atomic_write64
+ *
+ * Perform an atomic 32 bit write
+ *
+ * reg    FAU atomic register to access. 0 <= reg < 4096.
+ *                - Step by 8 for 64 bit access.
+ * value   Signed value to write.
+ */
+static inline void octeon_fau_atomic_write64 (octeon_fau_reg_64_t reg, int64_t value)
+{
+    oct_write64(octeon_fau_store_address(1, reg), value);
+}
+
+
+static inline void octeon_fau_atomic_add64 (octeon_fau_reg_64_t reg, int64_t value)
+{
+    oct_write64_int64(octeon_fau_store_address(0, reg), value);
+}
+
+
+extern void octeon_fau_init(void);
+extern void octeon_fau_enable(void);
+extern void octeon_fau_disable(void);
+
+
+#endif  /* ___OCTEON_FAU__H___ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_fpa.c svn/mips/sys/mips/octeon1/dev/rgmii/octeon_fpa.c
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_fpa.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_fpa.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,187 @@
+/*------------------------------------------------------------------
+ * octeon_fpa.c        Free Pool Allocator
+ *
+ *------------------------------------------------------------------
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#include <vm/vm.h>
+#include <vm/pmap.h>
+
+
+#include <mips/octeon1/octeon_pcmap_regs.h>
+#include "octeon_fpa.h"
+
+
+//#define FPA_DEBUG 1
+
+/*
+ * octeon_dump_fpa
+ *
+ */
+void octeon_dump_fpa (void)
+{
+    int i;
+    octeon_fpa_ctl_status_t status;
+    octeon_fpa_queue_available_t q_avail;
+
+    status.word64 = oct_read64(OCTEON_FPA_CTL_STATUS);
+    if (!status.bits.enb) {
+        printf("\n  FPA Disabled");
+        /*
+         * No dumping if disabled
+         */
+        return;
+    }
+    printf(" FPA  Ctrl-Status-reg 0x%llX := 0x%llX  EN %X  M1_E %X  M0_E %X\n",
+           OCTEON_FPA_CTL_STATUS, (unsigned long long)status.word64,
+           status.bits.enb, status.bits.mem1_err, status.bits.mem0_err);
+    for (i = 0; i < OCTEON_FPA_QUEUES; i++) {
+        printf("   Pool: %d\n", i);
+
+        q_avail.word64 = oct_read64((OCTEON_FPA_QUEUE_AVAILABLE + (i)*8ull));
+        printf("   Avail-reg 0x%llX :=   Size: 0x%X\n",
+               (OCTEON_FPA_QUEUE_AVAILABLE + (i)*8ull), q_avail.bits.queue_size);
+    }
+}
+
+void octeon_dump_fpa_pool (u_int pool)
+{
+    octeon_fpa_ctl_status_t status;
+    octeon_fpa_queue_available_t q_avail;
+
+    status.word64 = oct_read64(OCTEON_FPA_CTL_STATUS);
+    if (!status.bits.enb) {
+        printf("\n  FPA Disabled");
+        /*
+         * No dumping if disabled
+         */
+        return;
+    }
+    printf(" FPA  Ctrl-Status-reg 0x%llX := 0x%llX  EN %X  M1_E %X  M0_E %X\n",
+           OCTEON_FPA_CTL_STATUS, (unsigned long long)status.word64,
+           status.bits.enb, status.bits.mem1_err, status.bits.mem0_err);
+    q_avail.word64 = oct_read64((OCTEON_FPA_QUEUE_AVAILABLE + (pool)*8ull));
+    printf("   FPA Pool: %u   Avail-reg 0x%llX :=   Size: 0x%X\n", pool,
+           (OCTEON_FPA_QUEUE_AVAILABLE + (pool)*8ull), q_avail.bits.queue_size);
+}
+
+
+u_int octeon_fpa_pool_size (u_int pool)
+{
+    octeon_fpa_queue_available_t q_avail;
+    u_int size = 0;
+
+    if (pool < 7) {
+            q_avail.word64 = oct_read64((OCTEON_FPA_QUEUE_AVAILABLE + (pool)*8ull));
+            size = q_avail.bits.queue_size;
+    }
+    return (size);
+}
+
+
+/*
+ * octeon_enable_fpa
+ *
+ * configure fpa with defaults and then mark it enabled.
+ */
+void octeon_enable_fpa (void)
+{
+    int i;
+    octeon_fpa_ctl_status_t status;
+    octeon_fpa_fpf_marks_t marks;
+
+    for (i = 0; i < OCTEON_FPA_QUEUES; i++) {
+        marks.word64 = oct_read64((OCTEON_FPA_FPF_MARKS + (i)*8ull));
+
+        marks.bits.fpf_wr = 0xe0;
+        oct_write64((OCTEON_FPA_FPF_MARKS + (i)*8ull), marks.word64);
+    }
+
+    /* Enforce a 10 cycle delay between config and enable */
+    octeon_wait(10);
+
+    status.word64 = 0;
+    status.bits.enb = 1;
+    oct_write64(OCTEON_FPA_CTL_STATUS, status.word64);
+}
+
+
+//#define FPA_DEBUG_TERSE 1
+
+/*
+ * octeon_fpa_fill_pool_mem
+ *
+ * Fill the specified FPA pool with elem_num number of
+ * elements of size elem_size_words * 8
+ */
+void octeon_fpa_fill_pool_mem (u_int pool, u_int elem_size_words, u_int elem_num)
+{
+    void *memory;
+    u_int bytes, elem_size_bytes;
+    u_int block_size;
+
+#ifdef FPA_DEBUG
+    u_int elems = elem_num;
+    printf(" FPA fill: Pool %u  elem_size_words %u   Num: %u\n", pool, elem_size_words, elem_num);
+#endif
+    elem_size_bytes = elem_size_words * sizeof(uint64_t);
+    block_size = OCTEON_ALIGN(elem_size_bytes);
+
+//    block_size = ((elem_size_bytes / OCTEON_FPA_POOL_ALIGNMENT) + 1) * OCTEON_FPA_POOL_ALIGNMENT;
+
+    bytes = (elem_num * block_size);
+
+#ifdef FPA_DEBUG
+    printf(" elem_size_bytes = words * 8 = %u;  block_size %u\n", elem_size_bytes, block_size);
+#endif
+
+
+#ifdef FPA_DEBUG
+    int block = 0;
+
+    printf(" %% Filling Pool %u  with %u blocks of %u bytes  %u words\n",
+           pool, elem_num, elem_size_bytes, elem_size_words);
+#endif
+
+//    memory = malloc(bytes, M_DEVBUF, M_NOWAIT | M_ZERO);
+    memory = contigmalloc(bytes, M_DEVBUF, M_NOWAIT | M_ZERO,
+                          0, 0x20000000,
+                          OCTEON_FPA_POOL_ALIGNMENT, 0);
+
+    if (memory == NULL) {
+        printf(" %% FPA pool %u could not be filled with %u bytes\n",
+               pool, bytes);
+        return;
+    }
+
+    /*
+     * Forward Align allocated mem to needed alignment. Don't worry about growth, we
+     * already preallocated extra
+     */
+#ifdef FPA_DEBUG
+    printf(" %% Huge MemBlock  0x%X   Bytes %u\n", memory, bytes);
+#endif
+
+    memory = (void *) OCTEON_ALIGN(memory);
+
+#ifdef FPA_DEBUG_TERSE
+    printf("FPA fill: %u  Count: %u  SizeBytes: %u  SizeBytesAligned: %u  1st: 0x%X = %p\n",
+           pool, elem_num, elem_size_bytes, block_size, memory, (void *)OCTEON_PTR2PHYS(memory));
+#endif
+
+//    memory = (void *) ((((u_int) memory / OCTEON_FPA_POOL_ALIGNMENT) + 1) * OCTEON_FPA_POOL_ALIGNMENT);
+
+    while (elem_num--) {
+#ifdef FPA_DEBUG
+        if (((elems - elem_num) < 4) || (elem_num < 4))
+        printf(" %% Block %d:  0x%X  Phys 0x%X   Bytes %u\n", block, memory, OCTEON_PTR2PHYS(memory), elem_size_bytes);
+        block++;
+#endif
+        octeon_fpa_free(memory, pool, 0);
+        memory = (void *) (((u_long) memory) + block_size);
+    }
+}
+
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_fpa.h svn/mips/sys/mips/octeon1/dev/rgmii/octeon_fpa.h
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_fpa.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_fpa.h	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,219 @@
+/*------------------------------------------------------------------
+ * octeon_fpa.h      Free Pool Allocator
+ *
+ *------------------------------------------------------------------
+ */
+
+
+#ifndef ___OCTEON_FPA__H___
+#define ___OCTEON_FPA__H___
+
+
+#define OCTEON_FPA_FPA_OUTPUT_BUFFER_POOL           2    /* Same in octeon_rgmx.h */
+
+
+/*
+ * OCTEON_FPA_FPF_MARKS = FPA's Queue Free Page FIFO Read Write Marks
+ *
+ * The high and low watermark register that determines when we write and
+ * read free pages from L2C for Queue.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved                : 42;      /* Must be zero */
+        uint64_t fpf_wr                  : 11;      /* Write Hi Water mark */
+        uint64_t fpf_rd                  : 11;      /* Read Lo Water mark */
+    } bits;
+} octeon_fpa_fpf_marks_t;
+
+
+/*
+ * OCTEON_FPA_CTL_STATUS = FPA's Control/Status Register
+ *
+ * The FPA's interrupt enable register.
+ * - Use with the CVMX_FPA_CTL_STATUS CSR.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved                : 49;      /* Must be zero */
+        uint64_t enb                     : 1;       /* Enable */
+        uint64_t mem1_err                : 7;       /* ECC flip 1 */
+        uint64_t mem0_err                : 7;       /* ECC flip 0 */
+    } bits;
+} octeon_fpa_ctl_status_t;
+
+
+/*
+ * OCTEON_FPA_FPF_SIZE = FPA's Queue N Free Page FIFO Size
+ *
+ * The number of page pointers that will be kept local to the FPA for
+ *  this Queue. FPA Queues are assigned in order from Queue 0 to
+ *  Queue 7, though only Queue 0 through Queue x can be used.
+ * The sum of the 8 (0-7)OCTEON_FPA_FPF#_SIZE registers must be limited to 2048.
+ * - Use with the CVMX_FPA_FPF0_SIZE CSR.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved                : 52;      /* Must be zero */
+      /*
+       * The number of entries assigned in the FPA FIFO (used to hold
+       * page-pointers) for this Queue.
+       * The value of this register must divisable by 2, and the FPA will
+       * ignore bit [0] of this register.
+       * The total of the FPF_SIZ field of the 8 (0-7)OCTEON_FPA_FPF#_MARKS
+       * registers must not exceed 2048.
+       * After writing this field the FPA will need 10 core clock cycles
+       * to be ready for operation. The assignment of location in
+       * the FPA FIFO must start with Queue 0, then 1, 2, etc.
+       * The number of useable entries will be FPF_SIZ-2.
+       */
+        uint64_t fpf_siz                 : 12;
+    } bits;
+} octeon_fpa_fpf_size_t;
+
+/*
+ *OCTEON_FPA_INT_ENB = FPA's Interrupt Enable
+ *
+ * The FPA's interrupt enable register.
+ * - Use with the CVMX_FPA_INT_ENB CSR.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved                : 60;  /* Must be zero */
+        uint64_t fed1_dbe                : 1;   /* Int iff bit3 Int-Sum set */
+        uint64_t fed1_sbe                : 1;   /* Int iff bit2 Int-Sum set */
+        uint64_t fed0_dbe                : 1;   /* Int iff bit1 Int-Sum set */
+        uint64_t fed0_sbe                : 1;   /* Int iff bit0 Int-Sum set */
+    } bits;
+} octeon_fpa_int_enb_t;
+
+/**
+ *OCTEON_FPA_INT_SUM = FPA's Interrupt Summary Register
+ *
+ * Contains the diffrent interrupt summary bits of the FPA.
+ * - Use with the CVMX_FPA_INT_SUM CSR.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved                : 60;      /**< Must be zero */
+        uint64_t fed1_dbe                : 1;
+        uint64_t fed1_sbe                : 1;
+        uint64_t fed0_dbe                : 1;
+        uint64_t fed0_sbe                : 1;
+    } bits;
+} octeon_fpa_int_sum_t;
+
+
+/*
+ *OCTEON_FPA_QUEUE_PAGES_AVAILABLE = FPA's Queue 0-7 Free Page Available Register
+ *
+ * The number of page pointers that are available in the FPA and local DRAM.
+ * - Use with the CVMX_FPA_QUEX_AVAILABLE(0..7) CSR.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved                : 38;      /* Must be zero */
+        uint64_t queue_size              : 26;      /* free pages available */
+    } bits;
+} octeon_fpa_queue_available_t;
+
+
+/*
+ *OCTEON_FPA_QUEUE_PAGE_INDEX
+ *
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved                : 39;      /* Must be zero */
+        uint64_t page_index              : 25;      /* page_index */
+    } bits;
+} octeon_fpa_queue_page_index_t;
+
+
+#define OCTEON_DID_FPA			5ULL
+
+#define	OCTEON_FPA_POOL_ALIGNMENT	(OCTEON_CACHE_LINE_SIZE)
+
+
+/*
+ * Externs
+ */
+extern void octeon_dump_fpa(void);
+extern void octeon_dump_fpa_pool(u_int pool);
+extern u_int octeon_fpa_pool_size(u_int pool);
+extern void octeon_enable_fpa(void);
+extern void octeon_fpa_fill_pool_mem(u_int pool,
+                                     u_int block_size_words,
+                                     u_int block_num);
+
+/*
+ * octeon_fpa_free
+ *
+ * Free a mem-block to FPA pool.
+ *
+ * Takes away this 'buffer' from SW and passes it to FPA for management.
+ *
+ *  pool is FPA pool num, ptr is block ptr, num_cache_lines is number of
+ *  cache lines to invalidate (not written back).
+ */
+static inline void octeon_fpa_free (void *ptr, u_int pool,
+                                    u_int num_cache_lines)
+{
+    octeon_addr_t free_ptr;
+
+    free_ptr.word64 = (uint64_t)OCTEON_PTR2PHYS(ptr);
+
+    free_ptr.sfilldidspace.didspace = OCTEON_ADDR_DIDSPACE(
+        OCTEON_ADDR_FULL_DID(OCTEON_DID_FPA, pool));
+
+    /*
+     * Do not 'sync'
+     *     asm volatile ("sync\n");
+     */
+    oct_write64(free_ptr.word64, num_cache_lines);
+}
+
+
+
+/*
+ * octeon_fpa_alloc
+ *
+ * Allocate a new block from the FPA
+ *
+ * Buffer passes away from FPA management to SW control
+ */
+static inline void *octeon_fpa_alloc (u_int pool)
+{
+    uint64_t address;
+
+    address = oct_read64(OCTEON_ADDR_DID(OCTEON_ADDR_FULL_DID(OCTEON_DID_FPA,
+                                                              pool)));
+    if (address) {
+
+/*
+ * 32 bit FPA pointers only
+ */
+        /*
+         * We only use 32 bit pointers at this time
+         */
+/*XXX mips64 issue */
+        return ((void *) MIPS_PHYS_TO_KSEG0(address & 0xffffffff));
+    }
+    return (NULL);
+}
+
+static inline uint64_t octeon_fpa_alloc_phys (u_int pool)
+{
+
+    return (oct_read64(OCTEON_ADDR_DID(OCTEON_ADDR_FULL_DID(OCTEON_DID_FPA,
+                                                            pool))));
+}
+
+#endif /* ___OCTEON_FPA__H___ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_ipd.c svn/mips/sys/mips/octeon1/dev/rgmii/octeon_ipd.c
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_ipd.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_ipd.c	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,107 @@
+/*------------------------------------------------------------------
+ * octeon_ipd.c      Input Packet Unit
+ *
+ *------------------------------------------------------------------
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+
+#include <mips/octeon1/octeon_pcmap_regs.h>
+#include "octeon_ipd.h"
+
+/*
+ * octeon_ipd_enable
+ *
+ * enable ipd
+ */
+void octeon_ipd_enable (void)
+{
+    octeon_ipd_ctl_status_t octeon_ipd_reg;
+
+    octeon_ipd_reg.word64 = oct_read64(OCTEON_IPD_CTL_STATUS);
+    octeon_ipd_reg.bits.ipd_en = 1;
+    oct_write64(OCTEON_IPD_CTL_STATUS, octeon_ipd_reg.word64);
+}
+
+
+/*
+ * octeon_ipd_disable
+ *
+ * disable ipd
+ */
+void octeon_ipd_disable (void)
+{
+    octeon_ipd_ctl_status_t octeon_ipd_reg;
+
+    octeon_ipd_reg.word64 = oct_read64(OCTEON_IPD_CTL_STATUS);
+    octeon_ipd_reg.bits.ipd_en = 0;
+    oct_write64(OCTEON_IPD_CTL_STATUS, octeon_ipd_reg.word64);
+}
+
+
+/*
+ * octeon_ipd_config
+ *
+ * Configure IPD
+ *
+ * mbuff_size Packets buffer size in 8 byte words
+ * first_mbuff_skip
+ *                   Number of 8 byte words to skip in the first buffer
+ * not_first_mbuff_skip
+ *                   Number of 8 byte words to skip in each following buffer
+ * first_back Must be same as first_mbuff_skip / Cache_Line_size
+ * second_back
+ *                   Must be same as not_first_mbuff_skip / Cache_Line_Size
+ * wqe_fpa_pool
+ *                   FPA pool to get work entries from
+ * cache_mode
+ * back_pres_enable_flag
+ *                   Enable or disable port back pressure
+ */
+void octeon_ipd_config (u_int mbuff_size,
+                        u_int first_mbuff_skip,
+                        u_int not_first_mbuff_skip,
+                        u_int first_back,
+                        u_int second_back,
+                        u_int wqe_fpa_pool,
+                        octeon_ipd_mode_t cache_mode,
+                        u_int back_pres_enable_flag)
+{
+    octeon_ipd_mbuff_first_skip_t first_skip;
+    octeon_ipd_mbuff_not_first_skip_t not_first_skip;
+    octeon_ipd_mbuff_size_t size;
+    octeon_ipd_first_next_ptr_back_t first_back_struct;
+    octeon_ipd_second_next_ptr_back_t second_back_struct;
+    octeon_ipd_wqe_fpa_pool_t wqe_pool;
+    octeon_ipd_ctl_status_t octeon_ipd_ctl_reg;
+
+    first_skip.word64 = 0;
+    first_skip.bits.skip_sz = first_mbuff_skip;
+    oct_write64(OCTEON_IPD_1ST_MBUFF_SKIP, first_skip.word64);
+
+    not_first_skip.word64 = 0;
+    not_first_skip.bits.skip_sz = not_first_mbuff_skip;
+    oct_write64(OCTEON_IPD_NOT_1ST_MBUFF_SKIP, not_first_skip.word64);
+
+    size.word64 = 0;
+    size.bits.mb_size = mbuff_size;
+    oct_write64(OCTEON_IPD_PACKET_MBUFF_SIZE, size.word64);
+
+    first_back_struct.word64 = 0;
+    first_back_struct.bits.back = first_back;
+    oct_write64(OCTEON_IPD_1ST_NEXT_PTR_BACK, first_back_struct.word64);
+
+    second_back_struct.word64 = 0;
+    second_back_struct.bits.back = second_back;
+    oct_write64(OCTEON_IPD_2ND_NEXT_PTR_BACK, second_back_struct.word64);
+
+    wqe_pool.word64 = 0;
+    wqe_pool.bits.wqe_pool = wqe_fpa_pool;
+    oct_write64(OCTEON_IPD_WQE_FPA_QUEUE, wqe_pool.word64);
+
+    octeon_ipd_ctl_reg.word64 = 0;
+    octeon_ipd_ctl_reg.bits.opc_mode = cache_mode;
+    octeon_ipd_ctl_reg.bits.pbp_en = back_pres_enable_flag;
+    oct_write64(OCTEON_IPD_CTL_STATUS, octeon_ipd_ctl_reg.word64);
+}
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_ipd.h svn/mips/sys/mips/octeon1/dev/rgmii/octeon_ipd.h
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_ipd.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_ipd.h	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,164 @@
+/*------------------------------------------------------------------
+ * octeon_ipd.h      Input Packet Unit
+ *
+ *------------------------------------------------------------------
+ */
+
+
+#ifndef ___OCTEON_IPD__H___
+#define ___OCTEON_IPD__H___
+
+
+
+typedef enum {
+   OCTEON_IPD_OPC_MODE_STT = 0LL,   /* All blocks DRAM, not cached in L2 */
+   OCTEON_IPD_OPC_MODE_STF = 1LL,   /* All blocks into  L2 */
+   OCTEON_IPD_OPC_MODE_STF1_STT = 2LL,   /* 1st block L2, rest DRAM */
+   OCTEON_IPD_OPC_MODE_STF2_STT = 3LL    /* 1st, 2nd blocks L2, rest DRAM */
+} octeon_ipd_mode_t;
+
+
+
+
+/*
+ * IPD_CTL_STATUS = IPS'd Control Status Register
+ *  The number of words in a MBUFF used for packet data store.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved	: 58;      /* Reserved */
+        uint64_t pkt_lend       : 1;       /* Pkt Lil-Endian Writes to L2C */
+        uint64_t wqe_lend       : 1;       /* WQE Lik-Endian Writes to L2C */
+        uint64_t pbp_en         : 1;       /* Enable Back-Pressure */
+        octeon_ipd_mode_t opc_mode : 2;       /* Pkt data in Mem/L2-cache ? */
+        uint64_t ipd_en         : 1;       /* Enable IPD */
+    } bits;
+} octeon_ipd_ctl_status_t;
+
+
+/*
+ * IPD_1ST_NEXT_PTR_BACK = IPD First Next Pointer Back Values
+ *
+ * Contains the Back Field for use in creating the Next Pointer Header
+ *    for the First MBUF
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved	: 60;      /* Must be zero */
+        uint64_t back		: 4;       /* Used to find head of buffer from the nxt-hdr-ptr. */
+    } bits;
+} octeon_ipd_first_next_ptr_back_t;
+
+
+/*
+ * IPD_INTERRUPT_ENB = IPD Interrupt Enable Register
+ *
+ * Used to enable the various interrupting conditions of IPD
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved       : 59;      /* Must be zero */
+        uint64_t bp_sub		: 1;       /* BP subtract is illegal val */
+        uint64_t prc_par3       : 1;       /* PBM Bits [127:96] Parity Err */
+        uint64_t prc_par2       : 1;       /* PBM Bits [ 95:64] Parity Err */
+        uint64_t prc_par1       : 1;       /* PBM Bits [ 63:32] Parity Err */
+        uint64_t prc_par0       : 1;       /* PBM Bits [ 31:0 ] Parity Err */
+    } bits;
+} octeon_ipd_int_enb_t;
+
+
+/*
+ * IPD_INTERRUPT_SUM = IPD Interrupt Summary Register
+ *
+ * Set when an interrupt condition occurs, write '1' to clear.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved	: 59;      /* Must be zero */
+        uint64_t bp_sub         : 1;       /* BP subtract is illegal val */
+        uint64_t prc_par3       : 1;       /* PBM Bits [127:96] Parity Err */
+        uint64_t prc_par2       : 1;       /* PBM Bits [ 95:64] Parity Err */
+        uint64_t prc_par1       : 1;       /* PBM Bits [ 63:32] Parity Err */
+        uint64_t prc_par0       : 1;       /* PBM Bits [ 31:0 ] Parity Err */
+    } bits;
+} octeon_ipd_int_sum_t;
+
+
+/**
+ * IPD_1ST_MBUFF_SKIP = IPD First MBUFF Word Skip Size
+ *
+ * The number of words that the IPD will skip when writing the first MBUFF.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved	: 58;      /* Must be zero */
+        uint64_t skip_sz        : 6;       /* 64bit words from the top of */
+        				   /*  1st MBUFF that the IPD will */
+					   /*  store the next-pointer. */
+        				   /*  [0..32]  &&             */
+                                           /*    (skip_sz + 16) <= IPD_PACKET_MBUFF_SIZE[MB_SIZE]. */
+    } bits;
+} octeon_ipd_mbuff_first_skip_t;
+
+
+/*
+ * IPD_PACKET_MBUFF_SIZE = IPD's PACKET MUBUF Size In Words
+ *
+ * The number of words in a MBUFF used for packet data store.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved	: 52;      /* Must be zero */
+        uint64_t mb_size        : 12;      /* 64bit words in a MBUF. */
+        				   /* Must be [32..2048] */
+					   /* Is also the size of the FPA's */
+					   /*   Queue-0 Free-Page */
+    } bits;
+} octeon_ipd_mbuff_size_t;
+
+
+/*
+ * IPD_WQE_FPA_QUEUE = IPD Work-Queue-Entry FPA Page Size
+ *
+ * Which FPA Queue (0-7) to fetch page-pointers from for WQE's
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved	: 61;    /* Must be zero */
+        uint64_t wqe_pool       : 3;     /* FPA Pool to fetch WQE Page-ptrs */
+    } bits;
+} octeon_ipd_wqe_fpa_pool_t;
+
+
+
+
+/* End of Control and Status Register (CSR) definitions */
+
+typedef octeon_ipd_mbuff_first_skip_t octeon_ipd_mbuff_not_first_skip_t;
+typedef octeon_ipd_first_next_ptr_back_t octeon_ipd_second_next_ptr_back_t;
+
+
+/*
+ * Externs
+ */
+extern void octeon_ipd_enable(void);
+extern void octeon_ipd_disable(void);
+extern void octeon_ipd_config(u_int mbuff_size,
+                              u_int first_mbuff_skip,
+                              u_int not_first_mbuff_skip,
+                              u_int first_back,
+                              u_int second_back,
+                              u_int wqe_fpa_pool,
+                              octeon_ipd_mode_t cache_mode,
+                              u_int back_pres_enable_flag);
+
+
+
+#endif   /*  ___OCTEON_IPD__H___ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_pip.h svn/mips/sys/mips/octeon1/dev/rgmii/octeon_pip.h
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_pip.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_pip.h	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,179 @@
+/*
+ * octeon_pip.h		Packet Input Processing Block
+ *
+ */
+
+
+
+#ifndef __OCTEON_PIP_H__
+#define __OCTEON_PIP_H__
+
+/** 
+ * Enumeration representing the amount of packet processing
+ * and validation performed by the input hardware.
+ */
+typedef enum
+{
+    OCTEON_PIP_PORT_CFG_MODE_NONE = 0ull,  /**< Packet input doesn't perform any
+                                            processing of the input packet. */
+    OCTEON_PIP_PORT_CFG_MODE_SKIPL2 = 1ull,/**< Full packet processing is performed
+                                            with pointer starting at the L2
+                                            (ethernet MAC) header. */
+    OCTEON_PIP_PORT_CFG_MODE_SKIPIP = 2ull /**< Input packets are assumed to be IP.
+                                            Results from non IP packets is
+                                            undefined. Pointers reference the
+                                            beginning of the IP header. */
+} octeon_pip_port_parse_mode_t;
+
+
+
+#define OCTEON_PIP_PRT_CFGX(offset)	(0x80011800A0000200ull+((offset)*8))
+#define OCTEON_PIP_PRT_TAGX(offset)	(0x80011800A0000400ull+((offset)*8))
+#define OCTEON_PIP_STAT_INB_PKTS(port)	(0x80011800A0001A00ull+((port) * 32))
+#define OCTEON_PIP_STAT_INB_ERRS(port)	(0x80011800A0001A10ull+((port) * 32))
+
+/*
+ * PIP Global Config
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved2	: 45;	/* Must be zero */
+        uint64_t tag_syn	: 1;	/* Not Include src_crc in TCP..*/
+        uint64_t ip6_udp	: 1;	/* IPv6/UDP checksum is mandatory */
+        uint64_t max_l2		: 1;	/* Largest L2 frame. 0/1 : 1500/1535 */
+        uint64_t reserved1	: 5;	/* Must be zero */
+        uint64_t raw_shf	: 3;	/* PCI RAW Packet shift/pad amount */
+        uint64_t reserved0	: 5;	/* Must be zero */
+        uint64_t nip_shf	: 3;	/* Non-IP shift/pad amount */
+    } bits;
+} octeon_pip_gbl_cfg_t;
+
+
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved4      : 37;      /* Must be zero */
+        uint64_t qos            : 3;       /* Default POW QoS queue */
+        uint64_t qos_wat        : 4;       /* Bitfield to enable QoS watcher */
+                                           /*  look up tables. 4 per port. */
+        uint64_t reserved3      : 1;       /* Must be zero */
+        uint64_t spare          : 1;       /* Must be zero */
+        uint64_t qos_diff       : 1;       /* Use IP diffserv to determine */
+                                           /*     the queue in the POW */
+        uint64_t qos_vlan       : 1;       /* Use the VLAN tag to determine */
+                                           /*     the queue in the POW */
+        uint64_t reserved2      : 3;       /* Must be zero */
+        uint64_t crc_en         : 1;       /* Enable HW checksum */
+        uint64_t reserved1      : 2;       /* Must be zero */
+        octeon_pip_port_parse_mode_t mode  : 2;  /* Raw/Parsed/IP/etc */
+        uint64_t reserved0      : 1;       /* Must be zero */
+        uint64_t skip           : 7;       /* 8 byte words to skip in the */
+                                           /*   beginning of a packet buffer */
+    } bits;
+} octeon_pip_port_cfg_t;
+
+
+
+/*
+ * Packet input to POW interface. How input packets are tagged for
+ * the POW is controlled here.
+ */
+typedef union {
+    uint64_t word64;
+    struct {        
+        uint64_t reserved                : 24;      /**< Reserved */
+        uint64_t grptagbase              : 4;       /**< Offset to use when computing group from tag bits
+                                                         when GRPTAG is set. Only applies to IP packets.
+                                                         (PASS2 only) */
+        uint64_t grptagmask              : 4;       /**< Which bits of the tag to exclude when computing
+                                                         group when GRPTAG is set. Only applies to IP packets.
+                                                         (PASS2 only) */
+        uint64_t grptag                  : 1;       /**< When set, use the lower bit of the tag to compute
+                                                         the group in the work queue entry
+                                                         GRP = WQE[TAG[3:0]] & ~GRPTAGMASK + GRPTAGBASE.
+                                                         Only applies to IP packets. (PASS2 only) */
+        uint64_t spare                   : 1;       /**< Spare bit
+                                                         (PASS2 only) */
+        uint64_t tag_mode     : 2;       /**< Which tag algorithm to use
+                                                         0 = always use tuple tag algorithm
+                                                         1 = always use mask tag algorithm
+                                                         2 = if packet is IP, use tuple else use mask
+                                                         3 = tuple XOR mask
+                                                         (PASS2 only) */
+        uint64_t inc_vs                  : 2;       /**< determines the VLAN ID (VID) to be included in
+                                                         tuple tag when VLAN stacking is detected
+                                                         0 = do not include VID in tuple tag generation
+                                                         1 = include VID (VLAN0) in hash
+                                                         2 = include VID (VLAN1) in hash
+                                                         3 = include VID ([VLAN0,VLAN1]) in hash
+                                                         (PASS2 only) */
+        uint64_t inc_vlan                : 1;       /**< when set, the VLAN ID is included in tuple tag
+                                                         when VLAN stacking is not detected
+                                                         0 = do not include VID in tuple tag generation
+                                                         1 = include VID in hash
+                                                         (PASS2 only) */
+        uint64_t inc_prt_flag            : 1;       /**< sets whether the port is included in tuple tag */
+        uint64_t ip6_dprt_flag           : 1;       /**< sets whether the TCP/UDP dst port is
+                                                         included in tuple tag for IPv6 packets */
+        uint64_t ip4_dprt_flag           : 1;       /**< sets whether the TCP/UDP dst port is
+                                                         included in tuple tag for IPv4 */
+        uint64_t ip6_sprt_flag           : 1;       /**< sets whether the TCP/UDP src port is
+                                                 	included in tuple tag for IPv6 packets */
+        uint64_t ip4_sprt_flag           : 1;       /**< sets whether the TCP/UDP src port is
+                                                         included in tuple tag for IPv4 */
+        uint64_t ip6_nxth_flag           : 1;       /**< sets whether ipv6 includes next header in tuple
+                                                         tag hash */
+        uint64_t ip4_pctl_flag           : 1;       /**< sets whether ipv4 includes protocol in tuple
+                                                         tag hash */
+        uint64_t ip6_dst_flag            : 1;       /**< sets whether ipv6 includes dst address in tuple
+                                                         tag hash */
+        uint64_t ip4_dst_flag            : 1;       /**< sets whether ipv4 includes dst address in tuple
+                                                         tag hash */
+        uint64_t ip6_src_flag            : 1;       /**< sets whether ipv6 includes src address in tuple
+                                                         tag hash */
+        uint64_t ip4_src_flag            : 1;       /**< sets whether ipv4 includes src address in tuple
+                                                         tag hash */
+        uint64_t tcp6_tag_type           : 2;       /**< sets the tag_type of a TCP packet (IPv6)
+                                                         0 = ordered tags
+                                                         1 = atomic tags
+                                                         2 = Null tags */
+        uint64_t tcp4_tag_type           : 2;       /**< sets the tag_type of a TCP packet (IPv4)
+                                                         0 = ordered tags
+                                                         1 = atomic tags
+                                                         2 = Null tags */
+        uint64_t ip6_tag_type            : 2;       /**< sets whether IPv6 packet tag type
+                                                         0 = ordered tags
+                                                         1 = atomic tags
+                                                         2 = Null tags */
+        uint64_t ip4_tag_type            : 2;       /**< sets whether IPv4 packet tag type
+                                                         0 = ordered tags
+                                                         1 = atomic tags
+                                                         2 = Null tags */
+        uint64_t non_tag_type            : 2;       /**< sets whether non-IP packet tag type
+                                                         0 = ordered tags
+                                                         1 = atomic tags
+                                                         2 = Null tags */
+        uint64_t grp                    : 4;    /* POW group for input pkts */
+    } bits;
+} octeon_pip_port_tag_cfg_t;
+
+
+/** 
+ * Configure an ethernet input port
+ *  
+ * @param port_num Port number to configure
+ * @param port_cfg Port hardware configuration
+ * @param port_tag_cfg
+ *                 Port POW tagging configuration
+ */
+static inline void octeon_pip_config_port(u_int port_num,
+                                          octeon_pip_port_cfg_t port_cfg,
+                                          octeon_pip_port_tag_cfg_t port_tag_cfg)
+{
+    oct_write64(OCTEON_PIP_PRT_CFGX(port_num), port_cfg.word64);
+    oct_write64(OCTEON_PIP_PRT_TAGX(port_num), port_tag_cfg.word64);
+}
+
+
+#endif /*  __OCTEON_PIP_H__ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_pko.c svn/mips/sys/mips/octeon1/dev/rgmii/octeon_pko.c
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_pko.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_pko.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,337 @@
+/*------------------------------------------------------------------
+ * octeon_pko.c      Packet Output Unit
+ *
+ *------------------------------------------------------------------
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <vm/vm.h>
+#include <vm/pmap.h>
+
+#include <mips/octeon1/octeon_pcmap_regs.h>
+#include "octeon_fau.h"
+#include "octeon_fpa.h"
+#include "octeon_pko.h"
+
+
+/*
+ *
+ */
+static void octeon_pko_clear_port_counts (u_int port)
+{
+    u_int port_num;
+    octeon_pko_read_idx_t octeon_pko_idx;
+
+    octeon_pko_idx.word64 = 0;
+    octeon_pko_idx.bits.idx = port;
+    octeon_pko_idx.bits.inc = 0;
+    oct_write64(OCTEON_PKO_REG_READ_IDX, octeon_pko_idx.word64);
+
+    port_num = port;
+    oct_write64(OCTEON_PKO_MEM_COUNT0, port_num);
+    port_num = port;
+    oct_write64(OCTEON_PKO_MEM_COUNT1, port_num);
+}
+
+/*
+ * octeon_pko_init
+ *
+ */
+void octeon_pko_init (void)
+{
+    u_int queue, port;
+    octeon_pko_read_idx_t octeon_pko_idx;
+    octeon_pko_queue_cfg_t octeon_pko_queue_cfg;
+
+    for (port = 0; port < OCTEON_PKO_PORTS_MAX; port++) {
+        octeon_pko_clear_port_counts(port);
+    }
+
+    octeon_pko_idx.word64 = 0;
+    octeon_pko_idx.bits.idx = 0;
+    octeon_pko_idx.bits.inc = 1;
+    oct_write64(OCTEON_PKO_REG_READ_IDX, octeon_pko_idx.word64);
+    for (queue = 0; queue < OCTEON_PKO_QUEUES_MAX; queue++) {
+
+        octeon_pko_queue_cfg.word64 = 0;
+        octeon_pko_queue_cfg.bits.queue = queue;
+        octeon_pko_queue_cfg.bits.port =  OCTEON_PKO_PORT_ILLEGAL;
+        octeon_pko_queue_cfg.bits.buf_ptr = 0;
+        oct_write64(OCTEON_PKO_MEM_QUEUE_PTRS, octeon_pko_queue_cfg.word64);
+    }
+}
+
+
+/*
+ * octeon_pko_enable
+ *
+ * enable pko
+ */
+void octeon_pko_enable (void)
+{
+
+    /*
+     * PKO enable
+     */
+    oct_write64(OCTEON_PKO_REG_FLAGS, 3);    /*  octeon_pko_enable() */
+}
+
+
+/*
+ * octeon_pko_disable
+ *
+ * disable pko
+ */
+void octeon_pko_disable (void)
+{
+
+    /*
+     * PKO disable
+     */
+    oct_write64(OCTEON_PKO_REG_FLAGS, 0);    /*  pko_disable() */
+}
+
+/*
+ * octeon_pko_config_cmdbuf_global_defaults
+ *
+ */
+void octeon_pko_config_cmdbuf_global_defaults (u_int cmdbuf_pool,
+                                               u_int cmdbuf_pool_elem_size )
+{
+    octeon_pko_pool_cfg_t octeon_pko_pool_config;
+
+    octeon_pko_pool_config.word64 = 0;
+    octeon_pko_pool_config.bits.pool = cmdbuf_pool;
+    octeon_pko_pool_config.bits.size = cmdbuf_pool_elem_size;
+    oct_write64(OCTEON_PKO_CMD_BUF, octeon_pko_pool_config.word64);
+}
+
+/*
+ * octeon_pko_config_rgmx_ports
+ *
+ * Configure rgmx pko.  Always enables 4 + 4 ports
+ */
+void octeon_pko_config_rgmx_ports (void)
+{
+    octeon_pko_reg_gmx_port_mode_t octeon_pko_gmx_mode;
+
+    octeon_pko_gmx_mode.word64 = 0;
+    octeon_pko_gmx_mode.bits.mode0 = 2;	/* 16 >> 2 == 4 ports */
+    octeon_pko_gmx_mode.bits.mode1 = 2;	/* 16 >> 2 == 4 ports */
+    oct_write64(OCTEON_PKO_GMX_PORT_MODE, octeon_pko_gmx_mode.word64);
+}
+
+
+/*
+ * octeon_pko_config
+ *
+ * Configure PKO
+ *
+ */
+void octeon_pko_config (void)
+{
+}
+
+/*
+ * octeon_pko_get_port_status
+ *
+ * Get the status counters for a PKO port.
+ *
+ * port_num Port number to get statistics for.
+ * clear    Set to 1 to clear the counters after they are read
+ * status   Where to put the results.
+ */
+void octeon_pko_get_port_status (u_int port, u_int clear,
+                                 octeon_pko_port_status_t *status)
+{
+    octeon_word_t packet_num;
+    octeon_pko_read_idx_t octeon_pko_idx;
+
+    packet_num.word64 = 0;
+
+    octeon_pko_idx.word64 = 0;
+    octeon_pko_idx.bits.idx = port;
+    octeon_pko_idx.bits.inc = 0;
+    oct_write64(OCTEON_PKO_REG_READ_IDX, octeon_pko_idx.word64);
+
+    packet_num.word64 = oct_read64(OCTEON_PKO_MEM_COUNT0);
+    status->packets = packet_num.bits.word32lo;
+
+    status->octets = oct_read64(OCTEON_PKO_MEM_COUNT1);
+    status->doorbell = oct_read64(OCTEON_PKO_MEM_DEBUG9);
+    status->doorbell = (status->doorbell >> 8) & 0xfffff;
+    if (clear) {
+        octeon_pko_clear_port_counts(port);
+    }
+}
+
+static void octeon_pko_doorbell_data_dump(uint64_t port);
+
+static void octeon_pko_doorbell_data_dump (uint64_t port)
+{
+    octeon_pko_port_status_t status;
+
+    octeon_pko_get_port_status(port, 0, &status);
+    printf("\n Port #%lld  Pkts %ld   Bytes %lld  DoorBell %lld",
+	(unsigned long long)port, status.packets,
+	(unsigned long long)status.octets,
+	(unsigned long long)status.doorbell);
+}
+
+/*
+ * octeon_pko_show
+ *
+ * Show the OCTEON_PKO status & configs
+ */
+void octeon_pko_show (u_int start_port, u_int end_port)
+{
+    u_int queue, queue_max, gmx_int0_ports, gmx_int1_ports;
+    u_int port;
+    uint64_t val64;
+    octeon_pko_port_status_t status;
+    octeon_pko_pool_cfg_t octeon_pko_pool_config;
+    octeon_pko_read_idx_t octeon_pko_idx;
+    octeon_pko_queue_mode_t octeon_pko_queue_mode;
+    octeon_pko_reg_gmx_port_mode_t octeon_pko_gmx_mode;
+    octeon_pko_crc_ports_enable_t octeon_pko_crc_ports;
+    octeon_pko_queue_cfg_t octeon_pko_queue_cfg;
+
+    printf("\n\nPKO Status:");
+    val64 = oct_read64(OCTEON_PKO_REG_FLAGS);
+    if ((val64 & 0x3) != 0x3) {
+        printf("  Disabled");
+        return;
+    } else {
+        printf("  Enabled");
+    }
+    octeon_pko_queue_mode.word64 = oct_read64(OCTEON_PKO_QUEUE_MODE);
+    queue_max = (128 >> octeon_pko_queue_mode.bits.mode);
+    octeon_pko_gmx_mode.word64 = oct_read64(OCTEON_PKO_GMX_PORT_MODE);
+    gmx_int0_ports = (16 >> octeon_pko_gmx_mode.bits.mode0);
+    gmx_int1_ports = (16 >> octeon_pko_gmx_mode.bits.mode1);
+    octeon_pko_crc_ports.word64 = oct_read64(OCTEON_PKO_REG_CRC_ENABLE);
+    printf("\n Total Queues: 0..%d  Ports GMX0 %d   GMX1 %d  CRC 0x%X",
+           queue_max - 1, gmx_int0_ports, gmx_int1_ports,
+           octeon_pko_crc_ports.bits.crc_ports_mask);
+
+    octeon_pko_pool_config.word64 = oct_read64(OCTEON_PKO_CMD_BUF);
+    printf("\n  CmdBuf Pool: %d    CmdBuf  Size in Words: %d  Bytes: %d",
+           octeon_pko_pool_config.bits.pool, octeon_pko_pool_config.bits.size,
+           octeon_pko_pool_config.bits.size * 8);
+
+    octeon_pko_idx.word64 = 0;
+    octeon_pko_idx.bits.idx = 0;
+    octeon_pko_idx.bits.inc = 1;
+    oct_write64(OCTEON_PKO_REG_READ_IDX, octeon_pko_idx.word64);
+    for (queue = 0; queue < queue_max; queue++) {
+
+        octeon_pko_queue_cfg.word64 = oct_read64(OCTEON_PKO_MEM_QUEUE_PTRS);
+        if (!octeon_pko_queue_cfg.bits.buf_ptr) continue;
+        printf("\n  Port # %d   Queue %3d   [%d]  BufPtr: 0x%llX Mask: %X%s",
+               octeon_pko_queue_cfg.bits.port, octeon_pko_queue_cfg.bits.queue,
+               octeon_pko_queue_cfg.bits.index,
+               (unsigned long long)octeon_pko_queue_cfg.bits.buf_ptr,
+	       octeon_pko_queue_cfg.bits.qos_mask,
+               (octeon_pko_queue_cfg.bits.tail)? "  Last":"");
+    }
+    printf("\n");
+
+    for (port = start_port; port < (end_port + 1); port++) {
+
+        octeon_pko_get_port_status(port, 0, &status);
+        octeon_pko_doorbell_data_dump(port);
+
+    }
+}
+
+
+
+
+/*
+ * octeon_pko_config_port
+ *
+ * Configure a output port and the associated queues for use.
+ *
+ */
+octeon_pko_status_t octeon_pko_config_port (u_int port,
+                                            u_int base_queue,
+                                            u_int num_queues,
+                                            const u_int priority[],
+                                            u_int pko_output_cmdbuf_fpa_pool,
+                                            octeon_pko_sw_queue_info_t sw_queues[])
+{
+    octeon_pko_status_t	result_code;
+    u_int		queue;
+    octeon_pko_queue_cfg_t	qconfig;
+
+    if ((port >= OCTEON_PKO_PORTS_MAX) && (port != OCTEON_PKO_PORT_ILLEGAL)) {
+        printf("\n%% Error: octeon_pko_config_port: Invalid port %u", port);
+        return (OCTEON_PKO_INVALID_PORT);
+    }
+
+    if ((base_queue + num_queues) > OCTEON_PKO_QUEUES_MAX) {
+        printf("\n%% Error: octeon_pko_config_port: Invalid queue range");
+        return (OCTEON_PKO_INVALID_QUEUE);
+    }
+
+    result_code = OCTEON_PKO_SUCCESS;
+
+    for (queue = 0; queue < num_queues; queue++) {
+        uint64_t  buf_ptr = 0;
+
+        qconfig.word64          = 0;
+        qconfig.bits.tail       = (queue == (num_queues - 1)) ? 1 : 0;
+        qconfig.bits.index      = queue;
+        qconfig.bits.port       = port;
+        qconfig.bits.queue      = base_queue + queue;
+
+        /* Convert the priority into an enable bit field. */
+        /* Try to space the bits out evenly so the pkts don't get grouped up */
+        switch ((int)priority[queue]) {
+	    case 0: qconfig.bits.qos_mask = 0x00; break;
+            case 1: qconfig.bits.qos_mask = 0x01; break;
+            case 2: qconfig.bits.qos_mask = 0x11; break;
+            case 3: qconfig.bits.qos_mask = 0x49; break;
+            case 4: qconfig.bits.qos_mask = 0x55; break;
+            case 5: qconfig.bits.qos_mask = 0x57; break;
+            case 6: qconfig.bits.qos_mask = 0x77; break;
+            case 7: qconfig.bits.qos_mask = 0x7f; break;
+            case 8: qconfig.bits.qos_mask = 0xff; break;
+            default:
+                printf("\n%% Error: octeon_pko_config_port Invalid priority %llu",
+                       (unsigned long long)priority[queue]);
+                qconfig.bits.qos_mask = 0xff;
+                result_code = OCTEON_PKO_INVALID_PRIORITY;
+                break;
+        }
+        if (port != OCTEON_PKO_PORT_ILLEGAL) {
+
+            buf_ptr = octeon_fpa_alloc_phys(pko_output_cmdbuf_fpa_pool);
+            if (!buf_ptr) {
+                printf("\n%% Error: octeon_pko_config_port: Unable to allocate");
+                return (OCTEON_PKO_NO_MEMORY);
+            }
+
+            sw_queues[queue].xmit_command_state = (buf_ptr << OCTEON_PKO_INDEX_BITS);
+            octeon_spinlock_init(&(sw_queues[queue].lock));
+
+//#define DEBUG_TX
+
+#ifdef DEBUG_TX
+            printf(" PKO: port %u pool: %u  base+queue %u %u %u  buf_ptr: 0x%llX\n",
+                   port,
+                   pko_output_cmdbuf_fpa_pool,
+                   base_queue, queue, base_queue+queue,
+                   buf_ptr);
+
+#endif
+            qconfig.bits.buf_ptr = buf_ptr;
+            oct_write64(OCTEON_PKO_MEM_QUEUE_PTRS, qconfig.word64);
+
+        }
+    }
+
+    return (result_code);
+}
+
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_pko.h svn/mips/sys/mips/octeon1/dev/rgmii/octeon_pko.h
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_pko.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_pko.h	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,292 @@
+/*------------------------------------------------------------------
+ * octeon_pko.h      Packet Output Block
+ *
+ *------------------------------------------------------------------
+ */
+
+
+#ifndef ___OCTEON_PKO__H___
+#define ___OCTEON_PKO__H___
+
+
+
+/*
+ * PKO Command Buffer Register.
+ * Specify Pool-# and Size of each entry in Pool. For Output Cmd Buffers.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t unused_mbz		: 41;   /* Must be zero */
+        uint64_t pool                   : 3;    /* FPA Pool to use */
+        uint64_t unused_mbz2              : 7;    /* Must be zero */
+        uint64_t size                   : 13;   /* Size of the pool blocks */
+    } bits;
+} octeon_pko_pool_cfg_t;
+
+
+/*
+ * PKO GMX Mode Register
+ * Specify the # of GMX1 ports and GMX0 ports
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t unused_mbz	: 58;      /* MBZ */
+        uint64_t mode1          : 3;       /* # GMX1 ports; */
+					   /*  16 >> MODE1, 0 <= MODE1 <=4 */
+        uint64_t mode0          : 3;       /* # GMX0 ports; */
+					   /*  16 >> MODE0, 0 <= MODE0 <=4 */
+    } bits;
+} octeon_pko_reg_gmx_port_mode_t;
+
+
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t unused_mbz	: 62;      /* MBZ */
+        uint64_t mode           : 2;       /* Queues Mode */
+    } bits;
+} octeon_pko_queue_mode_t;
+
+
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t unused_mbz	: 32;      /* MBZ */
+        uint64_t crc_ports_mask : 32;      /* CRC Ports Enable mask */
+    } bits;
+} octeon_pko_crc_ports_enable_t;
+
+
+
+#define OCTEON_PKO_QUEUES_MAX	128
+#define OCTEON_PKO_PORTS_MAX	36
+#define OCTEON_PKO_PORT_ILLEGAL	63
+
+/* Defines how the PKO command buffer FAU register is used */
+
+#define OCTEON_PKO_INDEX_BITS     12
+#define OCTEON_PKO_INDEX_MASK     ((1ull << OCTEON_PKO_INDEX_BITS) - 1)
+
+
+
+typedef enum {
+    OCTEON_PKO_SUCCESS,
+    OCTEON_PKO_INVALID_PORT,
+    OCTEON_PKO_INVALID_QUEUE,
+    OCTEON_PKO_INVALID_PRIORITY,
+    OCTEON_PKO_NO_MEMORY
+} octeon_pko_status_t;
+
+
+typedef struct {
+    long	packets;
+    uint64_t    octets;
+    uint64_t	doorbell;
+} octeon_pko_port_status_t;
+
+
+typedef union {
+    uint64_t                word64;
+    struct {
+	octeon_mips_space_t mem_space  : 2;    /* Octeon IO_SEG */
+        uint64_t	unused_mbz    :13;    /* Must be zero */
+        uint64_t        is_io       : 1;    /* Must be one */
+        uint64_t        did         : 8;    /* device-ID on non-coherent bus*/
+        uint64_t        unused_mbz2   : 4;    /* Must be zero */
+        uint64_t        unused_mbz3   :18;    /* Must be zero */
+        uint64_t        port	    : 6;    /* output port */
+        uint64_t        queue       : 9;    /* output queue to send */
+        uint64_t        unused_mbz4   : 3;    /* Must be zero */
+   } bits;
+} octeon_pko_doorbell_address_t;
+
+/*
+ * Structure of the first packet output command word.
+ */
+typedef union {
+    uint64_t                word64;
+    struct {
+        octeon_fau_op_size_t  size1       : 2; /* The size of reg1 operation */
+					/* - could be 8, 16, 32, or 64 bits */
+        octeon_fau_op_size_t  size0       : 2; /* The size of the reg0 operation  */
+					/* - could be 8, 16, 32, or 64 bits */
+        uint64_t	subone1     : 1; /* Subtract 1, else sub pkt size */
+        uint64_t	reg1        :11; /* The register, subtract will be */
+					 /*       done if reg1 is non-zero */
+        uint64_t	subone0     : 1; /* Subtract 1, else sub pkt size */
+        uint64_t	reg0        :11; /* The register, subtract will be */
+					 /*       done if reg0 is non-zero */
+        uint64_t	unused      : 2; /* Must be zero */
+        uint64_t	wqp         : 1; /* If rsp, then word3 contains a */
+				         /*     ptr to a work queue entry */
+        uint64_t	rsp         : 1; /* HW will  respond when done */
+        uint64_t	gather      : 1; /* If set, the supplied pkt_ptr is */
+					 /*    a ptr to a list of pkt_ptr's */
+        uint64_t	ipoffp1     : 7; /* Off to IP hdr.  For HW checksum */
+        uint64_t	ignore_i    : 1; /* Ignore  I bit in all pointers */
+        uint64_t	dontfree    : 1; /* Don't free buffs containing pkt */
+        uint64_t	segs        : 6; /* Number of segs. If gather set, */
+					 /*        also gather list length */
+        uint64_t	total_bytes :16; /* Includes L2, w/o trailing CRC */
+    } bits;
+} octeon_pko_command_word0_t;
+
+
+typedef union {
+    void*           ptr;
+    uint64_t        word64;
+    struct {
+        uint64_t    i    : 1; /* Invert the "free" pick of the overall pkt. */
+        		      /* For inbound pkts, HW always sets this to 0 */
+        uint64_t    back : 4; /* Amount to back up to get to buffer start */
+        		      /* in cache lines. This is mostly less than 1 */
+			      /* complete cache line; so the value is zero */
+        uint64_t    pool : 3; /* FPA pool that the buffer belongs to */
+        uint64_t    size :16; /* segment size (bytes) pointed at by addr */
+        uint64_t    addr :40; /* Ptr to 1st data byte. NOT buffer */
+    } bits;
+} octeon_pko_packet_ptr_t;
+
+
+/*
+ * Definition of the hardware structure used to configure an
+ * output queue.
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t unused_mbz	: 3;   /* Must be zero */
+        uint64_t qos_mask	: 8;   /* Control Mask priority */
+				       /*      across 8 QOS levels */
+        uint64_t buf_ptr	: 36;  /* Command buffer pointer, */
+				       /*          8 byte-aligned */
+        uint64_t tail		: 1;   /* Set if this queue is the tail */
+				       /*       of the port queue array */
+        uint64_t index		: 3;   /* Index (distance from head) in */
+				       /*          the port queue array */
+        uint64_t port		: 6;   /* Port ID for this queue  mapping */
+        uint64_t queue		: 7;   /* Hardware queue number */
+    } bits;
+} octeon_pko_queue_cfg_t;
+
+
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t unused_mbz	: 48;
+        uint64_t inc		: 8;
+        uint64_t idx		: 8;
+    } bits;
+} octeon_pko_read_idx_t;
+
+
+typedef struct octeon_pko_sw_queue_info_t_
+{
+    uint64_t xmit_command_state;
+    octeon_spinlock_t lock;
+    uint32_t pad[29];
+} octeon_pko_sw_queue_info_t;
+
+
+
+#define OCTEON_DID_PKT		10ULL
+#define OCTEON_DID_PKT_SEND	OCTEON_ADDR_FULL_DID(OCTEON_DID_PKT,2ULL)
+
+
+/*
+ * Ring the packet output doorbell. This tells the packet
+ * output hardware that "len" command words have been added
+ * to its pending list.  This command includes the required
+ * SYNCW before the doorbell ring.
+ *
+ * @param port   Port the packet is for
+ * @param queue  Queue the packet is for
+ * @param len    Length of the command in 64 bit words
+ */
+extern void octeon_pko_doorbell_data(u_int port);
+
+//#define CORE_0_ONLY 1
+
+static inline void octeon_pko_ring_doorbell (u_int port, u_int queue,
+                                             u_int len)
+{
+   octeon_pko_doorbell_address_t ptr;
+
+   ptr.word64          = 0;
+   ptr.bits.mem_space  = OCTEON_IO_SEG;
+   ptr.bits.did        = OCTEON_DID_PKT_SEND;
+   ptr.bits.is_io      = 1;
+   ptr.bits.port       = port;
+   ptr.bits.queue      = queue;
+   OCTEON_SYNCWS;
+   oct_write64(ptr.word64, len);
+}
+
+
+
+#define OCTEON_PKO_QUEUES_PER_PORT_INTERFACE0	1
+#define OCTEON_PKO_QUEUES_PER_PORT_INTERFACE1	1
+#define OCTEON_PKO_QUEUES_PER_PORT_PCI		1
+
+/*
+ * octeon_pko_get_base_queue
+ *
+ * For a given port number, return the base pko output queue
+ * for the port.
+ */
+static inline u_int octeon_pko_get_base_queue (u_int port)
+{
+    if (port < 16) {
+        return (port * OCTEON_PKO_QUEUES_PER_PORT_INTERFACE0);
+    }
+    if (port < 32) {
+        return (16 * OCTEON_PKO_QUEUES_PER_PORT_INTERFACE0 +
+                (port - 16) * OCTEON_PKO_QUEUES_PER_PORT_INTERFACE1);
+    }
+    return (16 * OCTEON_PKO_QUEUES_PER_PORT_INTERFACE0 +
+            16 * OCTEON_PKO_QUEUES_PER_PORT_INTERFACE1 +
+            (port - 32) * OCTEON_PKO_QUEUES_PER_PORT_PCI);
+}
+
+
+/*
+ * For a given port number, return the number of pko output queues.
+ *
+ * @param port   Port number
+ * @return Number of output queues
+ */
+static inline u_int octeon_pko_get_num_queues(u_int port)
+{
+    if (port < 16) {
+        return (OCTEON_PKO_QUEUES_PER_PORT_INTERFACE0);
+    } else if (port<32) {
+        return (OCTEON_PKO_QUEUES_PER_PORT_INTERFACE1);
+    }
+
+    return (OCTEON_PKO_QUEUES_PER_PORT_PCI);
+}
+
+
+
+/*
+ * Externs
+ */
+extern void octeon_pko_init(void);
+extern void octeon_pko_enable(void);
+extern void octeon_pko_disable(void);
+extern void octeon_pko_show(u_int start_port, u_int end_port);
+extern void octeon_pko_config(void);
+extern void octeon_pko_config_cmdbuf_global_defaults(u_int cmdbuf_pool, u_int elem_size);
+extern void octeon_pko_config_rgmx_ports(void);
+extern void octeon_pko_get_port_status(u_int, u_int, octeon_pko_port_status_t *status);
+extern octeon_pko_status_t octeon_pko_config_port(u_int port,
+                                                  u_int base_queue,
+                                                  u_int num_queues,
+                                                  const u_int priority[],
+                                                  u_int pko_output_cmdbuf_fpa_pool,
+						  octeon_pko_sw_queue_info_t sw_queues[]);
+
+
+#endif   /*  ___OCTEON_PKO__H___ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_rgmx.c svn/mips/sys/mips/octeon1/dev/rgmii/octeon_rgmx.c
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_rgmx.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_rgmx.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,2222 @@
+/*
+ * octeon_rgmx.c     RGMII  Ethernet Interfaces on Octeon
+ *
+ */
+
+
+/*
+ * Driver for the Reduced Gigabit Media Independent Interface (RGMII)
+ * present on the Cavium Networks' Octeon chip.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/octeon1/dev/rgmii/octeon_rgmx.c 195412 2009-07-06 18:15:57Z imp $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/sysctl.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/power.h>
+#include <sys/smp.h>
+#include <sys/time.h>
+#include <sys/timetc.h>
+#include <sys/malloc.h>
+#include <sys/kthread.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/mbuf.h>
+#include <sys/taskqueue.h>
+#include <vm/vm.h>
+#include <vm/pmap.h>
+
+#include <net/ethernet.h>
+#include <net/if.h>
+#include <net/if_dl.h>
+#include <net/if_mib.h>
+#include <net/if_media.h>
+#include <net/if_types.h>
+
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include <net/bpf.h>
+
+#include <machine/clock.h>
+#include <machine/locore.h>
+#include <machine/md_var.h>
+
+#include <mips/octeon1/octeon_pcmap_regs.h>
+
+#include "octeon_fau.h"
+#include "octeon_fpa.h"
+#include "octeon_ipd.h"
+#include "octeon_pko.h"
+#include "octeon_pip.h"
+#include "octeon_rgmx.h"
+
+
+/* The "battleship" boards have 8 ports */
+#define OCTEON_RGMX_NUM_PORTS_MAX	   8
+#define NUM_TX_PACKETS			  80
+#define NUM_RX_PACKETS			 300
+#define MAX_RX_BUFS			(NUM_RX_PACKETS) * (OCTEON_RGMX_NUM_PORTS_MAX)
+#define MAX_TX_BUFS			(NUM_TX_PACKETS)
+#define OCTEON_RGMX_DEV_NAME		"rgmx"
+#define OCTEON_RGMX_MIN_PORT		   0
+#define OCTEON_RGMX_MAX_PORT		  19
+#define OCTEON_RGMX_OQUEUE_PER_PORT	   8
+
+
+#define OCTEON_RGMX_SCHEDULED_ISRS	1     /*  Use Scheduled ISRs from kernel tasks */
+
+
+#ifndef POW_MAX_LOOP
+#define POW_MAX_LOOP 0x800
+#endif
+
+
+/*
+ * CIU related stuff for enabling POW interrupts
+ */
+#define OCTEON_RGMX_CIU_INTX	CIU_INT_0
+#define OCTEON_RGMX_CIU_ENX	CIU_EN_0
+
+MALLOC_DEFINE(M_RGMII_WQE, "rgmii_wqe", "FPA pool for WQEs");
+
+/* Driver data */
+
+struct rgmx_softc_dev {
+	device_t		sc_dev;	/* Device ID */
+    	uint64_t		link_status;
+    	struct ifnet            *ifp;
+        int                     sc_unit;
+
+    	u_int			port;
+	u_int			idx;
+        u_char                  ieee[6];
+
+        char const * typestr;   /* printable name of the interface.  */
+        u_short txb_size;       /* size of TX buffer, in bytes  */
+
+        /* Transmission buffer management.  */
+        u_short txb_free;       /* free bytes in TX buffer  */
+        u_char txb_count;       /* number of packets in TX buffer  */
+        u_char txb_sched;       /* number of scheduled packets  */
+
+    	/* Media information.  */
+    	struct ifmedia media;   /* used by if_media.  */
+        u_short mbitmap;        /* bitmap for supported media; see bit2media */
+        int defmedia;           /* default media  */
+    	struct ifqueue tx_pending_queue;    /* Queue of mbuf given to PKO currently */
+    	octeon_pko_sw_queue_info_t	*outq_ptr;
+
+	struct mtx	mtx;
+};
+
+
+/*
+ * Device methods
+ */
+static int rgmii_probe(device_t);
+static void rgmii_identify(driver_t *, device_t);
+static int rgmii_attach(device_t);
+
+
+
+/*
+ * Octeon specific routines
+ */
+static int octeon_has_4ports(void);
+static void octeon_config_rgmii_port(u_int port);
+static void octeon_rgmx_config_pip(u_int port);
+static void octeon_line_status_loop(void *);
+static void octeon_rx_loop(void *);
+static void octeon_config_hw_units_post_ports(void);
+static void octeon_config_hw_units_pre_ports(void);
+static void octeon_config_hw_units_port(struct rgmx_softc_dev *sc, u_int port);
+static struct rgmx_softc_dev *get_rgmx_softc(u_int port);
+static void octeon_rgmx_start_port(u_int port);
+static u_int octeon_rgmx_stop_port(u_int port);
+static u_int get_rgmx_port_ordinal(u_int port);
+static void octeon_rgmx_set_mac(u_int port);
+static void octeon_rgmx_init_sc(struct rgmx_softc_dev *sc, device_t dev, u_int port, u_int num_devices);
+static int octeon_rgmx_init_ifnet(struct rgmx_softc_dev *sc);
+static void octeon_rgmx_mark_ready(struct rgmx_softc_dev *sc);
+static void octeon_rgmx_stop(struct rgmx_softc_dev *sc);
+static void octeon_rgmx_config_speed(u_int port, u_int);
+#ifdef DEBUG_RGMX_DUMP
+static void octeon_dump_rgmx_stats(u_int port);
+static void octeon_dump_pow_stats(void);
+#endif
+#ifdef __not_used__
+static void rgmx_timer_periodic(void);
+#endif
+static void octeon_rgmx_enable_RED_all(int, int);
+
+#ifdef OCTEON_RGMX_SCHEDULED_ISRS
+static void octeon_rgmx_isr_link(void *context, int pending);
+static void octeon_rgmx_isr_rxtx(void *context, int pending);
+static int octeon_rgmx_intr_fast(void *arg);
+#else
+static int octeon_rgmx_intr(void *arg);
+#endif
+
+
+
+
+
+
+
+/* Standard driver entry points.  These can be static.  */
+static void  octeon_rgmx_init	      (void *);
+//static driver_intr_t    rgmx_intr;
+static int   octeon_rgmx_ioctl        (struct ifnet *, u_long, caddr_t);
+static void  octeon_rgmx_output_start (struct ifnet *);
+static void  octeon_rgmx_output_start_locked (struct ifnet *);
+#if 0
+static void  octeon_rgmx_watchdog     (struct ifnet *);
+#endif
+static int   octeon_rgmx_medchange    (struct ifnet *);
+static void  octeon_rgmx_medstat      (struct ifnet *, struct ifmediareq *);
+
+
+/* Mapping between media bitmap (in fe_softc.mbitmap) and ifm_media.  */
+static int const bit2media [] = {
+                        IFM_ETHER | IFM_AUTO,
+                        IFM_ETHER | IFM_MANUAL,
+                        IFM_ETHER | IFM_10_T,
+                        IFM_ETHER | IFM_10_2,
+                        IFM_ETHER | IFM_10_5,
+                        IFM_ETHER | IFM_10_FL,
+                        IFM_ETHER | IFM_10_T,
+        /* More can be added here... */
+};
+
+/* Mapping between media bitmap (in fe_softc.mbitmap) and ifm_media.  */
+#define MB_HA   0x0001
+#define MB_HM   0x0002
+#define MB_HT   0x0004
+#define MB_H2   0x0008
+#define MB_H5   0x0010
+#define MB_HF   0x0020
+#define MB_FT   0x0040
+
+#define LEBLEN          (ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN)
+
+
+static struct rgmx_softc_dev *rgmx_scdev_array[OCTEON_RGMX_NUM_PORTS_MAX] = {NULL};
+static u_int port_array[OCTEON_RGMX_NUM_PORTS_MAX] = {0};
+static u_int num_devices = 0;
+static octeon_pko_sw_queue_info_t output_queues_array[OCTEON_RGMX_NUM_PORTS_MAX * OCTEON_RGMX_OQUEUE_PER_PORT];
+static struct resource		*irq_res;       /* Interrupt resource. */
+static void		*int_handler_tag;
+
+
+#ifdef	OCTEON_RGMX_SCHEDULED_ISRS
+
+struct task	link_isr_task;
+struct task	rxtx_isr_task;
+struct taskqueue *tq;		/* private task queue */
+
+#endif
+
+
+
+static u_int get_rgmx_port_ordinal (u_int port)
+{
+    u_int idx;
+
+    for (idx = 0; idx < OCTEON_RGMX_NUM_PORTS_MAX; idx++) {
+        if (port_array[idx] == port) {
+            return (idx);
+        }
+    }
+    return (-1);
+}
+
+static struct rgmx_softc_dev *get_rgmx_softc (u_int port)
+{
+    u_int idx;
+
+    idx = get_rgmx_port_ordinal(port);
+    if (idx != -1) {
+            return (rgmx_scdev_array[idx]);
+    }
+    return (NULL);
+}
+
+
+
+static void octeon_rgmx_init_sc (struct rgmx_softc_dev *sc, device_t dev, u_int port, u_int num_devices)
+{
+    int ii;
+
+    	/* No software-controllable media selection.  */
+    	sc->mbitmap = MB_HM;
+        sc->defmedia = MB_HM;
+
+        sc->sc_dev = dev;
+        sc->port = port;
+        sc->idx = num_devices;
+        sc->link_status = 0;
+        sc->sc_unit = num_devices;
+        sc->mbitmap = MB_HT;
+        sc->defmedia = MB_HT;
+        sc->tx_pending_queue.ifq_maxlen = NUM_TX_PACKETS;
+        sc->tx_pending_queue.ifq_head = sc->tx_pending_queue.ifq_tail = NULL;
+        sc->tx_pending_queue.ifq_len = sc->tx_pending_queue.ifq_drops = 0;
+        mtx_init(&sc->tx_pending_queue.ifq_mtx, "if->sc->txpq.ifqmtx", NULL, MTX_DEF);
+
+        sc->outq_ptr = &(output_queues_array[num_devices * OCTEON_RGMX_OQUEUE_PER_PORT]);
+
+        for (ii = 0; ii < 6; ii++) {
+            sc->ieee[ii] = octeon_mac_addr[ii];
+        }
+        sc->ieee[5] += get_rgmx_port_ordinal(port);
+
+}
+
+static int octeon_rgmx_init_ifnet (struct rgmx_softc_dev *sc)
+{
+        struct ifnet *ifp;
+
+    	ifp = sc->ifp = if_alloc(IFT_ETHER);
+        if (NULL == ifp) {
+            device_printf(sc->sc_dev, "can not ifalloc for rgmx port\n");
+            return (ENOSPC);
+        }
+        /*
+         * Initialize ifnet structure
+         */
+        ifp->if_softc    = sc;
+        if_initname(sc->ifp, device_get_name(sc->sc_dev), device_get_unit(sc->sc_dev));
+        ifp->if_start    = octeon_rgmx_output_start;
+        ifp->if_ioctl    = octeon_rgmx_ioctl;
+        /* Watchdog interface is now deprecated.
+        ifp->if_watchdog = octeon_rgmx_watchdog;
+        */
+	ifp->if_hwassist = CSUM_TCP | CSUM_UDP;
+	ifp->if_capabilities = IFCAP_HWCSUM;
+	ifp->if_capenable = ifp->if_capabilities;
+        ifp->if_init     = octeon_rgmx_init;
+        ifp->if_linkmib  = NULL;  // &sc->mibdata;
+        ifp->if_linkmiblen = 0;   // sizeof (sc->mibdata);
+        /*
+         * Set fixed interface flags.
+         */
+        ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
+//                        | IFF_NEEDSGIANT;
+        if (ifp->if_snd.ifq_maxlen == 0)
+                ifp->if_snd.ifq_maxlen = ifqmaxlen;
+
+        ifmedia_init(&sc->media, 0, octeon_rgmx_medchange, octeon_rgmx_medstat);
+        ifmedia_add(&sc->media, bit2media[0], 0, NULL);
+        ifmedia_set(&sc->media, bit2media[0]);
+
+        ether_ifattach(sc->ifp, sc->ieee);
+        /* Print additional info when attached.  */
+        device_printf(sc->sc_dev, "type %s, full duplex\n", sc->typestr);
+
+        return (0);
+}
+
+
+
+/* Driver methods */
+
+
+/* ------------------------------------------------------------------- *
+ *                      rgmii_identify()                               *
+ * ------------------------------------------------------------------- */
+static void rgmii_identify (driver_t *drv, device_t parent)
+{
+	BUS_ADD_CHILD(parent, 0, "rgmii", 0);
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      rgmii_probe()                                  *
+ * ------------------------------------------------------------------- */
+static int rgmii_probe (device_t dev)
+{
+	if (device_get_unit(dev) != 0)
+		panic("can't probe/attach more rgmii devices\n");
+
+        device_set_desc(dev, "Octeon RGMII");
+	return (0);
+}
+
+
+
+/* ------------------------------------------------------------------- *
+ *                      rgmii_attach()                                 *
+ * ------------------------------------------------------------------- */
+static int rgmii_attach (device_t dev)
+{
+    	struct rgmx_softc_dev	*sc;
+	device_t		 child;
+	int			 iface, port, nr_ports, error;
+        void			 *softc;
+        int			irq_rid;
+
+        octeon_config_hw_units_pre_ports();
+
+	/* Count interfaces and ports*/
+	octeon_gmxx_inf_mode_t iface_mode;
+	iface_mode.word64 = 0;
+
+	for (iface = 0; iface < 2; iface++) {
+		iface_mode.word64 = oct_read64(OCTEON_RGMX_INF_MODE(iface));
+
+		/* interface is either disabled or SPI */
+		if (!iface_mode.bits.en)
+			continue;
+		if (octeon_get_chipid()  == OCTEON_CN3020_CHIP) {
+			nr_ports = 2;
+		} else {
+			nr_ports = (octeon_has_4ports()) ? 4 : 3;
+			if (iface_mode.bits.type ) {
+				if (octeon_get_chipid() == OCTEON_CN5020_CHIP) 
+					nr_ports = 2;
+				else
+					continue;
+			}
+		}
+
+		oct_write64(OCTEON_RGMX_TX_PRTS(iface), nr_ports);
+
+		for (port = iface * 16; port < iface * 16 + nr_ports; port++) {
+
+                        child = device_add_child(dev, OCTEON_RGMX_DEV_NAME, num_devices);
+                        if (child == NULL)
+                            	panic("%s: device_add_child() failed\n", __func__);
+
+                        softc = malloc(sizeof(struct rgmx_softc_dev), M_DEVBUF, M_NOWAIT | M_ZERO);
+                        if (!softc) {
+                            	panic("%s malloc failed for softc\n", __func__);
+                        }
+                        device_set_softc(child, softc);
+                        device_set_desc(child, "Octeon RGMII");
+                        sc = device_get_softc(child);
+                        if (!sc) {
+                            	printf(" No sc\n");
+                                num_devices++;
+                                continue;
+                        }
+                        port_array[num_devices] = port;
+                        rgmx_scdev_array[num_devices] = sc;
+                        RGMX_LOCK_INIT(sc, device_get_nameunit(child));
+                        octeon_rgmx_init_sc(sc, child, port, num_devices);
+                        octeon_config_hw_units_port(sc, port);
+                        if (octeon_rgmx_init_ifnet(sc)) {
+                            	device_printf(dev, "  ifinit failed for rgmx port %u\n", port);
+                                return (ENOSPC);
+                        }
+/*
+ * Don't call octeon_rgmx_mark_ready()
+ * ifnet will call it indirectly via  octeon_rgmx_init()
+ *
+ *                         octeon_rgmx_mark_ready(sc);
+ */
+                        num_devices++;
+                }
+	}
+
+        octeon_config_hw_units_post_ports();
+
+	irq_rid = 0;
+	irq_res = bus_alloc_resource(dev, SYS_RES_IRQ, &irq_rid, 0, 0, 1, RF_SHAREABLE | RF_ACTIVE);
+	if (irq_res == NULL) {
+		device_printf(dev, "failed to allocate irq\n");
+		return (ENXIO);
+	}
+
+
+#ifdef	OCTEON_RGMX_SCHEDULED_ISRS
+        /*
+         * Single task queues for all child devices. Since POW gives us a unified
+         * interrupt based on POW groups, not based on PORTs.
+         */
+	TASK_INIT(&rxtx_isr_task, 0, octeon_rgmx_isr_rxtx, NULL);
+	TASK_INIT(&link_isr_task, 0, octeon_rgmx_isr_link, NULL);
+	tq = taskqueue_create_fast("octeon_rgmx_taskq", M_NOWAIT,
+                                   taskqueue_thread_enqueue, &tq);
+	taskqueue_start_threads(&tq, 1, PI_NET, "%s taskq", device_get_nameunit(dev));
+
+	error = bus_setup_intr(dev, irq_res, INTR_TYPE_NET, octeon_rgmx_intr_fast, NULL,
+                               NULL, &int_handler_tag);
+	if (error != 0) {
+		device_printf(dev, "bus_setup_intr returned %d\n", error);
+		taskqueue_free(tq);
+                tq = NULL;
+		return (error);
+	}
+
+#else  /* OCTEON_RGMX_SCHEDULED_ISRS */
+
+	error = bus_setup_intr(dev, irq_res, INTR_TYPE_NET, octeon_rgmx_intr, NULL,
+                               NULL, &int_handler_tag);
+
+        if (error != 0) {
+		device_printf(dev, "bus_setup_intr returned %d\n", error);
+                tq = NULL;
+		return (error);
+	}
+
+#endif  /* OCTEON_RGMX_SCHEDULED_ISRS */
+
+	return (bus_generic_attach(dev));
+}
+
+
+
+
+#define OCTEON_MAX_RGMX_PORT_NUMS 32
+
+
+
+#define	OCTEON_POW_RX_GROUP_NUM		0
+#define	OCTEON_POW_TX_GROUP_NUM		1	/* If using TX WQE from PKO */
+
+#define	OCTEON_POW_RX_GROUP_MASK	(1 << OCTEON_POW_RX_GROUP_NUM)
+#define	OCTEON_POW_TX_GROUP_MASK	(1 << OCTEON_POW_TX_GROUP_NUM)
+#define OCTEON_POW_ALL_OUR_GROUPS_MASK  (OCTEON_POW_RX_GROUP_MASK | OCTEON_POW_RX_GROUP_MASK)
+#define OCTEON_POW_ALL_GROUPS_MASK	0xffff
+#define	OCTEON_POW_WORKQUEUE_INT       (0x8001670000000200ull)
+#define	OCTEON_POW_WORKQUEUE_INT_PC    (0x8001670000000208ull)
+#define	OCTEON_POW_WORKQUEUE_INT_THRESHOLD(group_num)  ((0x8001670000000080ull+((group_num)*0x8)))
+#define OCTEON_RGMX_POW_NOS_CNT		(0x8001670000000228ull)
+#define OCTEON_POW_INT_CNTR(core)	(0x8001670000000100ull+((core)*0x8))
+#define OCTEON_POW_INPT_Q_ALL_QOS	(0x8001670000000388ull)
+#define OCTEON_POW_INPT_QOS_GRP(grp)	(0x8001670000000340ull + ((grp) * 0x8))
+
+
+
+
+#define NUM_RX_PACKETS_CTL		(MAX_RX_BUFS + 3000)
+#define NUM_TX_PACKETS_CTL		40
+
+#define FPA_NOPOOL			0
+
+#define OCTEON_FPA_RX_PACKET_POOL		0
+#define OCTEON_FPA_RX_PACKET_POOL_WORDS		208		/* 2048 bytes */
+#define OCTEON_FPA_RX_PACKET_POOL_ELEM_SIZE	(OCTEON_FPA_RX_PACKET_POOL_WORDS)
+#define OCTEON_FPA_RX_PACKET_POOL_ELEMENTS	(MAX_RX_BUFS)
+#define OCTEON_RX_MAX_SIZE			(OCTEON_FPA_RX_PACKET_POOL_WORDS * sizeof(uint64_t))
+
+#define OCTEON_FPA_WQE_RX_POOL			1
+#define OCTEON_FPA_WQE_RX_WORDS			(OCTEON_CACHE_LINE_SIZE/8)
+#define OCTEON_FPA_WQE_RX_POOL_ELEM_SIZE	(OCTEON_FPA_WQE_RX_WORDS)
+#define OCTEON_FPA_WQE_RX_POOL_ELEMENTS      	(NUM_RX_PACKETS_CTL)
+
+#define OCTEON_FPA_TX_PACKET_POOL		2
+#define OCTEON_FPA_TX_PACKET_POOL_WORDS		208		/* 2048 bytes */
+#define OCTEON_FPA_TX_PACKET_POOL_ELEM_SIZE	(OCTEON_FPA_TX_PACKET_POOL_WORDS)
+#define OCTEON_FPA_TX_PACKET_POOL_ELEMENTS	(MAX_TX_BUFS)
+#define OCTEON_TX_MAX_SIZE			(OCTEON_FPA_TX_PACKET_POOL_WORDS * sizeof(uint64_t))
+
+#define OCTEON_FPA_TX_CMDBUF_POOL		3
+#define OCTEON_FPA_TX_CMD_SIZE			2
+#define OCTEON_FPA_TX_CMD_NUM			300
+#define	OCTEON_FPA_TX_CMDBUF_POOL_WORDS		(OCTEON_FPA_TX_CMD_SIZE * OCTEON_FPA_TX_CMD_NUM)
+#define OCTEON_FPA_TX_CMDBUF_POOL_ELEM_SIZE	(OCTEON_FPA_TX_CMDBUF_POOL_WORDS +1)
+#define OCTEON_FPA_TX_CMDBUF_POOL_ELEMENTS	(30 * OCTEON_RGMX_NUM_PORTS_MAX)
+
+#define FIRST_PARTICLE_SKIP		0
+#define NOT_FIRST_PARTICLE_SKIP		0
+
+#define ENABLE_BACK_PRESSURE		0
+#define RGMX_MAX_PAK_RECEIVE		5000000
+
+
+#ifdef	OCTEON_RGMX_SCHEDULED_ISRS
+
+
+static void octeon_rgmx_isr_link (void *context, int pending)
+{
+    	octeon_line_status_loop(NULL);
+}
+
+
+static void octeon_rgmx_isr_rxtx (void *context, int pending)
+{
+    	octeon_rx_loop(NULL);
+}
+
+
+/*********************************************************************
+ *
+ *  Fast Interrupt Service routine
+ *
+ *********************************************************************/
+
+//#define OCTEON_RGMX_POW_TIME_THR_INTS 1
+
+
+static int octeon_rgmx_intr_fast(void *arg)
+{
+
+    	int handled_flag = 0;
+        uint64_t ciu_summary;
+
+        ciu_summary = ciu_get_int_summary(CIU_THIS_CORE, OCTEON_RGMX_CIU_INTX,
+                                          OCTEON_RGMX_CIU_ENX);
+
+        if (ciu_summary & CIU_GENTIMER_BITS_ENABLE(CIU_GENTIMER_NUM_1)) {
+
+            	/*
+                 * Timer Interrupt for link status checks
+                 * Acknowledging it will mask it for this cycle.
+                 */
+            	ciu_clear_int_summary(CIU_THIS_CORE, OCTEON_RGMX_CIU_INTX,
+                                      OCTEON_RGMX_CIU_ENX,
+                                      CIU_GENTIMER_BITS_ENABLE(CIU_GENTIMER_NUM_1));
+
+		taskqueue_enqueue(taskqueue_fast, &link_isr_task);
+                handled_flag = 1;
+        }
+
+        if (ciu_summary & OCTEON_POW_ALL_GROUPS_MASK) {
+#ifndef OCTEON_RGMX_POW_TIME_THR_INTS
+		/*
+                 * When using POW IQ/DSQ size based interrupts, then
+                 *    ack the interrupts right away.  So they don't interrupt
+                 *    until the queue size goes to 0 again.
+                 */
+                oct_write64(OCTEON_POW_WORKQUEUE_INT,
+                            0x10001 << OCTEON_POW_RX_GROUP_NUM);
+
+#else
+            	/*
+                 * We use POW thresholds based interrupt signalled on timer
+                 *   countdown. Acknowledge it now so that it doesn't
+                 *   interrupt us until next countdown to zero.
+                 */
+                oct_write64(OCTEON_POW_WORKQUEUE_INT,
+                            0x1 << OCTEON_POW_RX_GROUP_NUM);
+#endif
+
+            	taskqueue_enqueue(tq, &rxtx_isr_task);
+                handled_flag = 1;
+        }
+
+	return ((handled_flag) ? FILTER_HANDLED : FILTER_STRAY);
+}
+
+
+#else   /*  ! OCTEON_RGMX_SCHEDULED_ISRS */
+
+
+/*
+ * octeon_rgmx_intr
+ *
+ * This is direct inline isr. Will do all its work and heavy-lifting in interrupt context.
+ *
+ * Also note that the  RGMX_LOCK/UNLOCK code will have to checked/added, since that is new and
+ * was not supported with this model.
+ */
+static int octeon_rgmx_intr (void *arg)
+{
+    	int flag = 0;
+        uint64_t ciu_summary;
+
+        /*
+         * read ciu to see if any bits are pow
+         */
+        while (1) {
+            	ciu_summary = ciu_get_int_summary(CIU_THIS_CORE, OCTEON_RGMX_CIU_INTX,
+                                                  OCTEON_RGMX_CIU_ENX);
+
+                if ((ciu_summary & (OCTEON_POW_ALL_GROUPS_MASK | CIU_GENTIMER_BITS_ENABLE(CIU_GENTIMER_NUM_1))) == 0) {
+                    	break;
+                }
+
+                flag = 1;
+
+                if (ciu_summary & OCTEON_POW_ALL_GROUPS_MASK) {
+                        octeon_rx_loop(NULL);
+                        /*
+                         * Acknowledge the interrupt after processing queues.
+                         */
+                    	oct_write64(OCTEON_POW_WORKQUEUE_INT, OCTEON_POW_RX_GROUP_MASK);
+                }
+                if (ciu_summary & CIU_GENTIMER_BITS_ENABLE(CIU_GENTIMER_NUM_1)) {
+                    	octeon_line_status_loop(NULL);
+                    	ciu_clear_int_summary(CIU_THIS_CORE, OCTEON_RGMX_CIU_INTX,
+                                              OCTEON_RGMX_CIU_ENX,
+                                              CIU_GENTIMER_BITS_ENABLE(CIU_GENTIMER_NUM_1));
+                }
+        }
+
+	return ((flag) ? FILTER_HANDLED : FILTER_STRAY);
+}
+
+
+#endif   /*  OCTEON_RGMX_SCHEDULED_ISRS */
+
+
+
+static struct mbuf *octeon_rgmx_build_new_rx_mbuf(struct ifnet *ifp, void *data_start, u_int totlen);
+
+static struct mbuf *octeon_rgmx_build_new_rx_mbuf (struct ifnet *ifp, void *data_start, u_int totlen)
+{
+	struct mbuf *m, *m0, *newm;
+	caddr_t newdata;
+	int len;
+
+	if (totlen <= ETHER_HDR_LEN || totlen > LEBLEN - ETHER_CRC_LEN) {
+#ifdef LEDEBUG
+		if_printf(ifp, "invalid packet size %d; dropping\n", totlen);
+#endif
+		return (NULL);
+	}
+
+	MGETHDR(m0, M_DONTWAIT, MT_DATA);
+	if (m0 == NULL) {
+		return (NULL);
+        }
+
+        /* Initialize packet header info.  */
+	m0->m_pkthdr.rcvif = ifp;
+	m0->m_pkthdr.len = totlen;
+        m0->m_pkthdr.csum_flags = CSUM_IP_CHECKED | CSUM_IP_VALID | CSUM_DATA_VALID | CSUM_PSEUDO_HDR;
+        m0->m_pkthdr.csum_data = 0xffff;
+	len = MHLEN;
+	m = m0;
+
+	while (totlen > 0) {
+		if (totlen >= MINCLSIZE) {
+			MCLGET(m, M_DONTWAIT);
+			if ((m->m_flags & M_EXT) == 0)
+				goto octeon_rgmx_build_new_rx_mbuf_bad;
+			len = MCLBYTES;
+		}
+
+		if (m == m0) {
+			newdata = (caddr_t)ALIGN(m->m_data + ETHER_HDR_LEN) - ETHER_HDR_LEN;
+			len -= newdata - m->m_data;
+			m->m_data = newdata;
+		}
+
+                /* Set the length of this mbuf.  */
+		m->m_len = len = min(totlen, len);
+                bcopy(data_start, mtod(m, caddr_t), len);
+		data_start = (void *) (((u_long) (data_start)) + len);
+
+		totlen -= len;
+		if (totlen > 0) {
+			MGET(newm, M_DONTWAIT, MT_DATA);
+			if (newm == 0)
+				goto octeon_rgmx_build_new_rx_mbuf_bad;
+			len = MLEN;
+			m = m->m_next = newm;
+		}
+	}
+
+	return (m0);
+
+octeon_rgmx_build_new_rx_mbuf_bad:
+
+	m_freem(m0);
+	return (NULL);
+}
+
+
+
+//#define DEBUG_RX 1
+
+static void  octeon_rgmx_rx_process_work (octeon_wqe_t *work, u_int port)
+{
+    	struct rgmx_softc_dev  *sc;
+        struct ifnet *ifp;
+        u_int	len;
+        void	*data_start, *new_data_start;
+        struct mbuf *mbuf;
+
+//#define DEBUG_RX_PKT_DUMP 1
+#ifdef DEBUG_RX_PKT_DUMP
+        int i; u_char *dc;
+#endif
+        
+        data_start = octeon_pow_pktptr_to_kbuffer(work->packet_ptr);
+
+//#define DEBUG_RX2
+#ifdef DEBUG_RX2
+        printf(" WQE 0x%X: port:%u  ", work, port);
+        printf(" Grp: %u, %llX  Tag: %u  %llX  type: %u 0x%llx\n",
+               work->grp, work->grp, work->tag, work->tag, work->tag_type, work->tag_type);
+#endif
+
+        if ((port >= OCTEON_RGMX_MIN_PORT) || (port <= OCTEON_RGMX_MAX_PORT)) {
+
+            	sc = get_rgmx_softc(port);
+
+                if (!sc || !sc->ifp) {
+
+                    	printf(" octeon_rgmx_rx_process_work No sc or sc->ifp -  port:%u", port);
+                } else {
+
+                    	ifp = sc->ifp;
+
+                    	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+
+                                if (!work->word2.bits.rcv_error) {
+
+                                    len = work->len;
+
+                                    /*
+                                     * We cannot pass the same FPA phys-buffer higher up.
+                                     * User space will not be able to use this phys-buffer.
+                                     *
+                                     * Start building a mbuf packet here using  data_start & len.
+                                     */
+
+                                    new_data_start = data_start;
+                                    if (!work->word2.bits.not_IP) {
+                                    	new_data_start = (void *) (((unsigned long) (new_data_start)) + 14);
+                                        /* mark it as checksum checked */
+                                    } else {
+                                    	new_data_start = (void *) (((unsigned long) (new_data_start)) + 8);
+                                    }
+
+#ifdef DEBUG_RX_PKT_DUMP
+                                    dc = new_data_start; printf("In:\n");
+                                    for (i = 0; i < len; i++) { if (!(i % 16)) printf ("\n"); printf(" %02X", dc[i]); }
+#endif
+                                
+                                    mbuf = octeon_rgmx_build_new_rx_mbuf(ifp, new_data_start, len);
+                                    if (mbuf) {
+//                                    	printf(" Passing pkt to ifp: pkt_len: %u len: %u ", mbuf->m_pkthdr.len, mbuf->m_len);
+#ifdef DEBUG_RX_PKT_DUMP
+
+                                        dc = mtod(mbuf, u_char *); printf("\n"); printf("In: ");
+                                        for (i = 0; i < mbuf->m_len; i++) { if (!(i % 16)) printf ("\n"); printf(" %02X", dc[i]); }
+
+#endif
+
+                                    	/* Feed the packet to upper layer.  */
+                                    	(*ifp->if_input)(ifp, mbuf);
+                                        ifp->if_ipackets++;
+
+                                    } else {  /* mbuf error */
+                                    	if_printf(ifp, "mbuf rx construct error\n");
+                                        printf(" mbuf rx construct error\n");
+                                        ifp->if_ierrors++;
+                                    }	      /*  mbuf error */
+
+                                } else {      /*  rcv_error */
+                                    ifp->if_ierrors++;
+                                }            /*  rcv_error */
+
+                        } /* IFF_DRV_RUNNING */
+
+                }   /*  sc && sc->ifp */
+
+        } else {    /* port number */
+            	printf(" rgmx_rx:%u bad port\n", port);
+        }
+
+        octeon_fpa_free(data_start, OCTEON_FPA_RX_PACKET_POOL, 0);
+        octeon_fpa_free((void *)work, OCTEON_FPA_WQE_RX_POOL, 0);
+}
+
+
+
+
+/* ------------------------------------------------------------------- *
+ *                      octeon_rx_loop()                               *
+ * ------------------------------------------------------------------- */
+
+
+//#define OCTEON_VISUAL_RGMX 1
+#ifdef OCTEON_VISUAL_RGMX
+static int where0 = 0;
+static int where1 = 0;
+#endif
+
+static void octeon_rx_loop (void *unused)
+{
+	u_int		core_id;
+	uint64_t 	prev_grp_mask;
+	u_int		pak_count;
+	octeon_wqe_t 	*work;
+
+	core_id = octeon_get_core_num();
+	pak_count = 0;
+
+	/* Only allow work for our group */
+	prev_grp_mask = oct_read64(OCTEON_POW_CORE_GROUP_MASK(core_id));
+	oct_write64(OCTEON_POW_CORE_GROUP_MASK(core_id), OCTEON_POW_ALL_GROUPS_MASK);
+
+
+#ifdef OCTEON_VISUAL_RGMX
+        octeon_led_run_wheel(&where0, 3);
+#endif
+	while(1) {
+
+                if (pak_count++ > RGMX_MAX_PAK_RECEIVE) {
+                    break;
+                }
+
+        	work = octeon_pow_work_request_sync(OCTEON_POW_WAIT);
+
+		if (work == NULL) {
+                    	/*
+                         * No more incoming packets. We can take a break now.
+                         */
+                    	break;
+		}
+
+#ifdef OCTEON_VISUAL_RGMX
+                octeon_led_run_wheel(&where1, 4);
+#endif
+                octeon_rgmx_rx_process_work(work, work->ipprt);
+
+	}
+
+	oct_write64(OCTEON_POW_CORE_GROUP_MASK(core_id), prev_grp_mask);
+}
+
+
+static void *octeon_rgmx_write_mbufs_to_fpa_buff (struct rgmx_softc_dev *sc, struct mbuf *m, u_int len)
+{
+        struct mbuf *mp;
+        void *data_area;
+        u_char *write_offset;
+
+        /*
+         * FIXME
+         *
+         * Compare len with max FPA-tx-packet size. Or else we will possibly corrupt the next pkt.
+         */
+
+
+        /*
+         * Get an FPA buffer from Xmit-packets FPA pool
+         */
+        data_area = octeon_fpa_alloc(OCTEON_FPA_TX_PACKET_POOL);
+        if (!data_area) {
+            	/*
+                 * Fail.  No room. No resources.
+                 */
+            	return (NULL);
+        }
+
+        /*
+         * Transfer the data from mbuf chain to the transmission buffer.
+         */
+        write_offset = data_area;
+        for (mp = m; mp != 0; mp = mp->m_next) {
+            	if (mp->m_len) {
+                    	bcopy(mtod(mp, caddr_t), write_offset, mp->m_len);
+                        write_offset = (u_char *) (((u_long) write_offset) + mp->m_len);
+                }
+        }
+        return (data_area);
+}
+
+
+static u_int octeon_rgmx_pko_xmit_packet (struct rgmx_softc_dev *sc, void *out_buff, u_int len, u_int checksum)
+{
+    octeon_pko_command_word0_t	pko_cmd;
+    octeon_pko_packet_ptr_t	pko_pkt_word;
+    u_long temp;
+    u_short xmit_cmd_index;
+    uint64_t *xmit_cmd_ptr;
+    uint64_t xmit_cmd_state;
+    int queue = 0;		// we should randomize queue # based on core num. Using same
+				// queue 0 for this port, by all cores on is less efficient.
+
+    /*
+     * Prepare the PKO buffer and command word.
+     *   Cmd Buf Word 0
+     *   No FAU
+     *   Set #-segs and #-bytes
+     */
+    pko_cmd.word64 = 0;
+    pko_cmd.bits.segs = 1;
+    pko_cmd.bits.total_bytes = len;
+    if (checksum) {
+        pko_cmd.bits.ipoffp1 = ETHER_HDR_LEN + 1;	/* IPOffP1 is +1 based.  1 means offset 0 */
+    }
+
+    /*
+     * Build the PKO buffer pointer. PKO Cmd Buf Word 1
+     */
+    pko_pkt_word.word64 = 0;
+    pko_pkt_word.bits.addr =  OCTEON_PTR2PHYS(out_buff);
+    pko_pkt_word.bits.pool =  OCTEON_FPA_TX_PACKET_POOL;
+    pko_pkt_word.bits.size =  2048; // dummy. Actual len is above.
+
+#ifdef DEBUG_TX
+    printf(" PKO: 0x%llX  0x%llX ", pko_cmd.word64, pko_pkt_word.word64);
+#endif
+
+    /*
+     * Get the queue command ptr location from the per port per queue, pko info struct.
+     */
+    octeon_spinlock_lock(&(sc->outq_ptr[queue].lock));
+#ifdef DEBUG_TX
+    printf(" xmit: sc->outq_ptr[queue].xmit_command_state: 0x%llX  ", sc->outq_ptr[queue].xmit_command_state);
+#endif
+    xmit_cmd_state = sc->outq_ptr[queue].xmit_command_state;
+    sc->outq_ptr[queue].xmit_command_state = xmit_cmd_state + 2;
+
+    temp = (u_long) (xmit_cmd_state >> OCTEON_PKO_INDEX_BITS);
+#ifdef DEBUG_TX
+    printf(" temp: 0x%X ", temp);
+#endif
+    xmit_cmd_ptr = (uint64_t *) MIPS_PHYS_TO_KSEG0(temp);
+    xmit_cmd_index = xmit_cmd_state & OCTEON_PKO_INDEX_MASK;
+    xmit_cmd_ptr += xmit_cmd_index;
+
+    /*
+     * We end the PKO cmd buffer at odd boundary. Towards the end we will have
+     * 4 or 3 or 2 or 1 or 0 word remaining.  Case of 4, 2, or 0 can never happen.
+     * We only care when we have 3 words remaining. In this case we write our 2 words
+     * for PKO command and 3rd word as chain for next PKO cmd buffer.
+     */
+    xmit_cmd_ptr[0] = pko_cmd.word64;
+
+    if (xmit_cmd_index < (OCTEON_FPA_TX_CMDBUF_POOL_WORDS - 2)) {
+        /*
+         * Plenty of space left. Write our 2nd word and worry the next time.
+         */
+        xmit_cmd_ptr[1] = pko_pkt_word.word64;
+
+    } else {
+        /*
+         * 3 words or less are left. We write our 2nd word now and then put in a chain link
+         * to new PKO cmd buf.
+         */
+        void *pko_cmd_buf = octeon_fpa_alloc(OCTEON_FPA_TX_CMDBUF_POOL);
+        uint64_t phys_cmd_buf;
+
+        if (!pko_cmd_buf) {
+            /*
+             * FPA pool for xmit-buffer-commands is empty.
+             */
+            sc->outq_ptr[queue].xmit_command_state -= 2;
+            octeon_spinlock_unlock(&(sc->outq_ptr[queue].lock));
+            return (0);
+        }
+        phys_cmd_buf = OCTEON_PTR2PHYS(pko_cmd_buf);
+
+        xmit_cmd_ptr[1] = pko_pkt_word.word64;
+        xmit_cmd_ptr[2] = phys_cmd_buf;
+
+        sc->outq_ptr[queue].xmit_command_state = (phys_cmd_buf << OCTEON_PKO_INDEX_BITS);
+    }
+    /*
+     * Unlock queue structures.
+     */
+    octeon_spinlock_unlock(&(sc->outq_ptr[queue].lock));
+
+    /*
+     * 2 words incremented in PKO. Ring the doorbell.
+     */
+#ifdef DEBUG_TX
+    printf(" Ringing doorbell: Port %u  Queue %u  words 2", sc->port, octeon_pko_get_base_queue(sc->port) + queue);
+#endif
+    octeon_pko_ring_doorbell(sc->port, octeon_pko_get_base_queue(sc->port) + queue, 2);
+
+    return (1);
+}
+
+
+static void octeon_rgmx_xmit_mark_buffers_done(struct rgmx_softc_dev *sc, u_int n);
+
+static void octeon_rgmx_xmit_mark_buffers_done (struct rgmx_softc_dev *sc, u_int n)
+{
+        struct mbuf *m;
+        u_int i;
+
+        for (i = 0; i < n; i++) {
+            	/*
+                 * Remove packets in queue. Leaving a lag of 3, to allow for PKO in-flight xmission
+                 */
+            	if (_IF_QLEN(&sc->tx_pending_queue) > 4) {
+                    	IF_DEQUEUE(&sc->tx_pending_queue, m);
+                        if (!m) {
+                                break;		// Queue became empty now. Break out.
+                        }
+                        /*
+                         * Return the mbuf to system.
+                         */
+                        m_freem(m);
+                }
+        }
+        if (!i) {
+            	return;	// Nothing removed from queue.
+        }
+
+        /*
+         * The transmitter is no more active.
+         * Reset output active flag and watchdog timer.
+         */
+        sc->ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+        sc->ifp->if_timer = 0;
+}
+
+
+#define OCTEON_RGMX_FLUSH_N_XMIT_MBUFS_EACH_LOOP	5
+#define OCTEON_RGMX_FLUSH_PENDING_MBUFS_MAX		1000
+
+#ifdef __not_used__
+/*
+ * octeon_rgmx_output_flush
+ *
+ * Drop all packets queued at ifnet layer.
+ */
+static void octeon_rgmx_output_flush (struct ifnet *ifp)
+{
+        struct mbuf *m;
+        u_int max_flush = OCTEON_RGMX_FLUSH_PENDING_MBUFS_MAX;	/* Arbitrarily high number */
+
+        while (max_flush-- && _IF_QLEN(&ifp->if_snd)) {
+                /*
+                 * Get the next mbuf Packet chain to flush.
+                 */
+                IF_DEQUEUE(&ifp->if_snd, m);
+                if (m == NULL) {
+                        /* No more packets to flush */
+                    	break;
+                }
+                _IF_DROP(&ifp->if_snd);
+                m_freem(m);
+                ifp->if_oerrors++;
+        }
+}
+#endif
+
+/*
+ * octeon_rgmx_output_start
+ *
+ * Start output on interface.
+ */
+static void octeon_rgmx_output_start (struct ifnet *ifp)
+{
+    	struct rgmx_softc_dev *sc = ifp->if_softc;
+
+	RGMX_LOCK(sc);
+        octeon_rgmx_output_start_locked(ifp);
+	RGMX_UNLOCK(sc);
+}
+
+
+
+/*
+ * octeon_rgmx_output_start_locked
+ *
+ * Start output on interface.  Assume Driver locked
+ */
+static void octeon_rgmx_output_start_locked (struct ifnet *ifp)
+{
+    	struct rgmx_softc_dev *sc = ifp->if_softc;
+        struct mbuf *m;
+        u_int len, need_l4_checksum;
+        void *out_buff;
+
+	/*
+         * Take out some of the last queued mbuf's from xmit-pending queue
+         */
+        octeon_rgmx_xmit_mark_buffers_done(sc, OCTEON_RGMX_FLUSH_N_XMIT_MBUFS_EACH_LOOP);
+
+        while (1) {
+                /*
+                 * See if there is room to put another packet in the buffer.
+                 * We *could* do better job by peeking the send queue to
+                 * know the length of the next packet.  Current version just
+                 * tests against the worst case (i.e., longest packet).  FIXME.
+                 *
+                 * When adding the packet-peek feature, don't forget adding a
+                 * test on txb_count against QUEUEING_MAX.
+                 * There is a little chance the packet count exceeds
+                 * the limit.  Assume transmission buffer is 8KB (2x8KB
+                 * configuration) and an application sends a bunch of small
+                 * (i.e., minimum packet sized) packets rapidly.  An 8KB
+                 * buffer can hold 130 blocks of 62 bytes long...
+                 */
+
+            	/*
+                 * If unable to send more.
+                 */
+            	if (_IF_QLEN(&sc->tx_pending_queue) >= MAX_TX_BUFS) {
+                    printf(" Xmit not possible. NO room %u", _IF_QLEN(&sc->tx_pending_queue));
+                    goto indicate_active;
+                }
+
+
+                /*
+                 * Get the next mbuf chain for a packet to send.
+                 */
+                IF_DEQUEUE(&ifp->if_snd, m);
+                if (m == NULL) {
+                        /* No more packets to send.  */
+                        goto indicate_inactive;
+                }
+
+                len = m->m_pkthdr.len;
+                /*
+                 * Should never send big packets.  If such a packet is passed,
+                 * it should be a bug of upper layer.  We just ignore it.
+                 * ... Partial (too short) packets, neither.
+                 */
+                if (len < ETHER_HDR_LEN ||
+                    len > ETHER_MAX_LEN - ETHER_CRC_LEN) {
+                    	/*
+                         * Fail.  Bad packet size.  Return the mbuf to system.
+                         */
+                    	if_printf(ifp,
+                                  "got an out-of-spec packet (%u bytes) to send\n", len);
+                        m_freem(m);
+                        goto indicate_active;
+                }
+
+                /*
+                 * Copy the mbuf chain into the transmission buffer.
+                 * txb_* variables are updated as necessary.
+                 */
+                out_buff = octeon_rgmx_write_mbufs_to_fpa_buff(sc, m, len);
+                if (!out_buff) {
+                    	/*
+                         * No FPA physical buf resource.
+                         * Let's requeue it back.  And slow it down for a while.
+                         */
+                    	IF_PREPEND(&ifp->if_snd, m);
+                    	goto indicate_active;
+                }
+
+                need_l4_checksum = (m->m_pkthdr.csum_flags & (CSUM_TCP | CSUM_UDP)) ? 1 : 0;
+
+                /*
+                 * put the mbuf onto pending queue
+                 */
+//#define DEBUG_TX_PKT_DUMP 1
+#ifdef DEBUG_TX_PKT_DUMP
+                int ii;
+                u_char *dc = out_buff;
+
+                printf("\n"); printf("Out: ");
+                for (ii = 0; ii < len; ii++) printf(" %X", dc[ii]); printf("\n");
+#endif
+
+        	IF_ENQUEUE(&sc->tx_pending_queue, m);
+
+                /*
+                 * Pass the mbuf data packet to PKO for xmission.
+                 */
+                octeon_rgmx_pko_xmit_packet(sc, out_buff, len, need_l4_checksum);
+
+                ifp->if_opackets++;
+        }
+
+indicate_inactive:
+        /*
+         * We are using the !OACTIVE flag to indicate to
+         * the outside world that we can accept an
+         * additional packet rather than that the
+         * transmitter is _actually_ active.  Indeed, the
+         * transmitter may be active, but if we haven't
+         * filled all the buffers with data then we still
+         * want to accept more.
+         */
+        ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+        return;
+
+
+indicate_active:
+        /*
+         * The transmitter is active, and there are no room for
+         * more outgoing packets in the transmission buffer.
+         */
+	ifp->if_oerrors++;
+//	sc->mibdata.dot3StatsInternalMacTransmitErrors++;
+        ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+        return;
+}
+
+
+
+
+/* ------------------------------------------------------------------- *
+ *                      octeon_config_hw_units()                       *
+ * ------------------------------------------------------------------- *
+ *
+ * Initialize Octeon hardware components. To get the RGMX going.
+ *
+ */
+static void octeon_config_hw_units_pre_ports (void)
+{
+
+        /* Enable FPA */
+	octeon_enable_fpa();
+
+        /* Enable PKO */
+	octeon_pko_enable();
+
+        /* Init PKO */
+	octeon_pko_init();
+
+
+	/* Fill FPA */
+
+        /*
+         * Input Buffers Pool
+         * Pool 0
+         */
+        octeon_fpa_fill_pool_mem(OCTEON_FPA_RX_PACKET_POOL, OCTEON_FPA_RX_PACKET_POOL_ELEM_SIZE,
+                                 OCTEON_FPA_RX_PACKET_POOL_ELEMENTS);
+
+        /*
+         * WQE Blocks Pool
+         * Pool 1
+         */
+        octeon_fpa_fill_pool_mem(OCTEON_FPA_WQE_RX_POOL, OCTEON_FPA_WQE_RX_POOL_ELEM_SIZE,
+                                 OCTEON_FPA_WQE_RX_POOL_ELEMENTS);
+
+        /*
+         * PKO Command Pool
+         * Pool  3
+         */
+        octeon_fpa_fill_pool_mem(OCTEON_FPA_TX_CMDBUF_POOL, OCTEON_FPA_TX_CMDBUF_POOL_ELEM_SIZE,
+                                 OCTEON_FPA_TX_CMDBUF_POOL_ELEMENTS);
+
+        /*
+         * Output Buffers Pool
+         * Pool 2
+         */
+        octeon_fpa_fill_pool_mem(OCTEON_FPA_TX_PACKET_POOL, OCTEON_FPA_TX_PACKET_POOL_ELEM_SIZE,
+                                 OCTEON_FPA_TX_PACKET_POOL_ELEMENTS);
+
+
+
+        octeon_rgmx_enable_RED_all(OCTEON_FPA_RX_PACKET_POOL_ELEMENTS >> 2, OCTEON_FPA_RX_PACKET_POOL_ELEMENTS >> 3);
+
+	/* Configure IPD */
+	octeon_ipd_config(OCTEON_FPA_RX_PACKET_POOL_WORDS,
+                          FIRST_PARTICLE_SKIP / 8,
+                          NOT_FIRST_PARTICLE_SKIP / 8,
+                          FIRST_PARTICLE_SKIP / 128,
+                          NOT_FIRST_PARTICLE_SKIP / 128,
+                          OCTEON_FPA_WQE_RX_POOL,
+                          OCTEON_IPD_OPC_MODE_STF,
+                          ENABLE_BACK_PRESSURE);
+
+        /*
+         * PKO setup Output Command Buffers
+         */
+        octeon_pko_config_cmdbuf_global_defaults(OCTEON_FPA_TX_CMDBUF_POOL,
+                                                 OCTEON_FPA_TX_CMDBUF_POOL_ELEM_SIZE);
+
+}
+
+
+
+static void octeon_config_hw_units_port (struct rgmx_softc_dev *sc, u_int port)
+{
+	const u_int priorities[8] = {8,8,8,8,8,8,8,8};
+        u_int total_queues, base_queue;
+
+    	octeon_config_rgmii_port(port);
+
+        total_queues = octeon_pko_get_num_queues(port);
+        base_queue = octeon_pko_get_base_queue(port);
+        /* Packet output configures Queue and Ports */
+        octeon_pko_config_port(port, base_queue,
+                               total_queues,
+                               priorities,
+                               OCTEON_FPA_TX_CMDBUF_POOL,
+                               sc->outq_ptr);
+
+        octeon_rgmx_set_mac(port);
+
+        /* Setup Port input tagging */
+        octeon_rgmx_config_pip(port);
+}
+
+
+typedef union
+{
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    rsvd3	: 35;
+        uint64_t    enable	: 1;
+        uint64_t    time_thr	: 4;
+        uint64_t    rsvd2	: 1;
+        uint64_t    ds_thr	: 11;
+        uint64_t    rsvd	: 1;
+        uint64_t    iq_thr	: 11;
+    } bits;
+} octeon_rgmx_pow_int_threshold_t;
+
+typedef union
+{
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    rsvd	: 36;
+        uint64_t    tc_cnt	: 4;
+        uint64_t    ds_cnt	: 12;
+        uint64_t    iq_cnt	: 12;
+    } bits;
+} octeon_rgmx_pow_int_cnt_t;
+
+typedef union
+{
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    rsvd3	: 4;
+        uint64_t    thr_freq	: 28;  // R/O
+        uint64_t    rsvd2	: 4;
+        uint64_t    thr_period	: 20;
+        uint64_t    rsvd	: 8;
+    } bits;
+} octeon_rgmx_pow_int_pc_t;
+
+
+typedef union
+{
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    rsvd	: 52;
+        uint64_t    nos_cnt	: 12;
+    } bits;
+} octeon_rgmx_pow_nos_cnt;
+
+
+
+typedef union
+{
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    rsvd	: 32;
+        uint64_t    inb_pkts	: 32;
+    } bits;
+} octeon_rgmx_pip_inb_pkts;
+
+typedef union
+{
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    rsvd	: 48;
+        uint64_t    inb_errs	: 16;
+    } bits;
+} octeon_rgmx_pip_inb_errs;
+
+
+
+typedef union
+{
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    rsvd	: 32;
+        uint64_t    iq_cnt	: 32;
+    } bits;
+} octeon_pow_inpt_q_all_qos;
+
+
+
+typedef union
+{
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    rsvd	: 32;
+        uint64_t    iq_cnt	: 32;
+    } bits;
+} octeon_pow_inpt_q_grp_qos;
+
+
+static void octeon_config_hw_units_post_ports (void)
+{
+
+    	octeon_rgmx_pow_int_threshold_t thr;
+        octeon_rgmx_pow_int_pc_t intpc;
+                          
+    	thr.word64 = 0;
+        intpc.word64 = 0;
+        intpc.bits.thr_freq = (500 * 1000 * 1000) / (1000 * 16 * 256);
+
+#ifdef OCTEON_RGMX_POW_TIME_THR_INTS
+        thr.bits.enable = 1;
+        thr.bits.time_thr = 0xf;
+        oct_write64(OCTEON_POW_WORKQUEUE_INT_THRESHOLD(OCTEON_POW_RX_GROUP_NUM), thr.word64);
+
+        oct_write64(OCTEON_POW_WORKQUEUE_INT_PC, intpc.word64);
+
+#else
+	thr.bits.ds_thr = thr.bits.iq_thr = 1;  // Only if doing absolute queue-cnt interrupts.
+        oct_write64(OCTEON_POW_WORKQUEUE_INT_THRESHOLD(OCTEON_POW_RX_GROUP_NUM), thr.word64);
+#endif
+
+        ciu_enable_interrupts(OCTEON_CORE_ID, OCTEON_RGMX_CIU_INTX, OCTEON_RGMX_CIU_ENX,
+                              (OCTEON_POW_RX_GROUP_MASK |
+                               CIU_GENTIMER_BITS_ENABLE(CIU_GENTIMER_NUM_1)), CIU_MIPS_IP2);
+
+        ciu_clear_int_summary(CIU_THIS_CORE, OCTEON_RGMX_CIU_INTX,
+                              OCTEON_RGMX_CIU_ENX, CIU_GENTIMER_BITS_ENABLE(CIU_GENTIMER_NUM_1));
+
+        octeon_ciu_start_gtimer(CIU_GENTIMER_NUM_1, OCTEON_GENTIMER_PERIODIC,
+                                OCTEON_GENTIMER_LEN_1SEC);
+        /*
+         * Enable IPD
+         */
+        octeon_ipd_enable();
+}
+
+
+
+
+
+static void octeon_rgmx_config_pip (u_int port)
+{
+    octeon_pip_gbl_cfg_t	pip_config;
+    octeon_pip_port_cfg_t	pip_port_config;
+    octeon_pip_port_tag_cfg_t	pip_tag_config;
+
+    /*
+     * PIP Global config
+     */
+    pip_config.word64 = 0;
+    pip_config.bits.max_l2 = 1;
+    oct_write64(OCTEON_PIP_GBL_CFG, pip_config.word64);
+
+    /*
+     * PIP Port config
+     */
+    pip_port_config.word64 = 0;
+    pip_port_config.bits.mode	= OCTEON_PIP_PORT_CFG_MODE_SKIPL2;
+    pip_port_config.bits.qos	= port & 0x7;
+    pip_port_config.bits.crc_en = 1;
+
+
+    /*
+     * PIP -> POW tags config
+     *
+     * We don't use any pkt input fields for tag hash, except for Port#
+     */
+    pip_tag_config.word64 = 0;
+
+    pip_tag_config.bits.grptag = 0;
+    pip_tag_config.bits.grptagmask = 0xf;
+    pip_tag_config.bits.grptagbase = 1;
+
+    pip_tag_config.bits.ip6_src_flag  = 0;
+    pip_tag_config.bits.ip6_dst_flag  = 0;
+    pip_tag_config.bits.ip6_sprt_flag = 0;
+    pip_tag_config.bits.ip6_dprt_flag = 0;
+    pip_tag_config.bits.ip6_nxth_flag = 0;
+
+    pip_tag_config.bits.ip4_src_flag  = 1;
+    pip_tag_config.bits.ip4_dst_flag  = 1;
+    pip_tag_config.bits.ip4_sprt_flag = 1;
+    pip_tag_config.bits.ip4_dprt_flag = 1;
+    pip_tag_config.bits.ip4_pctl_flag = 1;
+
+    pip_tag_config.bits.tcp6_tag_type = 0;
+    pip_tag_config.bits.tcp4_tag_type = 0;
+    pip_tag_config.bits.ip6_tag_type  = 0;
+    pip_tag_config.bits.ip4_tag_type  = 0;
+    pip_tag_config.bits.inc_prt_flag  = 1;
+    pip_tag_config.bits.non_tag_type  = OCTEON_POW_TAG_TYPE_NULL;
+    pip_tag_config.bits.grp	      = OCTEON_POW_RX_GROUP_NUM;
+
+    octeon_pip_config_port(port, pip_port_config, pip_tag_config);
+
+    oct_write64(OCTEON_POW_CORE_GROUP_MASK(OUR_CORE), OCTEON_POW_ALL_GROUPS_MASK);
+
+}
+
+
+/*
+ * octeon_rgmx_stop_port
+ *
+ */
+static u_int octeon_rgmx_stop_port (u_int port)
+{
+    int interface = INTERFACE(port);
+    int index = INDEX(port);
+    octeon_rgmx_prtx_cfg_t gmx_cfg;
+    u_int last_enabled = 0;
+
+    gmx_cfg.word64 = oct_read64(OCTEON_RGMX_PRTX_CFG(index, interface));
+    last_enabled = (gmx_cfg.bits.en == 1);
+    gmx_cfg.bits.en = 0;
+    oct_write64(OCTEON_RGMX_PRTX_CFG(index, interface), gmx_cfg.word64);
+    return (last_enabled);
+}
+
+static void octeon_rgmx_start_port(u_int port)
+{
+    int interface = INTERFACE(port);
+    int index = INDEX(port);
+    octeon_rgmx_prtx_cfg_t gmx_cfg;
+
+    gmx_cfg.word64 = oct_read64(OCTEON_RGMX_PRTX_CFG(index, interface));
+    gmx_cfg.bits.en = 1;
+    oct_write64(OCTEON_RGMX_PRTX_CFG(index, interface), gmx_cfg.word64);
+}
+
+
+static void octeon_rgmx_stop (struct rgmx_softc_dev *sc)
+{
+    	octeon_rgmx_stop_port(sc->port);
+
+        /* Reset transmitter variables and interface flags.  */
+        sc->ifp->if_drv_flags &= ~(IFF_DRV_OACTIVE | IFF_DRV_RUNNING);
+        sc->ifp->if_timer = 0;
+        sc->txb_count = 0;
+        sc->txb_sched = 0;
+}
+
+
+/* Change the media selection.  */
+static int octeon_rgmx_medchange (struct ifnet *ifp)
+{
+    	struct rgmx_softc_dev *sc = ifp->if_softc;
+
+#ifdef DIAGNOSTIC
+        /* If_media should not pass any request for a media which this
+           interface doesn't support.  */
+        int b;
+
+        for (b = 0; bit2media[b] != 0; b++) {
+                if (bit2media[b] == sc->media.ifm_media) break;
+        }
+        if (((1 << b) & sc->mbitmap) == 0) {
+                if_printf(sc->ifp,
+                    "got an unsupported media request (0x%x)\n",
+                    sc->media.ifm_media);
+                return EINVAL;
+        }
+#endif
+
+        /* We don't actually change media when the interface is down.
+           fe_init() will do the job, instead.  Should we also wait
+           until the transmission buffer being empty?  Changing the
+           media when we are sending a frame will cause two garbages
+           on wires, one on old media and another on new.  FIXME */
+        if (sc->ifp->if_flags & IFF_UP) {
+            	printf(" Media change requested while IF is up\n");
+        } else  {
+            printf(" Media change requested while IF is Down\n");
+        }
+
+        return 0;
+}
+
+
+static void octeon_rgmx_medstat (struct ifnet *ifp, struct ifmediareq *ifm)
+{
+    /*
+     * No support for Media Status callback
+     */
+}
+
+static int octeon_rgmx_ioctl (struct ifnet * ifp, u_long command, caddr_t data)
+{
+    	struct rgmx_softc_dev *sc = ifp->if_softc;
+        struct ifreq *ifr = (struct ifreq *)data;
+    	int error = 0;
+
+        if (!sc) {
+            printf(" octeon_rgmx_ioctl. No sc\n");
+            return (0);
+        }
+        switch (command) {
+
+          	case SIOCSIFFLAGS:
+                    /*
+                     * Switch interface state between "running" and
+                     * "stopped", reflecting the UP flag.
+                     */
+                    if (ifp->if_flags & IFF_UP) {
+
+
+                        /*
+                         * New state is IFF_UP
+                         * Restart or Start now, if driver is not running currently.
+                         */
+                        if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0) {
+                            printf(" SIOCSTIFFLAGS  UP/Not-running\n"); break;
+                            octeon_rgmx_init(sc);
+                        } else {
+                            printf(" SIOCSTIFFLAGS  UP/Running\n"); break;
+                        }
+                    } else {
+                        /*
+                         * New state is IFF_DOWN.
+                         * Stop & shut it down now, if driver is running currently.
+                         */
+                        if ((ifp->if_drv_flags & IFF_DRV_RUNNING) != 0) {
+                            printf(" SIOCSTIFFLAGS  Down/Running\n"); break;
+                            octeon_rgmx_stop(sc);
+                        } else {
+                            printf(" SIOCSTIFFLAGS  Down/Not-Running\n"); break;
+                        }
+                    }
+                    break;
+
+        	case SIOCADDMULTI:
+        	case SIOCDELMULTI:
+                    break;
+
+        	case SIOCSIFMEDIA:
+        	case SIOCGIFMEDIA:
+                    /* Let if_media to handle these commands and to call
+                       us back.  */
+                    error = ifmedia_ioctl(ifp, ifr, &sc->media, command);
+                    break;
+
+		case SIOCSIFCAP:
+                {
+                    int mask;
+
+                    ifp->if_hwassist &= ~CSUM_TSO;
+                    ifp->if_capenable &= ~IFCAP_VLAN_HWTAGGING;
+                    mask = ifr->ifr_reqcap ^ ifp->if_capenable;
+                    if (mask & IFCAP_HWCSUM) {
+			ifp->if_capenable ^= IFCAP_HWCSUM;
+			if (ifp->if_capenable & IFCAP_TXCSUM) {
+                            ifp->if_hwassist |= (CSUM_TCP | CSUM_UDP);
+                        } else {
+                            ifp->if_hwassist &= ~(CSUM_TCP | CSUM_UDP);
+                        }
+                    }
+                }
+		break;
+
+        	default:
+                    error = ether_ioctl(ifp, command, data);
+                    break;
+        }
+
+        return (error);
+}
+
+
+
+
+/*
+ * octeon_rgmx_mark_ready
+ *
+ * Initialize the rgmx driver for this instance
+ * Initialize device.
+ */
+static void octeon_rgmx_mark_ready (struct rgmx_softc_dev *sc)
+{
+
+        /* Enable interrupts.  */
+    	/* For RGMX they are already enabled earlier */
+
+        /* Enable transmitter and receiver.  */
+    	/* For RGMX they are already enabled earlier */
+
+        /* Flush out all HW receive buffers for this interface. */
+    	/* For RGMX, no means to flush an individual port */
+
+        /* Set 'running' flag, because we are now running.   */
+        sc->ifp->if_drv_flags |= IFF_DRV_RUNNING;
+
+        /* Set the HW Address filter. aka program Mac-addr & Multicast filters */
+    	/* For RGMX this was taken care of via set_mac_addr() */
+
+        /* Kick start the output */
+        /* Hopefully PKO is running and will pick up packets via the timer  or receive loop */
+}
+
+
+static void  octeon_rgmx_init (void *xsc)
+{
+
+    /*
+     * Called mostly from ifnet interface  ifp->if_init();
+     * I think we can anchor most of our iniialization here and
+     * not do it in different places  from driver_attach().
+     */
+    /*
+     * For now, we only mark the interface ready
+     */
+    octeon_rgmx_mark_ready((struct rgmx_softc_dev *) xsc);
+}
+
+
+
+static void octeon_rgmx_config_speed (u_int port, u_int report_link)
+{
+    	int index = INDEX(port);
+        int iface = INTERFACE(port);
+        struct rgmx_softc_dev		*sc;
+        octeon_rgmx_rxx_rx_inbnd_t	link_status, old_link_status;
+        octeon_rgmx_prtx_cfg_t		gmx_cfg;
+        uint64_t			val64_tx_clk, val64_tx_slot, val64_tx_burst;
+        u_int				last_enabled;
+
+
+        sc = get_rgmx_softc(port);
+        if (!sc) {
+            printf(" config_speed didn't find sc int:%u port:%u", iface, port);
+            return;
+        }
+
+        /*
+         * Look up interface-port speed params
+         */
+        link_status.word64 = oct_read64(OCTEON_RGMX_RXX_RX_INBND(index, iface));
+
+        /*
+         * Compre to prev known state. If same then nothing to do.
+         */
+        if (link_status.word64 == sc->link_status) {
+            	return;
+        }
+
+        RGMX_LOCK(sc);
+
+        old_link_status.word64 = sc->link_status;
+
+        sc->link_status = link_status.word64;
+
+        last_enabled = octeon_rgmx_stop_port(port);
+
+        gmx_cfg.word64 = oct_read64(OCTEON_RGMX_PRTX_CFG(index, iface));
+
+        /*
+         * Duplex
+         */
+        gmx_cfg.bits.duplex = 1;
+
+        switch (link_status.bits.speed) {
+        case 0:	/* 10Mbps */
+            gmx_cfg.bits.speed = 0;
+            gmx_cfg.bits.slottime = 0;
+            val64_tx_clk = 50; val64_tx_slot = 0x40; val64_tx_burst = 0;
+            break;
+        case 1:	/* 100Mbps */
+            gmx_cfg.bits.speed = 0;
+            gmx_cfg.bits.slottime = 0;
+            val64_tx_clk = 5; val64_tx_slot = 0x40; val64_tx_burst = 0;
+            break;
+
+        case 2:	/* 1Gbps */
+            gmx_cfg.bits.speed = 1;
+            gmx_cfg.bits.slottime = 1;
+            val64_tx_clk = 1; val64_tx_slot = 0x200; val64_tx_burst = 0x2000;
+            break;
+
+        case 3:	/* ?? */
+        default:
+            gmx_cfg.bits.speed = 1;
+            gmx_cfg.bits.slottime = 1;
+            val64_tx_clk = 1; val64_tx_slot = 0x200; val64_tx_burst = 0x2000;
+            break;
+        }
+
+        oct_write64(OCTEON_RGMX_TXX_CLK(index, iface), val64_tx_clk);
+        oct_write64(OCTEON_RGMX_TXX_SLOT(index, iface), val64_tx_slot);
+        oct_write64(OCTEON_RGMX_TXX_BURST(index, iface), val64_tx_burst);
+
+        oct_write64(OCTEON_RGMX_PRTX_CFG(index, iface), gmx_cfg.word64);
+
+        if (last_enabled) octeon_rgmx_start_port(port);
+
+        if (link_status.bits.status != old_link_status.bits.status) {
+
+//#define DEBUG_LINESTATUS
+            if (link_status.bits.status) {
+#ifdef DEBUG_LINESTATUS
+                printf(" %u/%u: Interface is now alive\n", iface, port);
+#endif
+                if (report_link)  if_link_state_change(sc->ifp, LINK_STATE_UP);
+            } else {
+#ifdef DEBUG_LINESTATUS
+                printf(" %u/%u: Interface went down\n", iface, port);
+#endif
+                if (report_link)  if_link_state_change(sc->ifp, LINK_STATE_DOWN);
+            }
+        }
+        RGMX_UNLOCK(sc);
+
+}
+
+
+
+#ifdef DEBUG_RGMX_DUMP
+static void octeon_dump_rgmx_stats (u_int port)
+{
+
+}
+#endif
+
+#ifdef __not_used__
+static void rgmx_timer_periodic (void)
+{
+    u_int port;
+    int index;
+    struct rgmx_softc_dev *sc;
+    struct ifnet *ifp;
+
+        for (index = 0; index < OCTEON_RGMX_NUM_PORTS_MAX; index ++) {
+
+            	port = port_array[index];
+                sc = rgmx_scdev_array[index];
+
+                /*
+                 * Skip over ports/slots not in service.
+                 */
+                if ((port < OCTEON_RGMX_MIN_PORT) || (port > OCTEON_RGMX_MAX_PORT)) {
+                    continue;
+                }
+                if ((NULL == sc) || (((struct rgmx_softc_dev *)-1) == sc)) {
+                    continue;
+                }
+
+                /*
+                 * Now look for anamolous conditions
+                 */
+                if (sc != get_rgmx_softc(port)) {
+                    printf(" port %u  sc %p not in sync with index: %u\n",
+                           port, sc, index);
+                    continue;
+                }
+
+                if (sc->port != port) {
+                    printf(" port %u  sc %p port-> %u  not in sync with index: %u\n",
+                           port, sc, sc->port, index);
+                    continue;
+                }
+
+                ifp = sc->ifp;
+                if (ifp == NULL) {
+                    printf(" port %u  sc %p . Bad ifp %p\n", port, sc, ifp);
+                    continue;
+                }
+
+                /*
+                 * Check if packets queued at ifnet layer. Kick start output if we can.
+                 */
+                if (sc->ifp->if_flags & IFF_UP) {
+                    octeon_rgmx_output_start(ifp);
+                } else {
+                    octeon_rgmx_output_flush(ifp);
+                }
+
+                /*
+                 * Check if line status changed ?  Adjust ourselves.
+                 */
+                octeon_rgmx_config_speed(port, 1);
+        }
+}
+#endif
+
+#ifdef DEBUG_RGMX_DUMP
+static void octeon_dump_pow_stats(void)
+{
+    octeon_rgmx_pow_nos_cnt nos_cnt;
+    octeon_rgmx_pow_int_pc_t intpc;
+    octeon_rgmx_pow_int_threshold_t thr;
+    octeon_rgmx_pow_int_cnt_t int_cnt;
+    int core = octeon_get_core_num();
+    octeon_pow_inpt_q_all_qos inpt_q_all;
+    octeon_pow_inpt_q_grp_qos inpt_q_grp;
+    octeon_rgmx_pip_inb_pkts pkts;
+    octeon_rgmx_pip_inb_errs errs;
+    static u_int pkts0 = 0;
+    static u_int pkts1 = 0;
+    static u_int errs0 = 0;
+    static u_int errs1 = 0;
+    int i;
+
+
+    nos_cnt.word64 = oct_read64(OCTEON_RGMX_POW_NOS_CNT);
+    if (nos_cnt.bits.nos_cnt) printf(" *** No sched cnt %u\n", nos_cnt.bits.nos_cnt);
+    printf(" \nGroup mask: 0x%llX     WorkQueue Int :    0x%llX\n", oct_read64(OCTEON_POW_CORE_GROUP_MASK(OUR_CORE)), oct_read64(OCTEON_POW_WORKQUEUE_INT));
+    intpc.word64 = oct_read64(OCTEON_POW_WORKQUEUE_INT_PC);
+    printf(" Intr Periodic Cntr: PC %u  thr:  %u\n", intpc.bits.thr_freq, intpc.bits.thr_period);
+    thr.word64 = oct_read64(OCTEON_POW_WORKQUEUE_INT_THRESHOLD(OCTEON_POW_RX_GROUP_NUM));
+    printf(" Thresholds iq %u  ds %u  time %u  enable %u\n",
+           thr.bits.iq_thr, thr.bits.ds_thr, thr.bits.time_thr, thr.bits.enable);
+    int_cnt.word64 = oct_read64(OCTEON_POW_INT_CNTR(core));
+    printf(" Int_cnt  iq_cnt %u  ds_cnt %u  tc_cnt %u\n",
+           int_cnt.bits.iq_cnt, int_cnt.bits.ds_cnt, int_cnt.bits.tc_cnt);
+    pkts.word64 = oct_read64(OCTEON_PIP_STAT_INB_PKTS(16)); pkts0 += pkts.bits.inb_pkts;
+    errs.word64 = oct_read64(OCTEON_PIP_STAT_INB_ERRS(16)); errs0 += errs.bits.inb_errs;
+    pkts.word64 = oct_read64(OCTEON_PIP_STAT_INB_PKTS(17)); pkts1 += pkts.bits.inb_pkts;
+    errs.word64 = oct_read64(OCTEON_PIP_STAT_INB_ERRS(17)); errs1 += errs.bits.inb_errs;
+    printf(" PIP inbound pkts(16): %u   Errors: %u    inbound(17): %u   Errors: %u\n", pkts0, errs0, pkts1, errs1);
+    inpt_q_all.word64 = oct_read64(OCTEON_POW_INPT_Q_ALL_QOS);
+    printf(" All queued pkt in qos Levels: %u -- ", inpt_q_all.bits.iq_cnt);
+    for (i = 0 ; i < 7; i++) {
+        inpt_q_grp.word64 = oct_read64(OCTEON_POW_INPT_QOS_GRP(i));
+        if (inpt_q_grp.bits.iq_cnt)  printf(" Grp-%u:  %u ", i, inpt_q_grp.bits.iq_cnt);
+    }
+}
+#endif
+
+/* ------------------------------------------------------------------- *
+ *                      octeon_line_status_loop()                      *
+ * ------------------------------------------------------------------- */
+static void octeon_line_status_loop (void *unused)
+{
+    	struct rgmx_softc_dev *sc;
+        u_int idx;
+
+                for (idx = 0; idx < num_devices; idx++) {
+                    	sc = rgmx_scdev_array[idx];
+                        if (sc && sc->ifp) {
+                                if ((sc->ifp->if_drv_flags & IFF_DRV_RUNNING)) {
+                                    	octeon_rgmx_config_speed(sc->port, 1);
+
+                                        octeon_rgmx_output_start(sc->ifp);
+                                }
+                        }
+                }
+
+//#define DEBUG_RGMX_DUMP
+#ifdef DEBUG_RGMX_DUMP
+        static int count = 0;
+
+                if (++count > 5) {
+                    count = 0;
+//                    octeon_dump_fpa_pool(OCTEON_FPA_RX_PACKET_POOL);
+//                    octeon_dump_fpa_pool(OCTEON_FPA_WQE_RX_POOL);
+//                    octeon_dump_fpa_pool(OCTEON_FPA_TX_PACKET_POOL);
+                    octeon_dump_rgmx_stats(16);
+                    octeon_dump_pow_stats();
+                }
+#endif
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      octeon_rgmx_set_mac	                       *
+ * ------------------------------------------------------------------- *
+ *
+ * octeon_rgmx_set_mac
+ *
+ * Program the ethernet HW address
+ *
+ */
+static void octeon_rgmx_set_mac (u_int port)
+{
+    struct rgmx_softc_dev *sc;
+    u_int iface = INTERFACE(port);
+    u_int index = INDEX(port);
+    int ii;
+    uint64_t mac = 0;
+    u_int last_enabled;
+
+    sc = get_rgmx_softc(port);
+    if (!sc) {
+        printf(" octeon_rgmx_set_mac Missing sc.  port:%u", port);
+        return;
+    }
+
+    for (ii = 0; ii < 6; ii++) {
+        mac = (mac << 8) | (uint64_t)(sc->ieee[ii]);
+    }
+
+    last_enabled = octeon_rgmx_stop_port(port);
+
+    oct_write64(OCTEON_RGMX_SMACX(index, iface), mac);
+    oct_write64(OCTEON_RGMX_RXX_ADR_CAM0(index, iface), sc->ieee[0]);
+    oct_write64(OCTEON_RGMX_RXX_ADR_CAM1(index, iface), sc->ieee[1]);
+    oct_write64(OCTEON_RGMX_RXX_ADR_CAM2(index, iface), sc->ieee[2]);
+    oct_write64(OCTEON_RGMX_RXX_ADR_CAM3(index, iface), sc->ieee[3]);
+    oct_write64(OCTEON_RGMX_RXX_ADR_CAM4(index, iface), sc->ieee[4]);
+    oct_write64(OCTEON_RGMX_RXX_ADR_CAM5(index, iface), sc->ieee[5]);
+    oct_write64(OCTEON_RGMX_RXX_ADR_CTL(index, iface),
+                OCTEON_RGMX_ADRCTL_ACCEPT_BROADCAST | 
+                OCTEON_RGMX_ADRCTL_ACCEPT_ALL_MULTICAST |
+                OCTEON_RGMX_ADRCTL_CAM_MODE_ACCEPT_DMAC);
+    oct_write64(OCTEON_RGMX_RXX_ADR_CAM_EN(index, iface), 1);
+    if (last_enabled)  octeon_rgmx_start_port(port);
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      octeon_config_rgmii_port()                     *
+ * ------------------------------------------------------------------- */
+static void octeon_config_rgmii_port (u_int port)
+{
+    	u_int iface = INTERFACE(port);
+        u_int index = INDEX(port);
+
+	/* 
+	 * Configure an RGMII port
+	 */
+        octeon_rgmx_prtx_cfg_t gmx_cfg;
+
+	/* Enable ASX */
+	oct_write64(OCTEON_ASXX_RX_PRT_EN(iface), oct_read64(OCTEON_ASXX_RX_PRT_EN(iface)) | (1<<index));
+        oct_write64(OCTEON_ASXX_TX_PRT_EN(iface), oct_read64(OCTEON_ASXX_TX_PRT_EN(iface)) | (1<<index));
+
+        /* Enable RGMX */
+        gmx_cfg.word64 = oct_read64(OCTEON_RGMX_PRTX_CFG(index, iface));
+        gmx_cfg.bits.en = 1;
+        oct_write64(OCTEON_RGMX_PRTX_CFG(index, iface), gmx_cfg.word64);
+
+
+        octeon_rgmx_config_speed(port, 0);
+
+        oct_write64(OCTEON_RGMX_TXX_THRESH(index, iface), 32);
+
+        /*
+         * Set hi water mark
+         */
+        oct_write64(OCTEON_ASXX_TX_HI_WATERX(index, iface), 10);
+	if (octeon_get_chipid() == OCTEON_CN5020_CHIP) {
+        	oct_write64(OCTEON_ASXX_TX_CLK_SETX(index, iface), 16);
+        	oct_write64(OCTEON_ASXX_RX_CLK_SETX(index, iface), 16);
+	} else {
+        	oct_write64(OCTEON_ASXX_TX_CLK_SETX(index, iface), 24);
+        	oct_write64(OCTEON_ASXX_RX_CLK_SETX(index, iface), 24);
+	}
+}
+
+
+
+static void octeon_rgmx_enable_RED_queue (int queue, int slow_drop, int all_drop)
+{
+    octeon_rgmx_ipd_queue_red_marks_t red_marks;
+    octeon_rgmx_ipd_red_q_param_t red_param;
+
+    if (slow_drop == all_drop) { printf("Bad val in %s", __FUNCTION__); return; }
+    red_marks.word64 = 0;
+    red_marks.bits.all_drop = all_drop;
+    red_marks.bits.slow_drop = slow_drop;
+    oct_write64(OCTEON_IPD_QOSX_RED_MARKS(queue), red_marks.word64);
+
+    /* Use the actual queue 0 counter, not the average */
+    red_param.word64 = 0;
+    red_param.bits.prb_con = (255ul << 24) / (slow_drop - all_drop);
+    red_param.bits.avg_con = 1;
+    red_param.bits.new_con = 255;
+    red_param.bits.use_pagecount = 1;
+    oct_write64(OCTEON_IPD_RED_Q_PARAM(queue), red_param.word64);
+}
+
+
+static void octeon_rgmx_enable_RED_all (int slow_drop, int all_drop)
+{
+
+    int port, queue;
+    octeon_ipd_port_bp_page_count_t ipd_bp_page_count;
+    octeon_ipd_red_port_enable_t red_port_enable;
+
+    /*
+     * First remove BP settings
+     */
+    ipd_bp_page_count.word64 = 0;
+    ipd_bp_page_count.bits.bp_enable = 0;
+    ipd_bp_page_count.bits.page_count = 100;
+
+    for (port = 0; port < OCTEON_RGMX_MAX_PORT; port++) {
+        oct_write64(OCTEON_IPD_PORT_BP_PAGE_COUNT(port), ipd_bp_page_count.word64);
+    }
+
+    /*
+     * Enable RED for each individual queue
+     */
+    for (queue = 0; queue < 8; queue++) {
+        octeon_rgmx_enable_RED_queue(queue, slow_drop, all_drop);
+    }
+
+    oct_write64(OCTEON_IPD_BP_PORT_RED_END, 0);
+
+    red_port_enable.word64 = 0;
+    red_port_enable.bits.port_enable = 0xfffffffffull;
+    red_port_enable.bits.avg_dly = 10000;
+    red_port_enable.bits.prb_dly = 10000;
+    oct_write64(OCTEON_IPD_RED_PORT_ENABLE, red_port_enable.word64);
+}
+
+
+
+/* ------------------------------------------------------------------- *
+ *                    octeon_has_4ports()                                 *
+ * ------------------------------------------------------------------- */
+static int octeon_has_4ports (void)
+{
+    u_int chipid;
+    int retcode = 1;
+
+    chipid = octeon_get_chipid() & 0xffffff00;
+
+    switch (chipid) {
+        case OCTEON_CN31XX_CHIP:
+        case OCTEON_CN30XX_CHIP:
+	case OCTEON_CN5020_CHIP:
+            retcode = 0;
+            break;
+
+        default:
+            break;
+    }
+    return (retcode);
+}
+
+
+#ifdef __not_used__
+/*
+ * octeon_rgmx_free_intr
+ *
+ * We have 4 child and one parent device.
+ * It's tricky and unexpected that anyone will detach the device that is built'in on
+ * the chip.
+ * We will not support  detachment for now. But keep adding good code that will be used
+ * someday.
+ */
+static void octeon_rgmx_free_intr (struct rgmx_softc_dev *sc)
+{
+	device_t dev = sc->sc_dev;
+
+        /*
+         * Make sure that sc/dev  are the parent Root structs. Not one
+         * of the rgmxN childs.
+         */
+	if (int_handler_tag != NULL) {
+		bus_teardown_intr(dev, irq_res, int_handler_tag);
+		int_handler_tag = NULL;
+	}
+
+#ifdef OCTEON_RGMX_SCHEDULED_ISRS
+	if (tq != NULL) {
+		taskqueue_drain(tq, &rxtx_isr_task);
+		taskqueue_drain(taskqueue_fast, &link_isr_task);
+		taskqueue_free(tq);
+		tq = NULL;
+	}
+#endif
+
+}
+#endif
+
+static device_method_t rgmii_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		rgmii_probe),
+	DEVMETHOD(device_identify,	rgmii_identify),
+	DEVMETHOD(device_attach,	rgmii_attach),
+	DEVMETHOD(device_detach,	bus_generic_detach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+
+	{ 0, 0 }
+};
+
+static driver_t rgmii_driver = {
+    	"rgmii", rgmii_methods, sizeof(struct rgmx_softc_dev)
+};
+
+static devclass_t rgmii_devclass;
+
+DRIVER_MODULE(rgmii, nexus, rgmii_driver, rgmii_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/octeon1/dev/rgmii/octeon_rgmx.h svn/mips/sys/mips/octeon1/dev/rgmii/octeon_rgmx.h
--- releng8/src/sys/mips/octeon1/dev/rgmii/octeon_rgmx.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/dev/rgmii/octeon_rgmx.h	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,590 @@
+/*------------------------------------------------------------------
+ * octeon_rgmx.h      RGMII Ethernet Interfaces
+ *
+ *------------------------------------------------------------------
+ */
+
+
+#ifndef ___OCTEON_RGMX__H___
+#define ___OCTEON_RGMX__H___
+
+
+
+#define OCTEON_FPA_PACKET_POOL                  0
+#define OCTEON_FPA_WQE_RX_POOL                  1
+#define OCTEON_FPA_OUTPUT_BUFFER_POOL           2
+#define OCTEON_FPA_WQE_POOL_SIZE                (1 *  OCTEON_CACHE_LINE_SIZE)
+#define OCTEON_FPA_OUTPUT_BUFFER_POOL_SIZE      (8 *  OCTEON_CACHE_LINE_SIZE)
+#define OCTEON_FPA_PACKET_POOL_SIZE             (16 * OCTEON_CACHE_LINE_SIZE)
+
+#define OCTEON_POW_WORK_REQUEST(wait)   	(0x8001600000000000ull | (wait<<3))
+
+typedef union
+{
+    void*           ptr;
+    uint64_t        word64;
+    struct
+    {
+        uint64_t    i    : 1;
+        uint64_t    back : 4;
+        uint64_t    pool : 3;
+        uint64_t    size :16;
+        uint64_t    addr :40;
+    } bits;
+} octeon_buf_ptr_t;
+
+/**
+ * Work queue entry format
+ */
+typedef struct
+{
+    uint16_t                   hw_chksum;
+    uint8_t                    unused;
+    uint64_t                   next_ptr      : 40;
+    uint64_t                   len           :16;
+    uint64_t                   ipprt         : 6;
+    uint64_t                   qos           : 3;
+    uint64_t                   grp           : 4;
+    uint64_t                   tag_type      : 3;
+    uint64_t                   tag           :32;
+    union
+    {
+        uint64_t               word64;
+        struct
+        {
+            uint64_t           bufs          : 8;
+            uint64_t           ip_offset     : 8;
+            uint64_t           vlan_valid    : 1;
+            uint64_t           unassigned    : 2;
+            uint64_t           vlan_cfi      : 1;
+            uint64_t           vlan_id       :12;
+            uint64_t           unassigned2   :12;
+            uint64_t           dec_ipcomp    : 1;
+            uint64_t           tcp_or_udp    : 1;
+            uint64_t           dec_ipsec     : 1;
+            uint64_t           is_v6         : 1;
+            uint64_t           software      : 1;
+            uint64_t           L4_error      : 1;
+            uint64_t           is_frag       : 1;
+            uint64_t           IP_exc        : 1;
+            uint64_t           is_bcast      : 1;
+            uint64_t           is_mcast      : 1;
+            uint64_t           not_IP        : 1;
+            uint64_t           rcv_error     : 1;
+            uint64_t           err_code      : 8;
+        } bits;
+ struct
+        {
+            uint64_t           bufs          : 8;
+            uint64_t           unused        : 8;
+            uint64_t           vlan_valid    : 1;
+            uint64_t           unassigned    : 2;
+            uint64_t           vlan_cfi      : 1;
+            uint64_t           vlan_id       :12;
+            uint64_t           unassigned2   :16;
+            uint64_t           software      : 1;
+            uint64_t           unassigned3   : 1;
+            uint64_t           is_rarp       : 1;
+            uint64_t           is_arp        : 1;
+            uint64_t           is_bcast      : 1;
+            uint64_t           is_mcast      : 1;
+            uint64_t           not_IP        : 1;
+            uint64_t           rcv_error     : 1;
+            uint64_t           err_code      : 8;
+        } snoip;
+    } word2;
+    octeon_buf_ptr_t           packet_ptr;
+    uint8_t packet_data[96];
+} octeon_wqe_t;
+
+typedef union {
+    uint64_t         word64;
+
+    struct {
+        uint64_t                scraddr : 8;    /**< the (64-bit word) location in scratchpad to write to (if len != 0) */
+        uint64_t                len     : 8;    /**< the number of words in the response (0 => no response) */
+        uint64_t                did     : 8;    /**< the ID of the device on the non-coherent bus */
+        uint64_t                unused  :36;
+        uint64_t                wait    : 1;    /**< if set, don't return load response until work is available */
+        uint64_t                unused2 : 3;
+    } bits;
+
+} octeon_pow_iobdma_store_t;
+
+
+/**
+ * Wait flag values for pow functions.
+ */
+typedef enum
+{
+    OCTEON_POW_WAIT = 1,
+    OCTEON_POW_NO_WAIT = 0,
+} octeon_pow_wait_t;
+
+
+
+static inline void * phys_to_virt (unsigned long address)
+{
+        return (void *)(address + 0x80000000UL);
+}
+
+// decode within DMA space
+typedef enum {
+   OCTEON_ADD_WIN_DMA_ADD = 0L,     // add store data to the write buffer entry, allocating it if necessary
+   OCTEON_ADD_WIN_DMA_SENDMEM = 1L, // send out the write buffer entry to DRAM
+                                     // store data must be normal DRAM memory space address in this case
+   OCTEON_ADD_WIN_DMA_SENDDMA = 2L, // send out the write buffer entry as an IOBDMA command
+                                     // see OCTEON_ADD_WIN_DMA_SEND_DEC for data contents
+   OCTEON_ADD_WIN_DMA_SENDIO = 3L,  // send out the write buffer entry as an IO write
+                                     // store data must be normal IO space address in this case
+   OCTEON_ADD_WIN_DMA_SENDSINGLE = 4L, // send out a single-tick command on the NCB bus
+                                        // no write buffer data needed/used
+} octeon_add_win_dma_dec_t;
+
+
+#define OCTEON_OCT_DID_FPA	5ULL
+#define OCTEON_OCT_DID_TAG	12ULL
+#define OCTEON_OCT_DID_TAG_SWTAG OCTEON_ADDR_FULL_DID(OCTEON_OCT_DID_TAG, 0ULL)
+
+
+#define OCTEON_IOBDMA_OFFSET            (-3*1024ll)
+#define OCTEON_IOBDMA_SEP               16 
+#define OCTEON_IOBDMA_SENDSINGLE        (OCTEON_IOBDMA_OFFSET +         \
+                                        (OCTEON_ADD_WIN_DMA_SENDSINGLE *\
+                                        OCTEON_IOBDMA_SEP))
+
+static inline void octeon_send_single (uint64_t data)
+{
+    oct_write64((uint64_t)(OCTEON_IOBDMA_SENDSINGLE * (long long)8), data);
+}
+
+
+static inline void octeon_pow_work_request_async_nocheck (int scratch_addr,
+                                                          octeon_pow_wait_t wait)
+{
+    octeon_pow_iobdma_store_t data;
+
+    /* scratch_addr must be 8 byte aligned */
+    data.bits.scraddr = scratch_addr >> 3;
+    data.bits.len = 1;
+    data.bits.did = OCTEON_OCT_DID_TAG_SWTAG;
+    data.bits.wait = wait;
+    octeon_send_single(data.word64);
+}
+
+
+
+/**
+ * octeon_gmx_inf_mode
+ *
+ * GMX_INF_MODE = Interface Mode
+ *
+ */
+typedef union
+{       
+    uint64_t word64;
+    struct gmxx_inf_mode_s
+    {       
+        uint64_t reserved_3_63           : 61;
+        uint64_t p0mii                   : 1;       /**< Port 0 Interface Mode
+                                                         0: Port 0 is RGMII
+                                                         1: Port 0 is MII */
+        uint64_t en                      : 1;       /**< Interface Enable */
+        uint64_t type                    : 1;       /**< Interface Mode
+                                                         0: RGMII Mode
+                                                         1: Spi4 Mode */
+    } bits;
+    struct gmxx_inf_mode_cn3020
+    {               
+        uint64_t reserved_2_63           : 62;
+        uint64_t en                      : 1;       /**< Interface Enable */
+        uint64_t type                    : 1;       /**< Interface Mode
+                                                         0: All three ports are RGMII ports
+                                                         1: prt0 is RGMII, prt1 is GMII, and prt2 is unused */
+    } cn3020;
+    struct gmxx_inf_mode_s          cn30xx;
+    struct gmxx_inf_mode_cn3020     cn31xx;
+    struct gmxx_inf_mode_cn3020     cn36xx;
+    struct gmxx_inf_mode_cn3020     cn38xx;
+    struct gmxx_inf_mode_cn3020     cn38xxp2;
+    struct gmxx_inf_mode_cn3020     cn56xx;
+    struct gmxx_inf_mode_cn3020     cn58xx;
+} octeon_gmxx_inf_mode_t;
+
+
+
+
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved	: 60;      /* Reserved */
+        uint64_t slottime	: 1;       /* Slot Time for Half-Duplex */
+        /* operation - 0 = 512 bitimes (10/100Mbs operation) */
+        /* - 1 = 4096 bitimes (1000Mbs operation) */
+        uint64_t duplex		: 1;       /* Duplex - 0 = Half Duplex */
+        /* (collisions/extentions/bursts)            - 1 = Full Duplex */
+        uint64_t speed		: 1;       /* Link Speed - 0 = 10/100Mbs */
+	/* operation - 1 = 1000Mbs operation */
+        uint64_t en		: 1;       /* Link Enable */
+    } bits;
+} octeon_rgmx_prtx_cfg_t;
+
+
+/*
+ * GMX_RX_INBND = RGMX InBand Link Status
+ *
+ */
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved	: 60;      /* Reserved */
+        uint64_t duplex		: 1;       /* 0 = Half, 1 = Full */
+        uint64_t speed		: 2;       /* Inbound Link Speed */
+					   /* 00 = 2.5Mhz, 01 = 25Mhz */
+        				   /* 10 = 125MHz, 11 = Reserved */
+        uint64_t status		: 1;       /* Inbound Status Up/Down */
+    } bits;
+} octeon_rgmx_rxx_rx_inbnd_t;
+
+
+
+typedef union
+{
+    uint64_t word64;
+    struct {
+        uint64_t all_drop                    : 32;
+        uint64_t slow_drop                   : 32;
+    } bits;
+} octeon_rgmx_ipd_queue_red_marks_t;
+
+
+typedef union
+{
+    uint64_t word64;
+    struct {
+        uint64_t reserved	         : 15;
+        uint64_t use_pagecount           : 1;
+        uint64_t new_con                 : 8;
+        uint64_t avg_con                 : 8;
+        uint64_t prb_con                 : 32;
+    } bits;
+} octeon_rgmx_ipd_red_q_param_t;
+
+
+
+typedef union
+{
+    uint64_t word64;
+    struct {
+        uint64_t reserved          	 : 46;
+        uint64_t bp_enable               : 1;
+        uint64_t page_count              : 17;
+    } bits;
+} octeon_ipd_port_bp_page_count_t;
+
+
+typedef union
+{
+    uint64_t word64;
+    struct {
+        uint64_t prb_dly                 : 14;
+        uint64_t avg_dly                 : 14;
+        uint64_t port_enable             : 36;
+    } bits;
+} octeon_ipd_red_port_enable_t;
+
+
+/**
+ * Tag type definitions
+ */ 
+typedef enum
+{
+    OCTEON_POW_TAG_TYPE_ORDERED   = 0L,   /**< Tag ordering is maintained */
+    OCTEON_POW_TAG_TYPE_ATOMIC    = 1L,   /**< Tag ordering is maintained, and at most one PP has the tag */
+    OCTEON_POW_TAG_TYPE_NULL      = 2L,   /**< The work queue entry from the order
+                                            - NEVER tag switch from NULL to NULL */
+    OCTEON_POW_TAG_TYPE_NULL_NULL = 3L    /**< A tag switch to NULL, and there is no space reserved in POW
+                                            - NEVER tag switch to NULL_NULL
+                                            - NEVER tag switch from NULL_NULL
+                                            - NULL_NULL is entered at the beginning of time and on a deschedule.
+                                            - NULL_NULL can be exited by a new work request. A NULL_SWITCH load can also switch the state to NULL */
+} octeon_pow_tag_type_t ;
+
+/**
+ * This structure defines the response to a load/SENDSINGLE to POW (except CSR reads)
+ */
+typedef union {
+    uint64_t         word64;
+
+    octeon_wqe_t *wqp;
+
+    // response to new work request loads
+    struct {
+        uint64_t       no_work : 1;   // set when no new work queue entry was returned
+        // If there was de-scheduled work, the HW will definitely
+        // return it. When this bit is set, it could mean
+        // either mean:
+        //   - There was no work, or
+        //   - There was no work that the HW could find. This
+        //     case can happen, regardless of the wait bit value
+        //     in the original request, when there is work
+        //     in the IQ's that is too deep down the list.
+        uint64_t       unused  : 23;
+        uint64_t       addr    : 40;  // 36 in O1 -- the work queue pointer
+    } s_work;
+
+    // response to NULL_RD request loads
+    struct {
+        uint64_t       unused  : 62;
+        uint64_t       state    : 2;  // of type octeon_pow_tag_type_t
+        // state is one of the following:
+        //       OCTEON_POW_TAG_TYPE_ORDERED
+        //       OCTEON_POW_TAG_TYPE_ATOMIC
+        //       OCTEON_POW_TAG_TYPE_NULL
+        //       OCTEON_POW_TAG_TYPE_NULL_NULL
+    } s_null_rd;
+
+} octeon_pow_tag_load_resp_t;
+
+
+/*
+ * This structure describes the address to load stuff from POW
+ */
+typedef union {
+    uint64_t word64;
+
+    // address for new work request loads (did<2:0> == 0)
+    struct {
+        uint64_t                mem_region  :2;
+        uint64_t                mbz  :13;
+        uint64_t                is_io  : 1;    // must be one
+        uint64_t                did    : 8;    // the ID of POW -- did<2:0> == 0 in this case
+        uint64_t                unaddr : 4;
+        uint64_t                unused :32;
+        uint64_t                wait   : 1;    // if set, don't return load response until work is available
+        uint64_t                mbzl   : 3;    // must be zero
+    } swork; // physical address
+
+
+    // address for NULL_RD request (did<2:0> == 4)
+    // when this is read, HW attempts to change the state to NULL if it is NULL_NULL
+    // (the hardware cannot switch from NULL_NULL to NULL if a POW entry is not available -
+    // software may need to recover by finishing another piece of work before a POW
+    // entry can ever become available.)
+    struct {
+        uint64_t                mem_region  :2;
+        uint64_t                mbz  :13;
+        uint64_t                is_io  : 1;    // must be one
+        uint64_t                did    : 8;    // the ID of POW -- did<2:0> == 4 in this case
+        uint64_t                unaddr : 4;
+        uint64_t                unused :33;
+        uint64_t                mbzl   : 3;    // must be zero
+    } snull_rd; // physical address
+
+    // address for CSR accesses
+    struct {
+        uint64_t                mem_region  :2;
+        uint64_t                mbz  :13;
+        uint64_t                is_io  : 1;    // must be one
+        uint64_t                did    : 8;    // the ID of POW -- did<2:0> == 7 in this case
+        uint64_t                unaddr : 4;
+        uint64_t                csraddr:36;    // only 36 bits in O1, addr<2:0> must be zero
+    } stagcsr; // physical address
+
+} octeon_pow_load_addr_t;
+
+
+static inline void octeon_pow_tag_switch_wait (void)
+{
+    uint64_t switch_complete;
+
+    do
+    {
+        OCTEON_CHORD_HEX(&switch_complete);
+    } while (!switch_complete);
+
+    return;
+}
+
+
+static inline octeon_wqe_t *octeon_pow_work_request_sync_nocheck (octeon_pow_wait_t wait)
+{
+    octeon_pow_load_addr_t ptr;
+    octeon_pow_tag_load_resp_t result;
+
+    ptr.word64 = 0;
+    ptr.swork.mem_region = OCTEON_IO_SEG;
+    ptr.swork.is_io = 1;
+    ptr.swork.did = OCTEON_OCT_DID_TAG_SWTAG;
+    ptr.swork.wait = wait;
+
+    result.word64 = oct_read64(ptr.word64);
+
+    if (result.s_work.no_work || !result.s_work.addr) {
+        return NULL;
+    }
+    return (octeon_wqe_t *) MIPS_PHYS_TO_KSEG0(result.s_work.addr);
+}
+
+static inline octeon_wqe_t *octeon_pow_work_request_sync_nocheck_debug (octeon_pow_wait_t wait)
+{
+    octeon_pow_load_addr_t ptr;
+    octeon_pow_tag_load_resp_t result;
+
+    ptr.word64 = 0;
+    ptr.swork.mem_region = OCTEON_IO_SEG;
+    ptr.swork.is_io = 1;
+    ptr.swork.did = OCTEON_OCT_DID_TAG_SWTAG;
+    ptr.swork.wait = wait;
+
+    result.word64 = oct_read64(ptr.word64);
+
+    printf("WQE Result: 0x%llX  No-work %X   Addr %llX  Ptr: %p\n",
+	(unsigned long long)result.word64,  result.s_work.no_work,
+	(unsigned long long)result.s_work.addr,
+	(void *)MIPS_PHYS_TO_KSEG0(result.s_work.addr));
+
+    if (result.s_work.no_work || !result.s_work.addr) {
+        return NULL;
+    }
+    return (octeon_wqe_t *) MIPS_PHYS_TO_KSEG0(result.s_work.addr);
+}
+
+static inline octeon_wqe_t *octeon_pow_work_request_sync (octeon_pow_wait_t wait)
+{
+    octeon_pow_tag_switch_wait();
+    return (octeon_pow_work_request_sync_nocheck(wait));
+}
+
+
+static inline octeon_wqe_t *octeon_pow_work_request_sync_debug (octeon_pow_wait_t wait)
+{
+    octeon_pow_tag_switch_wait();
+    return (octeon_pow_work_request_sync_nocheck_debug(wait));
+}
+    
+
+
+/**
+ * Gets result of asynchronous work request.  Performs a IOBDMA sync
+ * to wait for the response.
+ *
+ * @param scratch_addr Scratch memory address to get result from
+ *                  Byte address, must be 8 byte aligned.
+ * @return Returns the WQE from the scratch register, or NULL if no work was available.
+ */
+static inline octeon_wqe_t *octeon_pow_work_response_async(int scratch_addr)
+{
+    octeon_pow_tag_load_resp_t result;
+
+    OCTEON_SYNCIOBDMA;
+    result.word64 = oct_scratch_read64(scratch_addr);
+
+    if (result.s_work.no_work) {
+        return NULL;
+    }
+    return (octeon_wqe_t*) MIPS_PHYS_TO_KSEG0(result.s_work.addr);
+}
+
+
+
+/*
+ * The address from POW is a physical address. Adjust for back ptr, as well as
+ * make it accessible using  KSEG0.
+ */
+static inline void *octeon_pow_pktptr_to_kbuffer (octeon_buf_ptr_t pkt_ptr)
+{
+    return ((void *)MIPS_PHYS_TO_KSEG0(
+	((pkt_ptr.bits.addr >> 7) - pkt_ptr.bits.back) << 7));
+}
+
+#define INTERFACE(port) (port >> 4) /* Ports 0-15 are interface 0, 16-31 are interface 1 */
+#define INDEX(port) (port & 0xf)
+
+
+#define  OCTEON_RGMX_PRTX_CFG(index,interface)	(0x8001180008000010ull+((index)*2048)+((interface)*0x8000000ull))
+#define  OCTEON_RGMX_SMACX(offset,block_id)	(0x8001180008000230ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_ADR_CAM0(offset,block_id)	(0x8001180008000180ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_ADR_CAM1(offset,block_id)	(0x8001180008000188ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_ADR_CAM2(offset,block_id)	(0x8001180008000190ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_ADR_CAM3(offset,block_id)	(0x8001180008000198ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_ADR_CAM4(offset,block_id)	(0x80011800080001A0ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_ADR_CAM5(offset,block_id)	(0x80011800080001A8ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_ADR_CTL(offset,block_id)	(0x8001180008000100ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_ADR_CAM_EN(offset,block_id)	(0x8001180008000108ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_INF_MODE(block_id)		(0x80011800080007F8ull+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_TX_PRTS(block_id)		(0x8001180008000480ull+((block_id)*0x8000000ull))
+#define  OCTEON_ASXX_RX_PRT_EN(block_id)	(0x80011800B0000000ull+((block_id)*0x8000000ull))
+#define  OCTEON_ASXX_TX_PRT_EN(block_id)	(0x80011800B0000008ull+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_TXX_THRESH(offset,block_id)	(0x8001180008000210ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_ASXX_TX_HI_WATERX(offset,block_id)	(0x80011800B0000080ull+((offset)*8)+((block_id)*0x8000000ull))
+#define  OCTEON_ASXX_RX_CLK_SETX(offset,block_id)	(0x80011800B0000020ull+((offset)*8)+((block_id)*0x8000000ull))
+#define  OCTEON_ASXX_TX_CLK_SETX(offset,block_id)	(0x80011800B0000048ull+((offset)*8)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_RXX_RX_INBND(offset,block_id)	(0x8001180008000060ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_TXX_CLK(offset,block_id)	(0x8001180008000208ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_TXX_SLOT(offset,block_id)	(0x8001180008000220ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_RGMX_TXX_BURST(offset,block_id)	(0x8001180008000228ull+((offset)*2048)+((block_id)*0x8000000ull))
+#define  OCTEON_PIP_GBL_CTL			(0x80011800A0000020ull)
+#define  OCTEON_PIP_GBL_CFG			(0x80011800A0000028ull)
+#define  OCTEON_PIP_PRT_CFGX(offset)		(0x80011800A0000200ull+((offset)*8))
+#define  OCTEON_PIP_PRT_TAGX(offset)		(0x80011800A0000400ull+((offset)*8))
+
+
+
+#define OUR_CORE	0
+#define IP2		0
+#define IP3		1
+#define CIU_TIMERS	4
+#define OCTEON_POW_CORE_GROUP_MASK(core)  (0x8001670000000000ull + (8 * core))
+
+#define	OCTEON_CIU_INT_EN0(CORE,IP)  (0x8001070000000200ull + (IP * 16) + \
+					((CORE) * 32))
+#define	OCTEON_CIU_INT_SUM0(CORE,IP) (0x8001070000000000ull + (IP * 8) + \
+					((CORE) * 32))
+#define OCTEON_CIU_TIMX(offset)	     (0x8001070000000480ull+((offset)*8))
+
+#define	OCTEON_POW_WQ_INT_THRX(offset)  ((0x8001670000000080ull+((offset)*8)))
+#define	OCTEON_POW_WQ_INT_CNTX(offset)  ((0x8001670000000100ull+((offset)*8)))
+#define	OCTEON_POW_QOS_THRX(offset)     ((0x8001670000000180ull+((offset)*8)))
+#define	OCTEON_POW_QOS_RNDX(offset)     ((0x80016700000001C0ull+((offset)*8)))
+#define	OCTEON_POW_WQ_INT_PC            (0x8001670000000208ull)
+#define	OCTEON_POW_NW_TIM               (0x8001670000000210ull)
+#define	OCTEON_POW_ECC_ERR              (0x8001670000000218ull)
+#define	OCTEON_POW_INT_CTL              (0x8001670000000220ull)
+#define	OCTEON_POW_NOS_CNT              (0x8001670000000228ull)
+#define	OCTEON_POW_WS_PCX(offset)       ((0x8001670000000280ull+((offset)*8)))
+#define	OCTEON_POW_WA_PCX(offset)       ((0x8001670000000300ull+((offset)*8)))
+#define	OCTEON_POW_IQ_CNTX(offset)      ((0x8001670000000340ull+((offset)*8)))
+#define	OCTEON_POW_WA_COM_PC            (0x8001670000000380ull)
+#define	OCTEON_POW_IQ_COM_CNT           (0x8001670000000388ull)
+#define	OCTEON_POW_TS_PC                (0x8001670000000390ull)
+#define	OCTEON_POW_DS_PC                (0x8001670000000398ull)
+#define	OCTEON_POW_BIST_STAT            (0x80016700000003F8ull)
+
+
+#define	OCTEON_POW_WQ_INT               (0x8001670000000200ull)
+
+#define OCTEON_IPD_PORT_BP_COUNTERS_PAIRX(offset)  (0x80014F00000001B8ull+((offset)*8))
+
+/*
+ * Current Counts that triggered interrupt
+ */
+#define  OCTEON_POW_WQ_INT_CNTX(offset)	((0x8001670000000100ull+((offset)*8)))
+
+
+
+#define OCTEON_RGMX_ADRCTL_CAM_MODE_REJECT_DMAC	0
+#define OCTEON_RGMX_ADRCTL_ACCEPT_BROADCAST	1
+#define OCTEON_RGMX_ADRCTL_REJECT_ALL_MULTICAST	2
+#define OCTEON_RGMX_ADRCTL_ACCEPT_ALL_MULTICAST	4
+#define OCTEON_RGMX_ADRCTL_CAM_MODE_ACCEPT_DMAC	8
+
+
+#define	RGMX_LOCK_INIT(_sc, _name) \
+	mtx_init(&(_sc)->mtx, _name, MTX_NETWORK_LOCK, MTX_DEF)
+#define	RGMX_LOCK_DESTROY(_sc)	mtx_destroy(&(_sc)->mtx)
+#define	RGMX_LOCK(_sc)		mtx_lock(&(_sc)->mtx)
+#define	RGMX_UNLOCK(_sc)	mtx_unlock(&(_sc)->mtx)
+#define	RGMX_LOCK_ASSERT(_sc)	mtx_assert(&(_sc)->mtx, MA_OWNED)
+
+#endif /* ___OCTEON_RGMX__H___ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/driveid.h svn/mips/sys/mips/octeon1/driveid.h
--- releng8/src/sys/mips/octeon1/driveid.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/driveid.h	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,259 @@
+
+/*
+ * driveid.h
+ *
+ */
+
+#ifndef __DRIVEID_H__
+#define __DRIVEID_H__
+
+
+struct hd_driveid {
+        unsigned short  config;         /* lots of obsolete bit flags */
+        unsigned short  cyls;           /* Obsolete, "physical" cyls */
+        unsigned short  reserved2;      /* reserved (word 2) */
+        unsigned short  heads;          /* Obsolete, "physical" heads */
+        unsigned short  track_bytes;    /* unformatted bytes per track */
+        unsigned short  sector_bytes;   /* unformatted bytes per sector */
+        unsigned short  sectors;        /* Obsolete, "physical" sectors per track */
+        unsigned short  vendor0;        /* vendor unique */
+        unsigned short  vendor1;        /* vendor unique */
+        unsigned short  vendor2;        /* Retired vendor unique */
+        unsigned char   serial_no[20];  /* 0 = not_specified */
+        unsigned short  buf_type;       /* Retired */
+        unsigned short  buf_size;       /* Retired, 512 byte increments
+                                         * 0 = not_specified
+                                         */
+        unsigned short  ecc_bytes;      /* for r/w long cmds; 0 = not_specified */
+        unsigned char   fw_rev[8];      /* 0 = not_specified */
+        unsigned char   model[40];      /* 0 = not_specified */
+        unsigned char   max_multsect;   /* 0=not_implemented */
+        unsigned char   vendor3;        /* vendor unique */
+        unsigned short  dword_io;       /* 0=not_implemented; 1=implemented */
+        unsigned char   vendor4;        /* vendor unique */
+        unsigned char   capability;     /* (upper byte of word 49)
+                                         *  3:  IORDYsup
+                                         *  2:  IORDYsw
+                                         *  1:  LBA
+                                         *  0:  DMA
+                                         */
+        unsigned short  reserved50;     /* reserved (word 50) */
+        unsigned char   vendor5;        /* Obsolete, vendor unique */
+        unsigned char   tPIO;           /* Obsolete, 0=slow, 1=medium, 2=fast */
+        unsigned char   vendor6;        /* Obsolete, vendor unique */
+        unsigned char   tDMA;           /* Obsolete, 0=slow, 1=medium, 2=fast */
+        unsigned short  field_valid;    /* (word 53)
+                                         *  2:  ultra_ok        word  88
+                                         *  1:  eide_ok         words 64-70
+                                         *  0:  cur_ok          words 54-58
+                                         */
+        unsigned short  cur_cyls;       /* Obsolete, logical cylinders */
+        unsigned short  cur_heads;      /* Obsolete, l heads */
+        unsigned short  cur_sectors;    /* Obsolete, l sectors per track */
+        unsigned short  cur_capacity0;  /* Obsolete, l total sectors on drive */
+	unsigned short  cur_capacity1;  /* Obsolete, (2 words, misaligned int)     */
+        unsigned char   multsect;       /* current multiple sector count */
+        unsigned char   multsect_valid; /* when (bit0==1) multsect is ok */
+        unsigned int    lba_capacity;   /* Obsolete, total number of sectors */
+        unsigned short  dma_1word;      /* Obsolete, single-word dma info */
+        unsigned short  dma_mword;      /* multiple-word dma info */
+        unsigned short  eide_pio_modes; /* bits 0:mode3 1:mode4 */
+        unsigned short  eide_dma_min;   /* min mword dma cycle time (ns) */
+        unsigned short  eide_dma_time;  /* recommended mword dma cycle time (ns) */
+        unsigned short  eide_pio;       /* min cycle time (ns), no IORDY  */
+        unsigned short  eide_pio_iordy; /* min cycle time (ns), with IORDY */
+        unsigned short  words69_70[2];  /* reserved words 69-70
+                                         * future command overlap and queuing
+                                         */
+        /* HDIO_GET_IDENTITY currently returns only words 0 through 70 */
+        unsigned short  words71_74[4];  /* reserved words 71-74
+                                         * for IDENTIFY PACKET DEVICE command
+                                         */
+        unsigned short  queue_depth;    /* (word 75)
+                                         * 15:5 reserved
+                                         *  4:0 Maximum queue depth -1
+                                         */
+        unsigned short  words76_79[4];  /* reserved words 76-79 */
+        unsigned short  major_rev_num;  /* (word 80) */
+        unsigned short  minor_rev_num;  /* (word 81) */
+        unsigned short  command_set_1;  /* (word 82) supported
+                                         * 15:  Obsolete
+                                         * 14:  NOP command
+                                         * 13:  READ_BUFFER
+                                         * 12:  WRITE_BUFFER
+                                         * 11:  Obsolete
+                                         * 10:  Host Protected Area
+                                         *  9:  DEVICE Reset
+                                         *  8:  SERVICE Interrupt
+                                         *  7:  Release Interrupt
+                                         *  6:  look-ahead
+                                         *  5:  write cache
+                                         *  4:  PACKET Command
+                                         *  3:  Power Management Feature Set
+                                         *  2:  Removable Feature Set
+                                         *  1:  Security Feature Set
+                                         *  0:  SMART Feature Set
+                                         */
+	unsigned short  command_set_2;  /* (word 83)
+                                         * 15:  Shall be ZERO
+                                         * 14:  Shall be ONE
+                                         * 13:  FLUSH CACHE EXT
+                                         * 12:  FLUSH CACHE
+                                         * 11:  Device Configuration Overlay
+                                         * 10:  48-bit Address Feature Set
+                                         *  9:  Automatic Acoustic Management
+                                         *  8:  SET MAX security
+                                         *  7:  reserved 1407DT PARTIES
+                                         *  6:  SetF sub-command Power-Up
+                                         *  5:  Power-Up in Standby Feature Set
+                                         *  4:  Removable Media Notification
+                                         *  3:  APM Feature Set
+                                         *  2:  CFA Feature Set
+                                         *  1:  READ/WRITE DMA QUEUED
+                                         *  0:  Download MicroCode
+                                         */
+        unsigned short  cfsse;          /* (word 84)
+                                         * cmd set-feature supported extensions
+                                         * 15:  Shall be ZERO
+                                         * 14:  Shall be ONE
+                                         * 13:6 reserved
+                                         *  5:  General Purpose Logging
+                                         *  4:  Streaming Feature Set
+                                         *  3:  Media Card Pass Through
+                                         *  2:  Media Serial Number Valid
+                                         *  1:  SMART selt-test supported
+                                         *  0:  SMART error logging
+                                         */
+        unsigned short  cfs_enable_1;   /* (word 85)
+                                         * command set-feature enabled
+                                         * 15:  Obsolete
+                                         * 14:  NOP command
+                                         * 13:  READ_BUFFER
+                                         * 12:  WRITE_BUFFER
+                                         * 11:  Obsolete
+                                         * 10:  Host Protected Area
+                                         *  9:  DEVICE Reset
+                                         *  8:  SERVICE Interrupt
+                                         *  7:  Release Interrupt
+                                         *  6:  look-ahead
+                                         *  5:  write cache
+                                         *  4:  PACKET Command
+					 *  3:  Power Management Feature Set
+                                         *  2:  Removable Feature Set
+                                         *  1:  Security Feature Set
+                                         *  0:  SMART Feature Set
+                                         */
+        unsigned short  cfs_enable_2;   /* (word 86)
+                                         * command set-feature enabled
+                                         * 15:  Shall be ZERO
+                                         * 14:  Shall be ONE
+                                         * 13:  FLUSH CACHE EXT
+                                         * 12:  FLUSH CACHE
+                                         * 11:  Device Configuration Overlay
+                                         * 10:  48-bit Address Feature Set
+                                         *  9:  Automatic Acoustic Management
+                                         *  8:  SET MAX security
+                                         *  7:  reserved 1407DT PARTIES
+                                         *  6:  SetF sub-command Power-Up
+                                         *  5:  Power-Up in Standby Feature Set
+                                         *  4:  Removable Media Notification
+                                         *  3:  APM Feature Set
+                                         *  2:  CFA Feature Set
+                                         *  1:  READ/WRITE DMA QUEUED
+                                         *  0:  Download MicroCode
+                                         */
+        unsigned short  csf_default;    /* (word 87)
+                                         * command set-feature default
+                                         * 15:  Shall be ZERO
+                                         * 14:  Shall be ONE
+                                         * 13:6 reserved
+                                         *  5:  General Purpose Logging enabled
+                                         *  4:  Valid CONFIGURE STREAM executed
+                                         *  3:  Media Card Pass Through enabled
+                                         *  2:  Media Serial Number Valid
+                                         *  1:  SMART selt-test supported
+                                         *  0:  SMART error logging
+                                         */
+        unsigned short  dma_ultra;      /* (word 88) */
+        unsigned short  trseuc;         /* time required for security erase */
+        unsigned short  trsEuc;         /* time required for enhanced erase */
+        unsigned short  CurAPMvalues;   /* current APM values */
+        unsigned short  mprc;           /* master password revision code */
+        unsigned short  hw_config;      /* hardware config (word 93)
+ 					 * 15:  Shall be ZERO
+                                         * 14:  Shall be ONE
+                                         * 13:
+                                         * 12:
+                                         * 11:
+                                         * 10:
+                                         *  9:
+                                         *  8:
+                                         *  7:
+                                         *  6:
+                                         *  5:
+                                         *  4:
+                                         *  3:
+                                         *  2:
+                                         *  1:
+                                         *  0:  Shall be ONE
+                                         */
+        unsigned short  acoustic;       /* (word 94)
+                                         * 15:8 Vendor's recommended value
+                                         *  7:0 current value
+                                         */
+        unsigned short  msrqs;          /* min stream request size */
+        unsigned short  sxfert;         /* stream transfer time */
+        unsigned short  sal;            /* stream access latency */
+        unsigned int    spg;            /* stream performance granularity */
+        unsigned long long lba_capacity_2;/* 48-bit total number of sectors */
+        unsigned short  words104_125[22];/* reserved words 104-125 */
+        unsigned short  last_lun;       /* (word 126) */
+        unsigned short  word127;        /* (word 127) Feature Set
+                                         * Removable Media Notification
+                                         * 15:2 reserved
+                                         *  1:0 00 = not supported
+                                         *      01 = supported
+                                         *      10 = reserved
+                                         *      11 = reserved
+                                         */
+        unsigned short  dlf;            /* (word 128)
+                                         * device lock function
+                                         * 15:9 reserved
+                                         *  8   security level 1:max 0:high
+                                         *  7:6 reserved
+					 *  5   enhanced erase
+                                         *  4   expire
+                                         *  3   frozen
+                                         *  2   locked
+                                         *  1   en/disabled
+                                         *  0   capability
+                                         */
+        unsigned short  csfo;           /*  (word 129)
+                                         * current set features options
+                                         * 15:4 reserved
+                                         *  3:  auto reassign
+                                         *  2:  reverting
+                                         *  1:  read-look-ahead
+                                         *  0:  write cache
+                                         */
+        unsigned short  words130_155[26];/* reserved vendor words 130-155 */
+        unsigned short  word156;        /* reserved vendor word 156 */
+        unsigned short  words157_159[3];/* reserved vendor words 157-159 */
+        unsigned short  cfa_power;      /* (word 160) CFA Power Mode
+                                         * 15 word 160 supported
+                                         * 14 reserved
+                                         * 13
+                                         * 12
+                                         * 11:0
+                                         */
+        unsigned short  words161_175[15];/* Reserved for CFA */
+        unsigned short  words176_205[30];/* Current Media Serial Number */
+        unsigned short  words206_254[49];/* reserved words 206-254 */
+        unsigned short  integrity_word; /* (word 255)
+                                         * 15:8 Checksum
+                                         *  7:0 Signature
+                                         */
+};
+
+#endif /* __DRIVEID_H__ */
+
diff -I '.*' -Naur releng8/sys/mips/octeon1/files.octeon1 svn/mips/sys/mips/octeon1/files.octeon1
--- releng8/src/sys/mips/octeon1/files.octeon1	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/files.octeon1	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,15 @@
+# $FreeBSD$
+# Octeon Support Files
+#
+mips/mips/mp_machdep.c				optional smp
+mips/octeon1/dev/rgmii/octeon_fau.c		optional rgmii
+mips/octeon1/dev/rgmii/octeon_fpa.c		optional rgmii
+mips/octeon1/dev/rgmii/octeon_ipd.c 		optional rgmii
+mips/octeon1/dev/rgmii/octeon_pko.c		optional rgmii
+mips/octeon1/dev/rgmii/octeon_rgmx.c		optional rgmii
+mips/octeon1/obio.c				optional uart
+mips/octeon1/octeon_ebt3000_cf.c		optional cf
+mips/octeon1/octeon_machdep.c			standard
+mips/octeon1/uart_bus_octeonusart.c		optional uart
+mips/octeon1/uart_cpu_octeonusart.c		optional uart
+mips/octeon1/uart_dev_oct16550.c		optional uart
diff -I '.*' -Naur releng8/sys/mips/octeon1/obio.c svn/mips/sys/mips/octeon1/obio.c
--- releng8/src/sys/mips/octeon1/obio.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/obio.c	2009-09-08 11:01:51.000000000 -0700
@@ -0,0 +1,182 @@
+/*	$NetBSD: obio.c,v 1.11 2003/07/15 00:25:05 lukem Exp $	*/
+
+/*-
+ * Copyright (c) 2001, 2002, 2003 Wasabi Systems, Inc.
+ * All rights reserved.
+ *
+ * Written by Jason R. Thorpe for Wasabi Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed for the NetBSD Project by
+ *	Wasabi Systems, Inc.
+ * 4. The name of Wasabi Systems, Inc. may not be used to endorse
+ *    or promote products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * On-board device autoconfiguration support for Intel IQ80321
+ * evaluation boards.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/octeon1/obio.c 196236 2009-08-15 01:03:13Z imp $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h>
+
+#include <mips/octeon1/octeonreg.h>
+#include <mips/octeon1/obiovar.h>
+
+int	obio_probe(device_t);
+int	obio_attach(device_t);
+
+/*
+ * We need only one obio.  Any other device hanging off of it,
+ * shouldn't cause multiple of these to be found.
+ */
+static int have_one = 0;
+
+int
+obio_probe(device_t dev)
+{
+	if (!have_one) {
+		have_one = 1;
+		return 0;
+	}
+	return (ENXIO);
+}
+
+int
+obio_attach(device_t dev)
+{
+	struct obio_softc *sc = device_get_softc(dev);
+
+	sc->oba_st = mips_bus_space_generic;
+	sc->oba_addr = OCTEON_UART0ADR;
+	sc->oba_size = 0x10000;
+	sc->oba_rman.rm_type = RMAN_ARRAY;
+	sc->oba_rman.rm_descr = "OBIO I/O";
+	if (rman_init(&sc->oba_rman) != 0 ||
+	    rman_manage_region(&sc->oba_rman,
+	    sc->oba_addr, sc->oba_addr + sc->oba_size) != 0)
+		panic("obio_attach: failed to set up I/O rman");
+	sc->oba_irq_rman.rm_type = RMAN_ARRAY;
+	sc->oba_irq_rman.rm_descr = "OBIO IRQ";
+
+	/* 
+	 * This module is intended for UART purposes only and
+	 * it's IRQ is 0  corresponding to IP2.
+	 */
+	if (rman_init(&sc->oba_irq_rman) != 0 ||
+	    rman_manage_region(&sc->oba_irq_rman, 0, 0) != 0)
+		panic("obio_attach: failed to set up IRQ rman");
+
+	device_add_child(dev, "uart", 1);  /* Setup Uart-1 first. */
+	device_add_child(dev, "uart", 0);  /* Uart-0 next. So it is first in console list */
+	bus_generic_probe(dev);
+	bus_generic_attach(dev);
+	return (0);
+}
+
+static struct resource *
+obio_alloc_resource(device_t bus, device_t child, int type, int *rid,
+    u_long start, u_long end, u_long count, u_int flags)
+{
+	struct resource *rv;
+	struct rman *rm;
+	bus_space_tag_t bt = 0;
+	bus_space_handle_t bh = 0;
+	struct obio_softc *sc = device_get_softc(bus);
+
+	switch (type) {
+	case SYS_RES_IRQ:
+		rm = &sc->oba_irq_rman;
+		break;
+	case SYS_RES_MEMORY:
+		return (NULL);
+	case SYS_RES_IOPORT:
+		rm = &sc->oba_rman;
+		bt = sc->oba_st;
+		bh = device_get_unit(child) ? OCTEON_UART1ADR : OCTEON_UART0ADR;
+		start = bh;
+		break;
+	default:
+		return (NULL);
+	}
+
+	rv = rman_reserve_resource(rm, start, end, count, flags, child);
+	if (rv == NULL)  {
+		return (NULL);
+        }
+	if (type == SYS_RES_IRQ) {
+		return (rv);
+        }
+	rman_set_rid(rv, *rid);
+	rman_set_bustag(rv, bt);
+	rman_set_bushandle(rv, bh);
+	
+	if (0) {
+		if (bus_activate_resource(child, type, *rid, rv)) {
+			rman_release_resource(rv);
+			return (NULL);
+		}
+	}
+	return (rv);
+
+}
+
+static int
+obio_activate_resource(device_t bus, device_t child, int type, int rid,
+    struct resource *r)
+{
+	return (0);
+}
+static device_method_t obio_methods[] = {
+	DEVMETHOD(device_probe, obio_probe),
+	DEVMETHOD(device_attach, obio_attach),
+
+	DEVMETHOD(bus_alloc_resource, obio_alloc_resource),
+	DEVMETHOD(bus_activate_resource, obio_activate_resource),
+	DEVMETHOD(bus_setup_intr,	bus_generic_setup_intr),
+	DEVMETHOD(bus_teardown_intr,	bus_generic_teardown_intr),
+
+	{0, 0},
+};
+
+static driver_t obio_driver = {
+	"obio",
+	obio_methods,
+	sizeof(struct obio_softc),
+};
+static devclass_t obio_devclass;
+
+DRIVER_MODULE(obio, nexus, obio_driver, obio_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/octeon1/obiovar.h svn/mips/sys/mips/octeon1/obiovar.h
--- releng8/src/sys/mips/octeon1/obiovar.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/obiovar.h	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,58 @@
+/*	$NetBSD: obiovar.h,v 1.4 2003/06/16 17:40:53 thorpej Exp $	*/
+
+/*-
+ * Copyright (c) 2002, 2003 Wasabi Systems, Inc.
+ * All rights reserved.
+ *
+ * Written by Jason R. Thorpe for Wasabi Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed for the NetBSD Project by
+ *	Wasabi Systems, Inc.
+ * 4. The name of Wasabi Systems, Inc. may not be used to endorse
+ *    or promote products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: projects/mips/sys/mips/octeon1/obiovar.h 194140 2009-06-14 02:46:07Z imp $
+ *
+ */
+
+#ifndef _OCTEON_OBIOVAR_H_
+#define	_OCTEON_OBIOVAR_H_
+
+#include <sys/rman.h>
+
+struct obio_softc {
+	bus_space_tag_t oba_st;		/* bus space tag */
+	bus_addr_t oba_addr;		/* address of device */
+	bus_size_t oba_size;		/* size of device */
+	int oba_width;			/* bus width */
+	int oba_irq;			/* XINT interrupt bit # */
+	struct rman oba_rman;
+	struct rman oba_irq_rman;
+	
+};
+extern struct bus_space obio_bs_tag;
+
+#endif /* _OCTEON_OBIOVAR_H_ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/octeon_ebt3000_cf.c svn/mips/sys/mips/octeon1/octeon_ebt3000_cf.c
--- releng8/src/sys/mips/octeon1/octeon_ebt3000_cf.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/octeon_ebt3000_cf.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,621 @@
+/*
+ *  octeon_ebt3000_cf.c
+ *
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/octeon1/octeon_ebt3000_cf.c 195414 2009-07-06 18:18:27Z imp $");
+
+#include <sys/param.h>
+#include <sys/bio.h>
+#include <sys/systm.h>
+#include <sys/sysctl.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/rman.h>
+#include <sys/power.h>
+#include <sys/smp.h>
+#include <sys/time.h>
+#include <sys/timetc.h>
+#include <sys/malloc.h>
+
+#include <geom/geom.h>
+
+#include <machine/clock.h>
+#include <machine/locore.h>
+#include <machine/md_var.h>
+#include <machine/cpuregs.h>
+
+#include "octeon_ebt3000_cf.h"
+#include "driveid.h"
+#include <mips/octeon1/octeon_pcmap_regs.h>
+
+/* ATA Commands */
+#define CMD_READ_SECTOR		0x20
+#define CMD_WRITE_SECTOR	0x30
+#define CMD_IDENTIFY		0xEC
+
+/* The ATA Task File */
+#define TF_DATA			0x00
+#define TF_ERROR		0x01
+#define TF_PRECOMP		0x01
+#define TF_SECTOR_COUNT		0x02
+#define TF_SECTOR_NUMBER	0x03
+#define TF_CYL_LSB		0x04
+#define TF_CYL_MSB		0x05
+#define TF_DRV_HEAD		0x06
+#define TF_STATUS		0x07
+#define TF_COMMAND		0x07
+
+/* Status Register */
+#define STATUS_BSY		0x80	/* Drive is busy */
+#define STATUS_RDY		0x40	/* Drive is ready */
+#define STATUS_DRQ		0x08	/* Data can be transferred */
+
+/* Miscelaneous */
+#define SECTOR_SIZE		512
+#define WAIT_DELAY		1000
+#define NR_TRIES		1000
+#define SWAP_SHORT(x)		((x << 8) | (x >> 8))
+#define SWAP_LONG(x)		(((x << 24) & 0xFF000000) | ((x <<  8) & 0x00FF0000) | \
+				 ((x >> 8) & 0x0000FF00)  | ((x << 24) & 0x000000FF) )
+#define MODEL_STR_SIZE		40
+
+
+/* Globals */
+int	bus_width;
+void	*base_addr;
+
+/* Device softc */
+struct cf_priv {
+
+	device_t dev;
+	struct drive_param *drive_param;
+
+	struct bio_queue_head cf_bq;
+	struct g_geom *cf_geom;
+	struct g_provider *cf_provider;
+
+};
+
+/* Device parameters */
+struct drive_param{
+	union {
+		char buf[SECTOR_SIZE];
+		struct hd_driveid driveid;
+	} u;
+
+	char model[MODEL_STR_SIZE];
+	uint32_t nr_sectors;
+	uint16_t sector_size;
+	uint16_t heads;
+	uint16_t tracks;
+	uint16_t sec_track;
+
+} drive_param;
+
+/* GEOM class implementation */
+static g_access_t       cf_access;
+static g_start_t        cf_start;
+static g_ioctl_t        cf_ioctl;
+
+struct g_class g_cf_class = {
+        .name =         "CF",
+        .version =      G_VERSION,
+        .start =        cf_start,
+        .access =       cf_access,
+        .ioctl =        cf_ioctl,
+};
+
+/* Device methods */
+static int	cf_probe(device_t);
+static void	cf_identify(driver_t *, device_t);
+static int	cf_attach(device_t);
+static int	cf_attach_geom(void *, int);
+
+/* ATA methods */
+static void	cf_cmd_identify(void);
+static void	cf_cmd_write(uint32_t, uint32_t, void *);
+static void	cf_cmd_read(uint32_t, uint32_t, void *);
+static void	cf_wait_busy(void);
+static void	cf_send_cmd(uint32_t, uint8_t);
+static void	cf_attach_geom_proxy(void *arg, int flag);
+
+/* Miscelenous */
+static void	cf_swap_ascii(unsigned char[], char[]);
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_access()                                    *
+ * ------------------------------------------------------------------- */
+static int cf_access (struct g_provider *pp, int r, int w, int e)
+{
+
+	pp->sectorsize = drive_param.sector_size;
+        pp->stripesize = drive_param.heads * drive_param.sec_track * drive_param.sector_size;
+        pp->mediasize  = pp->stripesize * drive_param.tracks;
+
+	return (0);
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_start()                                     *
+ * ------------------------------------------------------------------- */
+static void cf_start (struct bio *bp)
+{
+	/*
+	* Handle actual I/O requests. The request is passed down through
+	* the bio struct.
+	*/
+
+	if(bp->bio_cmd & BIO_GETATTR) {
+		if (g_handleattr_int(bp, "GEOM::fwsectors", drive_param.sec_track))
+                        return;
+                if (g_handleattr_int(bp, "GEOM::fwheads",   drive_param.heads))
+                        return;
+                g_io_deliver(bp, ENOIOCTL);
+                return;
+	}
+
+	if ((bp->bio_cmd & (BIO_READ | BIO_WRITE))) {
+
+		if (bp->bio_cmd & BIO_READ) {
+			cf_cmd_read(bp->bio_length / drive_param.sector_size,
+					bp->bio_offset / drive_param.sector_size, bp->bio_data);
+
+		} else if (bp->bio_cmd & BIO_WRITE) {
+			cf_cmd_write(bp->bio_length / drive_param.sector_size,
+					bp->bio_offset/drive_param.sector_size, bp->bio_data);
+		}
+
+		bp->bio_resid = 0;
+		bp->bio_completed = bp->bio_length;
+		g_io_deliver(bp, 0);
+	}
+}
+
+
+static int cf_ioctl (struct g_provider *pp, u_long cmd, void *data, int fflag, struct thread *td)
+{
+    return (0);
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_cmd_read()                                  *
+ * ------------------------------------------------------------------- *
+ *
+ *  Read nr_sectors from the device starting from start_sector.
+ */
+static void cf_cmd_read (uint32_t nr_sectors, uint32_t start_sector, void *buf)
+{
+	unsigned long lba;
+	uint32_t count;
+	uint16_t *ptr_16;
+	uint8_t  *ptr_8;
+
+//#define OCTEON_VISUAL_CF_0 1
+#ifdef OCTEON_VISUAL_CF_0
+        octeon_led_write_char(0, 'R');
+#endif
+	ptr_8  = (uint8_t*)buf;
+	ptr_16 = (uint16_t*)buf;
+	lba = start_sector; 
+
+
+	while (nr_sectors--) {
+
+		cf_send_cmd(lba, CMD_READ_SECTOR);
+
+		if (bus_width == 8) {
+			volatile uint8_t *task_file = (volatile uint8_t*)base_addr;
+        		volatile uint8_t dummy;
+			for (count = 0; count < SECTOR_SIZE; count++) {
+				*ptr_8++ = task_file[TF_DATA];
+				if ((count & 0xf) == 0) dummy = task_file[TF_STATUS];
+			}
+		} else {
+			volatile uint16_t *task_file = (volatile uint16_t*)base_addr;
+        		volatile uint16_t dummy;
+			for (count = 0; count < SECTOR_SIZE; count+=2) {
+				uint16_t temp;
+				temp = task_file[TF_DATA];
+				*ptr_16++ = SWAP_SHORT(temp);
+				if ((count & 0xf) == 0) dummy = task_file[TF_STATUS/2];
+			}
+		}  
+
+		lba ++;
+	}
+#ifdef OCTEON_VISUAL_CF_0
+        octeon_led_write_char(0, ' ');
+#endif
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_cmd_write()                                 *
+ * ------------------------------------------------------------------- *
+ *
+ * Write nr_sectors to the device starting from start_sector.
+ */
+static void cf_cmd_write (uint32_t nr_sectors, uint32_t start_sector, void *buf)
+{
+	uint32_t lba;
+	uint32_t count;
+	uint16_t *ptr_16;
+	uint8_t  *ptr_8;
+	
+//#define OCTEON_VISUAL_CF_1 1
+#ifdef OCTEON_VISUAL_CF_1
+        octeon_led_write_char(1, 'W');
+#endif
+	lba = start_sector;
+	ptr_8  = (uint8_t*)buf;
+	ptr_16 = (uint16_t*)buf;
+
+	while (nr_sectors--) {
+
+		cf_send_cmd(lba, CMD_WRITE_SECTOR);
+
+		if (bus_width == 8) {
+			volatile uint8_t *task_file;
+        		volatile uint8_t dummy;
+
+			task_file = (volatile uint8_t *) base_addr;
+			for (count = 0; count < SECTOR_SIZE; count++) {
+				task_file[TF_DATA] =  *ptr_8++;
+				if ((count & 0xf) == 0) dummy = task_file[TF_STATUS];
+			}
+		} else {
+			volatile uint16_t *task_file;
+        		volatile uint16_t dummy;
+
+			task_file = (volatile uint16_t *) base_addr;
+			for (count = 0; count < SECTOR_SIZE; count+=2) {
+				uint16_t temp = *ptr_16++;
+				task_file[TF_DATA] =  SWAP_SHORT(temp);
+				if ((count & 0xf) == 0) dummy = task_file[TF_STATUS/2];
+			}
+		} 
+
+		lba ++;
+	}
+#ifdef OCTEON_VISUAL_CF_1
+        octeon_led_write_char(1, ' ');
+#endif
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_cmd_identify()                              *
+ * ------------------------------------------------------------------- *
+ *
+ * Read parameters and other information from the drive and store 
+ * it in the drive_param structure
+ *
+ */
+static void cf_cmd_identify (void)
+{
+	int count;
+	uint8_t status;
+
+	if (bus_width == 8) {
+        	volatile uint8_t *task_file;
+
+        	task_file = (volatile uint8_t *) base_addr;
+
+		while ((status = task_file[TF_STATUS]) & STATUS_BSY) {
+			DELAY(WAIT_DELAY);
+        	}
+
+        	task_file[TF_SECTOR_COUNT]  = 0;
+        	task_file[TF_SECTOR_NUMBER] = 0;
+        	task_file[TF_CYL_LSB]  = 0;
+        	task_file[TF_CYL_MSB]  = 0;
+        	task_file[TF_DRV_HEAD] = 0;
+        	task_file[TF_COMMAND]  = CMD_IDENTIFY;
+
+		cf_wait_busy();
+
+        	for (count = 0; count < SECTOR_SIZE; count++) 
+               	 	drive_param.u.buf[count] = task_file[TF_DATA];
+
+	} else {
+		volatile uint16_t *task_file;
+
+		task_file = (volatile uint16_t *) base_addr;
+
+		while ((status = (task_file[TF_STATUS/2]>>8)) & STATUS_BSY) {
+			DELAY(WAIT_DELAY);
+		}
+
+		task_file[TF_SECTOR_COUNT/2]  = 0; /* this includes TF_SECTOR_NUMBER */
+		task_file[TF_CYL_LSB/2]  = 0; /* this includes TF_CYL_MSB */
+		task_file[TF_DRV_HEAD/2] = 0 | (CMD_IDENTIFY<<8); /* this includes TF_COMMAND */
+
+		cf_wait_busy();
+
+		for (count = 0; count < SECTOR_SIZE; count+=2) {
+			uint16_t temp;
+			temp = task_file[TF_DATA];
+			
+			/* endianess will be swapped below */
+			drive_param.u.buf[count]   = (temp & 0xff);
+			drive_param.u.buf[count+1] = (temp & 0xff00)>>8;
+		}
+	}
+
+	cf_swap_ascii(drive_param.u.driveid.model, drive_param.model);
+
+	drive_param.sector_size =  512;   //=  SWAP_SHORT (drive_param.u.driveid.sector_bytes);
+	drive_param.heads 	=  SWAP_SHORT (drive_param.u.driveid.cur_heads);
+	drive_param.tracks	=  SWAP_SHORT (drive_param.u.driveid.cur_cyls); 
+	drive_param.sec_track   =  SWAP_SHORT (drive_param.u.driveid.cur_sectors);
+	drive_param.nr_sectors  =  SWAP_LONG  (drive_param.u.driveid.lba_capacity);
+
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_send_cmd()                                  *
+ * ------------------------------------------------------------------- *
+ *
+ * Send command to read/write one sector specified by lba.
+ *
+ */
+static void cf_send_cmd (uint32_t lba, uint8_t cmd)
+{
+	uint8_t status;
+
+	if (bus_width == 8) {
+		volatile uint8_t *task_file;
+
+		task_file = (volatile uint8_t *) base_addr;
+
+		while ( (status = task_file[TF_STATUS]) & STATUS_BSY) {
+			DELAY(WAIT_DELAY);
+		}
+
+		task_file[TF_SECTOR_COUNT]  = 1;
+		task_file[TF_SECTOR_NUMBER] = (lba & 0xff);
+		task_file[TF_CYL_LSB]  =  ((lba >> 8) & 0xff);
+		task_file[TF_CYL_MSB]  =  ((lba >> 16) & 0xff);
+		task_file[TF_DRV_HEAD] =  ((lba >> 24) & 0xff) | 0xe0; 
+		task_file[TF_COMMAND]  =  cmd;
+
+	} else {
+		volatile uint16_t *task_file;
+
+		task_file = (volatile uint16_t *) base_addr;
+
+		while ( (status = (task_file[TF_STATUS/2]>>8)) & STATUS_BSY) {
+			DELAY(WAIT_DELAY);
+		}
+
+		task_file[TF_SECTOR_COUNT/2]  = 1 | ((lba & 0xff) << 8);
+		task_file[TF_CYL_LSB/2]  =  ((lba >> 8) & 0xff) | (((lba >> 16) & 0xff) << 8);
+		task_file[TF_DRV_HEAD/2] =  (((lba >> 24) & 0xff) | 0xe0) | (cmd << 8); 
+
+	}
+
+	cf_wait_busy();
+}
+
+/* ------------------------------------------------------------------- *
+ *                      cf_wait_busy()                                 *
+ * ------------------------------------------------------------------- *
+ *
+ * Wait until the drive finishes a given command and data is
+ * ready to be transferred. This is done by repeatedly checking 
+ * the BSY and DRQ bits of the status register. When the controller
+ * is ready for data transfer, it clears the BSY bit and sets the 
+ * DRQ bit.
+ *
+ */
+static void cf_wait_busy (void)
+{
+	uint8_t status;
+
+//#define OCTEON_VISUAL_CF_2 1
+#ifdef OCTEON_VISUAL_CF_2
+        static int where0 = 0;
+
+        octeon_led_run_wheel(&where0, 2);
+#endif
+
+	if (bus_width == 8) {
+		volatile uint8_t *task_file;
+		task_file = (volatile uint8_t *)base_addr;
+
+		status = task_file[TF_STATUS];	
+		while ((status & STATUS_BSY) == STATUS_BSY || (status & STATUS_DRQ) != STATUS_DRQ ) {
+			DELAY(WAIT_DELAY);
+			status = task_file[TF_STATUS];
+		}
+	} else {
+		volatile uint16_t *task_file;
+		task_file = (volatile uint16_t *)base_addr;
+
+		status = task_file[TF_STATUS/2]>>8;	
+		while ((status & STATUS_BSY) == STATUS_BSY || (status & STATUS_DRQ) != STATUS_DRQ ) {
+			DELAY(WAIT_DELAY);
+			status = (uint8_t)(task_file[TF_STATUS/2]>>8);
+		}
+	}
+
+#ifdef OCTEON_VISUAL_CF_2
+        octeon_led_write_char(2, ' ');
+#endif
+}
+
+/* ------------------------------------------------------------------- *
+ *                      cf_swap_ascii()                                *
+ * ------------------------------------------------------------------- *
+ *
+ * The ascii string returned by the controller specifying 
+ * the model of the drive is byte-swaped. This routine 
+ * corrects the byte ordering.
+ *
+ */
+static void cf_swap_ascii (unsigned char str1[], char str2[])
+{
+	int i;
+
+	for(i = 0; i < MODEL_STR_SIZE; i++) {
+            str2[i] = str1[i^1];
+        }
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_probe()                                     *
+ * ------------------------------------------------------------------- */
+
+static int cf_probe (device_t dev)
+{
+    	if (!octeon_board_real()) return 1;
+
+	if (device_get_unit(dev) != 0) {
+                panic("can't attach more devices\n");
+        }
+
+        device_set_desc(dev, "Octeon Compact Flash Driver");
+
+	cf_cmd_identify();
+
+        return (0);
+}
+
+/* ------------------------------------------------------------------- *
+ *                      cf_identify()                                  *
+ * ------------------------------------------------------------------- *
+ *
+ * Find the bootbus region for the CF to determine 
+ * 16 or 8 bit and check to see if device is 
+ * inserted.
+ *
+ */
+static void cf_identify (driver_t *drv, device_t parent)
+{
+	uint8_t status;
+        int bus_region;
+	int count = 0;
+        octeon_mio_boot_reg_cfgx_t cfg;
+
+
+    	if (!octeon_board_real())
+		return;
+
+	base_addr = (void *) MIPS_PHYS_TO_KSEG0(OCTEON_CF_COMMON_BASE_ADDR);
+
+        for (bus_region = 0; bus_region < 8; bus_region++)
+        {
+                cfg.word64 = oct_read64(OCTEON_MIO_BOOT_REG_CFGX(bus_region));
+                if (cfg.bits.base == OCTEON_CF_COMMON_BASE_ADDR >> 16)
+                {
+                        bus_width = (cfg.bits.width) ? 16: 8;
+                        printf("Compact flash found in bootbus region %d (%d bit).\n", bus_region, bus_width);
+                        break;
+                }
+        }
+
+	if (bus_width == 8) {
+		volatile uint8_t *task_file;
+		task_file = (volatile uint8_t *) base_addr;
+		/* Check if CF is inserted */
+		while ( (status = task_file[TF_STATUS]) & STATUS_BSY){
+			if ((count++) == NR_TRIES )     {
+				printf("Compact Flash not present\n");
+				return;
+                	}
+			DELAY(WAIT_DELAY);
+        	}
+	} else {
+		volatile uint16_t *task_file;
+		task_file = (volatile uint16_t *) base_addr;
+		/* Check if CF is inserted */
+		while ( (status = (task_file[TF_STATUS/2]>>8)) & STATUS_BSY){
+			if ((count++) == NR_TRIES )     {
+				printf("Compact Flash not present\n");
+				return;
+                	}
+			DELAY(WAIT_DELAY);
+        	}
+	}
+
+	BUS_ADD_CHILD(parent, 0, "cf", 0);
+}
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_attach_geom()                               *
+ * ------------------------------------------------------------------- */
+
+static int cf_attach_geom (void *arg, int flag)
+{
+	struct cf_priv *cf_priv;
+
+	cf_priv = (struct cf_priv *) arg;
+	cf_priv->cf_geom = g_new_geomf(&g_cf_class, "cf%d", device_get_unit(cf_priv->dev));
+	cf_priv->cf_provider = g_new_providerf(cf_priv->cf_geom, cf_priv->cf_geom->name);
+	cf_priv->cf_geom->softc = cf_priv;
+        g_error_provider(cf_priv->cf_provider, 0);
+
+        return (0);
+}
+
+/* ------------------------------------------------------------------- *
+ *                      cf_attach_geom()                               *
+ * ------------------------------------------------------------------- */
+static void cf_attach_geom_proxy (void *arg, int flag)
+{
+    cf_attach_geom(arg, flag);
+}
+
+
+
+/* ------------------------------------------------------------------- *
+ *                      cf_attach()                                    *
+ * ------------------------------------------------------------------- */
+
+static int cf_attach (device_t dev)
+{
+	struct cf_priv *cf_priv;
+
+    	if (!octeon_board_real()) return 1;
+
+	cf_priv = device_get_softc(dev);
+	cf_priv->dev = dev;
+	cf_priv->drive_param = &drive_param;
+
+	g_post_event(cf_attach_geom_proxy, cf_priv, M_WAITOK, NULL);
+	bioq_init(&cf_priv->cf_bq);
+
+        return 0;
+}
+
+
+static device_method_t cf_methods[] = {
+        /* Device interface */
+        DEVMETHOD(device_probe,         cf_probe),
+        DEVMETHOD(device_identify,      cf_identify),
+        DEVMETHOD(device_attach,        cf_attach),
+        DEVMETHOD(device_detach,        bus_generic_detach),
+        DEVMETHOD(device_shutdown,      bus_generic_shutdown),
+
+        { 0, 0 }
+};
+
+static driver_t cf_driver = {
+        "cf", 
+	cf_methods, 
+	sizeof(struct cf_priv)
+};
+
+static devclass_t cf_devclass;
+
+DRIVER_MODULE(cf, nexus, cf_driver, cf_devclass, 0, 0);
+
diff -I '.*' -Naur releng8/sys/mips/octeon1/octeon_ebt3000_cf.h svn/mips/sys/mips/octeon1/octeon_ebt3000_cf.h
--- releng8/src/sys/mips/octeon1/octeon_ebt3000_cf.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/octeon_ebt3000_cf.h	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,35 @@
+/*
+ *  octeon_ebt3000_cf.h
+ *
+ */
+
+
+#ifndef  __OCTEON_EBT3000_H__
+#define  __OCTEON_EBT3000_H__
+
+
+
+#define OCTEON_CF_COMMON_BASE_ADDR		(0x1d000000 | (1 << 11))
+#define OCTEON_MIO_BOOT_REG_CFGX(offset)	(0x8001180000000000ull + ((offset) * 8))
+
+
+typedef union
+{   
+    uint64_t	word64;
+    struct
+    {
+        uint64_t reserved                : 27;      /**< Reserved */
+        uint64_t sam                     : 1;       /**< Region 0 SAM */
+        uint64_t we_ext                  : 2;       /**< Region 0 write enable count extension */
+        uint64_t oe_ext                  : 2;       /**< Region 0 output enable count extension */
+        uint64_t en                      : 1;       /**< Region 0 enable */
+        uint64_t orbit                   : 1;       /**< No function for region 0 */
+        uint64_t ale                     : 1;       /**< Region 0 ALE mode */
+        uint64_t width                   : 1;       /**< Region 0 bus width */
+        uint64_t size                    : 12;      /**< Region 0 size */
+        uint64_t base                    : 16;      /**< Region 0 base address */
+    } bits;
+} octeon_mio_boot_reg_cfgx_t;
+
+
+#endif  /* __OCTEON_EBT3000_H__ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/octeon_machdep.c svn/mips/sys/mips/octeon1/octeon_machdep.c
--- releng8/src/sys/mips/octeon1/octeon_machdep.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/octeon_machdep.c	2009-09-08 11:01:51.000000000 -0700
@@ -0,0 +1,1012 @@
+/*-
+ * Copyright (c) 2006 Wojciech A. Koszek <wkoszek@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: projects/mips/sys/mips/octeon1/octeon_machdep.c 196314 2009-08-17 12:23:58Z imp $
+ */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/octeon1/octeon_machdep.c 196314 2009-08-17 12:23:58Z imp $");
+
+#include <sys/param.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/imgact.h>
+#include <sys/bio.h>
+#include <sys/buf.h>
+#include <sys/bus.h>
+#include <sys/cpu.h>
+#include <sys/cons.h>
+#include <sys/exec.h>
+#include <sys/ucontext.h>
+#include <sys/proc.h>
+#include <sys/kdb.h>
+#include <sys/ptrace.h>
+#include <sys/reboot.h>
+#include <sys/signalvar.h>
+#include <sys/sysent.h>
+#include <sys/sysproto.h>
+#include <sys/user.h>
+
+#include <vm/vm.h>
+#include <vm/vm_object.h>
+#include <vm/vm_page.h>
+#include <vm/vm_pager.h>
+
+#include <machine/atomic.h>
+#include <machine/cache.h>
+#include <machine/clock.h>
+#include <machine/cpu.h>
+#include <machine/cpuregs.h>
+#include <machine/cpufunc.h>
+#include <mips/octeon1/octeon_pcmap_regs.h>
+#include <mips/octeon1/octeonreg.h>
+#include <machine/hwfunc.h>
+#include <machine/intr_machdep.h>
+#include <machine/locore.h>
+#include <machine/md_var.h>
+#include <machine/pcpu.h>
+#include <machine/pte.h>
+#include <machine/trap.h>
+#include <machine/vmparam.h>
+
+#if defined(__mips_n64) 
+#define MAX_APP_DESC_ADDR     0xffffffffafffffff
+#else
+#define MAX_APP_DESC_ADDR     0xafffffff
+#endif
+
+extern int	*edata;
+extern int	*end;
+
+
+/*
+ * Perform a board-level soft-reset.
+ * Note that this is not emulated by gxemul.
+ */
+void
+platform_reset(void)
+{
+	((void(*)(void))0x1fc00000)();	/* Jump to this hex address */
+}
+
+
+static inline uint32_t octeon_disable_interrupts (void)
+{
+    uint32_t status_bits;
+
+    status_bits = mips_rd_status();
+    mips_wr_status(status_bits & ~MIPS_SR_INT_IE);
+    return (status_bits);
+}
+
+
+static inline void octeon_set_interrupts (uint32_t status_bits)
+{
+    mips_wr_status(status_bits);
+}
+
+
+void octeon_led_write_char (int char_position, char val)
+{
+    uint64_t ptr = (OCTEON_CHAR_LED_BASE_ADDR | 0xf8);
+
+    if (!octeon_board_real()) return;
+
+    char_position &= 0x7;  /* only 8 chars */
+    ptr += char_position;
+    oct_write8_x8(ptr, val);
+}
+
+void octeon_led_write_char0 (char val)
+{
+    uint64_t ptr = (OCTEON_CHAR_LED_BASE_ADDR | 0xf8);
+
+    if (!octeon_board_real()) return;
+
+    oct_write8_x8(ptr, val);
+}
+
+void octeon_led_write_hexchar (int char_position, char hexval)
+{
+    uint64_t ptr = (OCTEON_CHAR_LED_BASE_ADDR | 0xf8);
+    char char1, char2;
+
+    if (!octeon_board_real()) return;
+
+    char1 = (hexval >> 4) & 0x0f; char1 = (char1 < 10)?char1+'0':char1+'7';
+    char2 = (hexval  & 0x0f); char2 = (char2 < 10)?char2+'0':char2+'7';
+    char_position &= 0x7;  /* only 8 chars */
+    if (char_position > 6) char_position = 6;
+    ptr += char_position;
+    oct_write8_x8(ptr, char1);
+    ptr++;
+    oct_write8_x8(ptr, char2);
+}
+
+void octeon_led_write_string (const char *str)
+{
+    uint64_t ptr = (OCTEON_CHAR_LED_BASE_ADDR | 0xf8);
+    int i;
+
+    if (!octeon_board_real()) return;
+
+    for (i=0; i<8; i++, ptr++) {
+        if (str && *str) {
+            oct_write8_x8(ptr, *str++);
+        } else {
+            oct_write8_x8(ptr, ' ');
+        }
+        oct_read64(OCTEON_MIO_BOOT_BIST_STAT);
+    }
+}
+
+static char progress[8] = { '-', '/', '|', '\\', '-', '/', '|', '\\'};
+
+void octeon_led_run_wheel (/*int count, */int *prog_count, int led_position)
+{
+    if (!octeon_board_real()) return;
+
+    octeon_led_write_char(led_position, progress[*prog_count]);
+    *prog_count += 1;
+    *prog_count &= 0x7;
+}
+
+#define LSR_DATAREADY        0x01    /* Data ready */
+#define LSR_THRE             0x20    /* Transmit holding register empty */
+#define LSR_TEMT	     0x40    /* Transmitter Empty. THR, TSR & FIFO */
+#define USR_TXFIFO_NOTFULL   0x02    /* Uart TX FIFO Not full */
+
+/*
+ * octeon_uart_write_byte
+ * 
+ * Put out a single byte off of uart port.
+ */
+
+void octeon_uart_write_byte (int uart_index, uint8_t ch)
+{
+    uint64_t val, val2;
+    if ((uart_index < 0) || (uart_index > 1)) {
+        return;
+    }
+
+    while (1) {
+        val = oct_read64(OCTEON_MIO_UART0_LSR + (uart_index * 0x400));
+        val2 = oct_read64(OCTEON_MIO_UART0_USR + (uart_index * 0x400));
+        if ((((uint8_t) val) & LSR_THRE) ||
+            (((uint8_t) val2) & USR_TXFIFO_NOTFULL)) {
+            break;
+        }
+    }
+
+    /* Write the byte */
+    oct_write8(OCTEON_MIO_UART0_THR + (uart_index * 0x400), (uint64_t) ch);
+
+    /* Force Flush the IOBus */
+    oct_read64(OCTEON_MIO_BOOT_BIST_STAT);
+}
+
+
+void octeon_uart_write_byte0 (uint8_t ch)
+{
+    uint64_t val, val2;
+
+    while (1) {
+        val = oct_read64(OCTEON_MIO_UART0_LSR);
+        val2 = oct_read64(OCTEON_MIO_UART0_USR);
+        if ((((uint8_t) val) & LSR_THRE) ||
+            (((uint8_t) val2) & USR_TXFIFO_NOTFULL)) {
+            break;
+        }
+    }
+
+    /* Write the byte */
+    oct_write8(OCTEON_MIO_UART0_THR, (uint64_t) ch);
+
+    /* Force Flush the IOBus */
+    oct_read64(OCTEON_MIO_BOOT_BIST_STAT);
+}
+
+/*
+ * octeon_uart_write_string
+ * 
+ */
+void octeon_uart_write_string (int uart_index, const char *str)
+{
+     /* Just loop writing one byte at a time */
+    
+    while (*str)
+    {
+        octeon_uart_write_byte(uart_index, *str);
+        if (*str == '\n') {
+            octeon_uart_write_byte(uart_index, '\r');
+        }
+        str++;
+    }
+ }
+
+static char wstr[30];
+
+void octeon_led_write_hex (uint32_t wl)
+{
+    char nbuf[80];
+
+    sprintf(nbuf, "%X", wl);
+    octeon_led_write_string(nbuf);
+}
+
+
+void octeon_uart_write_hex2 (uint32_t wl, uint32_t wh)
+{
+    sprintf(wstr, "0x%X-0x%X  ", wh, wl);
+    octeon_uart_write_string(0, wstr);
+}
+
+void octeon_uart_write_hex (uint32_t wl)
+{
+    sprintf(wstr, " 0x%X  ", wl);
+    octeon_uart_write_string(0, wstr);
+}
+
+#ifdef __not_used__
+#define OCT_CONS_BUFLEN	200
+static char console_str_buff0[OCT_CONS_BUFLEN + 1];
+#include <machine/stdarg.h>
+
+//#define USE_KERN_SUBR_PRINTF
+#ifndef USE_KERN_SUBR_PRINTF
+static int oct_printf (const char *fmt, va_list ap);
+#endif
+
+int kern_cons_printf(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+#ifndef USE_KERN_SUBR_PRINTF
+        oct_printf(fmt, ap);
+#else
+        ker_printf(fmt, ap);
+#endif
+        va_end(ap);
+        return (0);
+}
+
+#ifndef USE_KERN_SUBR_PRINTF
+static int oct_printf(const char *fmt, va_list ap)
+{
+        snprintf(console_str_buff0, OCT_CONS_BUFLEN, fmt, ap);
+        octeon_uart_write_string(0, console_str_buff0);
+        return (0);
+}
+#endif
+
+int console_printf(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+        sprintf(console_str_buff0, fmt, ap);
+        va_end(ap);
+        octeon_uart_write_string(0, console_str_buff0);
+        return (0);
+}
+#endif
+
+
+/*
+ * octeon_wait_uart_flush
+ */
+void octeon_wait_uart_flush (int uart_index, uint8_t ch)
+{
+    uint64_t val;
+    int64_t val3;
+    uint32_t cpu_status_bits;
+
+    if ((uart_index < 0) || (uart_index > 1)) {
+        return;
+    }
+
+    cpu_status_bits = octeon_disable_interrupts();
+    /* Force Flush the IOBus */
+    oct_read64(OCTEON_MIO_BOOT_BIST_STAT);
+    for (val3 = 0xfffffffff; val3 > 0; val3--) {
+        val = oct_read64(OCTEON_MIO_UART0_LSR + (uart_index * 0x400));
+        if (((uint8_t) val) & LSR_TEMT) {
+            break;
+        }
+    }
+    octeon_set_interrupts(cpu_status_bits);
+}
+
+
+/*
+ * octeon_debug_symbol
+ *
+ * Does nothing.
+ * Used to mark the point for simulator to begin tracing
+ */
+void octeon_debug_symbol (void)
+{
+}
+
+void octeon_ciu_stop_gtimer (int timer)
+{
+    oct_write64(OCTEON_CIU_GENTIMER_ADDR(timer), 0ll);
+}
+
+void octeon_ciu_start_gtimer (int timer, u_int one_shot, uint64_t time_cycles)
+{
+    	octeon_ciu_gentimer gentimer;
+
+        gentimer.word64 = 0;
+        gentimer.bits.one_shot = one_shot;
+        gentimer.bits.len = time_cycles - 1;
+        oct_write64(OCTEON_CIU_GENTIMER_ADDR(timer), gentimer.word64);
+}
+
+/*
+ * octeon_ciu_reset
+ *
+ * Shutdown all CIU to IP2, IP3 mappings
+ */
+void octeon_ciu_reset (void)
+{
+
+    octeon_ciu_stop_gtimer(CIU_GENTIMER_NUM_0);
+    octeon_ciu_stop_gtimer(CIU_GENTIMER_NUM_1);
+    octeon_ciu_stop_gtimer(CIU_GENTIMER_NUM_2);
+    octeon_ciu_stop_gtimer(CIU_GENTIMER_NUM_3);
+
+    ciu_disable_intr(CIU_THIS_CORE, CIU_INT_0, CIU_EN_0);
+    ciu_disable_intr(CIU_THIS_CORE, CIU_INT_0, CIU_EN_1);
+    ciu_disable_intr(CIU_THIS_CORE, CIU_INT_1, CIU_EN_0);
+    ciu_disable_intr(CIU_THIS_CORE, CIU_INT_1, CIU_EN_1);
+
+    ciu_clear_int_summary(CIU_THIS_CORE, CIU_INT_0, CIU_EN_0, 0ll);
+    ciu_clear_int_summary(CIU_THIS_CORE, CIU_INT_1, CIU_EN_0, 0ll);
+    ciu_clear_int_summary(CIU_THIS_CORE, CIU_INT_1, CIU_EN_1, 0ll);
+}
+
+/*
+ * mips_disable_interrupt_controllers
+ *
+ * Disable interrupts in the CPU controller
+ */
+void mips_disable_interrupt_controls (void)
+{
+    /*
+     * Disable interrupts in CIU.
+     */
+    octeon_ciu_reset();
+}
+
+static uint64_t ciu_get_intr_sum_reg_addr(int core_num, int intx, int enx);
+
+/*
+ * ciu_get_intr_sum_reg_addr
+ */
+static uint64_t ciu_get_intr_sum_reg_addr (int core_num, int intx, int enx)
+{
+    uint64_t ciu_intr_sum_reg_addr;
+
+    	if (enx == CIU_EN_0) {
+            	ciu_intr_sum_reg_addr = OCTEON_CIU_SUMMARY_BASE_ADDR + (core_num * 0x10) +
+                                        (intx * 0x8);
+        } else {
+            	ciu_intr_sum_reg_addr = OCTEON_CIU_SUMMARY_INT1_ADDR;
+        }
+
+        return (ciu_intr_sum_reg_addr);
+}
+
+
+static uint64_t ciu_get_intr_en_reg_addr(int core_num, int intx, int enx);
+
+/*
+ * ciu_get_intr_en_reg_addr
+ */
+static uint64_t ciu_get_intr_en_reg_addr (int core_num, int intx, int enx)
+{
+    uint64_t ciu_intr_reg_addr;
+
+
+    	ciu_intr_reg_addr = OCTEON_CIU_ENABLE_BASE_ADDR + ((enx == 0) ? 0x0 : 0x8) +
+                            (intx * 0x10) +  (core_num * 0x20);
+
+        return (ciu_intr_reg_addr);
+}
+
+
+
+
+uint64_t ciu_get_en_reg_addr_new (int corenum, int intx, int enx, int ciu_ip);
+
+/*
+ * ciu_get_intr_reg_addr
+ *
+ * 200 ---int0,en0 ip2
+ * 208 ---int0,en1 ip2 ----> this is wrong... this is watchdog
+ * 
+ * 210 ---int0,en0 ip3 --
+ * 218 ---int0,en1 ip3 ----> same here.. .this is watchdog... right?
+ * 
+ * 220 ---int1,en0 ip2
+ * 228 ---int1,en1 ip2
+ * 230 ---int1,en0 ip3 --
+ * 238 ---int1,en1 ip3
+ *
+ */
+uint64_t ciu_get_en_reg_addr_new (int corenum, int intx, int enx, int ciu_ip)
+{
+    uint64_t ciu_intr_reg_addr = OCTEON_CIU_ENABLE_BASE_ADDR;
+
+    if (enx < CIU_EN_0 || enx > CIU_EN_1) {
+        printf("%s: invalid enx value %d, should be %d or %d\n",
+               __FUNCTION__, enx, CIU_EN_0, CIU_EN_1);
+        return 0;
+    }
+    if (intx < CIU_INT_0 || intx > CIU_INT_1) {
+        printf("%s: invalid intx value %d, should be %d or %d\n",
+               __FUNCTION__, enx, CIU_INT_0, CIU_INT_1);
+        return 0;
+    }
+    if (ciu_ip < CIU_MIPS_IP2 || ciu_ip > CIU_MIPS_IP3) {
+        printf("%s: invalid ciu_ip value %d, should be %d or %d\n",
+               __FUNCTION__, ciu_ip, CIU_MIPS_IP2, CIU_MIPS_IP3);
+        return 0;
+    }
+
+    ciu_intr_reg_addr += (enx    * 0x8);
+    ciu_intr_reg_addr += (ciu_ip * 0x10);
+    ciu_intr_reg_addr += (intx   * 0x20);
+
+    return (ciu_intr_reg_addr);
+}
+
+/*
+ * ciu_get_int_summary
+ */
+uint64_t ciu_get_int_summary (int core_num, int intx, int enx)
+{
+    uint64_t ciu_intr_sum_reg_addr;
+
+    if (core_num == CIU_THIS_CORE) {
+        	core_num = octeon_get_core_num();
+    }
+    ciu_intr_sum_reg_addr = ciu_get_intr_sum_reg_addr(core_num, intx, enx);
+    return (oct_read64(ciu_intr_sum_reg_addr));
+}
+
+//#define DEBUG_CIU 1
+
+#ifdef DEBUG_CIU
+#define DEBUG_CIU_SUM 1
+#define DEBUG_CIU_EN 1
+#endif
+
+
+/*
+ * ciu_clear_int_summary
+ */
+void ciu_clear_int_summary (int core_num, int intx, int enx, uint64_t write_bits)
+{
+    uint32_t cpu_status_bits;
+    uint64_t ciu_intr_sum_reg_addr;
+
+//#define DEBUG_CIU_SUM 1
+
+#ifdef DEBUG_CIU_SUM
+    uint64_t ciu_intr_sum_bits;
+#endif
+
+
+    if (core_num == CIU_THIS_CORE) {
+        	core_num = octeon_get_core_num();
+    }
+
+#ifdef DEBUG_CIU_SUM
+        printf(" CIU: core %u clear sum IntX %u  Enx %u  Bits: 0x%llX\n",
+               core_num, intx, enx, write_bits);
+#endif
+
+    cpu_status_bits = octeon_disable_interrupts();
+
+    ciu_intr_sum_reg_addr = ciu_get_intr_sum_reg_addr(core_num, intx, enx);
+
+#ifdef DEBUG_CIU_SUM
+    	ciu_intr_sum_bits =  oct_read64(ciu_intr_sum_reg_addr);	/* unneeded dummy read */
+        printf(" CIU: status: 0x%X  reg_addr: 0x%llX   Val: 0x%llX   ->  0x%llX",
+               cpu_status_bits, ciu_intr_sum_reg_addr, ciu_intr_sum_bits,
+               ciu_intr_sum_bits | write_bits);
+#endif
+
+    oct_write64(ciu_intr_sum_reg_addr, write_bits);
+    oct_read64(OCTEON_MIO_BOOT_BIST_STAT);	/* Bus Barrier */
+
+#ifdef DEBUG_CIU_SUM
+        printf(" Readback: 0x%llX\n\n   ", (uint64_t) oct_read64(ciu_intr_sum_reg_addr));
+#endif
+    
+    octeon_set_interrupts(cpu_status_bits);
+}
+
+/*
+ * ciu_disable_intr
+ */
+void ciu_disable_intr (int core_num, int intx, int enx)
+{
+    uint32_t cpu_status_bits;
+    uint64_t ciu_intr_reg_addr;
+
+    if (core_num == CIU_THIS_CORE) {
+        	core_num = octeon_get_core_num();
+    }
+
+    cpu_status_bits = octeon_disable_interrupts();
+    
+    ciu_intr_reg_addr = ciu_get_intr_en_reg_addr(core_num, intx, enx);
+
+    oct_read64(ciu_intr_reg_addr);	/* Dummy read */
+
+    oct_write64(ciu_intr_reg_addr, 0LL);
+    oct_read64(OCTEON_MIO_BOOT_BIST_STAT);	/* Bus Barrier */
+
+    octeon_set_interrupts(cpu_status_bits);
+}
+
+void ciu_dump_interrutps_enabled (int core_num, int intx, int enx, int ciu_ip);
+void ciu_dump_interrutps_enabled (int core_num, int intx, int enx, int ciu_ip)
+{
+
+	uint64_t ciu_intr_reg_addr;
+	uint64_t ciu_intr_bits;
+
+        if (core_num == CIU_THIS_CORE) {
+            	core_num = octeon_get_core_num();
+        }
+
+#ifndef OCTEON_SMP_1
+	ciu_intr_reg_addr = ciu_get_intr_en_reg_addr(core_num, intx, enx);
+#else
+	ciu_intr_reg_addr = ciu_get_en_reg_addr_new(core_num, intx, enx, ciu_ip);
+#endif
+
+        if (!ciu_intr_reg_addr) {
+            printf("Bad call to %s\n", __FUNCTION__);
+            while(1);
+            return;
+        }
+
+	ciu_intr_bits =  oct_read64(ciu_intr_reg_addr);
+        printf(" CIU core %d  int: %d  en: %d  ip: %d  Add: %p  enabled: 0x%llX  SR: %x\n",
+	    core_num, intx, enx, ciu_ip, (void *)ciu_intr_reg_addr,
+	    (unsigned long long)ciu_intr_bits, mips_rd_status());
+}
+
+
+/*
+ * ciu_enable_interrupts
+ */
+void ciu_enable_interrupts (int core_num, int intx, int enx, uint64_t set_these_interrupt_bits,
+                            int ciu_ip)
+{
+
+	uint32_t cpu_status_bits;
+	uint64_t ciu_intr_reg_addr;
+	uint64_t ciu_intr_bits;
+
+        if (core_num == CIU_THIS_CORE) {
+            	core_num = octeon_get_core_num();
+        }
+
+//#define DEBUG_CIU_EN 1
+
+#ifdef DEBUG_CIU_EN
+        printf(" CIU: core %u enabling Intx %u  Enx %u IP %d  Bits: 0x%llX\n",
+               core_num, intx, enx, ciu_ip, set_these_interrupt_bits);
+#endif
+
+	cpu_status_bits = octeon_disable_interrupts();
+
+#ifndef OCTEON_SMP_1
+	ciu_intr_reg_addr = ciu_get_intr_en_reg_addr(core_num, intx, enx);
+#else
+	ciu_intr_reg_addr = ciu_get_en_reg_addr_new(core_num, intx, enx, ciu_ip);
+#endif
+
+        if (!ciu_intr_reg_addr) {
+            printf("Bad call to %s\n", __FUNCTION__);
+            while(1);
+            return;
+        }
+
+	ciu_intr_bits =  oct_read64(ciu_intr_reg_addr);
+
+#ifdef DEBUG_CIU_EN
+        printf(" CIU: status: 0x%X  reg_addr: 0x%llX   Val: 0x%llX   ->  0x%llX",
+               cpu_status_bits, ciu_intr_reg_addr, ciu_intr_bits, ciu_intr_bits | set_these_interrupt_bits);
+#endif
+	ciu_intr_bits |=  set_these_interrupt_bits;
+	oct_write64(ciu_intr_reg_addr, ciu_intr_bits);
+#ifdef OCTEON_SMP
+	mips_wbflush();
+#endif
+	oct_read64(OCTEON_MIO_BOOT_BIST_STAT);	/* Bus Barrier */
+
+#ifdef DEBUG_CIU_EN
+        printf(" Readback: 0x%llX\n\n   ", (uint64_t) oct_read64(ciu_intr_reg_addr));
+#endif
+
+	octeon_set_interrupts(cpu_status_bits);
+}
+
+void
+platform_start(__register_t a0, __register_t a1,
+    __register_t a2 __unused, __register_t a3 __unused)
+{
+	uint64_t platform_counter_freq;
+	vm_offset_t kernend;
+	int argc = a0;
+	char **argv = (char **)a1;
+	int i, mem;
+
+	/* clear the BSS and SBSS segments */
+	kernend = round_page((vm_offset_t)&end);
+	memset(&edata, 0, kernend - (vm_offset_t)(&edata));
+
+        octeon_ciu_reset();
+    	octeon_uart_write_string(0, "\nPlatform Starting");
+
+/* From here on down likely is bogus */
+	/*
+	 * Looking for mem=XXM argument
+	 */
+	mem = 0; /* Just something to start with */
+	for (i=0; i < argc; i++) {
+		if (strncmp(argv[i], "mem=", 4) == 0) {
+			mem = strtol(argv[i] + 4, NULL, 0);
+			break;
+		}
+	}
+
+	bootverbose = 1;
+	if (mem > 0)
+		realmem = btoc(mem << 20);
+	else
+		realmem = btoc(32 << 20);
+
+	for (i = 0; i < 10; i++) {
+		phys_avail[i] = 0;
+	}
+
+	/* phys_avail regions are in bytes */
+	phys_avail[0] = MIPS_KSEG0_TO_PHYS((vm_offset_t)&end);
+	phys_avail[1] = ctob(realmem);
+
+	physmem = realmem;
+
+	/* 
+	 * ns8250 uart code uses DELAY so ticker should be inititalized 
+	 * before cninit. And tick_init_params refers to hz, so * init_param1 
+	 * should be called first.
+	 */
+	init_param1();
+	/* TODO: parse argc,argv */
+	platform_counter_freq = 330000000UL; /* XXX: from idt */
+	mips_timer_init_params(platform_counter_freq, 1);
+	cninit();
+	/* Panic here, after cninit */ 
+	if (mem == 0)
+		panic("No mem=XX parameter in arguments");
+
+	printf("cmd line: ");
+	for (i=0; i < argc; i++)
+		printf("%s ", argv[i]);
+	printf("\n");
+
+	init_param2(physmem);
+	mips_cpu_init();
+	pmap_bootstrap();
+	mips_proc0_init();
+	mutex_init();
+#ifdef DDB
+	kdb_init();
+#endif
+}
+
+/*
+ ****************************************************************************************
+ *
+ * APP/BOOT  DESCRIPTOR  STUFF
+ *
+ ****************************************************************************************
+ */
+
+/* Define the struct that is initialized by the bootloader used by the 
+ * startup code.
+ *
+ * Copyright (c) 2004, 2005, 2006 Cavium Networks.
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#define OCTEON_CURRENT_DESC_VERSION     6
+#define OCTEON_ARGV_MAX_ARGS            (64)
+#define OCTOEN_SERIAL_LEN 20
+
+
+typedef struct {
+    /* Start of block referenced by assembly code - do not change! */
+    uint32_t desc_version;
+    uint32_t desc_size;
+
+    uint64_t stack_top;
+    uint64_t heap_base;
+    uint64_t heap_end;
+    uint64_t entry_point;   /* Only used by bootloader */
+    uint64_t desc_vaddr;
+    /* End of This block referenced by assembly code - do not change! */
+
+    uint32_t exception_base_addr;
+    uint32_t stack_size;
+    uint32_t heap_size;
+    uint32_t argc;  /* Argc count for application */
+    uint32_t argv[OCTEON_ARGV_MAX_ARGS];
+    uint32_t flags;
+    uint32_t core_mask;
+    uint32_t dram_size;  /**< DRAM size in megabyes */
+    uint32_t phy_mem_desc_addr;  /**< physical address of free memory descriptor block*/
+    uint32_t debugger_flags_base_addr;  /**< used to pass flags from app to debugger */
+    uint32_t eclock_hz;  /**< CPU clock speed, in hz */
+    uint32_t dclock_hz;  /**< DRAM clock speed, in hz */
+    uint32_t spi_clock_hz;  /**< SPI4 clock in hz */
+    uint16_t board_type;
+    uint8_t board_rev_major;
+    uint8_t board_rev_minor;
+    uint16_t chip_type;
+    uint8_t chip_rev_major;
+    uint8_t chip_rev_minor;
+    char board_serial_number[OCTOEN_SERIAL_LEN];
+    uint8_t mac_addr_base[6];
+    uint8_t mac_addr_count;
+    uint64_t cvmx_desc_vaddr;
+
+} octeon_boot_descriptor_t;
+
+
+typedef struct {
+    uint32_t major_version;
+    uint32_t minor_version;
+
+    uint64_t stack_top;
+    uint64_t heap_base;
+    uint64_t heap_end;
+    uint64_t desc_vaddr;
+
+    uint32_t exception_base_addr;
+    uint32_t stack_size;
+    uint32_t flags;
+    uint32_t core_mask;
+    uint32_t dram_size;  /**< DRAM size in megabyes */
+    uint32_t phy_mem_desc_addr;  /**< physical address of free memory descriptor block*/
+    uint32_t debugger_flags_base_addr;  /**< used to pass flags from app to debugger */
+    uint32_t eclock_hz;  /**< CPU clock speed, in hz */
+    uint32_t dclock_hz;  /**< DRAM clock speed, in hz */
+    uint32_t spi_clock_hz;  /**< SPI4 clock in hz */
+    uint16_t board_type;
+    uint8_t board_rev_major;
+    uint8_t board_rev_minor;
+    uint16_t chip_type;
+    uint8_t chip_rev_major;
+    uint8_t chip_rev_minor;
+    char board_serial_number[OCTOEN_SERIAL_LEN];
+    uint8_t mac_addr_base[6];
+    uint8_t mac_addr_count;
+
+} cvmx_bootinfo_t;
+
+uint32_t octeon_cpu_clock;
+uint64_t octeon_dram;
+uint32_t octeon_bd_ver = 0, octeon_cvmx_bd_ver = 0, octeon_board_rev_major, octeon_board_rev_minor, octeon_board_type;
+uint8_t octeon_mac_addr[6] = { 0 };
+int octeon_core_mask, octeon_mac_addr_count;
+int octeon_chip_rev_major = 0, octeon_chip_rev_minor = 0, octeon_chip_type = 0;
+
+#if defined(__mips_n64)
+extern uint64_t app_descriptor_addr;
+#else
+extern uint32_t app_descriptor_addr;
+#endif
+static octeon_boot_descriptor_t *app_desc_ptr;
+static cvmx_bootinfo_t *cvmx_desc_ptr;
+
+#define OCTEON_BOARD_TYPE_NONE 0
+#define OCTEON_BOARD_TYPE_SIM  1
+
+#define OCTEON_CLOCK_MIN     (100 * 1000 * 1000)
+#define OCTEON_CLOCK_MAX     (800 * 1000 * 1000)
+#define OCTEON_DRAM_DEFAULT  (256 * 1024 * 1024)
+#define OCTEON_DRAM_MIN	     30
+#define OCTEON_DRAM_MAX	     3000
+
+
+int octeon_board_real (void)
+{
+     if ((octeon_board_type == OCTEON_BOARD_TYPE_NONE) ||
+        (octeon_board_type == OCTEON_BOARD_TYPE_SIM) ||
+        !octeon_board_rev_major) {
+        return 0;
+     }
+     return 1;
+}
+
+static void octeon_process_app_desc_ver_unknown (void)
+{
+    	printf(" Unknown Boot-Descriptor: Using Defaults\n");
+
+    	octeon_cpu_clock = OCTEON_CLOCK_DEFAULT;
+        octeon_dram = OCTEON_DRAM_DEFAULT;
+        octeon_board_rev_major = octeon_board_rev_minor = octeon_board_type = 0;
+
+        octeon_core_mask = 1;
+        octeon_cpu_clock  = OCTEON_CLOCK_DEFAULT;
+        octeon_chip_type = octeon_chip_rev_major = octeon_chip_rev_minor = 0;
+
+        octeon_mac_addr[0] = 0x00; octeon_mac_addr[1] = 0x0f;
+        octeon_mac_addr[2] = 0xb7; octeon_mac_addr[3] = 0x10;
+        octeon_mac_addr[4] = 0x09; octeon_mac_addr[5] = 0x06;
+        octeon_mac_addr_count = 1;
+}
+
+static int octeon_process_app_desc_ver_6 (void)
+{
+    	cvmx_desc_ptr = (cvmx_bootinfo_t *) ((long) app_desc_ptr->cvmx_desc_vaddr);
+
+        if ((cvmx_desc_ptr == NULL) || (cvmx_desc_ptr == (cvmx_bootinfo_t *)0xffffffff)) {
+            	printf ("Bad cvmx_desc_ptr %p\n", cvmx_desc_ptr);
+                return 1;
+        }
+
+        cvmx_desc_ptr = (cvmx_bootinfo_t *) (((long) cvmx_desc_ptr) | MIPS_KSEG0_START);
+        octeon_cvmx_bd_ver = (cvmx_desc_ptr->major_version * 100) +
+                             cvmx_desc_ptr->minor_version;
+
+        if (cvmx_desc_ptr->major_version != 1) {
+            	printf("Incompatible CVMX descriptor from bootloader: %d.%d %p\n",
+                       (int) cvmx_desc_ptr->major_version,
+                       (int) cvmx_desc_ptr->minor_version, cvmx_desc_ptr);
+                while (1);	/*  Never return */
+                return 1;	/*  Satisfy the compiler */
+        }
+
+        octeon_core_mask = cvmx_desc_ptr->core_mask;
+        octeon_cpu_clock  = cvmx_desc_ptr->eclock_hz;
+        octeon_board_type = cvmx_desc_ptr->board_type;
+        octeon_board_rev_major = cvmx_desc_ptr->board_rev_major;
+        octeon_board_rev_minor = cvmx_desc_ptr->board_rev_minor;
+        octeon_chip_type = cvmx_desc_ptr->chip_type;
+        octeon_chip_rev_major = cvmx_desc_ptr->chip_rev_major;
+        octeon_chip_rev_minor = cvmx_desc_ptr->chip_rev_minor;
+        octeon_mac_addr[0] = cvmx_desc_ptr->mac_addr_base[0];
+        octeon_mac_addr[1] = cvmx_desc_ptr->mac_addr_base[1];
+        octeon_mac_addr[2] = cvmx_desc_ptr->mac_addr_base[2];
+        octeon_mac_addr[3] = cvmx_desc_ptr->mac_addr_base[3];
+        octeon_mac_addr[4] = cvmx_desc_ptr->mac_addr_base[4];
+        octeon_mac_addr[5] = cvmx_desc_ptr->mac_addr_base[5];
+        octeon_mac_addr_count = cvmx_desc_ptr->mac_addr_count;
+
+        if (app_desc_ptr->dram_size > 16*1024*1024) {
+            	octeon_dram = (uint64_t)app_desc_ptr->dram_size;
+        } else {
+            	octeon_dram = (uint64_t)app_desc_ptr->dram_size * 1024 * 1024;
+        }
+        return 0;
+}
+
+static int octeon_process_app_desc_ver_3_4_5 (void)
+{
+
+    	octeon_cvmx_bd_ver = octeon_bd_ver;
+        octeon_core_mask = app_desc_ptr->core_mask;
+
+        if (app_desc_ptr->desc_version > 3) {
+            	octeon_cpu_clock = app_desc_ptr->eclock_hz;
+        } else {
+            	octeon_cpu_clock  = OCTEON_CLOCK_DEFAULT;
+        }
+
+        if (app_desc_ptr->dram_size > 16*1024*1024) {
+            	octeon_dram = (uint64_t)app_desc_ptr->dram_size;
+        } else {
+            	octeon_dram = (uint64_t)app_desc_ptr->dram_size * 1024 * 1024;
+        }
+
+        if (app_desc_ptr->desc_version > 4) {
+            	octeon_board_type = app_desc_ptr->board_type;
+                octeon_board_rev_major = app_desc_ptr->board_rev_major;
+                octeon_board_rev_minor = app_desc_ptr->board_rev_minor;
+                octeon_chip_type = app_desc_ptr->chip_type;
+                octeon_chip_rev_major = app_desc_ptr->chip_rev_major;
+                octeon_chip_rev_minor = app_desc_ptr->chip_rev_minor;
+
+                octeon_mac_addr[0] = app_desc_ptr->mac_addr_base[0];
+                octeon_mac_addr[1] = app_desc_ptr->mac_addr_base[1];
+                octeon_mac_addr[2] = app_desc_ptr->mac_addr_base[2];
+                octeon_mac_addr[3] = app_desc_ptr->mac_addr_base[3];
+                octeon_mac_addr[4] = app_desc_ptr->mac_addr_base[4];
+                octeon_mac_addr[5] = app_desc_ptr->mac_addr_base[5];
+                octeon_mac_addr_count = app_desc_ptr->mac_addr_count;
+        }
+        return 0;
+}
+
+
+void mips_boot_params_init(void);
+
+void mips_boot_params_init (void)
+{
+    int descriptor_not_parsed = 1;
+
+    	if ((app_descriptor_addr == 0) || (app_descriptor_addr >= MAX_APP_DESC_ADDR)) {
+	        
+        } else {
+
+	        app_desc_ptr = (octeon_boot_descriptor_t *) app_descriptor_addr;
+		octeon_bd_ver = app_desc_ptr->desc_version;
+		
+                if ((octeon_bd_ver >= 3) && (octeon_bd_ver <= 5)) {
+		  descriptor_not_parsed = octeon_process_app_desc_ver_3_4_5();
+
+                } else if (app_desc_ptr->desc_version == 6) {
+                    	descriptor_not_parsed = octeon_process_app_desc_ver_6();
+                }
+
+        }
+
+        if (descriptor_not_parsed) {
+        	octeon_process_app_desc_ver_unknown();
+        }
+
+        printf("Boot Descriptor Ver: %u -> %u/%u",
+               octeon_bd_ver, octeon_cvmx_bd_ver/100, octeon_cvmx_bd_ver%100);
+        printf("  CPU clock: %uMHz\n", octeon_cpu_clock/1000000);
+        printf("  Dram: %u MB", (uint32_t)(octeon_dram >> 20));
+        printf("  Board Type: %u  Revision: %u/%u\n",
+               octeon_board_type, octeon_board_rev_major, octeon_board_rev_minor);
+        printf("  Octeon Chip: %u  Rev %u/%u",
+               octeon_chip_type, octeon_chip_rev_major, octeon_chip_rev_minor);
+
+        printf("  Mac Address %02X.%02X.%02X.%02X.%02X.%02X\n",
+               octeon_mac_addr[0], octeon_mac_addr[1], octeon_mac_addr[2],
+               octeon_mac_addr[3], octeon_mac_addr[4], octeon_mac_addr[5]);
+}
diff -I '.*' -Naur releng8/sys/mips/octeon1/octeon_pcmap_regs.h svn/mips/sys/mips/octeon1/octeon_pcmap_regs.h
--- releng8/src/sys/mips/octeon1/octeon_pcmap_regs.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/octeon_pcmap_regs.h	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,1079 @@
+/*
+ *    This product includes software developed by the University of
+ *    California, Berkeley and its contributors."
+*/
+
+#ifndef __OCTEON_PCMAP_REGS_H__
+#define __OCTEON_PCMAP_REGS_H__
+
+
+#define OCTEON_CACHE_LINE_SIZE	0x80	/* 128 bytes cache line size */
+#define IS_OCTEON_ALIGNED(p)	(!((u_long)(p) & 0x7f))
+#define OCTEON_ALIGN(p)		(((u_long)(p) + ((OCTEON_CACHE_LINE_SIZE) - 1)) & ~((OCTEON_CACHE_LINE_SIZE) - 1))
+
+#ifndef LOCORE
+
+/* XXXimp: From Cavium's include/pcpu.h, need to port that over */
+#ifndef OCTEON_SMP
+#define OCTEON_CORE_ID 0
+#else
+extern struct pcpu *cpuid_to_pcpu[];
+#define OCTEON_CORE_ID (mips_rd_coreid())
+#endif
+
+/*
+ * Utility inlines & macros
+ */
+
+/* turn the variable name into a string */
+#define OCTEON_TMP_STR(x) OCTEON_TMP_STR2(x)
+#define OCTEON_TMP_STR2(x) #x
+
+#define OCTEON_PREFETCH_PREF0(address, offset) \
+	__asm __volatile (	".set mips64\n"	     \
+			".set noreorder\n"   \
+			"pref 0, " OCTEON_TMP_STR(offset) "(%0)\n" \
+			".set reorder\n"     \
+			".set mips0\n"	     \
+			 : \
+			 : "r" (address) );
+
+#define OCTEON_PREFETCH(address, offset) OCTEON_PREFETCH_PREF0(address,offset)
+
+#define OCTEON_PREFETCH0(address) OCTEON_PREFETCH(address, 0)
+#define OCTEON_PREFETCH128(address) OCTEON_PREFETCH(address, 128)
+
+#define OCTEON_SYNCIOBDMA __asm __volatile (".word 0x8f" : : :"memory")
+
+#define OCTEON_SYNCW	__asm __volatile (".word  0x10f" : : )
+#define OCTEON_SYNCW	__asm __volatile (".word  0x10f" : : )
+#define OCTEON_SYNCWS	__asm __volatile (".word  0x14f" : : )
+
+//#if defined(__mips_n32) || defined(__mips_n64)
+#if defined(__not_used)
+
+static inline void oct_write64 (uint64_t csr_addr, uint64_t val64)
+{
+    uint64_t *ptr = (uint64_t *) csr_addr;
+    *ptr = val64;
+}
+
+static inline void oct_write64_int64 (uint64_t csr_addr, int64_t val64i)
+{
+    int64_t *ptr = (int64_t *) csr_addr;
+    *ptr = val64i;
+}
+
+static inline void oct_write8_x8 (uint64_t csr_addr, uint8_t val8)
+{
+    uint64_t *ptr = (uint64_t *) csr_addr;
+    *ptr = (uint64_t) val8;
+}
+
+static inline void oct_write8 (uint64_t csr_addr, uint8_t val8)
+{
+    oct_write64(csr_addr, (uint64_t) val8);
+}
+
+static inline void oct_write16 (uint64_t csr_addr, uint16_t val16)
+{
+    oct_write64(csr_addr, (uint64_t) val16);
+}
+
+static inline void oct_write32 (uint64_t csr_addr, uint32_t val32)
+{
+    oct_write64(csr_addr, (uint64_t) val32);
+}
+
+static inline uint8_t oct_read8 (uint64_t csr_addr)
+{
+    uint8_t *ptr = (uint8_t *) csr_addr;
+    return (*ptr);
+}
+
+static inline uint8_t oct_read16 (uint64_t csr_addr)
+{
+    uint16_t *ptr = (uint16_t *) csr_addr;
+    return (*ptr);
+}
+
+
+static inline uint32_t oct_read32 (uint64_t csr_addr)
+{
+    uint32_t *ptr = (uint32_t *) csr_addr;
+    return (*ptr);
+}
+
+static inline uint64_t oct_read64 (uint64_t csr_addr)
+{
+    uint64_t *ptr = (uint64_t *) csr_addr;
+    return (*ptr);
+}
+
+static inline int32_t oct_readint32 (uint64_t csr_addr)
+{
+    int32_t *ptr = (int32_t *) csr_addr;
+    return (*ptr);
+}
+
+
+
+#else
+
+
+/*  ABI o32 */
+
+
+/*
+ * Read/write functions
+ */
+static inline void oct_write64 (uint64_t csr_addr, uint64_t val64)
+{
+    uint32_t csr_addrh = csr_addr >> 32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t valh = (uint64_t)val64 >> 32;
+    uint32_t vall = val64;
+    uint32_t tmp1;
+    uint32_t tmp2;
+    uint32_t tmp3;
+
+    __asm __volatile (
+            ".set mips64\n"
+            "dsll   %0, %3, 32\n"
+            "dsll   %1, %5, 32\n"
+            "dsll   %2, %4, 32\n"
+            "dsrl   %2, %2, 32\n"
+            "or     %0, %0, %2\n"
+            "dsll   %2, %6, 32\n"
+            "dsrl   %2, %2, 32\n"
+            "or     %1, %1, %2\n"
+            "sd     %0, 0(%1)\n"
+            ".set mips0\n"
+            : "=&r" (tmp1), "=&r" (tmp2), "=&r" (tmp3)
+            : "r" (valh), "r" (vall),
+              "r" (csr_addrh), "r" (csr_addrl)
+        );
+}
+
+static inline void oct_write64_int64 (uint64_t csr_addr, int64_t val64i)
+{
+    uint32_t csr_addrh = csr_addr >> 32;
+    uint32_t csr_addrl = csr_addr;
+    int32_t valh = (uint64_t)val64i >> 32;
+    int32_t vall = val64i;
+    uint32_t tmp1;
+    uint32_t tmp2;
+    uint32_t tmp3;
+
+    __asm __volatile (
+            ".set mips64\n"
+            "dsll   %0, %3, 32\n"
+            "dsll   %1, %5, 32\n"
+            "dsll   %2, %4, 32\n"
+            "dsrl   %2, %2, 32\n"
+            "or     %0, %0, %2\n"
+            "dsll   %2, %6, 32\n"
+            "dsrl   %2, %2, 32\n"
+            "or     %1, %1, %2\n"
+            "sd     %0, 0(%1)\n"
+            ".set mips0\n"
+            : "=&r" (tmp1), "=&r" (tmp2), "=&r" (tmp3)
+            : "r" (valh), "r" (vall),
+              "r" (csr_addrh), "r" (csr_addrl)
+        );
+}
+
+
+/*
+ * oct_write8_x8
+ *
+ * 8 bit data write into IO Space. Written using an 8 bit bus io transaction
+ */
+static inline void oct_write8_x8 (uint64_t csr_addr, uint8_t val8)
+{
+    uint32_t csr_addrh = csr_addr>>32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t tmp1;
+    uint32_t tmp2;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %0, %3, 32\n"
+        "dsll   %1, %4, 32\n"
+        "dsrl   %1, %1, 32\n"
+        "or     %0, %0, %1\n"
+        "sb     %2, 0(%0)\n"
+	".set mips0\n"
+        : "=&r" (tmp1), "=&r" (tmp2)
+        : "r" (val8), "r" (csr_addrh), "r" (csr_addrl) );
+}
+
+/*
+ * oct_write8
+ *
+ * 8 bit data write into IO Space. Written using a 64 bit bus io transaction
+ */
+static inline void oct_write8 (uint64_t csr_addr, uint8_t val8)
+{
+#if 1
+    oct_write64(csr_addr, (uint64_t) val8);
+#else
+
+    uint32_t csr_addrh = csr_addr>>32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t tmp1;
+    uint32_t tmp2;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %0, %3, 32\n"
+        "dsll   %1, %4, 32\n"
+        "dsrl   %1, %1, 32\n"
+        "or     %0, %0, %1\n"
+        "sb     %2, 0(%0)\n"
+        ".set mips0\n"
+        : "=&r" (tmp1), "=&r" (tmp2)
+        : "r" (val8), "r" (csr_addrh), "r" (csr_addrl) );
+#endif
+}
+
+static inline void oct_write16 (uint64_t csr_addr, uint16_t val16)
+{
+#if 1
+    oct_write64(csr_addr, (uint64_t) val16);
+
+#else
+    uint32_t csr_addrh = csr_addr>>32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t tmp1;
+    uint32_t tmp2;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %0, %3, 32\n"
+        "dsll   %1, %4, 32\n"
+        "dsrl   %1, %1, 32\n"
+        "or     %0, %0, %1\n"
+        "sh     %2, 0(%0)\n"
+	".set mips0\n"
+        : "=&r" (tmp1), "=&r" (tmp2)
+        : "r" (val16), "r" (csr_addrh), "r" (csr_addrl) );
+#endif
+}
+
+static inline void oct_write32 (uint64_t csr_addr, uint32_t val32)
+{
+#if 1
+    oct_write64(csr_addr, (uint64_t) val32);
+#else
+
+    uint32_t csr_addrh = csr_addr>>32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t tmp1;
+    uint32_t tmp2;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %0, %3, 32\n"
+        "dsll   %1, %4, 32\n"
+        "dsrl   %1, %1, 32\n"
+        "or     %0, %0, %1\n"
+        "sw     %2, 0(%0)\n"
+	".set mips0\n"
+        : "=&r" (tmp1), "=&r" (tmp2)
+        : "r" (val32), "r" (csr_addrh), "r" (csr_addrl) );
+#endif
+}
+
+
+
+static inline uint8_t oct_read8 (uint64_t csr_addr)
+{
+    uint32_t csr_addrh = csr_addr>>32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t tmp1, tmp2;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %1, %2, 32\n"
+        "dsll   %0, %3, 32\n"
+        "dsrl   %0, %0, 32\n"
+        "or     %1, %1, %0\n"
+        "lb     %1, 0(%1)\n"
+        ".set mips0\n"
+        : "=&r" (tmp1), "=&r" (tmp2)
+        : "r" (csr_addrh), "r" (csr_addrl) );
+    return ((uint8_t) tmp2);
+}
+
+static inline uint8_t oct_read16 (uint64_t csr_addr)
+{
+    uint32_t csr_addrh = csr_addr>>32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t tmp1, tmp2;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %1, %2, 32\n"
+        "dsll   %0, %3, 32\n"
+        "dsrl   %0, %0, 32\n"
+        "or     %1, %1, %0\n"
+        "lh     %1, 0(%1)\n"
+        ".set mips0\n"
+        : "=&r" (tmp1), "=&r" (tmp2)
+        : "r" (csr_addrh), "r" (csr_addrl) );
+    return ((uint16_t) tmp2);
+}
+
+
+static inline uint32_t oct_read32 (uint64_t csr_addr)
+{
+    uint32_t csr_addrh = csr_addr>>32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t val32;
+    uint32_t tmp;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %0, %2, 32\n"
+        "dsll   %1, %3, 32\n"
+        "dsrl   %1, %1, 32\n"
+        "or     %0, %0, %1\n"
+        "lw    %0, 0(%0)\n"
+        ".set mips0\n"
+        : "=&r" (val32), "=&r" (tmp)
+        : "r" (csr_addrh), "r" (csr_addrl) );
+    return (val32);
+}
+
+
+static inline uint64_t oct_read64 (uint64_t csr_addr)
+{
+    uint32_t csr_addrh = csr_addr >> 32;
+    uint32_t csr_addrl = csr_addr;
+    uint32_t valh;
+    uint32_t vall;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %0, %2, 32\n"
+        "dsll   %1, %3, 32\n"
+        "dsrl   %1, %1, 32\n"
+        "or     %0, %0, %1\n"
+        "ld     %1, 0(%0)\n"
+        "dsrl   %0, %1, 32\n"
+        "dsll   %1, %1, 32\n"
+        "dsrl   %1, %1, 32\n"
+        ".set mips0\n"
+        : "=&r" (valh), "=&r" (vall)
+        : "r" (csr_addrh), "r" (csr_addrl)
+        );
+    return ((uint64_t)valh << 32) | vall;
+}
+
+
+static inline int32_t oct_readint32 (uint64_t csr_addr)
+{
+    uint32_t csr_addrh = csr_addr>>32;
+    uint32_t csr_addrl = csr_addr;
+    int32_t val32;
+    uint32_t tmp;
+
+    __asm __volatile (
+        ".set mips64\n"
+        "dsll   %0, %2, 32\n"
+        "dsll   %1, %3, 32\n"
+        "dsrl   %1, %1, 32\n"
+        "or     %0, %0, %1\n"
+        "lw    %0, 0(%0)\n"
+        : "=&r" (val32), "=&r" (tmp)
+        : "r" (csr_addrh), "r" (csr_addrl) );
+    return (val32);
+}
+
+
+#endif
+
+
+#define OCTEON_HW_BASE		((volatile uint64_t *) 0L)
+#define OCTEON_REG_OFFSET	(-4 * 1024ll)  /* local scratchpad reg base */
+#define OCTEON_SCRATCH_BASE	((volatile uint8_t *)(OCTEON_HW_BASE +	\
+                                                      OCTEON_REG_OFFSET))
+
+#define OCTEON_SCR_SCRATCH   8
+#define OCTEON_SCRATCH_0   16
+#define OCTEON_SCRATCH_1   24
+#define OCTEON_SCRATCH_2   32
+
+
+static inline uint64_t oct_mf_chord (void)
+{
+    uint64_t dest;
+
+    __asm __volatile (	".set push\n"
+                        ".set noreorder\n"
+                        ".set noat\n"
+                        ".set mips64\n"
+			"dmfc2 $1, 0x400\n"
+                        "move %0, $1\n"
+        		".set pop\n"
+ 			: "=r" (dest) :  : "$1");
+    return dest;
+}
+
+
+#define MIPS64_DMFCz(cop,regnum,cp0reg,select)  \
+        .word   (0x40200000 | (cop << 25) | (regnum << 16) | (cp0reg << 11) | select)
+
+
+#define mips64_getcpz_xstr(s) mips64_getcpz_str(s)
+#define mips64_getcpz_str(s) #s
+
+#define mips64_dgetcpz(cop,cpzreg,sel,val_ptr) \
+    ({ __asm __volatile( \
+            ".set push\n" \
+            ".set mips3\n" \
+            ".set noreorder\n" \
+            ".set noat\n" \
+            mips64_getcpz_xstr(MIPS64_DMFCz(cop,1,cpzreg,sel)) "\n" \
+            "nop\n" \
+            "nop\n" \
+            "nop\n" \
+            "nop\n" \
+            "sd $1,0(%0)\n" \
+            ".set pop" \
+            : /* no outputs */ : "r" (val_ptr) : "$1"); \
+    })
+
+
+#define mips64_dgetcp2(cp2reg,sel,retval_ptr) \
+    mips64_dgetcpz(2,cp2reg,sel,retval_ptr)
+
+
+#define OCTEON_MF_CHORD(dest)  mips64_dgetcp2(0x400, 0, &dest)
+
+
+
+#define OCTEON_RDHWR(result, regstr) \
+	__asm __volatile (		\
+        		".set mips3\n"		\
+			"rdhwr %0,$" OCTEON_TMP_STR(regstr) "\n"	\
+        		".set mips\n"		\
+			 : "=d" (result));
+
+#define CVMX_MF_CHORD(dest)         OCTEON_RDHWR(dest, 30)
+
+#define OCTEON_CHORD_HEX(dest_ptr)  \
+    ({ __asm __volatile( \
+            ".set push\n" \
+            ".set mips3\n" \
+            ".set noreorder\n" \
+            ".set noat\n" \
+	    ".word 0x7c02f03b \n"\
+            "nop\n" \
+            "nop\n" \
+            "nop\n" \
+            "nop\n" \
+            "sd $2,0(%0)\n" \
+            ".set pop" \
+            : /* no outputs */ : "r" (dest_ptr) : "$2"); \
+    })
+
+
+
+#define OCTEON_MF_CHORD_BAD(dest)	\
+         __asm __volatile (		\
+        		".set mips3\n"		\
+			"dmfc2 %0, 0x400\n"	\
+        		".set mips0\n"		\
+ 			: "=&r" (dest) : )
+
+static inline uint64_t oct_scratch_read64 (uint64_t address)
+{
+    return(*((volatile uint64_t *)(OCTEON_SCRATCH_BASE + address)));
+}
+
+static inline void oct_scratch_write64 (uint64_t address, uint64_t value)
+{
+    *((volatile uint64_t *)(OCTEON_SCRATCH_BASE + address)) = value;
+}
+
+
+#define OCTEON_READ_CSR32(addr, val) \
+	addr_ptr = addr; \
+	oct_read_32_ptr(&addr_ptr, &val);
+
+#define OCTEON_WRITE_CSR32(addr, val, val_dummy) \
+	addr_ptr = addr; \
+	oct_write_32_ptr(&addr_ptr, &val); \
+	oct_read64(OCTEON_MIO_BOOT_BIST_STAT);
+
+
+
+/*
+ * Octeon Address Space Definitions
+ */
+typedef enum {
+   OCTEON_MIPS_SPACE_XKSEG = 3LL,
+   OCTEON_MIPS_SPACE_XKPHYS = 2LL,
+   OCTEON_MIPS_SPACE_XSSEG = 1LL,
+   OCTEON_MIPS_SPACE_XUSEG = 0LL
+} octeon_mips_space_t;
+
+typedef enum {
+   OCTEON_MIPS_XKSEG_SPACE_KSEG0 = 0LL,
+   OCTEON_MIPS_XKSEG_SPACE_KSEG1 = 1LL,
+   OCTEON_MIPS_XKSEG_SPACE_SSEG = 2LL,
+   OCTEON_MIPS_XKSEG_SPACE_KSEG3 = 3LL
+} octeon_mips_xkseg_space_t;
+
+
+/*
+***********************************************************************
+ * 32 bit mode alert
+ * The kseg0 calc below might fail in xkphys.
+ */
+
+/*
+ * We limit the allocated device physical blocks to low mem. So use Kseg0
+ */
+
+/*
+ * Need to go back to kernel to find v->p mappings & vice-versa
+ * We are getting non 1-1 mappings.
+ * #define OCTEON_PTR2PHYS(addr)  ((unsigned long) addr & 0x7fffffff)
+ */
+#define OCTEON_PTR2PHYS(addr) octeon_ptr_to_phys(addr)
+
+
+
+/*  PTR_SIZE == sizeof(uint32_t)  */
+
+#if 0
+#define mipsx_addr_size				uint32_t	// u_int64
+#define MIPSX_ADDR_SIZE_KSEGX_BIT_SHIFT		30		// 62
+#define MIPSX_ADDR_SIZE_KSEGX_MASK_REMOVED	0x1fffffff	// 0x1fffffff
+#else
+#define mipsx_addr_size				uint64_t
+#define MIPSX_ADDR_SIZE_KSEGX_BIT_SHIFT		62
+#define MIPSX_ADDR_SIZE_KSEGX_MASK_REMOVED	0x1fffffffffffffff
+#endif
+
+
+#define octeon_ptr_to_phys(ptr)                                           \
+    ((((mipsx_addr_size) ptr) >> MIPSX_ADDR_SIZE_KSEGX_BIT_SHIFT) == 2) ? \
+    	((mipsx_addr_size) ptr & MIPSX_ADDR_SIZE_KSEGX_MASK_REMOVED)  :   \
+    	(vtophys(ptr))
+
+
+#ifdef CODE_FOR_64_BIT_NEEDED
+static inline mipsx_addr_size octeon_ptr_to_phys (void *ptr)
+{
+    if ((((mipsx_addr_size) ptr) >> MIPSX_ADDR_SIZE_KSEGX_BIT_SHIFT) == 2) {
+        /*
+         * KSEG0 based address ?
+         */
+        return ((mipsx_addr_size) ptr & MIPSX_ADDR_SIZE_KSEGX_MASK_REMOVED);
+    } else {
+        /*
+         * Ask kernel/vm to give us the phys translation.
+         */
+        return (vtophys(ptr));
+    }
+}
+#endif
+
+#define OCTEON_IO_SEG OCTEON_MIPS_SPACE_XKPHYS
+
+
+#define OCTEON_ADD_SEG(segment, add)	((((uint64_t)segment) << 62) | (add))
+
+#define OCTEON_ADD_IO_SEG(add)		OCTEON_ADD_SEG(OCTEON_IO_SEG, (add))
+#define OCTEON_ADDR_DID(did)		(OCTEON_ADDR_DIDSPACE(did) << 40)
+#define OCTEON_ADDR_DIDSPACE(did)	(((OCTEON_IO_SEG) << 22) | ((1ULL) << 8) | (did))
+#define OCTEON_ADDR_FULL_DID(did,subdid)	(((did) << 3) | (subdid))
+
+
+#define OCTEON_CIU_PP_RST	OCTEON_ADD_IO_SEG(0x0001070000000700ull)
+#define OCTEON_OCTEON_DID_TAG	12ULL
+
+
+
+
+/*
+ * octeon_addr_t
+ */
+typedef union {
+   uint64_t         word64;
+
+   struct {
+       octeon_mips_space_t          R   : 2;
+       uint64_t               offset :62;
+   } sva; // mapped or unmapped virtual address
+
+   struct {
+       uint64_t               zeroes :33;
+       uint64_t               offset :31;
+   } suseg; // mapped USEG virtual addresses (typically)
+
+   struct {
+       uint64_t                ones  :33;
+       octeon_mips_xkseg_space_t   sp   : 2;
+       uint64_t               offset :29;
+   } sxkseg; // mapped or unmapped virtual address
+
+   struct {
+       octeon_mips_space_t         R    :2; // CVMX_MIPS_SPACE_XKPHYS in this case
+       uint64_t                 cca  : 3; // ignored by octeon
+       uint64_t                 mbz  :10;
+       uint64_t                  pa  :49; // physical address
+   } sxkphys; // physical address accessed through xkphys unmapped virtual address
+
+   struct {
+       uint64_t                 mbz  :15;
+       uint64_t                is_io : 1; // if set, the address is uncached and resides on MCB bus
+       uint64_t                 did  : 8; // the hardware ignores this field when is_io==0, else device ID
+       uint64_t                unaddr: 4; // the hardware ignores <39:36> in Octeon I
+       uint64_t               offset :36;
+   } sphys; // physical address
+
+    struct {
+        uint64_t               zeroes :24; // techically, <47:40> are dont-cares
+        uint64_t                unaddr: 4; // the hardware ignores <39:36> in Octeon I
+        uint64_t               offset :36;
+    } smem; // physical mem address
+
+    struct {
+        uint64_t                 mem_region  :2;
+        uint64_t                 mbz  :13;
+        uint64_t                is_io : 1; // 1 in this case
+        uint64_t                 did  : 8; // the hardware ignores this field when is_io==0, else device ID
+        uint64_t                unaddr: 4; // the hardware ignores <39:36> in Octeon I
+        uint64_t               offset :36;
+    } sio; // physical IO address
+
+    struct {
+        uint64_t                didspace : 24;
+        uint64_t                unused   : 40;
+    } sfilldidspace;
+
+} octeon_addr_t;
+
+
+typedef union {
+    uint64_t	    word64;
+    struct {
+        uint32_t    word32hi;
+        uint32_t    word32lo;
+    } bits;
+} octeon_word_t;
+
+
+
+
+/*
+ * octeon_build_io_address
+ *
+ * Builds a memory address for I/O based on the Major 5bits and Sub DID 3bits
+ */
+static inline uint64_t octeon_build_io_address (uint64_t major_did,
+                                                uint64_t sub_did)
+{
+    return ((0x1ull << 48) | (major_did << 43) | (sub_did << 40));
+}
+
+/*
+ * octeon_build_mask
+ *
+ * Builds a bit mask given the required size in bits.
+ *
+ * @param bits   Number of bits in the mask
+ * @return The mask
+ */
+static inline uint64_t octeon_build_mask (uint64_t bits)
+{
+    return ~((~0x0ull) << bits);
+}
+
+/*
+ * octeon_build_bits
+ *
+ * Perform mask and shift to place the supplied value into
+ * the supplied bit rage.
+ *
+ * Example: octeon_build_bits(39,24,value)
+ * <pre>
+ * 6       5       4       3       3       2       1
+ * 3       5       7       9       1       3       5       7      0
+ * +-------+-------+-------+-------+-------+-------+-------+------+
+ * 000000000000000000000000___________value000000000000000000000000
+ * </pre>
+ *
+ * @param high_bit Highest bit value can occupy (inclusive) 0-63
+ * @param low_bit  Lowest bit value can occupy inclusive 0-high_bit
+ * @param value    Value to use
+ * @return Value masked and shifted
+ */
+static inline uint64_t octeon_build_bits (uint64_t high_bit, uint64_t low_bit,
+                                          uint64_t value)
+{
+    return ((value & octeon_build_mask(high_bit - low_bit + 1)) << low_bit);
+}
+
+
+/**********************  simple spinlocks ***************/
+typedef struct {
+    volatile uint32_t value;
+} octeon_spinlock_t;
+
+// note - macros not expanded in inline ASM, so values hardcoded
+#define  OCTEON_SPINLOCK_UNLOCKED_VAL  0
+#define  OCTEON_SPINLOCK_LOCKED_VAL    1
+
+/**
+ * Initialize a spinlock
+ *
+ * @param lock   Lock to initialize
+ */
+static inline void octeon_spinlock_init(octeon_spinlock_t *lock)
+{
+    lock->value = OCTEON_SPINLOCK_UNLOCKED_VAL;
+}
+/**
+ * Releases lock
+ *
+ * @param lock   pointer to lock structure
+ */
+static inline void octeon_spinlock_unlock(octeon_spinlock_t *lock)
+{
+    OCTEON_SYNCWS;
+
+    lock->value = 0;
+    OCTEON_SYNCWS;
+}
+
+/**
+ * Gets lock, spins until lock is taken
+ *
+ * @param lock   pointer to lock structure
+ */
+static inline void octeon_spinlock_lock(octeon_spinlock_t *lock)
+{
+    unsigned int tmp;
+    __asm __volatile(
+    ".set noreorder         \n"
+    "1: ll   %1, %0  \n"
+    "   bnez %1, 1b     \n"
+    "   li   %1, 1      \n"
+    "   sc   %1, %0 \n"
+    "   beqz %1, 1b     \n"
+    "   nop                \n"
+    ".set reorder           \n"
+    :  "+m" (lock->value), "=&r" (tmp )
+    :
+    : "memory");
+}
+
+/********************** end simple spinlocks ***************/
+
+
+
+/* ------------------------------------------------------------------- *
+ *                      octeon_get_chipid()                               *
+ * ------------------------------------------------------------------- */
+#define OCTEON_CN31XX_CHIP  0x000d0100
+#define OCTEON_CN30XX_CHIP  0x000d0200
+#define OCTEON_CN3020_CHIP  0x000d0112
+#define OCTEON_CN5020_CHIP  0x000d0601
+
+static inline uint32_t octeon_get_chipid(void)
+{
+    uint32_t id;
+
+    __asm __volatile ("mfc0 %0, $15,0" : "=r" (id));
+
+    return (id);
+}
+
+
+static inline uint32_t octeon_get_except_base_reg (void)
+{
+    uint32_t tmp;
+
+    __asm volatile (
+    "    .set mips64r2            \n"
+    "    .set noreorder         \n"
+    "    mfc0   %0, $15, 1  \n"
+    "    .set reorder           \n"
+     :  "=&r" (tmp) : );
+
+    return(tmp);
+}
+
+
+
+
+static inline unsigned int get_coremask (void)
+{
+    return(~(oct_read64(OCTEON_CIU_PP_RST)) & 0xffff);
+}
+
+
+static inline uint32_t octeon_get_core_num (void)
+{
+
+    return (0x3FF & octeon_get_except_base_reg());
+}
+
+
+static inline uint64_t octeon_get_cycle(void)
+{
+
+/*  ABI == 32 */
+
+    uint32_t tmp_low, tmp_hi;
+
+    __asm __volatile (
+               "   .set push                  \n"
+               "   .set mips64r2                \n"
+               "   .set noreorder               \n"
+               "   rdhwr %[tmpl], $31           \n"
+               "   dadd  %[tmph], %[tmpl], $0   \n"
+               "   dsrl  %[tmph], 32            \n"
+               "   dsll  %[tmpl], 32            \n"
+               "   dsrl  %[tmpl], 32            \n"
+               "   .set pop                 \n"
+                  : [tmpl] "=&r" (tmp_low), [tmph] "=&r" (tmp_hi) : );
+
+    return(((uint64_t)tmp_hi << 32) + tmp_low);
+}
+
+
+/**
+ * Wait for the specified number of cycle
+ *
+ * @param cycles
+ */
+static inline void octeon_wait (uint64_t cycles)
+{
+    uint64_t done = octeon_get_cycle() + cycles;
+
+    while (octeon_get_cycle() < done)
+    {
+        /* Spin */
+    }
+}
+
+
+
+/*
+ * octeon_machdep.c
+ *
+ * Direct to Board Support level.
+ */
+extern void octeon_led_write_char(int char_position, char val);
+extern void octeon_led_write_hexchar(int char_position, char hexval);
+extern void octeon_led_write_hex(uint32_t wl);
+extern void octeon_led_write_string(const char *str);
+extern void octeon_reset(void);
+extern void octeon_uart_write_byte(int uart_index, uint8_t ch);
+extern void octeon_uart_write_string(int uart_index, const char *str);
+extern void octeon_uart_write_hex(uint32_t wl);
+extern void octeon_uart_write_hex2(uint32_t wl, uint32_t wh);
+extern void octeon_wait_uart_flush(int uart_index, uint8_t ch);
+extern void octeon_uart_write_byte0(uint8_t ch);
+extern void octeon_led_write_char0(char val);
+extern void octeon_led_run_wheel(int *pos, int led_position);
+extern void octeon_debug_symbol(void);
+extern void mips_disable_interrupt_controls(void);
+extern uint32_t octeon_cpu_clock;
+extern uint64_t octeon_dram;
+extern uint32_t octeon_bd_ver, octeon_board_rev_major, octeon_board_rev_minor, octeon_board_type;
+extern uint8_t octeon_mac_addr[6];
+extern int octeon_core_mask, octeon_mac_addr_count, octeon_chip_rev_major, octeon_chip_rev_minor, octeon_chip_type;
+extern void bzero_64(void *str, size_t len);
+extern void bzero_32(void *str, size_t len);
+extern void bzero_16(void *str, size_t len);
+extern void bzero_old(void *str, size_t len);
+extern void octeon_ciu_reset(void);
+extern void ciu_disable_intr(int core_num, int intx, int enx);
+extern void ciu_enable_interrupts (int core_num, int intx, int enx, uint64_t set_these_interrupt_bits, int ciu_ip);
+extern void ciu_clear_int_summary(int core_num, int intx, int enx, uint64_t write_bits);
+extern uint64_t ciu_get_int_summary(int core_num, int intx, int enx);
+extern void octeon_ciu_start_gtimer(int timer, u_int one_shot, uint64_t time_cycles);
+extern void octeon_ciu_stop_gtimer(int timer);
+extern int octeon_board_real(void);
+
+
+
+typedef union {
+    uint64_t word64;
+    struct {
+        uint64_t reserved             : 27;     /* Not used */
+        uint64_t one_shot             : 1;      /* Oneshot ? */
+        uint64_t len                  : 36;     /* len of timer in clock cycles - 1 */
+    } bits;
+} octeon_ciu_gentimer;
+
+
+
+#endif	/* LOCORE */
+
+
+/*
+ * R4K Address space definitions
+ */
+#define ADRSPC_K0BASE    (0x80000000)
+#define ADRSPC_K0SIZE    (0x20000000)
+#define ADRSPC_K1BASE    (0xA0000000)
+#define ADRSPC_K1SIZE    (0x20000000)
+#define ADRSPC_KSBASE    (0xC0000000)
+#define ADRSPC_KSSIZE    (0x20000000)
+#define ADRSPC_K3BASE    (0xE0000000)
+#define ADRSPC_K3SIZE    (0x20000000)
+#define ADRSPC_KUBASE    (0x00000000)
+#define ADRSPC_KUSIZE    (0x80000000)
+#define KSEG_MSB_ADDR    0xFFFFFFFF
+
+
+
+#define OCTEON_CLOCK_DEFAULT (500 * 1000 * 1000)
+
+
+/*
+ * Octeon Boot Bus BIST Status
+ * Mostly used for dummy read to ensure all prev I/Os are write-complete.
+ */
+#define  OCTEON_MIO_BOOT_BIST_STAT      0x80011800000000F8ull
+
+/*
+ * Octeon UART unit
+ */
+#define  OCTEON_MIO_UART0_THR           0x8001180000000840ull
+#define  OCTEON_MIO_UART1_THR           0x8001180000000C40ull
+#define  OCTEON_MIO_UART0_LSR           0x8001180000000828ull
+#define  OCTEON_MIO_UART1_LSR           0x8001180000000C28ull
+#define  OCTEON_MIO_UART0_RBR           0x8001180000000800ull
+#define  OCTEON_MIO_UART1_RBR           0x8001180000000C00ull
+#define  OCTEON_MIO_UART0_USR           0x8001180000000938ull
+#define  OCTEON_MIO_UART1_USR           0x8001180000000D38ull
+#define  OCTEON_MIO_ADDR_HI24           0x800118
+
+
+/*
+ * EBT3000 LED Unit
+ */
+#define  OCTEON_CHAR_LED_BASE_ADDR	(0x1d020000 | (0x1ffffffffull << 31))
+
+#define  OCTEON_FPA_QUEUES		8
+
+/*
+ * Octeon FPA I/O Registers
+ */
+#define  OCTEON_FPA_CTL_STATUS		0x8001180028000050ull
+#define  OCTEON_FPA_FPF_SIZE		0x8001180028000058ull
+#define  OCTEON_FPA_FPF_MARKS		0x8001180028000000ull
+#define  OCTEON_FPA_INT_SUMMARY		0x8001180028000040ull
+#define  OCTEON_FPA_INT_ENABLE		0x8001180028000048ull
+#define  OCTEON_FPA_QUEUE_AVAILABLE	0x8001180028000098ull
+#define  OCTEON_FPA_PAGE_INDEX		0x80011800280000f0ull
+
+/*
+ * Octeon PKO Unit
+ */
+#define	 OCTEON_PKO_REG_FLAGS		0x8001180050000000ull
+#define	 OCTEON_PKO_REG_READ_IDX	0x8001180050000008ull
+#define	 OCTEON_PKO_CMD_BUF		0x8001180050000010ull
+#define	 OCTEON_PKO_GMX_PORT_MODE	0x8001180050000018ull
+#define	 OCTEON_PKO_REG_CRC_ENABLE	0x8001180050000020ull
+#define	 OCTEON_PKO_QUEUE_MODE		0x8001180050000048ull
+#define  OCTEON_PKO_MEM_QUEUE_PTRS     	0x8001180050001000ull
+#define	 OCTEON_PKO_MEM_COUNT0		0x8001180050001080ull
+#define	 OCTEON_PKO_MEM_COUNT1		0x8001180050001088ull
+#define	 OCTEON_PKO_MEM_DEBUG0		0x8001180050001100ull
+#define	 OCTEON_PKO_MEM_DEBUG1		0x8001180050001108ull
+#define	 OCTEON_PKO_MEM_DEBUG2		0x8001180050001110ull
+#define	 OCTEON_PKO_MEM_DEBUG3		0x8001180050001118ull
+#define	 OCTEON_PKO_MEM_DEBUG4		0x8001180050001120ull
+#define	 OCTEON_PKO_MEM_DEBUG5		0x8001180050001128ull
+#define	 OCTEON_PKO_MEM_DEBUG6		0x8001180050001130ull
+#define	 OCTEON_PKO_MEM_DEBUG7		0x8001180050001138ull
+#define	 OCTEON_PKO_MEM_DEBUG8		0x8001180050001140ull
+#define	 OCTEON_PKO_MEM_DEBUG9		0x8001180050001148ull
+
+
+/*
+ * Octeon IPD Unit
+ */
+#define  OCTEON_IPD_1ST_MBUFF_SKIP		0x80014F0000000000ull
+#define  OCTEON_IPD_NOT_1ST_MBUFF_SKIP		0x80014F0000000008ull
+#define  OCTEON_IPD_PACKET_MBUFF_SIZE		0x80014F0000000010ull
+#define  OCTEON_IPD_1ST_NEXT_PTR_BACK		0x80014F0000000150ull
+#define  OCTEON_IPD_2ND_NEXT_PTR_BACK		0x80014F0000000158ull
+#define  OCTEON_IPD_WQE_FPA_QUEUE		0x80014F0000000020ull
+#define  OCTEON_IPD_CTL_STATUS			0x80014F0000000018ull
+#define	 OCTEON_IPD_QOSX_RED_MARKS(queue)      (0x80014F0000000178ull + ((queue) * 8))
+#define	 OCTEON_IPD_RED_Q_PARAM(queue)	       (0x80014F00000002E0ull + ((queue) * 8))
+#define	 OCTEON_IPD_PORT_BP_PAGE_COUNT(port)   (0x80014F0000000028ull + ((port) * 8))
+#define	 OCTEON_IPD_BP_PORT_RED_END		0x80014F0000000328ull
+#define	 OCTEON_IPD_RED_PORT_ENABLE		0x80014F00000002D8ull
+
+/*
+ * Octeon CIU Unit
+ */
+#define OCTEON_CIU_ENABLE_BASE_ADDR	0x8001070000000200ull
+#define OCTEON_CIU_SUMMARY_BASE_ADDR	0x8001070000000000ull
+#define OCTEON_CIU_SUMMARY_INT1_ADDR	0x8001070000000108ull
+
+#define OCTEON_CIU_MBOX_SETX(offset)    (0x8001070000000600ull+((offset)*8))
+#define OCTEON_CIU_MBOX_CLRX(offset)    (0x8001070000000680ull+((offset)*8))
+#define OCTEON_CIU_ENABLE_MBOX_INTR	 0x0000000300000000ull /* bits 32, 33 */
+
+#define CIU_MIPS_IP2		0
+#define CIU_MIPS_IP3		1
+
+#define CIU_INT_0		CIU_MIPS_IP2
+#define CIU_INT_1		CIU_MIPS_IP3
+
+#define CIU_EN_0		0
+#define CIU_EN_1		1
+
+#define CIU_THIS_CORE		-1
+
+#define CIU_UART_BITS_UART0		      (0x1ull << 34)		// Bit 34
+#define CIU_UART_BITS_UART1		      (0x1ull << 35)		// Bit 35
+#define CIU_GENTIMER_BITS_ENABLE(timer)	      (0x1ull << (52 + (timer)))	// Bit 52..55
+
+#define CIU_GENTIMER_NUM_0			0
+#define CIU_GENTIMER_NUM_1			1
+#define CIU_GENTIMER_NUM_2			2
+#define CIU_GENTIMER_NUM_3			3
+#define OCTEON_GENTIMER_ONESHOT			1
+#define OCTEON_GENTIMER_PERIODIC		0
+
+#define OCTEON_CIU_GENTIMER_ADDR(timer)	     (0x8001070000000480ull + ((timer) * 0x8))
+
+
+#define OCTEON_GENTIMER_LEN_1MS		(0x7a120ull)   /* Back of envelope. 500Mhz Octeon */ // FIXME IF WRONG
+#define OCTEON_GENTIMER_LEN_1SEC	((OCTEON_GENTIMER_LEN_1MS) * 1000)
+
+/*
+ * Physical Memory Banks
+ */
+/* 1st BANK */
+#define OCTEON_DRAM_FIRST_256_START	0x00000000ull
+#define OCTEON_DRAM_FIRST_256_END	(0x10000000ull - 1ull)
+#define OCTEON_DRAM_RESERVED_END        0X1FFF000ULL	/* 32 Meg Reserved for Mips Kernel MD Ops */
+#define OCTEON_DRAM_FIRST_BANK_SIZE	(OCTEON_DRAM_FIRST_256_END - OCTEON_DRAM_FIRST_256_START + 1)
+
+/* 2nd BANK */
+#define OCTEON_DRAM_SECOND_256_START	(0x0000000410000000ull)
+#define OCTEON_DRAM_SECOND_256_END	(0x0000000420000000ull - 1ull)  /* Requires 64 bit paddr */
+#define OCTEON_DRAM_SECOND_BANK_SIZE	(OCTEON_DRAM_SECOND_256_END - OCTEON_DRAM_SECOND_256_START + 1ull)
+
+/* 3rd BANK */
+#define OCTEON_DRAM_ABOVE_512_START	0x20000000ull
+#define OCTEON_DRAM_ABOVE_512_END	(0x0000000300000000ull - 1ull)  /* To be calculated as remaining */
+#define OCTEON_DRAM_THIRD_BANK_SIZE	(OCTEON_DRAM_ABOVE_512_END - OCTEON_DRAM_ABOVE_512_START + 1ull)
+
+#endif /* !OCTEON_PCMAP_REGS_H__ */
diff -I '.*' -Naur releng8/sys/mips/octeon1/octeonreg.h svn/mips/sys/mips/octeon1/octeonreg.h
--- releng8/src/sys/mips/octeon1/octeonreg.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/octeonreg.h	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,246 @@
+/*	$NetBSD: octeonreg.h,v 1.1 2002/03/07 14:44:04 simonb Exp $	*/
+
+/*
+ * Copyright 2002 Wasabi Systems, Inc.
+ * All rights reserved.
+ *
+ * Written by Simon Burge for Wasabi Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed for the NetBSD Project by
+ *      Wasabi Systems, Inc.
+ * 4. The name of Wasabi Systems, Inc. may not be used to endorse
+ *    or promote products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+	Memory Map
+
+	0000.0000 *	128MB	Typically SDRAM (on Core Board)
+	0800.0000 *	256MB	Typically PCI
+	1800.0000 *	 62MB	Typically PCI
+	1be0.0000 *	  2MB	Typically System controller's internal registers
+	1c00.0000 *	 32MB	Typically not used
+	1e00.0000	  4MB	Monitor Flash
+	1e40.0000	 12MB	reserved
+	1f00.0000	 12MB	Switches
+				LEDs
+				ASCII display
+				Soft reset
+				FPGA revision number
+				CBUS UART (tty2)
+				General Purpose I/O
+				I2C controller
+	1f10.0000 *	 11MB	Typically System Controller specific
+	1fc0.0000	  4MB	Maps to Monitor Flash
+	1fd0.0000 *	  3MB	Typically System Controller specific
+
+		  * depends on implementation of the Core Board and of software
+ */
+
+/*
+	CPU interrupts
+
+		NMI	South Bridge or NMI button
+		 0	South Bridge INTR
+		 1	South Bridge SMI
+		 2	CBUS UART (tty2)
+		 3	COREHI (Core Card)
+		 4	CORELO (Core Card)
+		 5	Not used, driven inactive (typically CPU internal timer interrupt
+
+	IRQ mapping (as used by YAMON)
+
+		0	Timer		South Bridge
+		1	Keyboard	SuperIO
+		2			Reserved by South Bridge (for cascading)
+		3	UART (tty1)	SuperIO
+		4	UART (tty0)	SuperIO
+		5			Not used
+		6	Floppy Disk	SuperIO
+		7	Parallel Port	SuperIO
+		8	Real Time Clock	South Bridge
+		9	I2C bus		South Bridge
+		10	PCI A,B,eth	PCI slot 1..4, Ethernet
+		11	PCI C,audio	PCI slot 1..4, Audio, USB (South Bridge)
+			PCI D,USB
+		12	Mouse		SuperIO
+		13			Reserved by South Bridge
+		14	Primary IDE	Primary IDE slot
+		15	Secondary IDE	Secondary IDE slot/Compact flash connector
+ */
+
+#define	OCTEON_SYSTEMRAM_BASE	0x00000000  /* System RAM:	*/
+#define	OCTEON_SYSTEMRAM_SIZE	0x08000000  /*   128 MByte	*/
+
+#define	OCTEON_PCIMEM1_BASE	0x08000000  /* PCI 1 memory:	*/
+#define	OCTEON_PCIMEM1_SIZE	0x08000000  /*   128 MByte	*/
+
+#define	OCTEON_PCIMEM2_BASE	0x10000000  /* PCI 2 memory:	*/
+#define	OCTEON_PCIMEM2_SIZE	0x08000000  /*   128 MByte	*/
+
+#define	OCTEON_PCIMEM3_BASE	0x18000000  /* PCI 3 memory	*/
+#define	OCTEON_PCIMEM3_SIZE	0x03e00000  /*    62 MByte	*/
+
+#define	OCTEON_CORECTRL_BASE	0x1be00000  /* Core control:	*/
+#define	OCTEON_CORECTRL_SIZE	0x00200000  /*     2 MByte	*/
+
+#define	OCTEON_RESERVED_BASE1	0x1c000000  /* Reserved:	*/
+#define	OCTEON_RESERVED_SIZE1	0x02000000  /*    32 MByte	*/
+
+#define	OCTEON_MONITORFLASH_BASE	0x1e000000  /* Monitor Flash:	*/
+#define	OCTEON_MONITORFLASH_SIZE	0x003e0000  /*     4 MByte	*/
+#define	OCTEON_MONITORFLASH_SECTORSIZE 0x00010000 /* Sect. = 64 KB */
+
+#define	OCTEON_FILEFLASH_BASE	0x1e3e0000 /* File Flash (for monitor): */
+#define	OCTEON_FILEFLASH_SIZE	0x00020000 /*   128 KByte	*/
+
+#define	OCTEON_FILEFLASH_SECTORSIZE 0x00010000 /* Sect. = 64 KB	*/
+
+#define	OCTEON_RESERVED_BASE2	0x1e400000  /* Reserved:	*/
+#define	OCTEON_RESERVED_SIZE2	0x00c00000  /*    12 MByte	*/
+
+#define	OCTEON_FPGA_BASE		0x1f000000  /* FPGA:		*/
+#define	OCTEON_FPGA_SIZE		0x00c00000  /*    12 MByte	*/
+
+#define	OCTEON_NMISTATUS		(OCTEON_FPGA_BASE + 0x24)
+#define	 OCTEON_NMI_SB		 0x2	/* Pending NMI from the South Bridge */
+#define	 OCTEON_NMI_ONNMI	 0x1	/* Pending NMI from the ON/NMI push button */
+
+#define	OCTEON_NMIACK		(OCTEON_FPGA_BASE + 0x104)
+#define	 OCTEON_NMIACK_ONNMI	 0x1	/* Write 1 to acknowledge ON/NMI */
+
+#define	OCTEON_SWITCH		(OCTEON_FPGA_BASE + 0x200)
+#define	 OCTEON_SWITCH_MASK	 0xff	/* settings of DIP switch S2 */
+
+#define	OCTEON_STATUS		(OCTEON_FPGA_BASE + 0x208)
+#define	 OCTEON_ST_MFWR		 0x10	/* Monitor Flash is write protected (JP1) */
+#define	 OCTEON_S54		 0x08	/* switch S5-4 - set YAMON factory default mode */
+#define	 OCTEON_S53		 0x04	/* switch S5-3 */
+#define	 OCTEON_BIGEND		 0x02	/* switch S5-2 - big endian mode */
+
+#define	OCTEON_JMPRS		(OCTEON_FPGA_BASE + 0x210)
+#define	 OCTEON_JMPRS_PCICLK	 0x1c	/* PCI clock frequency */
+#define	 OCTEON_JMPRS_EELOCK	 0x02	/* I2C EEPROM is write protected */
+
+#define	OCTEON_LEDBAR		(OCTEON_FPGA_BASE + 0x408)
+#define	OCTEON_ASCIIWORD		(OCTEON_FPGA_BASE + 0x410)
+#define	OCTEON_ASCII_BASE	(OCTEON_FPGA_BASE + 0x418)
+#define	OCTEON_ASCIIPOS0		0x00
+#define	OCTEON_ASCIIPOS1		0x08
+#define	OCTEON_ASCIIPOS2		0x10
+#define	OCTEON_ASCIIPOS3		0x18
+#define	OCTEON_ASCIIPOS4		0x20
+#define	OCTEON_ASCIIPOS5		0x28
+#define	OCTEON_ASCIIPOS6		0x30
+#define	OCTEON_ASCIIPOS7		0x38
+
+#define	OCTEON_SOFTRES		(OCTEON_FPGA_BASE + 0x500)
+#define	 OCTEON_GORESET		 0x42	/* write this to OCTEON_SOFTRES for board reset */
+
+/*
+ * BRKRES is the number of milliseconds before a "break" on tty will
+ * trigger a reset.  A value of 0 will disable the reset.
+ */
+#define	OCTEON_BRKRES		(OCTEON_FPGA_BASE + 0x508)
+#define	 OCTEON_BRKRES_MASK	 0xff
+
+#define	OCTEON_CBUSUART		0x8001180000000800ull
+/* 16C550C UART, 8 bit registers on 8 byte boundaries */
+/* RXTX    0x00 */
+/* INTEN   0x08 */
+/* IIFIFO  0x10 */
+/* LCTRL   0x18 */
+/* MCTRL   0x20 */
+/* LSTAT   0x28 */
+/* MSTAT   0x30 */
+/* SCRATCH 0x38 */
+#define	OCTEON_CBUSUART_INTR	2
+
+#define	OCTEON_GPIO_BASE		(OCTEON_FPGA_BASE + 0xa00)
+#define	OCTEON_GPOUT		0x0
+#define	OCTEON_GPINP		0x8
+
+#define	OCTEON_BOOTROM_BASE	0x1fc00000  /* Boot ROM:	*/
+#define	OCTEON_BOOTROM_SIZE	0x00400000  /*     4 MByte	*/
+
+#define	 OCTEON_REVISION	 0x1fc00010
+#define	 OCTEON_REV_FPGRV	 0xff0000	/* CBUS FPGA revision */
+#define	 OCTEON_REV_CORID	 0x00fc00	/* Core Board ID */
+#define	 OCTEON_REV_CORRV	 0x000300	/* Core Board Revision */
+#define	 OCTEON_REV_PROID	 0x0000f0	/* Product ID */
+#define	 OCTEON_REV_PRORV	 0x00000f	/* Product Revision */
+
+/* PCI definitions */
+
+#define OCTEON_UART0ADR			0x8001180000000800ull
+#define OCTEON_UART1ADR         	0x8001180000000C00ull
+
+#define OCTEON_MIO_BOOT_BIST_STAT	0x80011800000000F8ull
+
+
+
+/**************************
+ * To Delete
+ */
+#define	OCTEON_SOUTHBRIDGE_INTR	   0
+
+#define OCTEON_PCI0_IO_BASE         OCTEON_PCIMEM3_BASE
+#define OCTEON_PCI0_ADDR( addr )    (OCTEON_PCI0_IO_BASE + (addr))
+
+#define OCTEON_RTCADR               0x70 // OCTEON_PCI_IO_ADDR8(0x70)
+#define OCTEON_RTCDAT               0x71 // OCTEON_PCI_IO_ADDR8(0x71)
+
+#define OCTEON_SMSC_COM1_ADR        0x3f8
+#define OCTEON_SMSC_COM2_ADR        0x2f8
+#define OCTEON_UARTT0ADR             OCTEON_PCI0_ADDR(OCTEON_SMSC_COM1_ADR)
+#define OCTEON_UARTT1ADR             OCTEON_SMSC_COM2_ADR // OCTEON_PCI0_ADDR(OCTEON_SMSC_COM2_ADR)
+
+#define OCTEON_SMSC_1284_ADR        0x378
+#define OCTEON_1284ADR              OCTEON_SMSC_1284_ADR // OCTEON_PCI0_ADDR(OCTEON_SMSC_1284_ADR)
+
+#define OCTEON_SMSC_FDD_ADR         0x3f0
+#define OCTEON_FDDADR               OCTEON_SMSC_FDD_ADR // OCTEON_PCI0_ADDR(OCTEON_SMSC_FDD_ADR)
+
+#define OCTEON_SMSC_KYBD_ADR        0x60  /* Fixed 0x60, 0x64 */
+#define OCTEON_KYBDADR              OCTEON_SMSC_KYBD_ADR // OCTEON_PCI0_ADDR(OCTEON_SMSC_KYBD_ADR)
+#define OCTEON_SMSC_MOUSE_ADR       OCTEON_SMSC_KYBD_ADR
+#define OCTEON_MOUSEADR             OCTEON_KYBDADR
+
+
+#define	OCTEON_DMA_PCI_PCIBASE	0x00000000UL
+#define	OCTEON_DMA_PCI_PHYSBASE	0x00000000UL
+#define	OCTEON_DMA_PCI_SIZE	(256 * 1024 * 1024)
+
+#define	OCTEON_DMA_ISA_PCIBASE	0x00800000UL
+#define	OCTEON_DMA_ISA_PHYSBASE	0x00000000UL
+#define	OCTEON_DMA_ISA_SIZE	(8 * 1024 * 1024)
+
+#ifndef _LOCORE
+void	led_bar(uint8_t);
+void	led_display_word(uint32_t);
+void	led_display_str(const char *);
+void	led_display_char(int, uint8_t);
+#endif
diff -I '.*' -Naur releng8/sys/mips/octeon1/std.octeon1 svn/mips/sys/mips/octeon1/std.octeon1
--- releng8/src/sys/mips/octeon1/std.octeon1	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/std.octeon1	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,22 @@
+# /*
+#  *    This product includes software developed by the University of
+#  *    California, Berkeley and its contributors."
+# */
+# $FreeBSD$
+# 
+files	"../octeon1/files.octeon1"
+
+#
+# 
+#
+cpu     CPU_MIPS4KC
+#device	pci
+#device	ata
+#device	atadisk
+
+#device clock
+#device obio
+#device uart
+
+# Kludge
+options	TARGET_OCTEON
diff -I '.*' -Naur releng8/sys/mips/octeon1/uart_bus_octeonusart.c svn/mips/sys/mips/octeon1/uart_bus_octeonusart.c
--- releng8/src/sys/mips/octeon1/uart_bus_octeonusart.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/uart_bus_octeonusart.c	2009-07-02 18:44:24.000000000 -0700
@@ -0,0 +1,122 @@
+/*-
+ * Copyright (c) 2006 Wojciech A. Koszek <wkoszek@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * $Id$
+ */
+/*
+ * Skeleton of this file was based on respective code for ARM
+ * code written by Olivier Houchard.
+ */
+
+/*
+ * XXXMIPS: This file is hacked from arm/... . XXXMIPS here means this file is
+ * experimental and was written for MIPS32 port.
+ */
+#include "opt_uart.h"
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/octeon1/uart_bus_octeonusart.c 194175 2009-06-14 07:01:22Z imp $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <machine/bus.h>
+#include <sys/rman.h>
+#include <machine/resource.h>
+
+#include <dev/pci/pcivar.h>
+
+#include <dev/uart/uart.h>
+#include <dev/uart/uart_bus.h>
+#include <dev/uart/uart_cpu.h>
+
+/*
+ * XXXMIPS:
+ */
+#include <mips/octeon1/octeonreg.h>
+
+#include "uart_if.h"
+
+extern struct uart_class uart_oct16550_class;
+
+
+static int uart_octeon_probe(device_t dev);
+static void octeon_uart_identify(driver_t * drv, device_t parent);
+
+extern struct uart_class octeon_uart_class;
+
+static device_method_t uart_octeon_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe, uart_octeon_probe),
+	DEVMETHOD(device_attach, uart_bus_attach),
+	DEVMETHOD(device_detach, uart_bus_detach),
+	DEVMETHOD(device_identify, octeon_uart_identify),
+	{0, 0}
+};
+
+static driver_t uart_octeon_driver = {
+	uart_driver_name,
+	uart_octeon_methods,
+	sizeof(struct uart_softc),
+};
+
+extern 
+SLIST_HEAD(uart_devinfo_list, uart_devinfo) uart_sysdevs;
+	static int
+	    uart_octeon_probe(device_t dev)
+{
+	struct uart_softc *sc;
+	int unit;
+
+/*
+ * Note that both tty0 & tty1 are viable consoles. We add child devices
+ * such that ttyu0 ends up front of queue.
+ */
+	unit = device_get_unit(dev);
+	sc = device_get_softc(dev);
+	sc->sc_sysdev = NULL;
+	sc->sc_sysdev = SLIST_FIRST(&uart_sysdevs);
+	bcopy(&sc->sc_sysdev->bas, &sc->sc_bas, sizeof(sc->sc_bas));
+	if (!unit) {
+		sc->sc_sysdev->bas.bst = 0;
+		sc->sc_sysdev->bas.bsh = OCTEON_UART0ADR;
+	}
+	sc->sc_class = &uart_oct16550_class;
+	sc->sc_bas.bst = 0;
+	sc->sc_bas.bsh = unit ? OCTEON_UART1ADR : OCTEON_UART0ADR;
+	sc->sc_bas.regshft = 0x3;
+	return (uart_bus_probe(dev, sc->sc_bas.regshft, 0, 0, unit));
+}
+
+static void
+octeon_uart_identify(driver_t * drv, device_t parent)
+{
+	BUS_ADD_CHILD(parent, 0, "uart", 0);
+}
+
+
+
+DRIVER_MODULE(uart, obio, uart_octeon_driver, uart_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/octeon1/uart_cpu_octeonusart.c svn/mips/sys/mips/octeon1/uart_cpu_octeonusart.c
--- releng8/src/sys/mips/octeon1/uart_cpu_octeonusart.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/uart_cpu_octeonusart.c	2009-09-08 11:01:51.000000000 -0700
@@ -0,0 +1,90 @@
+/*-
+ * Copyright (c) 2006 Wojciech A. Koszek <wkoszek@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Id$
+ */
+/*
+ * Skeleton of this file was based on respective code for ARM
+ * code written by Olivier Houchard.
+ */
+/*
+ * XXXMIPS: This file is hacked from arm/... . XXXMIPS here means this file is
+ * experimental and was written for MIPS32 port.
+ */
+#include "opt_uart.h"
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/octeon1/uart_cpu_octeonusart.c 196259 2009-08-15 19:48:14Z imp $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/cons.h>
+
+#include <machine/bus.h>
+
+#include <dev/uart/uart.h>
+#include <dev/uart/uart_cpu.h>
+
+#include <mips/octeon1/octeonreg.h>
+
+bus_space_tag_t uart_bus_space_io;
+bus_space_tag_t uart_bus_space_mem;
+
+extern struct uart_class uart_oct16550_class;
+extern struct uart_ops octeon_usart_ops;
+extern struct bus_space octeon_bs_tag;
+
+int
+uart_cpu_eqres(struct uart_bas *b1, struct uart_bas *b2)
+{
+	return ((b1->bsh == b2->bsh && b1->bst == b2->bst) ? 1 : 0);
+	return (0);
+}
+
+int
+uart_cpu_getdev(int devtype, struct uart_devinfo *di)
+{
+	struct uart_class *class;
+
+	class = &uart_oct16550_class;
+	di->ops = uart_getops(class);
+	di->bas.bst = 0;
+	di->bas.chan = 0;
+	di->bas.regshft = 3;	/* Each UART reg is 8 byte addresss apart.  1
+				 * << 3 */
+	di->bas.rclk = 0;
+	di->baudrate = 115200;
+	di->databits = 8;
+	di->stopbits = 1;
+	di->parity = UART_PARITY_NONE;
+
+	di->bas.bsh = OCTEON_UART0ADR;
+	uart_getenv(devtype, di, class);
+
+	uart_bus_space_io = NULL;
+	uart_bus_space_mem = mips_bus_space_generic;
+	return (0);
+}
diff -I '.*' -Naur releng8/sys/mips/octeon1/uart_dev_oct16550.c svn/mips/sys/mips/octeon1/uart_dev_oct16550.c
--- releng8/src/sys/mips/octeon1/uart_dev_oct16550.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/octeon1/uart_dev_oct16550.c	2009-09-08 11:01:51.000000000 -0700
@@ -0,0 +1,827 @@
+/*-
+ * Copyright (c) 2003 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * uart_dev_oct16550.c
+ *
+ * Derived from uart_dev_ns8250.c
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ */
+
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/octeon1/uart_dev_oct16550.c 196237 2009-08-15 02:03:41Z imp $");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/conf.h>
+#include <machine/bus.h>
+#include <machine/pcpu.h>
+
+#include <dev/uart/uart.h>
+#include <dev/uart/uart_cpu.h>
+#include <dev/uart/uart_bus.h>
+
+#include <dev/ic/ns16550.h>
+
+#include <mips/octeon1/octeon_pcmap_regs.h>
+
+#include "uart_if.h"
+
+/*
+ * Clear pending interrupts. THRE is cleared by reading IIR. Data
+ * that may have been received gets lost here.
+ */
+static void
+oct16550_clrint (struct uart_bas *bas)
+{
+	uint8_t iir;
+
+	iir = uart_getreg(bas, REG_IIR);
+	while ((iir & IIR_NOPEND) == 0) {
+		iir &= IIR_IMASK;
+		if (iir == IIR_RLS)
+			(void)uart_getreg(bas, REG_LSR);
+		else if (iir == IIR_RXRDY || iir == IIR_RXTOUT)
+			(void)uart_getreg(bas, REG_DATA);
+		else if (iir == IIR_MLSC)
+			(void)uart_getreg(bas, REG_MSR);
+                else if (iir == IIR_BUSY)
+                    	(void) uart_getreg(bas, REG_USR);
+		uart_barrier(bas);
+		iir = uart_getreg(bas, REG_IIR);
+	}
+}
+
+static int delay_changed = 1;
+
+static int
+oct16550_delay (struct uart_bas *bas)
+{
+	int divisor;
+	u_char lcr;
+        static int delay = 0;
+
+        if (!delay_changed) return delay;
+        delay_changed = 0;
+	lcr = uart_getreg(bas, REG_LCR);
+	uart_setreg(bas, REG_LCR, lcr | LCR_DLAB);
+	uart_barrier(bas);
+	divisor = uart_getreg(bas, REG_DLL) | (uart_getreg(bas, REG_DLH) << 8);
+	uart_barrier(bas);
+	uart_setreg(bas, REG_LCR, lcr);
+	uart_barrier(bas);
+	
+	if(!bas->rclk)
+		return 10; /* return an approx delay value */
+
+	/* 1/10th the time to transmit 1 character (estimate). */
+	if (divisor <= 134)
+		return (16000000 * divisor / bas->rclk);
+	return (16000 * divisor / (bas->rclk / 1000));
+
+}
+
+static int
+oct16550_divisor (int rclk, int baudrate)
+{
+	int actual_baud, divisor;
+	int error;
+
+	if (baudrate == 0)
+		return (0);
+
+	divisor = (rclk / (baudrate << 3) + 1) >> 1;
+	if (divisor == 0 || divisor >= 65536)
+		return (0);
+	actual_baud = rclk / (divisor << 4);
+
+	/* 10 times error in percent: */
+	error = ((actual_baud - baudrate) * 2000 / baudrate + 1) >> 1;
+
+	/* 3.0% maximum error tolerance: */
+	if (error < -30 || error > 30)
+		return (0);
+
+	return (divisor);
+}
+
+static int
+oct16550_drain (struct uart_bas *bas, int what)
+{
+	int delay, limit;
+
+	delay = oct16550_delay(bas);
+
+	if (what & UART_DRAIN_TRANSMITTER) {
+		/*
+		 * Pick an arbitrary high limit to avoid getting stuck in
+		 * an infinite loop when the hardware is broken. Make the
+		 * limit high enough to handle large FIFOs.
+		 */
+		limit = 10*10*10*1024;
+		while ((uart_getreg(bas, REG_LSR) & LSR_TEMT) == 0 && --limit)
+			DELAY(delay);
+		if (limit == 0) {
+			/* printf("oct16550: transmitter appears stuck... "); */
+			return (0);
+		}
+	}
+
+	if (what & UART_DRAIN_RECEIVER) {
+		/*
+		 * Pick an arbitrary high limit to avoid getting stuck in
+		 * an infinite loop when the hardware is broken. Make the
+		 * limit high enough to handle large FIFOs and integrated
+		 * UARTs. The HP rx2600 for example has 3 UARTs on the
+		 * management board that tend to get a lot of data send
+		 * to it when the UART is first activated.
+		 */
+		limit=10*4096;
+		while ((uart_getreg(bas, REG_LSR) & LSR_RXRDY) && --limit) {
+			(void)uart_getreg(bas, REG_DATA);
+			uart_barrier(bas);
+			DELAY(delay << 2);
+		}
+		if (limit == 0) {
+			/* printf("oct16550: receiver appears broken... "); */
+			return (EIO);
+		}
+	}
+
+	return (0);
+}
+
+/*
+ * We can only flush UARTs with FIFOs. UARTs without FIFOs should be
+ * drained. WARNING: this function clobbers the FIFO setting!
+ */
+static void
+oct16550_flush (struct uart_bas *bas, int what)
+{
+	uint8_t fcr;
+
+	fcr = FCR_ENABLE;
+	if (what & UART_FLUSH_TRANSMITTER)
+		fcr |= FCR_XMT_RST;
+	if (what & UART_FLUSH_RECEIVER)
+		fcr |= FCR_RCV_RST;
+	uart_setreg(bas, REG_FCR, fcr);
+	uart_barrier(bas);
+}
+
+static int
+oct16550_param (struct uart_bas *bas, int baudrate, int databits, int stopbits,
+    int parity)
+{
+	int divisor;
+	uint8_t lcr;
+
+	lcr = 0;
+	if (databits >= 8)
+		lcr |= LCR_8BITS;
+	else if (databits == 7)
+		lcr |= LCR_7BITS;
+	else if (databits == 6)
+		lcr |= LCR_6BITS;
+	else
+		lcr |= LCR_5BITS;
+	if (stopbits > 1)
+		lcr |= LCR_STOPB;
+	lcr |= parity << 3;
+
+	/* Set baudrate. */
+	if (baudrate > 0) {
+		divisor = oct16550_divisor(bas->rclk, baudrate);
+		if (divisor == 0)
+			return (EINVAL);
+		uart_setreg(bas, REG_LCR, lcr | LCR_DLAB);
+		uart_barrier(bas);
+		uart_setreg(bas, REG_DLL, divisor & 0xff);
+		uart_setreg(bas, REG_DLH, (divisor >> 8) & 0xff);
+		uart_barrier(bas);
+                delay_changed = 1;
+	}
+
+	/* Set LCR and clear DLAB. */
+	uart_setreg(bas, REG_LCR, lcr);
+	uart_barrier(bas);
+	return (0);
+}
+
+/*
+ * Low-level UART interface.
+ */
+static int oct16550_probe(struct uart_bas *bas);
+static void oct16550_init(struct uart_bas *bas, int, int, int, int);
+static void oct16550_term(struct uart_bas *bas);
+static void oct16550_putc(struct uart_bas *bas, int);
+static int oct16550_rxready(struct uart_bas *bas);
+static int oct16550_getc(struct uart_bas *bas, struct mtx *);
+
+struct uart_ops uart_oct16550_ops = {
+	.probe = oct16550_probe,
+	.init = oct16550_init,
+	.term = oct16550_term,
+	.putc = oct16550_putc,
+	.rxready = oct16550_rxready,
+	.getc = oct16550_getc,
+};
+
+static int
+oct16550_probe (struct uart_bas *bas)
+{
+	u_char val;
+
+	/* Check known 0 bits that don't depend on DLAB. */
+	val = uart_getreg(bas, REG_IIR);
+	if (val & 0x30)
+		return (ENXIO);
+	val = uart_getreg(bas, REG_MCR);
+	if (val & 0xc0)
+		return (ENXIO);
+	val = uart_getreg(bas, REG_USR);
+        if (val & 0xe0)
+            	return (ENXIO);
+	return (0);
+}
+
+static void
+oct16550_init (struct uart_bas *bas, int baudrate, int databits, int stopbits,
+    int parity)
+{
+	u_char	ier;
+
+	oct16550_param(bas, baudrate, databits, stopbits, parity);
+
+	/* Disable all interrupt sources. */
+	ier = uart_getreg(bas, REG_IER) & 0x0;
+	uart_setreg(bas, REG_IER, ier);
+	uart_barrier(bas);
+
+	/* Disable the FIFO (if present). */
+//	uart_setreg(bas, REG_FCR, 0);
+	uart_barrier(bas);
+
+	/* Set RTS & DTR. */
+	uart_setreg(bas, REG_MCR, MCR_RTS | MCR_DTR);
+	uart_barrier(bas);
+
+	oct16550_clrint(bas);
+}
+
+static void
+oct16550_term (struct uart_bas *bas)
+{
+
+	/* Clear RTS & DTR. */
+	uart_setreg(bas, REG_MCR, 0);
+	uart_barrier(bas);
+}
+
+static inline void oct16550_wait_txhr_empty (struct uart_bas *bas, int limit, int delay)
+{
+    while (((uart_getreg(bas, REG_LSR) & LSR_THRE) == 0) &&
+           ((uart_getreg(bas, REG_USR) & USR_TXFIFO_NOTFULL) == 0))
+        DELAY(delay);
+}
+
+static void
+oct16550_putc (struct uart_bas *bas, int c)
+{
+	int delay;
+
+	/* 1/10th the time to transmit 1 character (estimate). */
+	delay = oct16550_delay(bas);
+        oct16550_wait_txhr_empty(bas, 100, delay);
+	uart_setreg(bas, REG_DATA, c);
+	uart_barrier(bas);
+        oct16550_wait_txhr_empty(bas, 100, delay);
+}
+
+static int
+oct16550_rxready (struct uart_bas *bas)
+{
+
+	return ((uart_getreg(bas, REG_LSR) & LSR_RXRDY) != 0 ? 1 : 0);
+}
+
+static int
+oct16550_getc (struct uart_bas *bas, struct mtx *hwmtx)
+{
+	int c, delay;
+
+	uart_lock(hwmtx);
+
+	/* 1/10th the time to transmit 1 character (estimate). */
+	delay = oct16550_delay(bas);
+
+	while ((uart_getreg(bas, REG_LSR) & LSR_RXRDY) == 0) {
+		uart_unlock(hwmtx);
+		DELAY(delay);
+		uart_lock(hwmtx);
+	}
+
+	c = uart_getreg(bas, REG_DATA);
+
+	uart_unlock(hwmtx);
+
+	return (c);
+}
+
+/*
+ * High-level UART interface.
+ */
+struct oct16550_softc {
+	struct uart_softc base;
+	uint8_t		fcr;
+	uint8_t		ier;
+	uint8_t		mcr;
+};
+
+static int oct16550_bus_attach(struct uart_softc *);
+static int oct16550_bus_detach(struct uart_softc *);
+static int oct16550_bus_flush(struct uart_softc *, int);
+static int oct16550_bus_getsig(struct uart_softc *);
+static int oct16550_bus_ioctl(struct uart_softc *, int, intptr_t);
+static int oct16550_bus_ipend(struct uart_softc *);
+static int oct16550_bus_param(struct uart_softc *, int, int, int, int);
+static int oct16550_bus_probe(struct uart_softc *);
+static int oct16550_bus_receive(struct uart_softc *);
+static int oct16550_bus_setsig(struct uart_softc *, int);
+static int oct16550_bus_transmit(struct uart_softc *);
+
+static kobj_method_t oct16550_methods[] = {
+	KOBJMETHOD(uart_attach,		oct16550_bus_attach),
+	KOBJMETHOD(uart_detach,		oct16550_bus_detach),
+	KOBJMETHOD(uart_flush,		oct16550_bus_flush),
+	KOBJMETHOD(uart_getsig,		oct16550_bus_getsig),
+	KOBJMETHOD(uart_ioctl,		oct16550_bus_ioctl),
+	KOBJMETHOD(uart_ipend,		oct16550_bus_ipend),
+	KOBJMETHOD(uart_param,		oct16550_bus_param),
+	KOBJMETHOD(uart_probe,		oct16550_bus_probe),
+	KOBJMETHOD(uart_receive,	oct16550_bus_receive),
+	KOBJMETHOD(uart_setsig,		oct16550_bus_setsig),
+	KOBJMETHOD(uart_transmit,	oct16550_bus_transmit),
+	{ 0, 0 }
+};
+
+struct uart_class uart_oct16550_class = {
+	"oct16550 class",
+	oct16550_methods,
+	sizeof(struct oct16550_softc),
+	.uc_ops = &uart_oct16550_ops,
+	.uc_range = 8,
+	.uc_rclk = 0
+};
+
+#define	SIGCHG(c, i, s, d)				\
+	if (c) {					\
+		i |= (i & s) ? s : s | d;		\
+	} else {					\
+		i = (i & s) ? (i & ~s) | d : i;		\
+	}
+
+static int
+oct16550_bus_attach (struct uart_softc *sc)
+{
+	struct oct16550_softc *oct16550 = (struct oct16550_softc*)sc;
+	struct uart_bas *bas;
+        int unit;
+
+        unit = device_get_unit(sc->sc_dev);
+	bas = &sc->sc_bas;
+
+        oct16550_drain(bas, UART_DRAIN_TRANSMITTER);
+	oct16550->mcr = uart_getreg(bas, REG_MCR);
+	oct16550->fcr = FCR_ENABLE | FCR_RX_HIGH;
+	uart_setreg(bas, REG_FCR, oct16550->fcr);
+	uart_barrier(bas);
+	oct16550_bus_flush(sc, UART_FLUSH_RECEIVER|UART_FLUSH_TRANSMITTER);
+
+	if (oct16550->mcr & MCR_DTR)
+		sc->sc_hwsig |= SER_DTR;
+	if (oct16550->mcr & MCR_RTS)
+		sc->sc_hwsig |= SER_RTS;
+	oct16550_bus_getsig(sc);
+
+	oct16550_clrint(bas);
+	oct16550->ier = uart_getreg(bas, REG_IER) & 0xf0;
+	oct16550->ier |= IER_EMSC | IER_ERLS | IER_ERXRDY;
+	uart_setreg(bas, REG_IER, oct16550->ier);
+	uart_barrier(bas);
+
+	uint32_t status_bits = mips_rd_status();
+	mips_wr_status(status_bits & ~MIPS_SR_INT_IE);
+	/*
+	 * Enable the interrupt in CIU.     // UART-x2 @ IP2
+	 */
+        ciu_enable_interrupts(0, CIU_INT_0, CIU_EN_0,
+                              (!unit) ? CIU_UART_BITS_UART0 : CIU_UART_BITS_UART1, CIU_MIPS_IP2);
+	return (0);
+}
+
+static int
+oct16550_bus_detach (struct uart_softc *sc)
+{
+	struct uart_bas *bas;
+	u_char ier;
+
+	bas = &sc->sc_bas;
+	ier = uart_getreg(bas, REG_IER) & 0xf0;
+	uart_setreg(bas, REG_IER, ier);
+	uart_barrier(bas);
+	oct16550_clrint(bas);
+	return (0);
+}
+
+static int
+oct16550_bus_flush (struct uart_softc *sc, int what)
+{
+	struct oct16550_softc *oct16550 = (struct oct16550_softc*)sc;
+	struct uart_bas *bas;
+	int error;
+
+	bas = &sc->sc_bas;
+	uart_lock(sc->sc_hwmtx);
+	if (sc->sc_rxfifosz > 1) {
+		oct16550_flush(bas, what);
+		uart_setreg(bas, REG_FCR, oct16550->fcr);
+		uart_barrier(bas);
+		error = 0;
+	} else
+		error = oct16550_drain(bas, what);
+	uart_unlock(sc->sc_hwmtx);
+	return (error);
+}
+
+static int
+oct16550_bus_getsig (struct uart_softc *sc)
+{
+	uint32_t new, old, sig;
+	uint8_t msr;
+
+	do {
+		old = sc->sc_hwsig;
+		sig = old;
+		uart_lock(sc->sc_hwmtx);
+		msr = uart_getreg(&sc->sc_bas, REG_MSR);
+		uart_unlock(sc->sc_hwmtx);
+		SIGCHG(msr & MSR_DSR, sig, SER_DSR, SER_DDSR);
+		SIGCHG(msr & MSR_CTS, sig, SER_CTS, SER_DCTS);
+		SIGCHG(msr & MSR_DCD, sig, SER_DCD, SER_DDCD);
+		SIGCHG(msr & MSR_RI,  sig, SER_RI,  SER_DRI);
+		new = sig & ~SER_MASK_DELTA;
+	} while (!atomic_cmpset_32(&sc->sc_hwsig, old, new));
+	return (sig);
+}
+
+static int
+oct16550_bus_ioctl (struct uart_softc *sc, int request, intptr_t data)
+{
+	struct uart_bas *bas;
+	int baudrate, divisor, error;
+	uint8_t efr, lcr;
+
+	bas = &sc->sc_bas;
+	error = 0;
+	uart_lock(sc->sc_hwmtx);
+	switch (request) {
+	case UART_IOCTL_BREAK:
+		lcr = uart_getreg(bas, REG_LCR);
+		if (data)
+			lcr |= LCR_SBREAK;
+		else
+			lcr &= ~LCR_SBREAK;
+		uart_setreg(bas, REG_LCR, lcr);
+		uart_barrier(bas);
+		break;
+	case UART_IOCTL_IFLOW:
+		lcr = uart_getreg(bas, REG_LCR);
+		uart_barrier(bas);
+		uart_setreg(bas, REG_LCR, 0xbf);
+		uart_barrier(bas);
+		efr = uart_getreg(bas, REG_EFR);
+		if (data)
+			efr |= EFR_RTS;
+		else
+			efr &= ~EFR_RTS;
+		uart_setreg(bas, REG_EFR, efr);
+		uart_barrier(bas);
+		uart_setreg(bas, REG_LCR, lcr);
+		uart_barrier(bas);
+		break;
+	case UART_IOCTL_OFLOW:
+		lcr = uart_getreg(bas, REG_LCR);
+		uart_barrier(bas);
+		uart_setreg(bas, REG_LCR, 0xbf);
+		uart_barrier(bas);
+		efr = uart_getreg(bas, REG_EFR);
+		if (data)
+			efr |= EFR_CTS;
+		else
+			efr &= ~EFR_CTS;
+		uart_setreg(bas, REG_EFR, efr);
+		uart_barrier(bas);
+		uart_setreg(bas, REG_LCR, lcr);
+		uart_barrier(bas);
+		break;
+	case UART_IOCTL_BAUD:
+		lcr = uart_getreg(bas, REG_LCR);
+		uart_setreg(bas, REG_LCR, lcr | LCR_DLAB);
+		uart_barrier(bas);
+		divisor = uart_getreg(bas, REG_DLL) |
+		    (uart_getreg(bas, REG_DLH) << 8);
+		uart_barrier(bas);
+		uart_setreg(bas, REG_LCR, lcr);
+		uart_barrier(bas);
+		baudrate = (divisor > 0) ? bas->rclk / divisor / 16 : 0;
+                delay_changed = 1;
+		if (baudrate > 0)
+			*(int*)data = baudrate;
+		else
+			error = ENXIO;
+		break;
+	default:
+		error = EINVAL;
+		break;
+	}
+	uart_unlock(sc->sc_hwmtx);
+	return (error);
+}
+
+
+static int
+oct16550_bus_ipend(struct uart_softc *sc)
+{
+	struct uart_bas *bas;
+	int ipend = 0;
+	uint8_t iir, lsr;
+
+	bas = &sc->sc_bas;
+	uart_lock(sc->sc_hwmtx);
+
+	iir = uart_getreg(bas, REG_IIR) & IIR_IMASK;
+	if (iir != IIR_NOPEND) {
+
+            	if (iir == IIR_RLS) {
+                    	lsr = uart_getreg(bas, REG_LSR);
+                        if (lsr & LSR_OE)
+                            	ipend |= SER_INT_OVERRUN;
+                        if (lsr & LSR_BI)
+                            	ipend |= SER_INT_BREAK;
+                        if (lsr & LSR_RXRDY)
+                    		ipend |= SER_INT_RXREADY;
+
+                } else if (iir == IIR_RXRDY) {
+                    	ipend |= SER_INT_RXREADY;
+
+                } else if (iir == IIR_RXTOUT) {
+                    	ipend |= SER_INT_RXREADY;
+
+                } else if (iir == IIR_TXRDY) {
+                    	ipend |= SER_INT_TXIDLE;
+
+                } else if (iir == IIR_MLSC) {
+                    	ipend |= SER_INT_SIGCHG;
+
+                } else if (iir == IIR_BUSY) {
+                    	(void) uart_getreg(bas, REG_USR);
+                }
+	}
+	uart_unlock(sc->sc_hwmtx);
+
+//#define OCTEON_VISUAL_UART 1
+#ifdef OCTEON_VISUAL_UART
+        static int where1 = 0;
+
+        if (ipend)	octeon_led_run_wheel(&where1, 6 + device_get_unit(sc->sc_dev));
+#endif
+
+	return ((sc->sc_leaving) ? 0 : ipend);
+}
+
+
+
+
+static int
+oct16550_bus_param (struct uart_softc *sc, int baudrate, int databits,
+    int stopbits, int parity)
+{
+	struct uart_bas *bas;
+	int error;
+
+	bas = &sc->sc_bas;
+	uart_lock(sc->sc_hwmtx);
+	error = oct16550_param(bas, baudrate, databits, stopbits, parity);
+	uart_unlock(sc->sc_hwmtx);
+	return (error);
+}
+
+static int
+oct16550_bus_probe (struct uart_softc *sc)
+{
+	struct uart_bas *bas;
+	int error;
+
+	bas = &sc->sc_bas;
+	bas->rclk = uart_oct16550_class.uc_rclk = octeon_cpu_clock;
+
+	error = oct16550_probe(bas);
+	if (error) {
+		return (error);
+        }
+
+	uart_setreg(bas, REG_MCR, (MCR_DTR | MCR_RTS));
+
+	/*
+	 * Enable FIFOs. And check that the UART has them. If not, we're
+	 * done. Since this is the first time we enable the FIFOs, we reset
+	 * them.
+	 */
+        oct16550_drain(bas, UART_DRAIN_TRANSMITTER);
+#define ENABLE_OCTEON_FIFO 1
+#ifdef ENABLE_OCTEON_FIFO
+	uart_setreg(bas, REG_FCR, FCR_ENABLE | FCR_XMT_RST | FCR_RCV_RST);
+#endif
+	uart_barrier(bas);
+
+	oct16550_flush(bas, UART_FLUSH_RECEIVER|UART_FLUSH_TRANSMITTER);
+
+        if (device_get_unit(sc->sc_dev)) {
+            	device_set_desc(sc->sc_dev, "Octeon-16550 channel 1");
+        } else {
+            	device_set_desc(sc->sc_dev, "Octeon-16550 channel 0");
+        }
+#ifdef ENABLE_OCTEON_FIFO
+	sc->sc_rxfifosz = 64;
+	sc->sc_txfifosz = 64;
+#else
+	sc->sc_rxfifosz = 1;
+	sc->sc_txfifosz = 1;
+#endif
+
+
+#if 0
+	/*
+	 * XXX there are some issues related to hardware flow control and
+	 * it's likely that uart(4) is the cause. This basicly needs more
+	 * investigation, but we avoid using for hardware flow control
+	 * until then.
+	 */
+	/* 16650s or higher have automatic flow control. */
+	if (sc->sc_rxfifosz > 16) {
+		sc->sc_hwiflow = 1;
+		sc->sc_hwoflow = 1;
+	}
+#endif
+
+	return (0);
+}
+
+static int
+oct16550_bus_receive (struct uart_softc *sc)
+{
+	struct uart_bas *bas;
+	int xc;
+	uint8_t lsr;
+
+	bas = &sc->sc_bas;
+	uart_lock(sc->sc_hwmtx);
+	lsr = uart_getreg(bas, REG_LSR);
+
+	while (lsr & LSR_RXRDY) {
+		if (uart_rx_full(sc)) {
+			sc->sc_rxbuf[sc->sc_rxput] = UART_STAT_OVERRUN;
+			break;
+		}
+		xc = uart_getreg(bas, REG_DATA);
+		if (lsr & LSR_FE)
+			xc |= UART_STAT_FRAMERR;
+		if (lsr & LSR_PE)
+			xc |= UART_STAT_PARERR;
+		uart_rx_put(sc, xc);
+		lsr = uart_getreg(bas, REG_LSR);
+	}
+	/* Discard everything left in the Rx FIFO. */
+        /*
+         * First do a dummy read/discard anyway, in case the UART was lying to us.
+         * This problem was seen on board, when IIR said RBR, but LSR said no RXRDY
+         * Results in a stuck ipend loop.
+         */
+        (void)uart_getreg(bas, REG_DATA);
+	while (lsr & LSR_RXRDY) {
+		(void)uart_getreg(bas, REG_DATA);
+		uart_barrier(bas);
+		lsr = uart_getreg(bas, REG_LSR);
+	}
+	uart_unlock(sc->sc_hwmtx);
+ 	return (0);
+}
+
+static int
+oct16550_bus_setsig (struct uart_softc *sc, int sig)
+{
+	struct oct16550_softc *oct16550 = (struct oct16550_softc*)sc;
+	struct uart_bas *bas;
+	uint32_t new, old;
+
+	bas = &sc->sc_bas;
+	do {
+		old = sc->sc_hwsig;
+		new = old;
+		if (sig & SER_DDTR) {
+			SIGCHG(sig & SER_DTR, new, SER_DTR,
+			    SER_DDTR);
+		}
+		if (sig & SER_DRTS) {
+			SIGCHG(sig & SER_RTS, new, SER_RTS,
+			    SER_DRTS);
+		}
+	} while (!atomic_cmpset_32(&sc->sc_hwsig, old, new));
+	uart_lock(sc->sc_hwmtx);
+	oct16550->mcr &= ~(MCR_DTR|MCR_RTS);
+	if (new & SER_DTR)
+		oct16550->mcr |= MCR_DTR;
+	if (new & SER_RTS)
+		oct16550->mcr |= MCR_RTS;
+	uart_setreg(bas, REG_MCR, oct16550->mcr);
+	uart_barrier(bas);
+	uart_unlock(sc->sc_hwmtx);
+	return (0);
+}
+
+static int
+oct16550_bus_transmit (struct uart_softc *sc)
+{
+	struct oct16550_softc *oct16550 = (struct oct16550_softc*)sc;
+	struct uart_bas *bas;
+	int i;
+
+	bas = &sc->sc_bas;
+	uart_lock(sc->sc_hwmtx);
+#ifdef NO_UART_INTERRUPTS
+        for (i = 0; i < sc->sc_txdatasz; i++) {
+            oct16550_putc(bas, sc->sc_txbuf[i]);
+        }
+#else
+
+        oct16550_wait_txhr_empty(bas, 100, oct16550_delay(bas));
+	uart_setreg(bas, REG_IER, oct16550->ier | IER_ETXRDY);
+	uart_barrier(bas);
+
+	for (i = 0; i < sc->sc_txdatasz; i++) {
+		uart_setreg(bas, REG_DATA, sc->sc_txbuf[i]);
+		uart_barrier(bas);
+	}
+	sc->sc_txbusy = 1;
+#endif
+	uart_unlock(sc->sc_hwmtx);
+	return (0);
+}
diff -I '.*' -Naur releng8/sys/mips/sentry5/files.sentry5 svn/mips/sys/mips/sentry5/files.sentry5
--- releng8/src/sys/mips/sentry5/files.sentry5	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/sentry5/files.sentry5	2009-04-14 15:53:59.000000000 -0700
@@ -4,11 +4,4 @@
 # for USB 1.1 OHCI, Ethernet and IPSEC cores
 # which are believed to be devices we have drivers for
 # which just need to be tweaked for attachment to an SSB system bus.
-
 mips/sentry5/s5_machdep.c		standard
-dev/siba/siba.c					optional siba
-dev/siba/siba_pcib.c				optional siba pci
-mips/sentry5/siba_cc.c			optional siba
-
-# notyet
-#mips/sentry5/siba_mips.c			optional siba
diff -I '.*' -Naur releng8/sys/mips/sentry5/obio.c svn/mips/sys/mips/sentry5/obio.c
--- releng8/src/sys/mips/sentry5/obio.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/sentry5/obio.c	2009-09-08 11:01:51.000000000 -0700
@@ -72,13 +72,11 @@
 int
 obio_probe(device_t dev)
 {
-	if(!have_one)
-	{
+	if (!have_one) {
 		have_one = 1;
 		return 0;
 	}
-	else
-		return (ENXIO);
+	return (ENXIO);
 }
 
 int
@@ -119,7 +117,6 @@
 {
 	struct resource *rv;
 	struct rman *rm;
-	bus_space_tag_t bt = 0;
 	bus_space_handle_t bh = 0;
 	struct obio_softc *sc = device_get_softc(bus);
 
@@ -131,7 +128,6 @@
 		return (NULL);
 	case SYS_RES_IOPORT:
 		rm = &sc->oba_rman;
-		bt = sc->oba_st;
 		bh = sc->oba_addr;
 		start = bh;
 		break;
@@ -146,7 +142,7 @@
 	if (type == SYS_RES_IRQ)
 		return (rv);
 	rman_set_rid(rv, *rid);
-	rman_set_bustag(rv, bt);
+	rman_set_bustag(rv, mips_bus_space_generic);
 	rman_set_bushandle(rv, bh);
 	
 	if (0) {
diff -I '.*' -Naur releng8/sys/mips/sentry5/siba_cc.c svn/mips/sys/mips/sentry5/siba_cc.c
--- releng8/src/sys/mips/sentry5/siba_cc.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/sentry5/siba_cc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,154 +0,0 @@
-/*-
- * Copyright (c) 2007 Bruce M. Simpson.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * Child driver for ChipCommon core.
- * This is not MI code at the moment.
- * Two 16C550 compatible UARTs live here. On the WGT634U, uart1 is the
- * system console, and uart0 is not pinned out.
- *  Because their presence is conditional, they should probably
- *  be attached from here.
- * GPIO lives here.
- * The hardware watchdog lives here.
- * Clock control registers live here.
- *  You don't need to read them to determine the clock speed on the 5365,
- *  which is always 200MHz and thus may be hardcoded (for now).
- * Flash config registers live here. There may or may not be system flash.
- * The external interface bus lives here (conditionally).
- * There is a JTAG interface here which may be used to attach probes to
- * the SoC for debugging.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/mips/sentry5/siba_cc.c,v 1.1.2.1 2009/08/03 08:13:06 kensmith Exp $");
-
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/bus.h>
-#include <sys/kernel.h>
-#include <sys/module.h>
-#include <sys/rman.h>
-#include <sys/malloc.h>
-
-#include <machine/bus.h>
-
-#include <dev/siba/sibavar.h>
-#include <dev/siba/sibareg.h>
-#include <dev/siba/siba_ids.h>
-
-static int	siba_cc_attach(device_t);
-static int	siba_cc_probe(device_t);
-static void	siba_cc_intr(void *v);
-
-static int
-siba_cc_probe(device_t dev)
-{
-
-	if (siba_get_vendor(dev) == SIBA_VID_BROADCOM &&
-	    siba_get_device(dev) == SIBA_DEVID_CHIPCOMMON) {
-		device_set_desc(dev, "ChipCommon core");
-		return (BUS_PROBE_DEFAULT);
-	}
-
-	return (ENXIO);
-}
-
-struct siba_cc_softc {
-	void *notused;
-};
-
-static int
-siba_cc_attach(device_t dev)
-{
-	//struct siba_cc_softc *sc = device_get_softc(dev);
-	struct resource *mem;
-	struct resource *irq;
-	int rid;
-
-	/*
-	 * Allocate the resources which the parent bus has already
-	 * determined for us.
-	 * TODO: interrupt routing
-	 */
-#define MIPS_MEM_RID 0x20
-	rid = MIPS_MEM_RID;
-	mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid, RF_ACTIVE);
-	if (mem == NULL) {
-		device_printf(dev, "unable to allocate memory\n");
-		return (ENXIO);
-	}
-
-	rid = 0;
-	irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid, 0);
-	if (irq == NULL) {
-		device_printf(dev, "unable to allocate irq\n");
-		return (ENXIO);
-	}
-
-	/* now setup the interrupt */
-	/* may be fast, exclusive or mpsafe at a later date */
-
-	/*
-	 * XXX is this interrupt line in ChipCommon used for anything
-	 * other than the uart? in that case we shouldn't hog it ourselves
-	 * and let uart claim it to avoid polled mode.
-	 */
-	int err;
-	void *cookie;
-	err = bus_setup_intr(dev, irq, INTR_TYPE_TTY, NULL, siba_cc_intr, NULL,
-	    &cookie);
-	if (err != 0) {
-		device_printf(dev, "unable to setup intr\n");
-		return (ENXIO);
-	}
-
-	/* TODO: attach uart child */
-
-	return (0);
-}
-
-static void
-siba_cc_intr(void *v)
-{
-
-}
-
-static device_method_t siba_cc_methods[] = {
-	/* Device interface */
-	DEVMETHOD(device_attach,	siba_cc_attach),
-	DEVMETHOD(device_probe,		siba_cc_probe),
-
-	{0, 0},
-};
-
-static driver_t siba_cc_driver = {
-	"siba_cc",
-	siba_cc_methods,
-	sizeof(struct siba_softc),
-};
-static devclass_t siba_cc_devclass;
-
-DRIVER_MODULE(siba_cc, siba, siba_cc_driver, siba_cc_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/sentry5/siba_mips.c svn/mips/sys/mips/sentry5/siba_mips.c
--- releng8/src/sys/mips/sentry5/siba_mips.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/sentry5/siba_mips.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,113 +0,0 @@
-/*-
- * Copyright (c) 2007 Bruce M. Simpson.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * Child driver for MIPS 3302 core.
- * Interrupt controller registers live here. Interrupts may not be routed
- * to the MIPS core if they are masked out.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/mips/sentry5/siba_mips.c,v 1.1.2.1 2009/08/03 08:13:06 kensmith Exp $");
-
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/bus.h>
-#include <sys/kernel.h>
-#include <sys/module.h>
-#include <sys/rman.h>
-#include <sys/malloc.h>
-
-#include <machine/bus.h>
-
-#include <dev/siba/sibavar.h>
-#include <dev/siba/sibareg.h>
-#include <dev/siba/siba_ids.h>
-
-static int	siba_mips_attach(device_t);
-static int	siba_mips_probe(device_t);
-
-static int
-siba_mips_probe(device_t dev)
-{
-
-	if (siba_get_vendor(dev) == SIBA_VID_BROADCOM &&
-	    siba_get_device(dev) == SIBA_DEVID_MIPS_3302) {
-		device_set_desc(dev, "MIPS 3302 processor");
-		return (BUS_PROBE_DEFAULT);
-	}
-
-	return (ENXIO);
-}
-
-struct siba_mips_softc {
-	void *notused;
-};
-
-static int
-siba_mips_attach(device_t dev)
-{
-	//struct siba_mips_softc *sc = device_get_softc(dev);
-	struct resource *mem;
-	int rid;
-
-	/*
-	 * Allocate the resources which the parent bus has already
-	 * determined for us.
-	 * TODO: interrupt routing
-	 */
-#define MIPS_MEM_RID 0x20
-	rid = MIPS_MEM_RID;
-	mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid,
-	    RF_ACTIVE);
-	if (mem == NULL) {
-		device_printf(dev, "unable to allocate memory\n");
-		return (ENXIO);
-	}
-#if 0
-	device_printf(dev, "start %08lx size %04lx\n",
-	    rman_get_start(mem), rman_get_size(mem));
-#endif
-
-	return (0);
-}
-
-static device_method_t siba_mips_methods[] = {
-	/* Device interface */
-	DEVMETHOD(device_attach,	siba_mips_attach),
-	DEVMETHOD(device_probe,		siba_mips_probe),
-
-	{0, 0},
-};
-
-static driver_t siba_mips_driver = {
-	"siba_mips",
-	siba_mips_methods,
-	sizeof(struct siba_softc),
-};
-static devclass_t siba_mips_devclass;
-
-DRIVER_MODULE(siba_mips, siba, siba_mips_driver, siba_mips_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/sentry5/siba_sdram.c svn/mips/sys/mips/sentry5/siba_sdram.c
--- releng8/src/sys/mips/sentry5/siba_sdram.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/sentry5/siba_sdram.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,114 +0,0 @@
-/*-
- * Copyright (c) 2007 Bruce M. Simpson.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * Child driver for SDRAM/DDR controller core.
- * Generally the OS should not need to access this device unless the
- * firmware has not configured the SDRAM controller.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/mips/sentry5/siba_sdram.c,v 1.1.2.1 2009/08/03 08:13:06 kensmith Exp $");
-
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/bus.h>
-#include <sys/kernel.h>
-#include <sys/module.h>
-#include <sys/rman.h>
-#include <sys/malloc.h>
-
-#include <machine/bus.h>
-
-#include <dev/siba/sibavar.h>
-#include <dev/siba/sibareg.h>
-#include <dev/siba/siba_ids.h>
-
-static int	siba_sdram_attach(device_t);
-static int	siba_sdram_probe(device_t);
-
-static int
-siba_sdram_probe(device_t dev)
-{
-
-	if (siba_get_vendor(dev) == SIBA_VID_BROADCOM &&
-	    siba_get_device(dev) == SIBA_DEVID_SDRAMDDR) {
-		device_set_desc(dev, "SDRAM/DDR core");
-		return (BUS_PROBE_DEFAULT);
-	}
-
-	return (ENXIO);
-}
-
-struct siba_sdram_softc {
-	void *notused;
-};
-
-static int
-siba_sdram_attach(device_t dev)
-{
-	//struct siba_sdram_softc *sc = device_get_softc(dev);
-	struct resource *mem;
-	int rid;
-
-	/*
-	 * Allocate the resources which the parent bus has already
-	 * determined for us.
-	 * TODO: interrupt routing
-	 */
-#define MIPS_MEM_RID 0x20
-	rid = MIPS_MEM_RID;
-	mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &rid,
-	    RF_ACTIVE);
-	if (mem == NULL) {
-		device_printf(dev, "unable to allocate memory\n");
-		return (ENXIO);
-	}
-
-#if 0
-	device_printf(dev, "start %08lx size %04lx\n",
-	    rman_get_start(mem), rman_get_size(mem));
-#endif
-
-	return (0);
-}
-
-static device_method_t siba_sdram_methods[] = {
-	/* Device interface */
-	DEVMETHOD(device_attach,	siba_sdram_attach),
-	DEVMETHOD(device_probe,		siba_sdram_probe),
-
-	{0, 0},
-};
-
-static driver_t siba_sdram_driver = {
-	"siba_sdram",
-	siba_sdram_methods,
-	sizeof(struct siba_softc),
-};
-static devclass_t siba_sdram_devclass;
-
-DRIVER_MODULE(siba_sdram, siba, siba_sdram_driver, siba_sdram_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/sentry5/uart_bus_sbusart.c svn/mips/sys/mips/sentry5/uart_bus_sbusart.c
--- releng8/src/sys/mips/sentry5/uart_bus_sbusart.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/sentry5/uart_bus_sbusart.c	2009-05-06 14:57:15.000000000 -0700
@@ -85,9 +85,9 @@
 	sc->sc_sysdev = SLIST_FIRST(&uart_sysdevs);
 	sc->sc_class = &uart_ns8250_class;
 	bcopy(&sc->sc_sysdev->bas, &sc->sc_bas, sizeof(sc->sc_bas));
-	sc->sc_sysdev->bas.bst = 0;
+	sc->sc_sysdev->bas.bst = mips_bus_space_generic;
 	sc->sc_sysdev->bas.bsh = MIPS_PHYS_TO_KSEG1(SENTRY5_UART1ADR);
-	sc->sc_bas.bst = 0;
+	sc->sc_bas.bst = mips_bus_space_generic;
 	sc->sc_bas.bsh = MIPS_PHYS_TO_KSEG1(SENTRY5_UART1ADR);
 	return(uart_bus_probe(dev, 0, 0, 0, 0));
 }
diff -I '.*' -Naur releng8/sys/mips/sentry5/uart_cpu_sbusart.c svn/mips/sys/mips/sentry5/uart_cpu_sbusart.c
--- releng8/src/sys/mips/sentry5/uart_cpu_sbusart.c	2009-08-03 01:13:06.000000000 -0700
+++ svn/mips/sys/mips/sentry5/uart_cpu_sbusart.c	2009-05-06 14:57:15.000000000 -0700
@@ -76,7 +76,7 @@
 	di->parity = UART_PARITY_NONE;
 
 	uart_bus_space_io = MIPS_PHYS_TO_KSEG1(SENTRY5_UART1ADR);
-	uart_bus_space_mem = MIPS_PHYS_TO_KSEG1(SENTRY5_UART1ADR);
+	uart_bus_space_mem = mips_bus_space_generic;
 	di->bas.bsh = MIPS_PHYS_TO_KSEG1(SENTRY5_UART1ADR);
 	return (0);
 }
diff -I '.*' -Naur releng8/sys/mips/sibyte/ata_zbbus.c svn/mips/sys/mips/sibyte/ata_zbbus.c
--- releng8/src/sys/mips/sibyte/ata_zbbus.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/sibyte/ata_zbbus.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,170 @@
+/*-
+ * Copyright (c) 2009 Neelkanth Natu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/sema.h>
+#include <sys/taskqueue.h>
+
+#include <machine/bus.h>
+
+#include <vm/uma.h>
+
+#include <sys/ata.h>
+#include <dev/ata/ata-all.h>
+
+#include <machine/resource.h>
+
+__FBSDID("$FreeBSD: projects/mips/sys/mips/sibyte/ata_zbbus.c 195333 2009-07-04 03:05:48Z imp $");
+
+static int
+ata_zbbus_probe(device_t dev)
+{
+
+	return (ata_probe(dev));
+}
+
+static int
+ata_zbbus_attach(device_t dev)
+{
+	int i, rid, regshift, regoffset;
+	struct ata_channel *ch;
+	struct resource *io;
+	
+	ch = device_get_softc(dev);
+
+	if (ch->attached)
+		return (0);
+	ch->attached = 1;
+
+	rid = 0;
+	io = bus_alloc_resource(dev, SYS_RES_MEMORY, &rid, 0, ~0, 1, RF_ACTIVE);
+	if (io == NULL)
+		return (ENXIO);
+
+	/*
+	 * SWARM needs an address shift of 5 when accessing ATA registers.
+	 *
+	 * For e.g. an access to register 4 actually needs an address
+	 * of (4 << 5) to be output on the generic bus.
+	 */
+	regshift = 5;
+	resource_int_value(device_get_name(dev), device_get_unit(dev),
+			   "regshift", &regshift);
+	if (regshift && bootverbose)
+		device_printf(dev, "using a register shift of %d\n", regshift);
+
+	regoffset = 0x1F0;
+	resource_int_value(device_get_name(dev), device_get_unit(dev),
+			   "regoffset", &regoffset);
+	if (regoffset && bootverbose) {
+		device_printf(dev, "using a register offset of 0x%0x\n",
+			      regoffset);
+	}
+
+	/* setup the ata register addresses */
+	for (i = ATA_DATA; i <= ATA_COMMAND; ++i) {
+		ch->r_io[i].res = io;
+		ch->r_io[i].offset = (regoffset + i) << regshift;
+	}
+
+	ch->r_io[ATA_CONTROL].res = io;
+	ch->r_io[ATA_CONTROL].offset = (regoffset + ATA_CTLOFFSET) << regshift;
+	ch->r_io[ATA_IDX_ADDR].res = io;	/* XXX what is this used for */
+	ata_default_registers(dev);
+
+	/* initialize softc for this channel */
+	ch->unit = 0;
+	ch->flags |= ATA_USE_16BIT;
+	ata_generic_hw(dev);
+
+	return (ata_attach(dev));
+}
+
+static int
+ata_zbbus_detach(device_t dev)
+{
+	int error;
+	struct ata_channel *ch = device_get_softc(dev);
+
+	if (!ch->attached)
+		return (0);
+	ch->attached = 0;
+
+	error = ata_detach(dev);
+
+	bus_release_resource(dev, SYS_RES_MEMORY, 0,
+			     ch->r_io[ATA_IDX_ADDR].res);
+
+	return (error);
+}
+
+static int
+ata_zbbus_suspend(device_t dev)
+{
+	struct ata_channel *ch = device_get_softc(dev);
+
+	if (!ch->attached)
+		return (0);
+
+	return (ata_suspend(dev));
+}
+
+static int
+ata_zbbus_resume(device_t dev)
+{
+	struct ata_channel *ch = device_get_softc(dev);
+
+	if (!ch->attached)
+		return (0);
+
+	return (ata_resume(dev));
+}
+
+static device_method_t ata_zbbus_methods[] = {
+	/* device interface */
+	DEVMETHOD(device_probe,		ata_zbbus_probe),
+	DEVMETHOD(device_attach,	ata_zbbus_attach),
+	DEVMETHOD(device_detach,	ata_zbbus_detach),
+	DEVMETHOD(device_suspend,	ata_zbbus_suspend),
+	DEVMETHOD(device_resume,	ata_zbbus_resume),
+
+	{ 0, 0 }
+};
+
+static driver_t ata_zbbus_driver = {
+	"ata",
+	ata_zbbus_methods,
+	sizeof(struct ata_channel)
+};
+
+DRIVER_MODULE(ata, zbbus, ata_zbbus_driver, ata_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/sibyte/files.sibyte svn/mips/sys/mips/sibyte/files.sibyte
--- releng8/src/sys/mips/sibyte/files.sibyte	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/sibyte/files.sibyte	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,9 @@
+# $FreeBSD$
+
+mips/sibyte/sb_machdep.c			standard
+mips/sibyte/sb_zbbus.c				standard
+mips/sibyte/sb_zbpci.c				standard
+mips/sibyte/sb_scd.c				standard
+mips/sibyte/ata_zbbus.c				standard
+
+mips/sibyte/sb_asm.S				standard
diff -I '.*' -Naur releng8/sys/mips/sibyte/sb_asm.S svn/mips/sys/mips/sibyte/sb_asm.S
--- releng8/src/sys/mips/sibyte/sb_asm.S	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/sibyte/sb_asm.S	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,155 @@
+/*-
+ * Copyright (c) 2009 Neelkanth Natu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <machine/asm.h>
+
+/*
+ * We compile a 32-bit kernel to run on the SB-1 processor which is a 64-bit
+ * processor. It has some registers that must be accessed using 64-bit load
+ * and store instructions.
+ *
+ * So we have to resort to assembly because the compiler does not emit the
+ * 'ld' and 'sd' instructions since it thinks that it is compiling for a
+ * 32-bit mips processor.
+ */
+
+.set	mips64
+.set	noat
+.set	noreorder
+
+/*
+ * return (MIPS_PHYS_TO_KSEG1(0x10020008))
+ * Parameters: none
+ */
+LEAF(sb_read_syscfg)
+	lui     v0, 0xb002
+	ori     v0, v0, 0x8
+	ld      v1, 0(v0)	/* syscfg = MIPS_PHYS_TO_KSEG1(0x10020008) */
+	move	v0, v1
+	dsll32	v0, v0, 0
+	dsrl32	v0, v0, 0	/* v0 = lower_uint32(mask) */
+	jr	ra
+	dsrl32	v1, v1, 0	/* v1 = upper_uint32(mask) */
+END(sb_read_syscfg)
+
+/*
+ * MIPS_PHYS_TO_KSEG1(0x10020008) = (uint64_t)val
+ * Parameters:
+ * - lower_uint32(val): a0
+ * - upper_uint32(val): a1
+ */
+LEAF(sb_write_syscfg)
+	lui     v0, 0xb002
+	ori     v0, v0, 0x8
+	dsll32	a1, a1, 0	/* clear lower 32 bits of a1 */
+	dsll32	a0, a0, 0
+	dsrl32	a0, a0, 0	/* clear upper 32 bits of a0 */
+	or	a1, a1, a0
+	sd	a1, 0(v0)	/* MIPS_PHYS_TO_KSEG1(0x10020008) = val */
+	jr	ra
+	nop
+	nop
+END(sb_write_syscfg)
+
+/*
+ * MIPS_PHYS_TO_KSEG1(0x10020028) |= (1 << intsrc)
+ *
+ * Parameters:
+ * - intsrc (a0)
+ */
+LEAF(sb_disable_intsrc)
+	lui     v0, 0xb002
+	ori     v0, v0, 0x28
+	ld      v1, 0(v0)	/* mask = MIPS_PHYS_TO_KSEG1(0x10020028) */
+	li      a1, 1
+	dsllv   a1, a1, a0
+	or      a1, a1, v1	/* mask |= (1 << intsrc) */
+	jr	ra
+	sd      a1, 0(v0)	/* MIPS_PHYS_TO_KSEG1(0x10020028) = mask */
+END(sb_disable_intsrc)
+
+/*
+ * MIPS_PHYS_TO_KSEG1(0x10020028) &= ~(1 << intsrc)
+ *
+ * Parameters:
+ * - intsrc (a0)
+ */
+LEAF(sb_enable_intsrc)
+	lui     v0, 0xb002
+	ori     v0, v0, 0x28
+	ld      v1, 0(v0)	/* mask = MIPS_PHYS_TO_KSEG1(0x10020028) */
+	li      a2, 1
+	dsllv   a2, a2, a0
+	nor     a2, zero, a2
+	and     a2, a2, v1	/* mask &= ~(1 << intsrc) */
+	sd      a2, 0(v0)	/* MIPS_PHYS_TO_KSEG1(0x10020028) = mask */
+	jr      ra
+	nop
+END(sb_enable_intsrc)
+
+/*
+ * return ((uint64_t)MIPS_PHYS_TO_KSEG1(0x10020028))
+ * Parameters: none
+ */
+LEAF(sb_read_intsrc_mask)
+	lui     v0, 0xb002
+	ori     v0, v0, 0x28
+	ld      v1, 0(v0)	/* mask = MIPS_PHYS_TO_KSEG1(0x10020028) */
+	move	v0, v1
+	dsll32	v0, v0, 0
+	dsrl32	v0, v0, 0	/* v0 = lower_uint32(mask) */
+	jr	ra
+	dsrl32	v1, v1, 0	/* v1 = upper_uint32(mask) */
+END(sb_read_intsrc_mask)
+
+/*
+ * return ((uint64_t *)MIPS_PHYS_TO_KSEG1(0x10020200) + intsrc)
+ * Parameters:
+ * - intsrc (a0)
+ */
+LEAF(sb_read_intmap)
+	sll	a0, a0, 3	/* compute the offset of the intmap register */
+	lui     v0, 0xb002
+	addu    a0, a0, v0
+	ld      v0, 512(a0)	/* v0 = MIPS_PHYS_TO_KSEG1(0x10020200) + off */
+	jr      ra
+	nop
+END(sb_read_intmap)
+
+/*
+ * (uint64_t *)MIPS_PHYS_TO_KSEG1(0x10020200) + intsrc = irq
+ * Parameters:
+ * - intsrc (a0)
+ * - irq    (a1)
+ */
+LEAF(sb_write_intmap)
+	sll     a0, a0, 0x3 /* compute the offset of the intmap register */
+	lui     v0, 0xb002
+	addu    a0, a0, v0
+	sd      a1, 512(a0) /* MIPS_PHYS_TO_KSEG1(0x10020200) + off = irq */
+	jr      ra
+	nop
+END(sb_write_intmap)
diff -I '.*' -Naur releng8/sys/mips/sibyte/sb_machdep.c svn/mips/sys/mips/sibyte/sb_machdep.c
--- releng8/src/sys/mips/sibyte/sb_machdep.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/sibyte/sb_machdep.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,259 @@
+/*-
+ * Copyright (c) 2007 Bruce M. Simpson.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: projects/mips/sys/mips/sibyte/sb_machdep.c 195333 2009-07-04 03:05:48Z imp $");
+
+#include <sys/param.h>
+#include <machine/cpuregs.h>
+
+#include "opt_ddb.h"
+#include "opt_kdb.h"
+
+#include <sys/param.h>
+#include <sys/conf.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/imgact.h>
+#include <sys/bio.h>
+#include <sys/buf.h>
+#include <sys/bus.h>
+#include <sys/cpu.h>
+#include <sys/cons.h>
+#include <sys/exec.h>
+#include <sys/ucontext.h>
+#include <sys/proc.h>
+#include <sys/kdb.h>
+#include <sys/ptrace.h>
+#include <sys/reboot.h>
+#include <sys/signalvar.h>
+#include <sys/sysent.h>
+#include <sys/sysproto.h>
+#include <sys/user.h>
+
+#include <vm/vm.h>
+#include <vm/vm_object.h>
+#include <vm/vm_page.h>
+#include <vm/vm_pager.h>
+
+#include <machine/cache.h>
+#include <machine/clock.h>
+#include <machine/cpu.h>
+#include <machine/cpuinfo.h>
+#include <machine/cpufunc.h>
+#include <machine/cpuregs.h>
+#include <machine/hwfunc.h>
+#include <machine/intr_machdep.h>
+#include <machine/locore.h>
+#include <machine/md_var.h>
+#include <machine/pte.h>
+#include <machine/sigframe.h>
+#include <machine/trap.h>
+#include <machine/vmparam.h>
+
+#ifdef CFE
+#include <dev/cfe/cfe_api.h>
+#endif
+
+#include "sb_scd.h"
+
+#ifdef DDB
+#ifndef KDB
+#error KDB must be enabled in order for DDB to work!
+#endif
+#endif
+
+#ifdef CFE
+extern uint32_t cfe_handle;
+extern uint32_t cfe_vector;
+#endif
+
+#ifdef CFE_ENV
+extern void cfe_env_init(void);
+#endif
+
+extern int *edata;
+extern int *end;
+
+static void
+mips_init(void)
+{
+	int i, cfe_mem_idx, tmp;
+	uint64_t maxmem;
+
+#ifdef CFE_ENV
+	cfe_env_init();
+#endif
+
+	TUNABLE_INT_FETCH("boothowto", &boothowto);
+
+	if (boothowto & RB_VERBOSE)
+		bootverbose++;
+
+#ifdef MAXMEM
+	tmp = MAXMEM;
+#else
+	tmp = 0;
+#endif
+	TUNABLE_INT_FETCH("hw.physmem", &tmp);
+	maxmem = (uint64_t)tmp * 1024;
+
+#ifdef CFE
+	/*
+	 * Query DRAM memory map from CFE.
+	 */
+	physmem = 0;
+	cfe_mem_idx = 0;
+	for (i = 0; i < 10; i += 2) {
+		int result;
+		uint64_t addr, len, type;
+
+		result = cfe_enummem(cfe_mem_idx++, 0, &addr, &len, &type);
+		if (result < 0) {
+			phys_avail[i] = phys_avail[i + 1] = 0;
+			break;
+		}
+
+		KASSERT(type == CFE_MI_AVAILABLE,
+			("CFE DRAM region is not available?"));
+
+		if (bootverbose)
+			printf("cfe_enummem: 0x%016jx/%llu.\n", addr, len);
+
+		if (maxmem != 0) {
+			if (addr >= maxmem) {
+				printf("Ignoring %llu bytes of memory at 0x%jx "
+				       "that is above maxmem %dMB\n",
+				       len, addr,
+				       (int)(maxmem / (1024 * 1024)));
+				continue;
+			}
+
+			if (addr + len > maxmem) {
+				printf("Ignoring %llu bytes of memory "
+				       "that is above maxmem %dMB\n",
+				       (addr + len) - maxmem,
+				       (int)(maxmem / (1024 * 1024)));
+				len = maxmem - addr;
+			}
+		}
+
+		phys_avail[i] = addr;
+		if (i == 0 && addr == 0) {
+			/*
+			 * If this is the first physical memory segment probed
+			 * from CFE, omit the region at the start of physical
+			 * memory where the kernel has been loaded.
+			 */
+			phys_avail[i] += MIPS_KSEG0_TO_PHYS((vm_offset_t)&end);
+		}
+		phys_avail[i + 1] = addr + len;
+		physmem += len;
+	}
+
+	realmem = btoc(physmem);
+#endif
+
+	physmem = realmem;
+
+	init_param1();
+	init_param2(physmem);
+	mips_cpu_init();
+	pmap_bootstrap();
+	mips_proc0_init();
+	mutex_init();
+
+	kdb_init();
+#ifdef KDB
+	if (boothowto & RB_KDB)
+		kdb_enter(KDB_WHY_BOOTFLAGS, "Boot flags requested debugger");
+#endif
+}
+
+void
+platform_halt(void)
+{
+
+}
+
+
+void
+platform_identify(void)
+{
+
+}
+
+void
+platform_reset(void)
+{
+	
+	/*
+	 * XXX SMP
+	 * XXX flush data caches
+	 */
+	sb_system_reset();
+}
+
+void
+platform_trap_enter(void)
+{
+
+}
+
+void
+platform_trap_exit(void)
+{
+
+}
+
+void
+platform_start(__register_t a0 __unused, __register_t a1 __unused, 
+    __register_t a2 __unused, __register_t a3 __unused)
+{
+	vm_offset_t kernend;
+
+	/* clear the BSS and SBSS segments */
+	memset(&edata, 0, (vm_offset_t)&end - (vm_offset_t)&edata);
+	kernend = round_page((vm_offset_t)&end);
+
+#ifdef CFE
+	/*
+	 * Initialize CFE firmware trampolines before
+	 * we initialize the low-level console.
+	 */
+	if (cfe_handle != 0)
+		cfe_init(cfe_handle, cfe_vector);
+#endif
+	cninit();
+
+#ifdef CFE
+	if (cfe_handle == 0)
+		panic("CFE was not detected by locore.\n");
+#endif
+	mips_init();
+
+	mips_timer_init_params(sb_cpu_speed(), 0);
+}
diff -I '.*' -Naur releng8/sys/mips/sibyte/sb_scd.c svn/mips/sys/mips/sibyte/sb_scd.c
--- releng8/src/sys/mips/sibyte/sb_scd.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/sibyte/sb_scd.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,152 @@
+/*-
+ * Copyright (c) 2009 Neelkanth Natu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+
+#include <machine/resource.h>
+
+#include "sb_scd.h"
+
+__FBSDID("$FreeBSD: projects/mips/sys/mips/sibyte/sb_scd.c 195333 2009-07-04 03:05:48Z imp $");
+
+/*
+ * System Control and Debug (SCD) unit on the Sibyte ZBbus.
+ */
+
+/*
+ * Extract the value starting at bit position 'b' for 'n' bits from 'x'.
+ */
+#define	GET_VAL_64(x, b, n)	(((x) >> (b)) & ((1ULL << (n)) - 1))
+
+#define SYSCFG_PLLDIV(x)	GET_VAL_64((x), 7, 5)
+
+uint64_t
+sb_cpu_speed(void)
+{
+	int plldiv;
+	const uint64_t MHZ = 1000000;
+	
+	plldiv = SYSCFG_PLLDIV(sb_read_syscfg());
+	if (plldiv == 0) {
+		printf("PLL_DIV is 0 - assuming 6 (300MHz).\n");
+		plldiv = 6;
+	}
+
+	return (plldiv * 50 * MHZ);
+}
+
+void
+sb_system_reset(void)
+{
+	uint64_t syscfg;
+
+	const uint64_t SYSTEM_RESET = 1ULL << 60;
+	const uint64_t EXT_RESET = 1ULL << 59;
+	const uint64_t SOFT_RESET = 1ULL << 58;
+
+	syscfg = sb_read_syscfg();
+	syscfg &= ~SOFT_RESET;
+	syscfg |= SYSTEM_RESET | EXT_RESET;
+	sb_write_syscfg(syscfg);
+}
+
+int
+sb_route_intsrc(int intsrc)
+{
+	int intrnum;
+
+	KASSERT(intsrc >= 0 && intsrc < NUM_INTSRC,
+		("Invalid interrupt source number (%d)", intsrc));
+
+	/*
+	 * Interrupt 5 is used by sources internal to the CPU (e.g. timer).
+	 * Use a deterministic mapping for the remaining sources to map to
+	 * interrupt numbers 0 through 4.
+	 */
+	intrnum = intsrc % 5;
+
+	/*
+	 * Program the interrupt mapper while we are here.
+	 */
+	sb_write_intmap(intsrc, intrnum);
+
+	return (intrnum);
+}
+
+#define	SCD_PHYSADDR	0x10000000
+#define	SCD_SIZE	0x00060000
+
+static int
+scd_probe(device_t dev)
+{
+
+	device_set_desc(dev, "Broadcom/Sibyte System Control and Debug");
+	return (0);
+}
+
+static int
+scd_attach(device_t dev)
+{
+	int rid;
+	struct resource *res;
+
+	if (bootverbose) {
+		device_printf(dev, "attached.\n");
+	}
+
+	rid = 0;
+	res = bus_alloc_resource(dev, SYS_RES_MEMORY, &rid, SCD_PHYSADDR,
+				 SCD_PHYSADDR + SCD_SIZE - 1, SCD_SIZE, 0);
+	if (res == NULL) {
+		panic("Cannot allocate resource for system control and debug.");
+	}
+	
+	return (0);
+}
+
+static device_method_t scd_methods[] ={
+	/* Device interface */
+	DEVMETHOD(device_probe,		scd_probe),
+	DEVMETHOD(device_attach,	scd_attach),
+	DEVMETHOD(device_detach,	bus_generic_detach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+	DEVMETHOD(device_suspend,	bus_generic_suspend),
+	DEVMETHOD(device_resume,	bus_generic_resume),
+
+	{ 0, 0 }
+};
+
+static driver_t scd_driver = {
+	"scd",
+	scd_methods
+};
+
+static devclass_t scd_devclass;
+
+DRIVER_MODULE(scd, zbbus, scd_driver, scd_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/sibyte/sb_scd.h svn/mips/sys/mips/sibyte/sb_scd.h
--- releng8/src/sys/mips/sibyte/sb_scd.h	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/sibyte/sb_scd.h	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,46 @@
+/*-
+ * Copyright (c) 2009 Neelkanth Natu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SB_SCD_H_
+#define	_SB_SCD_H_
+
+#define	NUM_INTSRC		64	/* total number of interrupt sources */
+
+uint64_t	sb_cpu_speed(void);
+void		sb_system_reset(void);
+
+int		sb_route_intsrc(int src);
+void		sb_enable_intsrc(int src);
+void		sb_disable_intsrc(int src);
+uint64_t	sb_read_intsrc_mask(void);
+
+int		sb_read_intmap(int intsrc);
+void		sb_write_intmap(int intsrc, int intrnum);
+
+uint64_t	sb_read_syscfg(void);
+void		sb_write_syscfg(uint64_t val);
+
+#endif	/* _SB_SCD_H_ */
diff -I '.*' -Naur releng8/sys/mips/sibyte/sb_zbbus.c svn/mips/sys/mips/sibyte/sb_zbbus.c
--- releng8/src/sys/mips/sibyte/sb_zbbus.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/sibyte/sb_zbbus.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,501 @@
+/*-
+ * Copyright (c) 2009 Neelkanth Natu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/malloc.h>
+#include <sys/rman.h>
+
+#include <machine/resource.h>
+#include <machine/intr_machdep.h>
+
+#include "sb_scd.h"
+
+__FBSDID("$FreeBSD: projects/mips/sys/mips/sibyte/sb_zbbus.c 195333 2009-07-04 03:05:48Z imp $");
+
+static MALLOC_DEFINE(M_INTMAP, "sb1250 intmap", "Sibyte 1250 Interrupt Mapper");
+
+#define	NUM_HARD_IRQS	6
+
+struct sb_intmap {
+	int intsrc;		/* interrupt mapper register number (0 - 63) */
+	int active;		/* Does this source generate interrupts? */
+
+	/*
+	 * The device that the interrupt belongs to. Note that multiple
+	 * devices may share an interrupt. For e.g. PCI_INT_x lines.
+	 *
+	 * The device 'dev' in combination with the 'rid' uniquely
+	 * identify this interrupt source.
+	 */
+	device_t dev;
+	int rid;
+
+	SLIST_ENTRY(sb_intmap) next;
+};
+
+/*
+ * We register 'sb_intsrc.isrc' using cpu_register_hard_intsrc() for each
+ * hard interrupt source [0-5].
+ *
+ * The mask/unmask callbacks use the information in 'sb_intmap' to figure
+ * out the corresponding interrupt sources to mask/unmask.
+ */
+struct sb_intsrc {
+	struct intsrc isrc;
+	SLIST_HEAD(, sb_intmap) sb_intmap_head;
+};
+
+static struct sb_intsrc sb_intsrc[NUM_HARD_IRQS];
+
+static struct sb_intmap *
+sb_intmap_lookup(int intrnum, device_t dev, int rid)
+{
+	struct sb_intsrc *isrc;
+	struct sb_intmap *map;
+
+	isrc = &sb_intsrc[intrnum];
+	SLIST_FOREACH(map, &isrc->sb_intmap_head, next) {
+		if (dev == map->dev && rid == map->rid)
+			break;
+	}
+	return (map);
+}
+
+/*
+ * Keep track of which (dev,rid) tuple is using the interrupt source.
+ *
+ * We don't actually unmask the interrupt source until the device calls
+ * a bus_setup_intr() on the resource.
+ */
+static void
+sb_intmap_add(int intrnum, device_t dev, int rid, int intsrc)
+{
+	struct sb_intsrc *isrc;
+	struct sb_intmap *map;
+	register_t sr;
+	
+	KASSERT(intrnum >= 0 && intrnum < NUM_HARD_IRQS,
+		("intrnum is out of range: %d", intrnum));
+
+	isrc = &sb_intsrc[intrnum];
+	map = sb_intmap_lookup(intrnum, dev, rid);
+	if (map) {
+		KASSERT(intsrc == map->intsrc,
+			("%s%d allocating SYS_RES_IRQ resource with rid %d "
+			 "with a different intsrc (%d versus %d)",
+			device_get_name(dev), device_get_unit(dev), rid,
+			intsrc, map->intsrc));
+		return;
+	}
+
+	map = malloc(sizeof(*map), M_INTMAP, M_WAITOK | M_ZERO);
+	map->intsrc = intsrc;
+	map->dev = dev;
+	map->rid = rid;
+
+	sr = intr_disable();
+	SLIST_INSERT_HEAD(&isrc->sb_intmap_head, map, next);
+	intr_restore(sr);
+}
+
+static void
+sb_intmap_activate(int intrnum, device_t dev, int rid)
+{
+	struct sb_intmap *map;
+	register_t sr;
+	
+	KASSERT(intrnum >= 0 && intrnum < NUM_HARD_IRQS,
+		("intrnum is out of range: %d", intrnum));
+
+	map = sb_intmap_lookup(intrnum, dev, rid);
+	if (map) {
+		/*
+		 * See comments in sb_unmask_func() about disabling cpu intr
+		 */
+		sr = intr_disable();
+		map->active = 1;
+		sb_enable_intsrc(map->intsrc);
+		intr_restore(sr);
+	} else {
+		/*
+		 * In zbbus_setup_intr() we blindly call sb_intmap_activate()
+		 * for every interrupt activation that comes our way.
+		 *
+		 * We might end up here if we did not "hijack" the SYS_RES_IRQ
+		 * resource in zbbus_alloc_resource().
+		 */
+		printf("sb_intmap_activate: unable to activate interrupt %d "
+		       "for device %s%d rid %d.\n", intrnum,
+		       device_get_name(dev), device_get_unit(dev), rid);
+	}
+}
+
+static void
+sb_mask_func(struct intsrc *arg)
+{
+	struct sb_intmap *map;
+	struct sb_intsrc *isrc;
+	uint64_t isrc_bitmap;
+
+	isrc_bitmap = 0;
+	isrc = (struct sb_intsrc *)arg;
+	SLIST_FOREACH(map, &isrc->sb_intmap_head, next) {
+		if (map->active == 0)
+			continue;
+		/*
+		 * If we have already disabled this interrupt source then don't
+		 * do it again. This can happen when multiple devices share
+		 * an interrupt source (e.g. PCI_INT_x).
+		 */
+		if (isrc_bitmap & (1ULL << map->intsrc))
+			continue;
+		sb_disable_intsrc(map->intsrc);
+		isrc_bitmap |= 1ULL << map->intsrc;
+	}
+}
+
+static void
+sb_unmask_func(struct intsrc *arg)
+{
+	struct sb_intmap *map;
+	struct sb_intsrc *sb_isrc;
+	uint64_t isrc_bitmap;
+	register_t sr;
+	
+	isrc_bitmap = 0;
+	sb_isrc = (struct sb_intsrc *)arg;
+
+	/*
+	 * Make sure we disable the cpu interrupts when enabling the
+	 * interrupt sources.
+	 *
+	 * This is to prevent a condition where some interrupt sources have
+	 * been enabled (but not all) and one of those interrupt sources
+	 * triggers an interrupt.
+	 *
+	 * If any of the interrupt handlers executes in an ithread then
+	 * cpu_intr() will return with all interrupt sources feeding into
+	 * that cpu irq masked. But when the loop below picks up where it
+	 * left off it will enable the remaining interrupt sources!!!
+	 *
+	 * If the disable the cpu interrupts then this race does not happen.
+	 */
+	sr = intr_disable();
+
+	SLIST_FOREACH(map, &sb_isrc->sb_intmap_head, next) {
+		if (map->active == 0)
+			continue;
+		/*
+		 * If we have already enabled this interrupt source then don't
+		 * do it again. This can happen when multiple devices share
+		 * an interrupt source (e.g. PCI_INT_x).
+		 */
+		if (isrc_bitmap & (1ULL << map->intsrc))
+			continue;
+		sb_enable_intsrc(map->intsrc);
+		isrc_bitmap |= 1ULL << map->intsrc;
+	}
+
+	intr_restore(sr);
+}
+
+struct zbbus_devinfo {
+	struct resource_list resources;
+};
+
+static MALLOC_DEFINE(M_ZBBUSDEV, "zbbusdev", "zbbusdev");
+
+static int
+zbbus_probe(device_t dev)
+{
+
+	device_set_desc(dev, "Broadcom/Sibyte ZBbus");
+	return (0);
+}
+
+static int
+zbbus_attach(device_t dev)
+{
+	int i, error;
+	struct intsrc *isrc;
+
+	if (bootverbose) {
+		device_printf(dev, "attached.\n");
+	}
+
+	for (i = 0; i < NUM_HARD_IRQS; ++i) {
+		isrc = &sb_intsrc[i].isrc;
+		isrc->intrnum = i;
+		isrc->mask_func = sb_mask_func;
+		isrc->unmask_func = sb_unmask_func;
+		error = cpu_register_hard_intsrc(isrc);
+		if (error)
+			panic("Error %d registering intsrc %d", error, i);
+	}
+	
+	bus_generic_probe(dev);
+	bus_enumerate_hinted_children(dev);
+	bus_generic_attach(dev);
+
+	return (0);
+}
+
+static void
+zbbus_hinted_child(device_t bus, const char *dname, int dunit)
+{
+	device_t child;
+	long maddr, msize;
+	int err, irq;
+
+	if (resource_disabled(dname, dunit))
+		return;
+
+	child = BUS_ADD_CHILD(bus, 0, dname, dunit);
+	if (child == NULL) {
+		panic("zbbus: could not add child %s unit %d\n", dname, dunit);
+	}
+
+	if (bootverbose)
+		device_printf(bus, "Adding hinted child %s%d\n", dname, dunit);
+
+	/*
+	 * Assign any pre-defined resources to the child.
+	 */
+	if (resource_long_value(dname, dunit, "msize", &msize) == 0 &&
+	    resource_long_value(dname, dunit, "maddr", &maddr) == 0) {
+		if (bootverbose) {
+			device_printf(bus, "Assigning memory resource "
+					   "0x%0lx/%ld to child %s%d\n",
+					   maddr, msize, dname, dunit);
+		}
+		err = bus_set_resource(child, SYS_RES_MEMORY, 0, maddr, msize);
+		if (err) {
+			device_printf(bus, "Unable to set memory resource "
+					   "0x%0lx/%ld for child %s%d: %d\n",
+					   maddr, msize, dname, dunit, err);
+		}
+	}
+
+	if (resource_int_value(dname, dunit, "irq", &irq) == 0) {
+		if (bootverbose) {
+			device_printf(bus, "Assigning irq resource %d to "
+					   "child %s%d\n", irq, dname, dunit);
+		}
+		err = bus_set_resource(child, SYS_RES_IRQ, 0, irq, 1);
+		if (err) {
+			device_printf(bus, "Unable to set irq resource %d"
+					   "for child %s%d: %d\n",
+					   irq, dname, dunit, err);
+		}
+	}
+}
+
+static struct resource *
+zbbus_alloc_resource(device_t bus, device_t child, int type, int *rid,
+		     u_long start, u_long end, u_long count, u_int flags)
+{
+	struct resource *res;
+	int intrnum, intsrc, isdefault;
+	struct resource_list *rl;
+	struct resource_list_entry *rle;
+	struct zbbus_devinfo *dinfo;
+
+	isdefault = (start == 0UL && end == ~0UL && count == 1);
+
+	/*
+	 * Our direct child is asking for a default resource allocation.
+	 */
+	if (device_get_parent(child) == bus) {
+		dinfo = device_get_ivars(child);
+		rl = &dinfo->resources;
+		rle = resource_list_find(rl, type, *rid);
+		if (rle) {
+			if (rle->res)
+				panic("zbbus_alloc_resource: resource is busy");
+			if (isdefault) {
+				start = rle->start;
+				count = ulmax(count, rle->count);
+				end = ulmax(rle->end, start + count - 1);
+			}
+		} else {
+			if (isdefault) {
+				/*
+				 * Our child is requesting a default
+				 * resource allocation but we don't have the
+				 * 'type/rid' tuple in the resource list.
+				 *
+				 * We have to fail the resource allocation.
+				 */
+				return (NULL);
+			} else {
+				/*
+				 * The child is requesting a non-default
+				 * resource. We just pass the request up
+				 * to our parent. If the resource allocation
+				 * succeeds we will create a resource list
+				 * entry corresponding to that resource.
+				 */
+			}
+		}
+	} else {
+		rl = NULL;
+		rle = NULL;
+	}
+
+	/*
+	 * nexus doesn't know about the interrupt mapper and only wants to
+	 * see the hard irq numbers [0-6]. We translate from the interrupt
+	 * source presented to the mapper to the interrupt number presented
+	 * to the cpu.
+	 */
+	if ((count == 1) && (type == SYS_RES_IRQ)) {
+		intsrc = start;
+		intrnum = sb_route_intsrc(intsrc);
+		start = end = intrnum;
+	} else {
+		intsrc = -1;		/* satisfy gcc */
+		intrnum = -1;
+	}
+
+	res = bus_generic_alloc_resource(bus, child, type, rid,
+ 					 start, end, count, flags);
+
+	/*
+	 * Keep track of the input into the interrupt mapper that maps
+	 * to the resource allocated by 'child' with resource id 'rid'.
+	 *
+	 * If we don't record the mapping here then we won't be able to
+	 * locate the interrupt source when bus_setup_intr(child,rid) is
+	 * called.
+	 */
+	if (res != NULL && intrnum != -1)
+		sb_intmap_add(intrnum, child, rman_get_rid(res), intsrc);
+
+	/*
+	 * If a non-default resource allocation by our child was successful
+	 * then keep track of the resource in the resource list associated
+	 * with the child.
+	 */
+	if (res != NULL && rle == NULL && device_get_parent(child) == bus) {
+		resource_list_add(rl, type, *rid, start, end, count);
+		rle = resource_list_find(rl, type, *rid);
+		if (rle == NULL)
+			panic("zbbus_alloc_resource: cannot find resource");
+	}
+
+	if (rle != NULL) {
+		KASSERT(device_get_parent(child) == bus,
+			("rle should be NULL for passthru device"));
+		rle->res = res;
+		if (rle->res) {
+			rle->start = rman_get_start(rle->res);
+			rle->end = rman_get_end(rle->res);
+			rle->count = count;
+		}
+	}
+
+	return (res);
+}
+
+static int
+zbbus_setup_intr(device_t dev, device_t child, struct resource *irq, int flags,
+		 driver_filter_t *filter, driver_intr_t *intr, void *arg, 
+		 void **cookiep)
+{
+	int error;
+
+	error = bus_generic_setup_intr(dev, child, irq, flags,
+				       filter, intr, arg, cookiep);
+	if (error == 0)
+		sb_intmap_activate(rman_get_start(irq), child,
+				   rman_get_rid(irq));
+
+	return (error);
+}
+
+static device_t
+zbbus_add_child(device_t bus, int order, const char *name, int unit)
+{
+	device_t child;
+	struct zbbus_devinfo *dinfo;
+
+	child = device_add_child_ordered(bus, order, name, unit);
+	if (child != NULL) {
+		dinfo = malloc(sizeof(struct zbbus_devinfo), M_ZBBUSDEV,
+			       M_WAITOK | M_ZERO);
+		resource_list_init(&dinfo->resources);
+		device_set_ivars(child, dinfo);
+	}
+
+	return (child);
+}
+
+static struct resource_list *
+zbbus_get_resource_list(device_t dev, device_t child)
+{
+	struct zbbus_devinfo *dinfo = device_get_ivars(child);
+
+	return (&dinfo->resources);
+}
+
+static device_method_t zbbus_methods[] ={
+	/* Device interface */
+	DEVMETHOD(device_probe,		zbbus_probe),
+	DEVMETHOD(device_attach,	zbbus_attach),
+	DEVMETHOD(device_detach,	bus_generic_detach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+	DEVMETHOD(device_suspend,	bus_generic_suspend),
+	DEVMETHOD(device_resume,	bus_generic_resume),
+
+	/* Bus interface */
+	DEVMETHOD(bus_alloc_resource,	zbbus_alloc_resource),
+	DEVMETHOD(bus_activate_resource, bus_generic_activate_resource),
+	DEVMETHOD(bus_deactivate_resource, bus_generic_deactivate_resource),
+	DEVMETHOD(bus_release_resource,	bus_generic_release_resource),
+	DEVMETHOD(bus_get_resource_list,zbbus_get_resource_list),
+	DEVMETHOD(bus_set_resource,	bus_generic_rl_set_resource),
+	DEVMETHOD(bus_get_resource,	bus_generic_rl_get_resource),
+	DEVMETHOD(bus_delete_resource,	bus_generic_rl_delete_resource),
+	DEVMETHOD(bus_setup_intr,	zbbus_setup_intr),
+	DEVMETHOD(bus_teardown_intr,	bus_generic_teardown_intr),
+	DEVMETHOD(bus_add_child,	zbbus_add_child),
+	DEVMETHOD(bus_hinted_child,	zbbus_hinted_child),
+	
+	{ 0, 0 }
+};
+
+static driver_t zbbus_driver = {
+	"zbbus",
+	zbbus_methods
+};
+
+static devclass_t zbbus_devclass;
+
+DRIVER_MODULE(zbbus, nexus, zbbus_driver, zbbus_devclass, 0, 0);
diff -I '.*' -Naur releng8/sys/mips/sibyte/sb_zbpci.c svn/mips/sys/mips/sibyte/sb_zbpci.c
--- releng8/src/sys/mips/sibyte/sb_zbpci.c	1969-12-31 16:00:00.000000000 -0800
+++ svn/mips/sys/mips/sibyte/sb_zbpci.c	2009-08-04 10:47:01.000000000 -0700
@@ -0,0 +1,283 @@
+/*-
+ * Copyright (c) 2009 Neelkanth Natu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+#include <sys/pcpu.h>
+#include <sys/smp.h>
+
+#include <vm/vm.h>
+#include <vm/vm_param.h>
+#include <vm/vm_kern.h>
+#include <vm/vm_extern.h>
+#include <vm/pmap.h>
+
+#include <dev/pci/pcivar.h>
+#include <dev/pci/pcib_private.h>
+
+#include <machine/pmap.h>
+#include <machine/resource.h>
+
+#include "pcib_if.h"
+
+#include "sb_scd.h"
+
+__FBSDID("$FreeBSD: projects/mips/sys/mips/sibyte/sb_zbpci.c 195333 2009-07-04 03:05:48Z imp $");
+
+static struct {
+	vm_offset_t vaddr;
+	vm_paddr_t  paddr;
+} zbpci_config_space[MAXCPU];
+
+static const vm_paddr_t CFG_PADDR_BASE = 0xFE000000;
+	
+static int
+zbpci_probe(device_t dev)
+{
+	
+	device_set_desc(dev, "Broadcom/Sibyte PCI I/O Bridge");
+	return (0);
+}
+
+static int
+zbpci_attach(device_t dev)
+{
+	int n, rid, size;
+	vm_offset_t va;
+	struct resource *res;
+
+	/*
+	 * Reserve the the physical memory that is used to read/write to the
+	 * pci config space but don't activate it. We are using a page worth
+	 * of KVA as a window over this region.
+	 */
+	rid = 0;
+	size = (PCI_BUSMAX + 1) * (PCI_SLOTMAX + 1) * (PCI_FUNCMAX + 1) * 256;
+	res = bus_alloc_resource(dev, SYS_RES_MEMORY, &rid, CFG_PADDR_BASE,
+				 CFG_PADDR_BASE + size - 1, size, 0);
+	if (res == NULL) {
+		panic("Cannot allocate resource for config space accesses.");
+	}
+
+	/*
+	 * Allocate KVA for accessing PCI config space.
+	 */
+	va = kmem_alloc_nofault(kernel_map, PAGE_SIZE * mp_ncpus);
+	if (va == 0) {
+		device_printf(dev, "Cannot allocate virtual addresses for "
+				   "config space access.\n");
+		return (ENOMEM);
+	}
+
+	for (n = 0; n < mp_ncpus; ++n) {
+		zbpci_config_space[n].vaddr = va + n * PAGE_SIZE;
+	}
+
+	/*
+	 * Sibyte has the PCI bus hierarchy rooted at bus 0 and HT-PCI
+	 * hierarchy rooted at bus 1.
+	 */
+	if (device_add_child(dev, "pci", 0) == NULL) {
+		panic("zbpci_attach: could not add pci bus 0.\n");
+	}
+
+	if (device_add_child(dev, "pci", 1) == NULL) {
+		panic("zbpci_attach: could not add pci bus 1.\n");
+	}
+
+	if (bootverbose) {
+		device_printf(dev, "attached.\n");
+	}
+
+	return (bus_generic_attach(dev));
+}
+
+static int
+zbpci_read_ivar(device_t dev, device_t child, int which, uintptr_t *result)
+{
+	
+	switch (which) {
+	case PCIB_IVAR_DOMAIN:
+		*result = 0;				/* single PCI domain */
+		return (0);
+	case PCIB_IVAR_BUS:
+		*result = device_get_unit(child);	/* PCI bus 0 or 1 */
+		return (0);
+	default:
+		return (ENOENT);
+	}
+}
+
+/*
+ * We rely on the CFE to have configured the intline correctly to point to
+ * one of PCI-A/PCI-B/PCI-C/PCI-D in the interupt mapper.
+ */
+static int
+zbpci_route_interrupt(device_t pcib, device_t dev, int pin)
+{
+
+	return (PCI_INVALID_IRQ);
+}
+
+/*
+ * This function is expected to be called in a critical section since it
+ * changes the per-cpu pci config space va-to-pa mappings.
+ */
+static vm_offset_t
+zbpci_config_space_va(int bus, int slot, int func, int reg, int bytes)
+{
+	int cpu;
+	vm_offset_t va_page;
+	vm_paddr_t pa, pa_page;
+
+	if (bus <= PCI_BUSMAX && slot <= PCI_SLOTMAX && func <= PCI_FUNCMAX &&
+	    reg <= PCI_REGMAX && (bytes == 1 || bytes == 2 || bytes == 4) &&
+	    ((reg & (bytes - 1)) == 0)) {
+		cpu = PCPU_GET(cpuid);
+		va_page = zbpci_config_space[cpu].vaddr;
+		pa = CFG_PADDR_BASE |
+		     (bus << 16) | (slot << 11) | (func << 8) | reg;
+		pa_page = pa & ~(PAGE_SIZE - 1);
+		if (zbpci_config_space[cpu].paddr != pa_page) {
+			pmap_kremove(va_page);
+			pmap_kenter(va_page, pa_page);
+			zbpci_config_space[cpu].paddr = pa_page;
+		}
+		return (va_page + (pa - pa_page));
+	} else {
+		return (0);
+	}
+}
+
+static uint32_t
+zbpci_read_config(device_t dev, u_int b, u_int s, u_int f, u_int r, int w)
+{
+	uint32_t data;
+	vm_offset_t va;
+
+	critical_enter();
+
+	va = zbpci_config_space_va(b, s, f, r, w);
+	if (va == 0) {
+		panic("zbpci_read_config: invalid %d/%d/%d[%d] %d\n",
+		      b, s, f, r, w);
+	}
+
+	switch (w) {
+	case 4:
+		data = *(uint32_t *)va;
+		break;
+	case 2:
+		data = *(uint16_t *)va;
+		break;
+	case 1:
+		data = *(uint8_t *)va;
+		break;
+	default:
+		panic("zbpci_read_config: invalid width %d\n", w);
+	}
+
+	critical_exit();
+
+	return (data);
+}
+
+static void
+zbpci_write_config(device_t d, u_int b, u_int s, u_int f, u_int r,
+		   uint32_t data, int w)
+{
+	vm_offset_t va;
+
+	critical_enter();
+
+	va = zbpci_config_space_va(b, s, f, r, w);
+	if (va == 0) {
+		panic("zbpci_write_config: invalid %d/%d/%d[%d] %d/%d\n",
+		      b, s, f, r, data, w);
+	}
+
+	switch (w) {
+	case 4:
+		*(uint32_t *)va = data;
+		break;
+	case 2:
+		*(uint16_t *)va = data;
+		break;
+	case 1:
+		*(uint8_t *)va = data;
+		break;
+	default:
+		panic("zbpci_write_config: invalid width %d\n", w);
+	}
+
+	critical_exit();
+}
+
+static device_method_t zbpci_methods[] ={
+	/* Device interface */
+	DEVMETHOD(device_probe,		zbpci_probe),
+	DEVMETHOD(device_attach,	zbpci_attach),
+	DEVMETHOD(device_detach,	bus_generic_detach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+	DEVMETHOD(device_suspend,	bus_generic_suspend),
+	DEVMETHOD(device_resume,	bus_generic_resume),
+
+	/* Bus interface */
+	DEVMETHOD(bus_read_ivar,	zbpci_read_ivar),
+	DEVMETHOD(bus_write_ivar,	bus_generic_write_ivar),
+	DEVMETHOD(bus_alloc_resource,	bus_generic_alloc_resource),
+	DEVMETHOD(bus_activate_resource, bus_generic_activate_resource),
+	DEVMETHOD(bus_deactivate_resource, bus_generic_deactivate_resource),
+	DEVMETHOD(bus_release_resource,	bus_generic_release_resource),
+	DEVMETHOD(bus_setup_intr,	bus_generic_setup_intr),
+	DEVMETHOD(bus_teardown_intr,	bus_generic_teardown_intr),
+	DEVMETHOD(bus_add_child,	bus_generic_add_child),
+
+	/* pcib interface */
+	DEVMETHOD(pcib_maxslots,	pcib_maxslots),
+	DEVMETHOD(pcib_read_config,	zbpci_read_config),
+	DEVMETHOD(pcib_write_config,	zbpci_write_config),
+	DEVMETHOD(pcib_route_interrupt,	zbpci_route_interrupt),
+	
+	{ 0, 0 }
+};
+
+/*
+ * The "zbpci" class inherits from the "pcib" base class. Therefore in
+ * addition to drivers that belong to the "zbpci" class we will also
+ * consider drivers belonging to the "pcib" when probing children of
+ * "zbpci".
+ */
+DECLARE_CLASS(pcib_driver);
+DEFINE_CLASS_1(zbpci, zbpci_driver, zbpci_methods, 0, pcib_driver);
+
+static devclass_t zbpci_devclass;
+
+DRIVER_MODULE(zbpci, zbbus, zbpci_driver, zbpci_devclass, 0, 0);
