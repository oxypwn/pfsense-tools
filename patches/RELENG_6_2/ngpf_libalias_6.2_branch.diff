diff -uNr src_diff/contrib/pf/pfctl/parse.y src/contrib/pf/pfctl/parse.y
--- src_diff/contrib/pf/pfctl/parse.y	Thu Jun  7 16:55:16 2007
+++ src/contrib/pf/pfctl/parse.y	Thu Jun  7 18:00:44 2007
@@ -126,6 +126,7 @@
 
 enum	{ PF_STATE_OPT_MAX, PF_STATE_OPT_NOSYNC, PF_STATE_OPT_SRCTRACK,
 	    PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_CONN,
+            PF_STATE_OPT_MAX_PACKETS_TO_NETGRAPH,
 	    PF_STATE_OPT_MAX_SRC_CONN_RATE, PF_STATE_OPT_MAX_SRC_NODES,
 	    PF_STATE_OPT_OVERLOAD, PF_STATE_OPT_STATELOCK,
 	    PF_STATE_OPT_TIMEOUT };
@@ -138,6 +139,7 @@
 		u_int32_t	 max_states;
 		u_int32_t	 max_src_states;
 		u_int32_t	 max_src_conn;
+		u_int32_t        max_packets_to_netgraph;
 		struct {
 			u_int32_t	limit;
 			u_int32_t	seconds;
@@ -203,9 +205,11 @@
 	int			 allowopts;
 	char			*label;
 	struct node_qassign	 queues;
+	u_int16_t		 netgraph;
 	char			*tag;
 	char			*match_tag;
 	u_int8_t		 match_tag_not;
+	u_int8_t		 proxy;
 } filter_opts;
 
 struct antispoof_opts {
@@ -416,8 +420,9 @@
 %token	QUEUE PRIORITY QLIMIT
 %token	LOAD
 %token	STICKYADDRESS MAXSRCSTATES MAXSRCNODES SOURCETRACK GLOBAL RULE
-%token	MAXSRCCONN MAXSRCCONNRATE OVERLOAD FLUSH
-%token	TAGGED TAG IFBOUND GRBOUND FLOATING STATEPOLICY ROUTE
+%token	MAXSRCCONN MAXSRCCONNRATE MAXPCKTNETGRAPH OVERLOAD FLUSH
+%token	TAGGED TAG NETGRAPH IFBOUND GRBOUND FLOATING STATEPOLICY ROUTE
+%token	PROXY
 %token	<v.string>		STRING
 %token	<v.i>			PORTBINARY
 %type	<v.interface>		interface if_list if_item_not if_item
@@ -445,6 +450,7 @@
 %type	<v.route>		route
 %type	<v.redirection>		redirection redirpool
 %type	<v.string>		label string tag
+%type	<v.number>		netgraph proxy
 %type	<v.keep_state>		keep
 %type	<v.state_opt>		state_opt_spec state_opt_list state_opt_item
 %type	<v.logquick>		logquick
@@ -633,7 +639,9 @@
 					    PF_TAG_NAME_SIZE - 1);
 					YYERROR;
 				}
+			r.netgraph = $8.netgraph;
 			r.match_tag_not = $8.match_tag_not;
+			r.proxy = $8.proxy;
 
 			decide_address_family($7.src.host, &r.af);
 			decide_address_family($7.dst.host, &r.af);
@@ -1535,6 +1543,10 @@
 			r.prob = $9.prob;
 
 			r.af = $6;
+                        if ($9.proxy)
+                                r.proxy = $9.proxy;
+                        if ($9.netgraph)
+                                r.netgraph = $9.netgraph;
 			if ($9.tag)
 				if (strlcpy(r.tagname, $9.tag,
 				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
@@ -1662,6 +1674,18 @@
 					r.rule_flag |= PFRULE_SRCTRACK |
 					    PFRULE_RULESRCTRACK;
 					break;
+                                case PF_STATE_OPT_MAX_PACKETS_TO_NETGRAPH:
+                                        if (o->data.max_packets_to_netgraph == 0) {
+                                                yyerror("'max-packets-to-netgraph' "
+                                                        "must be > 0");
+                                                YYERROR;
+                                        }
+                                        r.max_packets_to_netgraph =
+                                            o->data.max_packets_to_netgraph;
+                                        r.rule_flag |= PFRULE_SRCTRACK |
+                                            PFRULE_RULESRCTRACK |
+                                            PFRULE_RULENETGRAPH;
+                                        break;
 				case PF_STATE_OPT_MAX_SRC_CONN_RATE:
 					if (r.max_src_conn_rate.limit) {
 						yyerror("state option "
@@ -1918,6 +1942,9 @@
 			}
 			filter_opts.queues = $1;
 		}
+                | NETGRAPH number                       {
+                        filter_opts.netgraph = $2;
+                }
 		| TAG string				{
 			filter_opts.tag = $2;
 		}
@@ -1925,6 +1952,9 @@
 			filter_opts.match_tag = $3;
 			filter_opts.match_tag_not = $1;
 		}
+                | PROXY number                          {
+                        filter_opts.proxy = $2;
+                }
 		| PROBABILITY STRING			{
 			char	*e;
 			double	 p = strtod($2, &e);
@@ -2906,6 +2936,15 @@
 			$$->next = NULL;
 			$$->tail = $$;
 		}
+                | MAXPCKTNETGRAPH number                   {
+                        $$ = calloc(1, sizeof(struct node_state_opt));
+                        if ($$ == NULL)
+                                err(1, "state_opt_item: calloc");
+                        $$->type = PF_STATE_OPT_MAX_PACKETS_TO_NETGRAPH;
+                        $$->data.max_src_states = $2;
+                        $$->next = NULL;
+                        $$->tail = $$;
+                }
 		| MAXSRCCONN number			{
 			$$ = calloc(1, sizeof(struct node_state_opt));
 			if ($$ == NULL)
@@ -3540,6 +3579,10 @@
 		}
 		;
 
+netgraph        : /* empty */           { $$ = 0; }
+                | NETGRAPH number       { $$ = $2; }
+                ;
+
 tag		: /* empty */		{ $$ = NULL; }
 		| TAG STRING		{ $$ = $2; }
 		;
@@ -3548,6 +3591,10 @@
 		| not TAGGED string	{ $$.neg = $1; $$.name = $3; }
 		;
 
+proxy           : /* empty */           { $$ = 0; }
+                | PROXY number          { $$ = $2; }
+                ;
+
 route_host	: STRING			{
 			$$ = calloc(1, sizeof(struct node_host));
 			if ($$ == NULL)
@@ -3799,11 +3846,24 @@
 		yyerror("keep state on block rules doesn't make sense");
 		problems++;
 	}
+        if (r->action == PF_DROP && r->netgraph) {
+                yyerror("netgraph with block rule doesn't make sense");
+                problems++;
+        }
 	if ((r->tagname[0] || r->match_tagname[0]) && !r->keep_state &&
 	    r->action == PF_PASS) {
 		yyerror("tags cannot be used without keep state");
 		problems++;
 	}
+        if (r->action == PF_DROP && r->proxy) {
+                yyerror("proxy on block rules doesn't make sense");
+                problems++;
+        }
+        if ((r->proxy && r->ifname[0] == 0) ||
+                (r->proxy && !r->direction) {
+                yyerror("proxy needs both interface and direction");
+                problems++;
+        }
 	return (-problems);
 }
 
@@ -4624,6 +4684,7 @@
 		{ "loginterface",	LOGINTERFACE},
 		{ "max",		MAXIMUM},
 		{ "max-mss",		MAXMSS},
+		{ "max-packets-to-netgraph", MAXPCKTNETGRAPH},
 		{ "max-src-conn",	MAXSRCCONN},
 		{ "max-src-conn-rate",	MAXSRCCONNRATE},
 		{ "max-src-nodes",	MAXSRCNODES},
@@ -4632,6 +4693,7 @@
 		{ "modulate",		MODULATE},
 		{ "nat",		NAT},
 		{ "nat-anchor",		NATANCHOR},
+		{ "netgraph",           NETGRAPH},
 		{ "no",			NO},
 		{ "no-df",		NODF},
 		{ "no-route",		NOROUTE},
@@ -4647,6 +4709,7 @@
 		{ "priq",		PRIQ},
 		{ "probability",	PROBABILITY},
 		{ "proto",		PROTO},
+		{ "proxy",              PROXY},
 		{ "qlimit",		QLIMIT},
 		{ "queue",		QUEUE},
 		{ "quick",		QUICK},
diff -uNr src_diff/contrib/pf/pfctl/pfctl_parser.c src/contrib/pf/pfctl/pfctl_parser.c
--- src_diff/contrib/pf/pfctl/pfctl_parser.c	Thu Jun  7 16:55:24 2007
+++ src/contrib/pf/pfctl/pfctl_parser.c	Thu Jun  7 18:00:30 2007
@@ -867,6 +867,13 @@
 			printf("max-src-conn %u", r->max_src_conn);
 			opts = 0;
 		}
+                if (r->max_packets_to_netgraph) {
+                        if (!opts)
+                                printf(", ");
+                        printf("max-packets-to-netgraph %u",
+                                r->max_packets_to_netgraph);
+                        opts = 0;
+                }
 		if (r->max_src_conn_rate.limit) {
 			if (!opts)
 				printf(", ");
@@ -947,6 +954,10 @@
 		printf(" queue(%s, %s)", r->qname, r->pqname);
 	else if (r->qname[0])
 		printf(" queue %s", r->qname);
+        if (r->netgraph)
+                printf(" netgraph %d", r->netgraph);
+        if (r->proxy)
+                printf(" proxy %u", r->proxy);
 	if (r->tagname[0])
 		printf(" tag %s", r->tagname);
 	if (r->match_tagname[0]) {
diff -uNr src_diff/sys/contrib/pf/net/pf.c src/sys/contrib/pf/net/pf.c
--- src_diff/sys/contrib/pf/net/pf.c	Thu Jun  7 16:53:34 2007
+++ src/sys/contrib/pf/net/pf.c	Thu Jun  7 17:59:32 2007
@@ -118,6 +118,9 @@
 #include <sys/ucred.h>
 
 extern int ip_optcopy(struct ip *, struct ip *);
+
+#include <netgraph/ng_pf.h>
+ng_pf_input_t *ng_pf_input_p = NULL;
 #endif
 
 #define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x
@@ -6383,6 +6386,7 @@
 	int			 off, dirndx, pqid = 0;
 
 #ifdef __FreeBSD__
+	struct ng_pf_tag	*ng;
 	PF_LOCK();
 #endif
 	if (!pf_status.running ||
@@ -6616,6 +6620,27 @@
 	if (s && s->tag)
 		pf_tag_packet(m, pf_get_tag(m), s->tag);
 
+#ifdef __FreeBSD__
+#ifdef PF_WITH_LIBALIAS
+       if (action == PF_PASS && r->proxy) {
+               if (pf_libalias_packet(m0, dir, r->proxy) == PF_DROP) {
+                       PF_UNLOCK();
+                       /*
+                        * XXX: Maybe include some more info
+                        * on the reason!
+                        */
+                       printf("%s: grrrrrr lodhu dhe pak\n", __func__);
+                       REASON_SET(&reason, PFRES_MEMORY);
+                       return (PF_DROP);
+               }
+               /* XXX: are these necessary?! */
+               m = *m0;
+               h = mtod(m, struct ip *);
+               pd.tot_len = ntohs(h->ip_len);
+       }
+#endif
+#endif
+
 #ifdef ALTQ
 	if (action == PF_PASS && r->qid) {
 		struct m_tag	*mtag;
@@ -6727,6 +6752,35 @@
 		pf_route(m0, r, dir, ifp, s);
 
 #ifdef __FreeBSD__
+#if 0
+       printf("%s: expires = %d && timeout = %d && time = %ld \n", __func__,
+               s != NULL ? s->expire : 0, s != NULL ? s->timeout : 0,
+               time_second);
+#endif
+       if (r->netgraph && *m0 != NULL && NG_PF_LOADED) {
+               if (r->rule_flag & PFRULE_RULENETGRAPH &&
+                       s->packets[dir == PF_OUT] > r->max_packets_to_netgraph) {
+                       PF_UNLOCK();
+                       return (action);
+               }
+
+               ng = (struct ng_pf_tag *)m_tag_locate(*m0,
+                       NGM_PF_COOKIE, 0, NULL);
+               if (ng != NULL) {
+                        if (r->netgraph != ng->hooknum) {
+                               /* printf("%s: resending to netgraph\n"
+                                *      , __func__);
+                                */
+                               m_tag_delete(*m0, (struct m_tag *)ng);
+                               goto sendit;
+                        }
+               } else {
+sendit:
+                       PF_UNLOCK();
+                       return (ng_pf_input_p(m0, dir, r->netgraph, &s));
+               }
+       }
+
 	PF_UNLOCK();
 #endif
 
@@ -6755,6 +6809,7 @@
 	int			 off, terminal = 0, dirndx;
 
 #ifdef __FreeBSD__
+	struct ng_pf_tag	*ng;
 	PF_LOCK();
 #endif
 
@@ -7009,6 +7064,27 @@
 	if (s && s->tag)
 		pf_tag_packet(m, pf_get_tag(m), s->tag);
 
+#ifdef __FreeBSD__
+#ifdef PF_WITH_LIBALIAS
+       if (action == PF_PASS && r->proxy) {
+               if (pf_libalias_packet(m0, dir, r->proxy) == PF_DROP) {
+                       PF_UNLOCK();
+                       /*
+                        * XXX: Maybe include some more info
+                        * on the reason!
+                        */
+                       printf("%s: grrrrrr lodhu dhe pak\n", __func__);
+                       REASON_SET(&reason, PFRES_MEMORY);
+                       return (PF_DROP);
+               }
+               /* XXX: are these necessary?! */
+               m = *m0;
+               h = mtod(m, struct ip *);
+               pd.tot_len = ntohs(h->ip_len);
+       }
+#endif
+#endif
+
 #ifdef ALTQ
 	if (action == PF_PASS && r->qid) {
 		struct m_tag	*mtag;
@@ -7115,6 +7191,31 @@
 		pf_route6(m0, r, dir, ifp, s);
 
 #ifdef __FreeBSD__
+       /* XXX: Is this true for IPv6?! */
+       if (r->netgraph && *m0 != NULL && NG_PF_LOADED) {
+               if (r->rule_flag & PFRULE_RULENETGRAPH &&
+                         s->packets[dir == PF_OUT] > r->max_packets_to_netgraph) {
+                        PF_UNLOCK();
+                        return (action);
+                }
+
+               ng = (struct ng_pf_tag *)m_tag_locate(*m0,
+                       NGM_PF_COOKIE, 0, NULL);
+               if (ng != NULL) {
+                       if (r->netgraph != ng->hooknum) {
+                               /* printf("%s: resending to netgraph\n"
+                                *      , __func__);
+                                */
+                                m_tag_delete(*m0, (struct m_tag *)ng);
+                                goto sendit;
+                       }
+                } else {
+sendit:
+                       PF_UNLOCK();
+                       return (ng_pf_input_p(m0, dir, r->netgraph, &s));
+               }
+       }
+
 	PF_UNLOCK();
 #endif
 	return (action);
diff -uNr src_diff/sys/contrib/pf/net/pf_ioctl.c src/sys/contrib/pf/net/pf_ioctl.c
--- src_diff/sys/contrib/pf/net/pf_ioctl.c	Thu Jun  7 16:54:01 2007
+++ src/sys/contrib/pf/net/pf_ioctl.c	Thu Jun  7 17:59:23 2007
@@ -840,6 +840,14 @@
 		return;
 	pf_tag_unref(rule->tag);
 	pf_tag_unref(rule->match_tag);
+#ifdef __FreeBSD__
+#ifdef PF_WITH_LIBALIAS
+       PF_UNLOCK();
+       pf_libalias_unref(rule->proxy);
+       PF_LOCK();
+#endif
+#endif
+
 #ifdef ALTQ
 	if (rule->pqid != rule->qid)
 		pf_qid_unref(rule->pqid);
@@ -1530,6 +1538,18 @@
 				rule->pqid = rule->qid;
 		}
 #endif
+
+#ifdef __FreeBSD__
+#ifdef PF_WITH_LIBALIAS
+               if ((rule->proxy && !rule->direction) ||
+                               (rule->proxy && rule->ifname[0] == 0))
+                       error = EINVAL;
+               PF_UNLOCK();
+               if (pf_libalias_setup(rule->proxy, rule->ifname) == NULL)
+                       error =  EINVAL;
+               PF_LOCK();
+#endif
+#endif
 		if (rule->tagname[0])
 			if ((rule->tag = pf_tagname2tag(rule->tagname)) == 0)
 				error = EBUSY;
@@ -1752,6 +1772,18 @@
 					newrule->pqid = newrule->qid;
 			}
 #endif /* ALTQ */
+
+#ifdef __FreeBSD__
+#ifdef PF_WITH_LIBALIAS
+                       if ((newrule->proxy && !newrule->direction) ||
+                               (newrule->proxy && newrule->ifname[0] == 0))
+                               error = EINVAL;
+                       PF_UNLOCK();
+                       if (pf_libalias_setup(newrule->proxy, newrule->ifname) == NULL)
+                               error =  EINVAL;
+                       PF_LOCK();
+#endif
+#endif
 			if (newrule->tagname[0])
 				if ((newrule->tag =
 				    pf_tagname2tag(newrule->tagname)) == 0)
@@ -3598,4 +3630,7 @@
 
 DECLARE_MODULE(pf, pf_mod, SI_SUB_PROTO_IFATTACHDOMAIN, SI_ORDER_FIRST);
 MODULE_VERSION(pf, PF_MODVER);
+#ifdef PF_WITH_LIBALIAS
+MODULE_DEPEND(pf, libalias, 1, 1, 1);
+#endif
 #endif	/* __FreeBSD__ */
diff -uNr src_diff/sys/contrib/pf/net/pf_libalias.c src/sys/contrib/pf/net/pf_libalias.c
--- src_diff/sys/contrib/pf/net/pf_libalias.c	Thu Jan  1 01:00:00 1970
+++ src/sys/contrib/pf/net/pf_libalias.c	Wed Jun  6 18:30:32 2007
@@ -0,0 +1,385 @@
+/*
+ * Copyright 2007, Ermal Lu<E7>i <ermal.luci@gmail.com>
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ * 	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * based on PF tags implementaion.
+ */
+
+#if defined(__FreeBSD__)
+#include "opt_inet.h"
+#include "opt_inet6.h"
+#endif
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#ifdef __FreeBSD__
+#include <sys/malloc.h>
+#endif
+#include <sys/mbuf.h>
+#include <sys/kernel.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+
+
+#include <net/if.h>
+#include <net/if_types.h>
+
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/tcp.h>
+#include <netinet/udp.h>
+
+#include <net/pfvar.h>
+
+#include <netinet/libalias/alias.h>
+#include <netinet/libalias/alias_local.h>
+
+#include <machine/in_cksum.h>
+
+struct pf_libalias {
+        TAILQ_ENTRY(pf_libalias) entries;
+        struct libalias         *ins;           	/* libalias instance */
+	char			ifname[IFNAMSIZ];	/* interface name */
+        u_int8_t                refcnt;         	/* Reference count */
+	u_int8_t		flags; 
+        int                     libins;         	/* library instance # */
+};
+#define PF_LIBALIAS_DYNIF	0x01
+
+TAILQ_HEAD(pf_libs, pf_libalias) pf_libs =
+                        TAILQ_HEAD_INITIALIZER(pf_libs);
+/*
+static void		 libalias_set_addr(struct libalias *, struct ifnet *);
+*/
+static void              libalias_unref(struct pf_libs *, u_int8_t);
+static struct libalias * libalias_setup(struct pf_libs *, u_int8_t, const char *);
+
+static eventhandler_tag ifaddr_event_tag;
+
+static void
+pf_libalias_ifaddr_change(void *arg __unused, struct ifnet *ifp) {
+	        struct pf_libalias	*ptr;
+		struct ifaddr 		*ifa;
+		struct in_addr		 ip;
+		
+		/* Check every instance entry... */
+		TAILQ_FOREACH(ptr, &pf_libs, entries) {
+			/* ...using nic 'ifp->if_xname' as dynamic alias address. */
+			if (strncmp(ptr->ifname, ifp->if_xname, IF_NAMESIZE) == 0) {
+				mtx_lock(&ifp->if_addr_mtx);
+				TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
+					if (ifa->ifa_addr == NULL)
+						continue;
+					if (ifa->ifa_addr->sa_family != AF_INET)
+						continue;
+					ip = ((struct sockaddr_in *)
+							(ifa->ifa_addr))->sin_addr;
+					LibAliasSetAddress(ptr->ins, ip);
+				}
+				mtx_unlock(&ifp->if_addr_mtx);
+			}
+		}
+}
+
+
+/* XXX: any better way?! */
+static void 
+libalias_set_addr(struct libalias *lib, struct ifnet *ifp)
+{
+	struct ifaddr		*ifa;
+	struct in_addr		ip;
+	
+	mtx_lock(&ifp->if_addr_mtx);
+	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
+		if (ifa->ifa_addr == NULL)
+			continue;
+		if (ifa->ifa_addr->sa_family != AF_INET)
+			continue;
+		ip = ((struct sockaddr_in *)
+				(ifa->ifa_addr))->sin_addr;
+		LibAliasSetAddress(lib, ip);
+	}
+	mtx_unlock(&ifp->if_addr_mtx);
+
+}
+							
+static  struct libalias *
+libalias_setup(struct pf_libs *head, u_int8_t libins, const char *ifname)
+{
+	struct pf_libalias      *ins, *p = NULL;
+	struct pfi_kif		*pk; 
+	u_int8_t                 new_insid = 1;
+	struct in_addr		 addr;
+
+	TAILQ_FOREACH(ins, head, entries)
+		if (ins->libins == libins) {
+			ins->refcnt++;
+			return (ins->ins);
+		}
+
+	/* 
+	 * to avoid fragmentation, we do a linear search from the beginning
+	 * and take the first free slot we find. if there is none or the list
+	 * is empty, append a new entry at the end.
+	 */
+	
+	/* new entry */
+	if (!TAILQ_EMPTY(head))
+		for (p = TAILQ_FIRST(head); p != NULL && 
+			p->libins == new_insid; p = TAILQ_NEXT(p, entries))
+			new_insid = p->libins + 1;
+
+	pk = pfi_lookup_if(ifname);
+	if (pk == NULL)
+		return (NULL); /* XXX: We don't expect this to happen! */
+
+	/* allocate and fill new struct pf_libalias */
+	ins = (struct pf_libalias *)malloc(sizeof(struct pf_libalias),
+			M_TEMP, M_NOWAIT);
+	if (ins == NULL)
+		return (NULL);
+	bzero(ins, sizeof(struct pf_libalias));
+	
+	ins->ins = LibAliasInit(NULL);
+	if (ins->ins == NULL) {
+		free(ins, M_TEMP);
+		return (NULL);
+	}
+	
+	LibAliasSetMode(ins->ins, PKT_ALIAS_ONLY_MODULES, 
+		PKT_ALIAS_ONLY_MODULES);
+	libalias_set_addr(ins->ins, pk->pfik_ifp);
+	bzero(&addr, sizeof(addr));
+	LibAliasSetTarget(ins->ins, addr);
+	
+	/* XXX: Is this the right flag?! */
+	if (pk->pfik_flags & PFI_IFLAG_DYNAMIC)	{
+		p->flags |= PF_LIBALIAS_DYNIF;
+		ifaddr_event_tag = EVENTHANDLER_REGISTER(ifaddr_event, 
+				pf_libalias_ifaddr_change, NULL, 
+				EVENTHANDLER_PRI_ANY);
+	}
+
+	
+	/*
+	 * Here you can extend libalias(3) support for other modes.
+	 * Be aware that you have to extend the syntax too!!!
+	 */
+	ins->libins = new_insid;
+	ins->refcnt++;
+
+	if (p != NULL)  /* insert new entry before p */
+		TAILQ_INSERT_BEFORE(p, ins, entries);
+	else    /* either list empty or no free slot in between */
+		TAILQ_INSERT_TAIL(head, ins, entries);
+
+	return (ins->ins);
+}
+
+static  void
+libalias_unref(struct pf_libs *head, u_int8_t libins)
+{
+	struct pf_libalias      *p, *next;
+
+	if (libins == 0)
+		return;
+
+	for (p = TAILQ_FIRST(head); p != NULL; p = next) {
+		next = TAILQ_NEXT(p, entries);
+		if (libins == p->libins) {
+                       if (--p->refcnt == 0) {
+			       TAILQ_REMOVE(head, p, entries);
+			       LibAliasUninit(p->ins);
+			       if (p->flags & PF_LIBALIAS_DYNIF) { 
+				       EVENTHANDLER_DEREGISTER(
+						ifaddr_event, 
+					        ifaddr_event_tag);
+			       }
+			       free(p, M_TEMP);
+			}
+		break;	 
+	 	}
+	}
+}
+
+#if 0
+void
+pf_libalias_ref(u_int8_t libins)
+{
+	struct pf_libalias *t;
+
+	TAILQ_FOREACH(t, &pf_libs, entries)
+		if (t->libins == libins)
+			break;
+	
+	if (t != NULL)
+		t->refcnt++;
+}
+#endif
+
+void
+pf_libalias_unref(u_int8_t libins)
+{
+	        return (libalias_unref(&pf_libs, libins));
+}
+
+struct libalias *
+pf_libalias_setup(u_int8_t libins, const char *ifname)
+{
+	        return (libalias_setup(&pf_libs, libins, ifname));
+}
+
+/* This is copied from ip_fw2.c with some minor adaption */
+int
+pf_libalias_packet(struct mbuf **m, int dir, u_int8_t libins)
+{
+	struct mbuf             *mcl =  NULL;
+	struct libalias         *ins;
+	struct ip		*ip;
+	int                     retval = 0;
+	char                    *c;
+	/* XXX - libalias duct tape */
+	int                     ldt = 0;
+
+	ins = pf_libalias_setup(libins, NULL);
+	if (ins == NULL) {
+		retval = PF_DROP;
+		goto done;
+	}
+
+	if ((mcl = m_megapullup(*m, (*m)->m_pkthdr.len)) == NULL) {
+		retval = PF_DROP;
+		goto done;
+	}
+
+	ip = mtod(mcl, struct ip *);
+
+	/*
+	 * XXX - Libalias checksum offload 'duct tape':
+	 * locally generated packets have only pseudo-header checksum
+	 * calculatedi and libalias will screw it[1], so mark them for later fix.
+	 * Moreover there are cases when libalias modify tcp packet data[2], mark
+	 * it for later fix too.
+	 *
+	 * [1] libalias was never meant to run in kernel, so it doesn't have any
+	 * knowledge about checksum offloading, and it expects a packet with a full
+	 * internet checksum. Unfortunately, packets generated locally will have
+	 * just the pseudo header calculated, and when libalias tries to adjust the
+	 * checksum it will actually screw it.
+	 * [2] when libalias modify tcp's data content, full TCP checksum has to
+	 * be recomputed: the problem is that libalias doesn't have any idea
+	 * about checksum offloading To workaround this, we do not do checksumming
+	 * in LibAlias, but only mark the packets in th_x2 field. If we receive a
+	 * marked packet, we calculate correct checksum for it aware of offloading.
+	 * Why such a terrible hack instead of recalculating checksum for each
+	 * packet?  Because the previous checksum was not checked! Recalculating
+	 * checksums for EVERY packet will hide ALL transmission errors. Yes, marked
+	 * packets still suffer from this problem. But, sigh, natd(8) has this
+	 * problem, too.
+	 *
+	 * TODO: -make libalias mbuf aware (so it can handle delayed checksum and tso)
+	 */
+	
+         if (mcl->m_pkthdr.rcvif == NULL && 
+			 mcl->m_pkthdr.csum_flags & CSUM_DELAY_DATA)
+	                 ldt = 1;
+
+         c = mtod(mcl, char *);
+         if (dir == PF_IN) 
+	                 retval = LibAliasIn(ins, c, MCLBYTES);
+	 else 
+	                 retval = LibAliasOut(ins, c, MCLBYTES);
+	
+
+         if (retval != PKT_ALIAS_OK) {
+	                 /* XXX - should i add some logging? */
+	                 m_free(mcl);
+			 *m = NULL;
+			 retval = PF_DROP;
+			 goto done;
+	 }
+	
+	 retval = PF_PASS;
+
+	 mcl->m_pkthdr.len = mcl->m_len = ntohs(ip->ip_len);
+	 /*XXX - libalias checksum offload 'duct tape' (see above) */
+	 if ((ip->ip_off & htons(IP_OFFMASK)) == 0 &&
+			 ip->ip_p == IPPROTO_TCP) {
+		 struct tcphdr   *th;
+		 
+		 th = (struct tcphdr *)(ip + 1);
+		 if (th->th_x2)
+			 ldt = 1;
+
+	 }
+
+	 if (ldt) {
+		 struct tcphdr   *th;
+
+		 struct udphdr   *uh;
+		 u_short cksum;
+		 
+		 ip->ip_len = ntohs(ip->ip_len);
+		 cksum = in_pseudo(ip->ip_src.s_addr, ip->ip_dst.s_addr,
+			 htons(ip->ip_p + ip->ip_len - (ip->ip_hl << 2)));
+
+		 switch (ip->ip_p) {
+			 case IPPROTO_TCP:
+				 th = (struct tcphdr *)(ip + 1);
+				 /* Maybe it was set in libalias... */
+				 th->th_x2 = 0;
+				 th->th_sum = cksum;
+				 mcl->m_pkthdr.csum_data = 
+					 offsetof(struct tcphdr, th_sum);
+				 break;
+			 case IPPROTO_UDP:
+				 uh = (struct udphdr *)(ip + 1);
+				 uh->uh_sum = cksum;
+				 mcl->m_pkthdr.csum_data = 
+					 offsetof(struct udphdr, uh_sum);
+				 break;
+		 }
+
+		 /* No hw checksum offloading: do it by ourself. */
+		 if ((mcl->m_pkthdr.csum_flags & CSUM_DELAY_DATA) == 0) {
+			 in_delayed_cksum(mcl);
+			 mcl->m_pkthdr.csum_flags &= ~CSUM_DELAY_DATA;
+		 }
+
+		 ip->ip_len = htons(ip->ip_len);
+	 }
+	
+	 *m = mcl;
+done:
+	 return (retval);
+}
+
diff -uNr src_diff/sys/contrib/pf/net/pfvar.h src/sys/contrib/pf/net/pfvar.h
--- src_diff/sys/contrib/pf/net/pfvar.h	Thu Jun  7 16:53:48 2007
+++ src/sys/contrib/pf/net/pfvar.h	Thu Jun  7 17:59:57 2007
@@ -610,6 +610,7 @@
 	u_int32_t		 src_nodes;
 	u_int32_t		 max_src_nodes;
 	u_int32_t		 max_src_states;
+	u_int32_t                max_packets_to_netgraph;
 	u_int32_t		 max_src_conn;
 	struct {
 		u_int32_t		limit;
@@ -624,6 +625,7 @@
 	u_int16_t		 return_icmp;
 	u_int16_t		 return_icmp6;
 	u_int16_t		 max_mss;
+	u_int16_t		 netgraph;
 	u_int16_t		 tag;
 	u_int16_t		 match_tag;
 
@@ -654,6 +656,11 @@
 	u_int8_t		 rt;
 	u_int8_t		 return_ttl;
 	u_int8_t		 tos;
+#ifdef __FreeBSD__
+#ifdef PF_WITH_LIBALIAS
+       u_int8_t                 proxy;         /* libalias instance #*/
+#endif
+#endif
 	u_int8_t		 anchor_relative;
 	u_int8_t		 anchor_wildcard;
 
@@ -671,6 +678,7 @@
 #define	PFRULE_NOSYNC		0x0010
 #define PFRULE_SRCTRACK		0x0020  /* track source states */
 #define PFRULE_RULESRCTRACK	0x0040  /* per rule */
+#define PFRULE_RULENETGRAPH     0x0080  /* netgraph */
 
 /* scrub flags */
 #define	PFRULE_NODF		0x0100
@@ -1674,6 +1682,18 @@
 		    sa_family_t);
 
 extern struct pfi_statehead	pfi_statehead;
+
+#ifdef __FreeBSD__
+#ifdef PF_WITH_LIBALIAS
+#if 0
+void           pf_libalias_ref(u_int8_t);
+#endif
+void           pf_libalias_unref(u_int8_t);
+struct libalias        *
+               pf_libalias_setup(u_int8_t, const char *);
+int            pf_libalias_packet(struct mbuf **, int, u_int8_t);
+#endif
+#endif
 
 u_int16_t	pf_tagname2tag(char *);
 void		pf_tag2tagname(u_int16_t, char *);
diff -uNr src_diff/sys/modules/netgraph/Makefile src/sys/modules/netgraph/Makefile
--- src_diff/sys/modules/netgraph/Makefile	Sun Jun  3 20:44:25 2007
+++ src/sys/modules/netgraph/Makefile	Sun Jun  3 20:43:52 2007
@@ -33,6 +33,7 @@
 	netflow \
 	netgraph \
 	one2many \
+	pf \
 	ppp \
 	pppoe \
 	pptpgre \
diff -uNr src_diff/sys/modules/netgraph/pf/Makefile src/sys/modules/netgraph/pf/Makefile
--- src_diff/sys/modules/netgraph/pf/Makefile	Thu Jan  1 01:00:00 1970
+++ src/sys/modules/netgraph/pf/Makefile	Sun Jun  3 20:43:52 2007
@@ -0,0 +1,6 @@
+# $FreeBSD$
+
+KMOD=	ng_pf
+SRCS= 	ng_pf.c
+
+.include <bsd.kmod.mk>
diff -uNr src_diff/sys/modules/pf/Makefile src/sys/modules/pf/Makefile
--- src_diff/sys/modules/pf/Makefile	Thu Jun  7 16:54:37 2007
+++ src/sys/modules/pf/Makefile	Thu Jun  7 18:01:17 2007
@@ -10,6 +10,10 @@
 
 CFLAGS+=  -I${.CURDIR}/../../contrib/pf
 
+.if defined(PF_WITH_LIBALIAS)
+SRCS +=        pf_libalias.c
+.endif
+
 .if !defined(KERNBUILDDIR)
 opt_inet.h:
 	echo "#define INET 1" > opt_inet.h
diff -uNr src_diff/sys/netgraph/ng_pf.c src/sys/netgraph/ng_pf.c
--- src_diff/sys/netgraph/ng_pf.c	Thu Jan  1 01:00:00 1970
+++ src/sys/netgraph/ng_pf.c	Sun Jun  3 20:41:50 2007
@@ -0,0 +1,907 @@
+/*
+ * Copyright 2007, Ermal Luçi <ermal.luci@gmail.com>
+ * All rights reserved.
+ *
+ * Copyright 2005, Gleb Smirnoff <glebius@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/* 
+ * author: Ermal Luçi 
+ */ 
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/mbuf.h>
+#include <sys/malloc.h>
+#include <sys/ctype.h>
+#include <sys/errno.h>
+#include <sys/socket.h>
+#include <sys/syslog.h>
+
+#include <net/if.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/in_var.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+
+#include <contrib/pf/net/pfvar.h> 
+
+#include <netgraph/ng_message.h>
+#include <netgraph/ng_parse.h>
+#include <netgraph/ng_pf.h>
+#include <netgraph/netgraph.h>
+
+
+static int		ng_pf_mod_event(module_t mod, int event, void *data);
+static ng_constructor_t	ng_pf_constructor;
+static ng_shutdown_t	ng_pf_shutdown;
+static ng_newhook_t	ng_pf_newhook;
+static ng_connect_t	ng_pf_connect;
+static ng_findhook_t	ng_pf_findhook;
+static ng_rcvdata_t	ng_pf_rcvdata;
+static ng_disconnect_t	ng_pf_disconnect;
+static ng_rcvmsg_t	ng_pf_rcvmsg;
+
+static hook_p		ng_pf_findhook1(node_p, u_int16_t );
+static int		ng_pf_input(struct mbuf **, int, u_int16_t,
+				struct pf_state **);
+
+void 			ng_pf_translate_tag(struct mbuf **, int, int *);
+
+/* We have only one node */
+static node_p	fw_node;
+/*
+ * Private node data. Cuurently number of tags just for speeding
+ * things up.
+*/
+typedef struct {
+	u_int32_t	ntags;
+} *priv_p;
+
+/* XXX: maybe make these sysctl(9) aware! */
+static int 		onepass = 0;	
+static u_int32_t	tagzone = NGM_PF_COOKIE;
+
+static const struct ng_parse_struct_field ng_pf_command_field[] = 
+	NG_PF_COMMAND;
+static const struct ng_parse_type ng_pf_command_type = {
+          &ng_parse_struct_type,             
+          &ng_pf_command_field              
+};
+
+static int
+ng_pf_getTableLength(const struct ng_parse_type *type,
+		const u_char *start, const u_char *buf) {
+	const struct ng_pf_get_tags *const table = 
+		(const struct ng_pf_get_tags *)(buf - sizeof(u_int32_t));
+
+	return (table->n);
+}
+
+static const struct ng_parse_array_info ng_pf_struct_array_info = {
+	&ng_pf_command_type,
+	ng_pf_getTableLength
+};
+static const struct ng_parse_type ng_pf_struct_array_type = {
+	&ng_parse_array_type,
+	&ng_pf_struct_array_info
+};
+	
+static const struct ng_parse_struct_field ng_pf_get_tags_fields[] = 
+	NG_PF_GET_TAGS;
+static const struct ng_parse_type ng_pf_get_tags_type = {
+	&ng_parse_struct_type,
+	&ng_pf_get_tags_fields
+};
+	
+#ifdef NG_PF_DEBUG
+static const struct ng_parse_struct_field ng_pf_stats_fields[] =
+	NG_PF_GET_STATS;
+static const struct ng_parse_type ng_pf_stats_type = {
+	&ng_parse_struct_type,
+	&ng_pf_stats_fields
+};
+#endif
+
+/* List of commands and how to convert arguments to/from ASCII */
+static const struct ng_cmdlist ng_pf_cmdlist[] = {
+        {
+          NGM_PF_COOKIE,
+          NGM_PF_ADD_TAG,
+          "addtag",
+          &ng_pf_command_type,
+	  NULL
+        },
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_CHG_TAG_FLAGS,
+	  "chgtagflag",
+	  &ng_parse_uint32_type,
+	  NULL
+	},
+        {
+          NGM_PF_COOKIE,
+          NGM_PF_RMV_TAG,
+          "rmvtag",
+          &ng_pf_command_type,
+          NULL
+        },
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_GET_TAGS,
+	  "gettags",
+	  NULL,
+	  &ng_pf_get_tags_type
+	},
+#ifdef NG_PF_DEBUG
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_GET_STATS,
+	  "getstats",
+	  &ng_parse_hookbuf_type,
+	  &ng_pf_stats_type
+	},
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_CLR_STATS,
+	  "clrstats",
+	  &ng_parse_hookbuf_type,
+	  NULL 
+	},
+        {
+	  NGM_PF_COOKIE,
+	  NGM_PF_GETCLR_STATS,
+	  "getclrstats",
+	  &ng_parse_hookbuf_type,
+	  &ng_pf_stats_type
+	},
+#endif
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_SET_TAGZONE,
+	  "settagzone",
+	  &ng_parse_uint32_type,
+	  NULL 
+	},
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_GET_TAGZONE,
+	  "gettagzone",
+	  NULL,
+	  &ng_parse_uint32_type
+	},
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_DEFAULT_TAGZONE,
+	  "defaulttagzone",
+	  NULL,
+	  NULL 
+	},
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_SET_ONEPASS,
+	  "setonepass",
+	  &ng_parse_uint32_type,
+	  &ng_parse_uint32_type 
+	},
+	{
+	  NGM_PF_COOKIE,
+	  NGM_PF_GET_ONEPASS,
+	  "getonepass",
+	  NULL,
+	  &ng_parse_uint32_type 
+	},
+        { 0 }
+};
+
+/* Netgraph node type descriptor */
+static struct ng_type ng_pf_typestruct = {
+	.version =	NG_ABI_VERSION,
+	.name =		NG_PF_NODE_TYPE,
+	.mod_event =	ng_pf_mod_event,
+	.constructor =	ng_pf_constructor,
+	.rcvmsg =	ng_pf_rcvmsg,
+	.shutdown =	ng_pf_shutdown,
+	.newhook =	ng_pf_newhook,
+	.connect =	ng_pf_connect,
+	.findhook =	ng_pf_findhook,
+	.rcvdata =	ng_pf_rcvdata,
+	.disconnect =	ng_pf_disconnect,
+	.cmdlist =	ng_pf_cmdlist,	
+};
+NETGRAPH_INIT(pf, &ng_pf_typestruct);
+MODULE_DEPEND(ng_pf, pf, PF_MODVER, PF_MODVER
+		, PF_MODVER); 
+
+/* Information we store for each hook */
+struct ng_pf_hook_priv {
+        hook_p			hook;
+	u_int16_t		hooknum;
+#ifdef NG_PF_DEBUG
+	struct ng_pf_stats	stats; 
+#endif
+};
+typedef struct ng_pf_hook_priv *hpriv_p;
+
+
+static int
+ng_pf_mod_event(module_t mod, int event, void *data)
+{
+	priv_p priv;
+	int error = 0;
+	switch (event) {
+	case MOD_LOAD:
+
+		if (ng_pf_input_p != NULL) {
+			error = EEXIST;
+			break;
+		}
+#if NG_PF_DEBUG 
+		printf("Begin load prepare\n");
+#endif
+		/* Setup node without any private data */
+		if ((error = ng_make_node_common(&ng_pf_typestruct, &fw_node))
+		    != 0) {
+			log(LOG_ERR, "%s: can't create ng_pf node", __func__);
+                	break;
+		}
+
+		/* Try to name node */
+		if (ng_name_node(fw_node, "pf") != 0)
+			log(LOG_WARNING, "%s: failed to name node \"pf\"",
+			    __func__);
+
+#ifdef NG_PF_DEBUG 
+		printf("Done load prepare\n");
+#endif
+		/* Allocate memory for this hook's private data */
+		MALLOC(priv, priv_p, sizeof(*priv), M_NETGRAPH, 
+			M_NOWAIT | M_ZERO);
+		if (priv== NULL)
+			return (ENOMEM);
+
+#if 0		
+		priv->tagzone = NGM_PF_COOKIE;
+#endif
+		NG_NODE_SET_PRIVATE(fw_node, priv);
+
+		/* Register hook */
+		ng_pf_input_p = ng_pf_input;
+		TAILQ_INIT(&ng_pf_tags);
+		break;
+
+	case MOD_UNLOAD:
+		 /*
+		  * This won't happen if a node exists.
+		  * ng_pf_input_p is already cleared.
+		  */
+		break;
+
+	default:
+		error = EOPNOTSUPP;
+		break;
+	}
+
+	return (error);
+}
+
+static int
+ng_pf_constructor(node_p node)
+{
+	return (EINVAL);	/* Only one node */
+}
+
+static int
+ng_pf_newhook(node_p node, hook_p hook, const char *name)
+{
+	hpriv_p	hpriv;
+	u_int16_t hooknum;
+	const char *cp;
+	char *endptr;
+
+	/* Protect from leading zero */
+	if (name[0] == '0' && name[1] != '\0')
+		return (EINVAL);
+
+	/* Check that name contains only digits */
+	for (cp = name; *cp != '\0'; cp++)
+		if (!isdigit(*cp))
+			return (EINVAL);
+
+	/* Convert it to integer */
+	hooknum = (u_int16_t)strtol(name, &endptr, 10);
+	if (*endptr != '\0')
+		return (EINVAL);
+
+	/* Allocate memory for this hook's private data */
+	MALLOC(hpriv, hpriv_p, sizeof(*hpriv), M_NETGRAPH, M_NOWAIT | M_ZERO);
+	if (hpriv== NULL)
+		return (ENOMEM);
+
+	hpriv->hook = hook;
+	hpriv->hooknum = hooknum;
+
+	NG_HOOK_SET_PRIVATE(hook, hpriv);
+
+	return(0);
+}
+
+/*
+ * Set hooks into queueing mode, to avoid recursion between
+ * netgraph layer and ip_{input,output}.
+ */
+static int
+ng_pf_connect(hook_p hook)
+{
+	NG_HOOK_FORCE_QUEUE(hook);
+	return (0);
+}
+
+
+/*
+ * Receive a control message.
+ */
+static int
+ng_pf_rcvmsg(node_p node, item_p item, hook_p lasthook)
+{
+	const priv_p priv = NG_NODE_PRIVATE(node);
+	struct ng_mesg *msg;
+	struct ng_mesg *resp = NULL; 
+	struct ng_pf_get_tags *tags = NULL;	
+	struct ng_pf_command *comm = NULL;
+	struct ng_pf_tagnames *tag = NULL;
+	int error = 0;
+
+	NGI_GET_MSG(item, msg);
+
+	switch (msg->header.typecookie) {			
+	case NGM_PF_COOKIE:
+                switch (msg->header.cmd) {
+                case NGM_PF_ADD_TAG:
+                    {
+			if (msg->header.arglen < sizeof(*comm)) {
+                                error = EINVAL;
+				break;
+			}
+                        comm = (struct ng_pf_command *)msg->data;
+			
+#ifdef NG_PF_DEBUG 
+			printf("%s: message recieved tag=%d tagname=%s\n",
+				__func__, comm->tag, comm->name);
+#endif
+			
+			/* this is adappted from pf_ioctl.c :) */
+        		TAILQ_FOREACH(tag, &ng_pf_tags, entries)
+                	if (strcmp(comm->name, tag->tagname) == 0)  {
+				error = EINVAL; /* find smth better */
+				goto done;
+			}
+                	
+#if 0
+/* XXX: keep in sync with pf_ioctl.c */
+#define TAGID_MAX        50000
+        		if (comm->tag > TAGID_MAX)  {
+                		error = EINVAL; /* find smth better */
+				goto done;
+			}
+#undef TAGID_MAX        
+#endif
+
+        		/* allocate and fill new struct ng_pf_tagname */
+        		tag = (struct ng_pf_tagnames *)
+				malloc(sizeof(struct ng_pf_tagnames),
+            			M_NETGRAPH, M_NOWAIT);
+        		if (tag == NULL) { 
+				error = EINVAL; /* find smth better */
+				goto done;
+			}	
+
+        		bzero(tag, sizeof(struct ng_pf_tagnames));
+        		strlcpy(tag->tagname, comm->name, sizeof(tag->tagname));
+        		tag->tag = comm->tag;
+			tag->flags = comm->flags;	
+                	TAILQ_INSERT_TAIL(&ng_pf_tags, tag, entries);
+			
+			/* Increment number of tags node knows about */
+			priv->ntags++;
+			
+			break;
+		}
+		case NGM_PF_RMV_TAG:
+			{
+               		        if (msg->header.arglen < sizeof(*comm)) {
+					error = EINVAL;
+					break;
+				}
+       		                comm = (struct ng_pf_command *)msg->data;
+
+				TAILQ_FOREACH(tag, &ng_pf_tags, entries) {
+					if (!strcmp(comm->name, tag->tagname)
+						&& comm->tag == tag->tag) {
+						TAILQ_REMOVE(&ng_pf_tags, 
+							tag, entries);
+						FREE(tag, M_NETGRAPH);
+						priv->ntags--;
+						break;
+					}
+				}
+
+				break;	
+			}
+		case NGM_PF_CHG_TAG_FLAGS:
+			{
+				/* XXX: TODO Implement this?! */
+				break;
+			}
+		case NGM_PF_GET_TAGS:
+			{
+				NG_MKRESPONSE(resp, msg, sizeof(*tags) +
+					priv->ntags * 
+					sizeof(*tags->tags),
+					M_NOWAIT);
+				if (resp == NULL) {
+					error = ENOMEM;
+					break;
+				}
+				tags = (struct ng_pf_get_tags *)resp->data;
+				tags->n = priv->ntags;
+#ifdef NG_PF_DEBUG 
+				printf("%s: tags->n=%d\n", __func__, tags->n);
+#endif
+				comm = &tags->tags[0];
+				TAILQ_FOREACH(tag, &ng_pf_tags, entries) {
+					comm->tag = tag->tag;
+					comm->flags = tag->flags;
+					strncpy(comm->name, tag->tagname,
+						NG_PF_TAG_NAME_SIZE);
+#ifdef NG_PF_DEBUG
+					printf("%s: comm->tag=%d "
+						"comm->name=%s"
+						"comm->flags=%x\n"
+						"tag->tag=%d "
+						"tag->tagname=%s" 
+						"tag->flags=%x\n", __func__,
+						comm->tag, comm->name,
+					       	comm->flags, tag->tag, 
+						tag->tagname, tag->flags);
+#endif
+					comm++;
+				}
+				break;
+			}
+#ifdef NG_PF_DEBUG 
+		case NGM_PF_GET_STATS:
+		case NGM_PF_CLR_STATS:
+		case NGM_PF_GETCLR_STATS:
+			{
+				struct ng_pf_stats *stats;
+				hook_p hook;
+
+				/* Sanity check */
+				if (msg->header.arglen == 0) {
+					error = EINVAL;
+					goto done;
+				}	
+				msg->data[msg->header.arglen - 1] = '\0';
+
+				/* Find hook */
+				if ( (hook = ng_pf_findhook(node, msg->data)) 
+						== NULL) {
+						error = EINVAL;
+						goto done;
+				}
+				stats = &((hpriv_p)
+					NG_HOOK_PRIVATE(hook))->stats;
+
+				if (msg->header.cmd != NGM_PF_CLR_STATS) {
+					NG_MKRESPONSE(resp, msg, 
+						sizeof(*stats), M_WAITOK);
+					bcopy(stats, resp->data, 
+							sizeof(*stats));
+				}
+
+				if (msg->header.cmd != NGM_PF_GET_STATS) {
+					bzero(stats, sizeof(*stats));
+				}
+				
+				break;
+			}
+#endif
+		case NGM_PF_SET_TAGZONE:
+			{
+				/* Sanity check */
+				if (msg->header.arglen < sizeof(u_int32_t)) {
+					error = EINVAL;
+					goto done;
+				}
+				tagzone = (u_int32_t)*msg->data;
+				
+				break;	
+			}
+		case NGM_PF_GET_TAGZONE:
+			{
+				NG_MKRESPONSE(resp, msg, sizeof(u_int32_t),
+					M_WAITOK);
+				bcopy(&tagzone, resp->data, 
+					sizeof(u_int32_t));			
+
+				break;
+			}
+		case NGM_PF_DEFAULT_TAGZONE:
+			{
+				tagzone = NGM_PF_COOKIE;
+
+				break;
+			}
+		case NGM_PF_SET_ONEPASS:
+			{
+				/* Sanity check */
+				if (msg->header.arglen < sizeof(u_int32_t)) {
+					error = EINVAL;
+					goto done;
+				}
+				onepass = (int)*msg->data;
+				break;
+			}
+		case NGM_PF_GET_ONEPASS:
+			{
+				NG_MKRESPONSE(resp, msg, sizeof(int),
+					M_WAITOK);
+				bcopy(&onepass, resp->data, sizeof(int));	
+				break;
+			}
+		default:
+			error = EINVAL;
+			break;
+		}
+		break;
+	default:
+		error = EINVAL;
+		break;
+	}
+	
+        NG_RESPOND_MSG(error, node, item, resp); 
+done:
+        NG_FREE_MSG(msg);
+        return (error);
+}
+
+
+
+/* Look up hook by name */
+hook_p
+ng_pf_findhook(node_p node, const char *name)
+{
+	u_int16_t n;	/* numeric representation of hook */
+	char *endptr;
+
+	n = (u_int16_t)strtol(name, &endptr, 10);
+	if (*endptr != '\0')
+		return NULL;
+	return ng_pf_findhook1(node, n);
+}
+
+/* Look up hook by rule number */
+static hook_p
+ng_pf_findhook1(node_p node, u_int16_t hooknum)
+{
+	hook_p	hook;
+	hpriv_p	hpriv;
+
+	LIST_FOREACH(hook, &node->nd_hooks, hk_hooks) {
+		hpriv = NG_HOOK_PRIVATE(hook);
+		if (NG_HOOK_IS_VALID(hook) && (hpriv->hooknum == hooknum))
+                        return (hook);
+	}
+
+	return (NULL);
+}
+
+
+static int
+ng_pf_rcvdata(hook_p hook, item_p item)
+{
+	struct ng_pf_tag	*ngit;
+	struct mbuf 		*m;
+	struct ip		*ip;
+	int			flags = 0;
+	
+	NGI_GET_M(item, m);
+	NG_FREE_ITEM(item);
+
+#ifdef NG_PF_DEBUG 
+	printf("%s: onepass = %d\n", __func__, onepass);
+#endif
+#if 0
+	if (onepass > 0)
+		m->m_flags |= M_SKIP_FIREWALL;
+#endif
+
+	if ((ngit = (struct ng_pf_tag *)m_tag_locate(m, NGM_PF_COOKIE, 0,
+	    NULL)) == NULL) {
+		NG_FREE_M(m);
+		return (EINVAL);	/* XXX: find smth better */
+	};
+
+	/* translation to netgraph aware tag */
+	ng_pf_translate_tag(&m, PF_OUT, &flags);
+
+	if (flags & NG_PF_SKIP_FIREWALL)
+		m->m_flags |= M_SKIP_FIREWALL;
+	
+	/* XXX: redundant? */
+	if (ngit->s != NULL) {
+		/* 
+		 * It speeds dropping the packet but is
+		 * somewhat magic and i don't like it 
+		 * at all, but anybody who likes can use
+		 * this behaviour!
+		 * 
+		 * really drop packet 
+		 */
+		if (flags & NG_PF_DROP_PACKET) {
+		       NG_FREE_M(m);
+		       ngit->s->timeout = PFTM_PURGE;
+		       return (0);
+		}
+			
+		/* instantly kill/remove state */
+		if (flags & NG_PF_KILL_STATE) 
+			pf_purge_expired_state(ngit->s);
+	
+		/* expire state */
+		if (flags & NG_PF_IGNORE_STATE)	
+			ngit->s->timeout = PFTM_PURGE; 
+	}
+			
+	
+#ifdef NG_PF_DEBUG
+	((hpriv_p)
+	NG_HOOK_PRIVATE(hook))->stats.packets_out++;
+#endif
+
+	switch (ngit->direction) {
+	case PF_OUT:
+	    {
+		if (m->m_len < sizeof(struct ip) &&
+	    		(m = m_pullup(m, sizeof(struct ip))) == NULL)
+			return (PF_DROP);
+
+		ip = mtod(m, struct ip *);
+		ip->ip_len = ntohs(ip->ip_len);
+		ip->ip_off = ntohs(ip->ip_off);    
+
+		return ip_output(m, NULL, NULL, IP_FORWARDING, 
+					NULL, NULL);
+	    }
+	case PF_IN:
+	    {
+		ip_input(m);
+		return (0);
+	    }
+	default:
+		panic("ng_pf_rcvdata: bad dir %u", ngit->direction);
+	}	
+
+	/* not reached */
+	return (0);
+}
+
+static int
+ng_pf_input(struct mbuf **m0, int dir, u_int16_t hooknum, 
+		struct pf_state **state)
+{
+	struct mbuf *m;
+	struct ng_pf_tag *ngit;
+	/*struct ip *ip;*/
+	struct pf_state *s = *state;
+	hook_p	hook;
+	int error = PF_PASS;
+
+	/*
+	 * Node must be loaded and corresponding hook must be present.
+	 */
+	if (fw_node == NULL || 
+	   (hook = ng_pf_findhook1(fw_node, hooknum)) == NULL) {
+		m_freem(*m0);
+		return (PF_DROP); /* no hook associated with this rule */
+	}
+	
+
+	/* translation to netgraph aware tag */	
+	ng_pf_translate_tag(m0, PF_IN, NULL);
+
+	m = *m0;
+	*m0 = NULL;	/* it belongs now to netgraph */
+
+
+	if ((ngit = (struct ng_pf_tag *)m_tag_alloc(NGM_PF_COOKIE,
+	    0, TAGSIZ, M_NOWAIT|M_ZERO)) == NULL) {
+		m_freem(m);
+		return (PF_DROP);
+	}
+
+#ifdef NG_PF_DEBUG
+	printf("%s: direction==%s\n", __func__, dir == PF_OUT ? "PF_OUT" :
+		dir == PF_IN ? "PF_IN" : "PF_INOUT grrr!!!");
+
+	((hpriv_p)
+	 NG_HOOK_PRIVATE(hook))->stats.packets_in++;
+#endif
+
+	ngit->direction = dir;
+	ngit->hooknum = hooknum;
+	ngit->s = s;
+#if 0
+	ngit->flags = flags;
+#endif
+	m_tag_prepend(m, &ngit->mt);
+
+/*	
+	if (dir == PF_OUT) {
+		if (m->m_len < sizeof(struct ip) &&
+	    		(m = m_pullup(m, sizeof(struct ip))) == NULL)
+			return (PF_DROP);
+
+		ip = mtod(m, struct ip *);
+		ip->ip_len = ntohs(ip->ip_len);
+		ip->ip_off = ntohs(ip->ip_off);
+	}
+	
+*/
+	NG_SEND_DATA_ONLY(error, hook, m);
+
+	if (error != 0 && error != PF_PASS) {
+#ifdef NG_PF_DEBUG
+		printf("%s: dropping packet!!!\n", __func__);
+#endif
+		return(PF_DROP);
+	}
+
+	return (error);
+}
+
+static int
+ng_pf_shutdown(node_p node)
+{
+
+	/*
+	 * After our single node has been removed,
+	 * the only thing that can be done is
+	 * 'kldunload ng_pf.ko'
+	 */
+	struct ng_pf_tagnames *n1, *n2;
+	n1 = TAILQ_FIRST(&ng_pf_tags);
+        while (n1 != NULL) {
+             n2 = TAILQ_NEXT(n1, entries);
+             FREE(n1, M_NETGRAPH);
+             n1 = n2;
+        }
+
+	ng_pf_input_p = NULL;
+	NG_NODE_UNREF(node);
+	return (0);
+}
+
+static int
+ng_pf_disconnect(hook_p hook)
+{
+	const hpriv_p hpriv = NG_HOOK_PRIVATE(hook);
+
+	NG_HOOK_SET_PRIVATE(hook, NULL);
+	FREE(hpriv, M_NETGRAPH);
+
+	return (0);
+}
+
+/* This is the workhorse in this node */
+void
+ng_pf_translate_tag(struct mbuf **m, int direction, int *flags) {
+	char tagname[PF_TAG_NAME_SIZE];
+	u_int16_t tagid;
+	struct ng_pf_tagnames *tagn;
+	struct mbuf *mtag = *m;
+	struct pf_tag *tag = NULL;
+	struct m_tag *r_tag = NULL;
+
+#ifdef NG_PF_DEBUG
+	printf("%s: Packet tags && tag_cookies\n", __func__);
+	for (r_tag = m_tag_first(mtag); r_tag != NULL;
+		r_tag = m_tag_next(mtag, r_tag))
+		if (r_tag == NULL) {
+			printf("%s: r_tag == NULL grrrr!!!!!\n", __func__);
+			continue;
+		}
+		else
+			printf("\ttag_id=%d tag_cookie=%d\n",
+				r_tag->m_tag_id, r_tag->m_tag_cookie);
+
+	/* Just to be safe. */
+	mtag = *m;
+    	r_tag = NULL;
+#endif
+	r_tag = m_tag_locate(mtag, tagzone, PACKET_TAG_PF_TAG, NULL);
+	/* Basically the loop is not needed since PF uses only the first
+	 * tag it finds, but we can use it later to do some trick maybe!
+	 */
+	while (r_tag != NULL) { 
+		tag = (struct pf_tag *)(r_tag+1);	
+		/* Can this happen?! */
+		if (tag == NULL)
+			continue;
+		if (direction == PF_IN) {
+			pf_tag2tagname(tag->tag, tagname);
+			TAILQ_FOREACH(tagn, &ng_pf_tags, entries)
+				if (strcmp(tagname, tagn->tagname) == 0) {
+					tag->tag = tagn->tag;
+					r_tag->m_tag_cookie = tagzone;
+       			                break; 
+       		       		  }
+#ifdef NG_PF_DEBUG
+			printf("%s: Translating PF to netgraph\n "
+				"\ttagname=%s tag_id=%d ng_tag_id=%d\n",
+				__func__, tagn->tagname, tagn->tag, tag->tag);
+#endif
+		} 
+		else {
+		
+          	        TAILQ_FOREACH(tagn, &ng_pf_tags, entries)
+                        if (tag->tag == tagn->tag) { 
+                                break;
+                          }
+			
+			if (tagn != NULL) {
+			/* XXX: this might allocate a tag on PF tags
+			 * so be aware of this. It also allows to have
+			 * tags preconfigured on the node that can be
+			 * used later on ruleset(easy administration+
+			 * preventing the check if each tagname configured
+			 * exists in PF.)
+			*/
+				tagid = pf_tagname2tag(tagn->tagname);
+      		        	tag->tag = tagid;
+				r_tag->m_tag_cookie = MTAG_ABI_COMPAT;
+				*flags = tagn->flags;
+				
+			}
+#ifdef NG_PF_DEBUG
+			printf("%s: Translating netgraph to PF\n "
+				"\ttagname=%s tag_id=%d tag_flags=%x "
+				"pf_tag_id=%d\n", __func__, tagn->tagname,
+			       	tagn->tag, tagn->flags, tag->tag);
+#endif
+		}	
+		r_tag = m_tag_locate(mtag, tagzone, PACKET_TAG_PF_TAG, 
+				r_tag);	
+     	} 
+
+     return;
+}
+
diff -uNr src_diff/sys/netgraph/ng_pf.h src/sys/netgraph/ng_pf.h
--- src_diff/sys/netgraph/ng_pf.h	Thu Jan  1 01:00:00 1970
+++ src/sys/netgraph/ng_pf.h	Wed Jun  6 18:55:58 2007
@@ -0,0 +1,133 @@
+/*-
+ * Copyright 2007, Ermal Luçi <ermal.luci@gmail.org>
+ * All rights reserved.
+ *
+ * Copyright 2005, Gleb Smirnoff <glebius@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+
+#define NG_PF_NODE_TYPE    "pf"
+#define NGM_PF_COOKIE      1105988990
+
+
+#define NG_PF_TAG_NAME_SIZE         32
+
+/* messages this node understands, plus ordinary ones */
+enum {
+        NGM_PF_ADD_TAG = 1,
+	NGM_PF_CHG_TAG_FLAGS,
+        NGM_PF_RMV_TAG,
+        NGM_PF_GET_TAGS,
+#ifdef NG_PF_DEBUG 
+	NGM_PF_GET_STATS,
+	NGM_PF_CLR_STATS,
+	NGM_PF_GETCLR_STATS,
+#endif
+	NGM_PF_SET_TAGZONE,
+	NGM_PF_GET_TAGZONE,
+	NGM_PF_SET_ONEPASS,
+	NGM_PF_GET_ONEPASS,
+	NGM_PF_DEFAULT_TAGZONE
+};
+
+struct ng_pf_command {
+	char 		name[NG_PF_TAG_NAME_SIZE];
+	u_int16_t	tag;
+	int		flags;
+};
+ 
+#define NG_PF_COMMAND { 					\
+	{ "tagname", 	&ng_parse_hookbuf_type }, 		\
+	{ "tag",	&ng_parse_uint16_type }, 		\
+	{ "flags",	&ng_parse_uint32_type },		\
+	{ NULL } 						\
+}
+
+/* Structur for GET_TAGS command */
+struct ng_pf_get_tags {
+	u_int32_t n;	/* numer of tags */
+	struct ng_pf_command tags[];
+};
+
+#define NG_PF_GET_TAGS { 					\
+	{ "n",		&ng_parse_uint32_type }, 		\
+	{ "tags",	&ng_pf_struct_array_type }, 		\
+	{ NULL } 						\
+}
+
+#ifdef NG_PF_DEBUG
+struct ng_pf_stats {
+	u_int32_t packets_in;
+	u_int32_t packets_out;
+};
+
+#define NG_PF_GET_STATS {					\
+	{ "packets_in",		&ng_parse_uint32_type },	\
+	{ "packets_out",	&ng_parse_uint32_type },	\
+	{ NULL }						\
+}
+#endif
+
+#define	NG_PF_SKIP_RULES	0x0002
+#define NG_PF_KILL_STATE	0x0004
+#define NG_PF_IGNORE_STATE	0x0008
+#define NG_PF_DROP_PACKET	0x0010
+#define NG_PF_SKIP_FIREWALL	0x0020
+
+#ifdef _KERNEL
+
+struct pf_state;
+
+typedef int ng_pf_input_t(struct mbuf **, int, u_int16_t, struct pf_state **);
+extern	ng_pf_input_t	*ng_pf_input_p;
+#define	NG_PF_LOADED	(ng_pf_input_p != NULL)
+
+
+/* XXX: Should we lock this?! */
+struct ng_pf_tagnames {
+	TAILQ_ENTRY(ng_pf_tagnames) entries;
+	char tagname[NG_PF_TAG_NAME_SIZE];
+	u_int16_t	tag;
+	int		flags;
+};
+
+TAILQ_HEAD(ng_pf_tags, ng_pf_tagnames) ng_pf_tags =
+         TAILQ_HEAD_INITIALIZER(ng_pf_tags);
+
+struct ng_pf_tag {
+	struct m_tag	mt;		/* tag header */
+	struct pf_state	*s;		/* PF state so we can do tricks */
+#if 0
+	int	flags;			/* might need this later! */
+#endif
+	u_int16_t	hooknum;	
+	int		direction;
+};
+
+#define	TAGSIZ	(sizeof(struct ng_pf_tag) - sizeof(struct m_tag))
+
+#endif /* _KERNEL */
diff -uNr src_diff/sys/netinet/libalias/alias.c src/sys/netinet/libalias/alias.c
--- src_diff/sys/netinet/libalias/alias.c	Thu Jun  7 16:56:01 2007
+++ src/sys/netinet/libalias/alias.c	Thu Jun  7 17:58:32 2007
@@ -1180,7 +1180,11 @@
 	struct ip *pip;
 	int iresult;
 
-	if (la->packetAliasMode & PKT_ALIAS_REVERSE) {
+        if (la->packetAliasMode & PKT_ALIAS_REVERSE
+#ifdef _KERNEL
+             && !(la->packetAliasMode & PKT_ALIAS_ONLY_MODULES)
+#endif
+        ) {
 		la->packetAliasMode &= ~PKT_ALIAS_REVERSE;
 		iresult = LibAliasOut(la, ptr, maxpacketsize);
 		la->packetAliasMode |= PKT_ALIAS_REVERSE;
@@ -1274,7 +1278,11 @@
 	struct in_addr addr_save;
 	struct ip *pip;
 
-	if (la->packetAliasMode & PKT_ALIAS_REVERSE) {
+        if (la->packetAliasMode & PKT_ALIAS_REVERSE
+#ifdef _KERNEL
+            && !(la->packetAliasMode & PKT_ALIAS_ONLY_MODULES)
+#endif
+        ) {
 		la->packetAliasMode &= ~PKT_ALIAS_REVERSE;
 		iresult = LibAliasIn(la, ptr, maxpacketsize);
 		la->packetAliasMode |= PKT_ALIAS_REVERSE;
diff -uNr src_diff/sys/netinet/libalias/alias.h src/sys/netinet/libalias/alias.h
--- src_diff/sys/netinet/libalias/alias.h	Thu Jun  7 16:56:08 2007
+++ src/sys/netinet/libalias/alias.h	Thu Jun  7 17:58:07 2007
@@ -265,6 +265,8 @@
  */
 #define	PKT_ALIAS_REVERSE		0x80
 
+#define PKT_ALIAS_ONLY_MODULES         0x200
+
 /* Function return codes. */
 #define	PKT_ALIAS_ERROR			-1
 #define	PKT_ALIAS_OK			1
diff -uNr src_diff/sys/netinet/libalias/alias_db.c src/sys/netinet/libalias/alias_db.c
--- src_diff/sys/netinet/libalias/alias_db.c	Thu Jun  7 16:56:04 2007
+++ src/sys/netinet/libalias/alias_db.c	Thu Jun  7 17:58:24 2007
@@ -1557,7 +1557,9 @@
 
 		alias_addr = FindAliasAddress(la, src_addr);
 		lnk = AddLink(la, src_addr, dst_addr, alias_addr,
-		    src_port, dst_port, GET_ALIAS_PORT,
+		    src_port, dst_port,
+                    la->packetAliasMode & PKT_ALIAS_ONLY_MODULES ? 0 :
+                    GET_ALIAS_PORT,
 		    link_type);
 	}
 	return (lnk);
@@ -1573,7 +1575,9 @@
 	struct alias_link *lnk;
 
 	lnk = AddLink(la, src_addr, dst_addr, alias_addr,
-	    src_call_id, 0, GET_ALIAS_PORT,
+	    src_call_id, 0,
+            la->packetAliasMode & PKT_ALIAS_ONLY_MODULES ? 0 :
+            GET_ALIAS_PORT,
 	    LINK_PPTP);
 
 	return (lnk);
